<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sql-map PUBLIC "-//iBATIS.com//DTD SQL Map 1.0//EN" "http://www.ibatis.com/dtd/sql-map.dtd">
<!--
    Document   : StandingInstructionBatchMap
    Created on : February 3, 2004, 2:07 PM
    Author     : Hemant
    Modified   : Shanmugavel
    Description:
        Purpose of the document follows.
-->

<sql-map name="StandingInstructionBatchMap">

    <result-map name="getStandingInst" class="com.see.truetransact.transferobject.supporting.standinginstruction.StandingInstructionTO">
        <property name="siId" column="SI_ID"/>
        <property name="siDt" column="SI_DT"/>
        <property name="siType" column="SI_TYPE"/>
        <property name="multiplesOf" column="MULTIPLES_OF"/>
        <property name="minBalance" column="MIN_BALANCE"/>
        <property name="siStartDt" column="SI_START_DT"/>
        <property name="siEndDt" column="SI_END_DT"/>
        <property name="frequency" column="FREQUENCY"/>
        <property name="graceDays" column="GRACE_DAYS"/>
        <property name="collectSiComm" column="COLLECT_SI_COMM"/>
        <property name="siCharges" column="SI_CHARGES"/>
        <property name="collectRemitComm" column="COLLECT_REMIT_COMM"/>
        <property name="remitCharges" column="REMIT_CHARGES"/>
        <property name="remitMode" column="REMIT_MODE"/>
        <property name="branchCode" column="BRANCH_CODE"/>
        <property name="beneficiary" column="BENEFICIARY"/>
        <property name="status" column="STATUS"/>
        <property name="authorizeStatus" column="AUTHORIZE_STATUS"/>
        <property name="authorizeDt" column="AUTHORIZE_DT"/>
        <property name="authorizeBy" column="AUTHORIZE_BY"/>
        <property name="authorizeRemark" column="AUTHORIZE_REMARK"/>
        <property name="weekDay" column="WEEK_DAY"/>
        <property name="week" column="WEEK"/>
        <property name="specificDate" column="SPECIFIC_DATE"/>
        <property name="siHolidayExec" column="SI_HOLIDAY_EXEC"/>
        <property name="automaticPosting" column="AUTOMATIC_POSTING"/>
        <property name="carriedForwardCount" column="CARRIED_FORWARD_COUNT"/>
        <property name="count" column="COUNT"/>
        <property name="execCharge" column="EXEC_CHARGE"/>
        <property name="failureCharge" column="FAILURE_CHARGE"/>
        <property name="failureServiceTax" column="FAILURE_ST"/>
        <property name="execConfig" column="EXEC_CONFIG"/>
        <property name="acceptanceCharge" column="ACCEPTANCE_CHARGE"/>
        <property name="changeHolidayExec" column="CHANGE_HOLIDAY_EXEC"/>
        <property name="nextRunDt" column="NEXT_RUN_DT"/>
        <property name="lastRunDt" column="LAST_RUN_DT"/>
        <property name="forwardRunDt" column="FORWARD_RUN_DT"/>
        <property name="execDtHoliday" column="EXEC_DT_IF_HOLIDAY"/>
        <property name="serviceTax" column="SERVICE_TAX"/>
    </result-map>
    
      <result-map name="getStandingVariableInst" class="com.see.truetransact.transferobject.supporting.standinginstruction.StandingInstructionTO">
        <property name="siId" column="SI_ID"/>
        <property name="siDt" column="SI_DT"/>
        <property name="siType" column="SI_TYPE"/>
        <property name="multiplesOf" column="MULTIPLES_OF"/>
        <property name="minBalance" column="MIN_BALANCE"/>
        <property name="siStartDt" column="SI_START_DT"/>
        <property name="siEndDt" column="SI_END_DT"/>
        <property name="frequency" column="FREQUENCY"/>
        <property name="graceDays" column="GRACE_DAYS"/>
        <property name="collectSiComm" column="COLLECT_SI_COMM"/>
        <property name="siCharges" column="SI_CHARGES"/>
        <property name="collectRemitComm" column="COLLECT_REMIT_COMM"/>
        <property name="remitCharges" column="REMIT_CHARGES"/>
        <property name="remitMode" column="REMIT_MODE"/>
        <property name="branchCode" column="BRANCH_CODE"/>
        <property name="beneficiary" column="BENEFICIARY"/>
        <property name="status" column="STATUS"/>
        <property name="authorizeStatus" column="AUTHORIZE_STATUS"/>
        <property name="authorizeDt" column="AUTHORIZE_DT"/>
        <property name="authorizeBy" column="AUTHORIZE_BY"/>
        <property name="authorizeRemark" column="AUTHORIZE_REMARK"/>
        <property name="weekDay" column="WEEK_DAY"/>
        <property name="week" column="WEEK"/>
        <property name="specificDate" column="SPECIFIC_DATE"/>
        <property name="siHolidayExec" column="SI_HOLIDAY_EXEC"/>
        <property name="automaticPosting" column="AUTOMATIC_POSTING"/>
        <property name="carriedForwardCount" column="CARRIED_FORWARD_COUNT"/>
        <property name="count" column="COUNT"/>
        <property name="execCharge" column="EXEC_CHARGE"/>
        <property name="failureCharge" column="FAILURE_CHARGE"/>
        <property name="failureServiceTax" column="FAILURE_ST"/>
        <property name="execConfig" column="EXEC_CONFIG"/>
        <property name="acceptanceCharge" column="ACCEPTANCE_CHARGE"/>
        <property name="changeHolidayExec" column="CHANGE_HOLIDAY_EXEC"/>
        <property name="nextRunDt" column="NEXT_RUN_DT"/>
        <property name="lastRunDt" column="LAST_RUN_DT"/>
        <property name="forwardRunDt" column="FORWARD_RUN_DT"/>
        <property name="execDtHoliday" column="EXEC_DT_IF_HOLIDAY"/>
        <property name="serviceTax" column="SERVICE_TAX"/>
        <property name="siAgentComm" column="SI_AGENT_COMM"/>
        <property name="commisionAcHd" column="COMMISION_HEAD"/>
        <property name="noOfInstalments" column="INSTALMENT_NO"/>
        <property name="chkInstalment" column="INSTALMENT_YN"/>
        <property name="chkPendingInstalment" column="PENDING_INST_YN"/>
    </result-map>
    <mapped-statement name="standingBatchRunManual" result-map="getStandingInst">
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT, 
        DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT)+CAST(FREQUENCY AS NUMERIC)
        AS NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY,NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST  FROM 
        STANDING_INSTRUCTION where SI_ID = #SI_ID:VARCHAR#
    </mapped-statement>
    
    <mapped-statement name="standingBatchRunVariableManual" result-map="getStandingVariableInst">
        SELECT S.SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT,
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE,s.BRANCH_CODE, BENEFICIARY, S.STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT, 
        <!--DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT)+FREQUENCY-->
        NVL(NEXT_RUN_DT,SI_START_DT) + FREQUENCY::numeric 
        AS NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY,NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST,(SELECT CALCULATE_DD_SI_COMMFUNCT(SD.ACCT_NO,#CURRDATE:DATE#,sd.PROD_ID,SD.SI_ID)  FROM DUAL) as SI_AGENT_COMM,
        (SELECT comm_col_ac_hd_id FROM agent_prod_mapping WHERE prod_id = sd.prod_id AND prod_type = sd.prod_type) AS COMMISION_HEAD,INSTALMENT_NO,INSTALMENT_YN,PENDING_INST_YN FROM 
        STANDING_INSTRUCTION S JOIN STANDING_INSTRUCTION_DEBIT SD ON S.SI_ID=SD.SI_ID where S.SI_ID = #SI_ID:VARCHAR#
    </mapped-statement>
    
    <!--2.05.2007 system-->
    <dynamic-mapped-statement name="standingBatchRun" result-map="getStandingInst">
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT, 
        DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT)+FREQUENCY
        AS NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY,NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST  FROM STANDING_INSTRUCTION SI WHERE
        #TODAY_DT:DATE# BETWEEN SI_START_DT AND SI_END_DT
        <dynamic>
            <isEqual property="TRANS_STATUS" compareValue="SUCCESS" prepend="AND">
                FORWARD_RUN_DT IS NULL AND TO_CHAR(DECODE (NEXT_RUN_DT, NULL, 
                SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')
            </isEqual>
            <isEqual property="TRANS_STATUS" compareValue="FAILURE" prepend="AND">
                TO_DATE(TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'), 'DD-MM-YYYY') &lt;= 
                TO_DATE(TO_CHAR(NVL(FORWARD_RUN_DT,NEXT_RUN_DT), 'DD-MM-YYYY'), 'DD-MM-YYYY')
            </isEqual>     
        </dynamic>
        AND SI_TYPE = #SI_TYPE:VARCHAR#
        AND STATUS &lt;&gt; 'DELETED' AND STATUS &lt;&gt; 'SUSPENDED' AND STATUS &lt;&gt; 'CLOSED'
        AND AUTHORIZE_STATUS = 'AUTHORIZED'
                <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#
        AND FREQUENCY &lt; 30  AND
        SI.SI_ID IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI) AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
           <!-- UNION
                SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
                FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
                REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
                AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
                SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
                FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
                LAST_RUN_DT, FORWARD_RUN_DT, DECODE(WEEK_DAY, NULL,
                ADD_MONTHS(DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT), (FREQUENCY/30))
                , NEXT_DAY(ADD_MONTHS(DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT), (FREQUENCY/30)), WEEK_DAY) )
                AS NEXT_RUN_DT 
                FROM STANDING_INSTRUCTION SI WHERE #TODAY_DT# BETWEEN SI_START_DT AND SI_END_DT
                <dynamic>
                    <isEqual property="TRANS_STATUS" compareValue="SUCCESS" prepend="AND">
                        FORWARD_RUN_DT IS NULL AND TO_CHAR(DECODE (NEXT_RUN_DT, NULL, 
                        SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT#, 'DD-MM-YYYY')
                    </isEqual>
                    <isEqual property="TRANS_STATUS" compareValue="FAILURE" prepend="AND">
                        TO_DATE(TO_CHAR(#TODAY_DT#, 'DD-MM-YYYY'), 'DD-MM-YYYY') &lt;= 
                        TO_DATE(TO_CHAR(NVL(FORWARD_RUN_DT,NEXT_RUN_DT), 'DD-MM-YYYY'), 'DD-MM-YYYY')
                    </isEqual>     
                </dynamic>
                AND SI_TYPE = #SI_TYPE#
                AND STATUS &lt;&gt; 'DELETED' AND STATUS &lt;&gt; 'SUSPENDED' AND AUTHORIZE_STATUS = 'AUTHORIZED'
                AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#
                AND FREQUENCY &gt;=30  AND
                SI.SI_ID IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI)  -->
        UNION
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT, DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT)+FREQUENCY 
        AS NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY, NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT:DATE# BETWEEN SI_START_DT AND SI_END_DT AND
        SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI) AND 
        NOT EXISTS (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI WHERE SIBI.SI_ID=SI.SI_ID) AND 
        (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR 
        SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE = #SI_TYPE:VARCHAR# 
                <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR# 
        AND TO_CHAR(DECODE (NEXT_RUN_DT, NULL, SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') 
        = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY') AND FREQUENCY &lt; 30 AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
        UNION
                <!--SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
                FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
                REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
                AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
                SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
                FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
                LAST_RUN_DT, FORWARD_RUN_DT, DECODE(WEEK_DAY, NULL,
                ADD_MONTHS(DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT), (FREQUENCY/30))
                , NEXT_DAY(ADD_MONTHS(DECODE(NEXT_RUN_DT,NULL, SI_START_DT, NEXT_RUN_DT), 
                (FREQUENCY/30)), WEEK_DAY) ) AS NEXT_RUN_DT FROM STANDING_INSTRUCTION SI WHERE 
                #TODAY_DT# BETWEEN SI_START_DT AND SI_END_DT AND
                SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where SIBI.STATUS != 'FAILURE') AND 
                 NOT EXISTS (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI WHERE SI.SI_ID=SIBI.SI_ID
                AND SIBI.STATUS != 'FAILURE' ) AND 
                (SI.STATUS NOT IN ('DELETED','SUSPENDED') OR SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR 
                SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE = #SI_TYPE# AND 
                DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#  AND 
                ((TO_CHAR(DECODE (NEXT_RUN_DT, NULL, SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') 
                = TO_CHAR(#TODAY_DT#, 'DD-MM-YYYY')) OR (TO_CHAR(FORWARD_RUN_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT#, 'DD-MM-YYYY'))) AND FREQUENCY &gt;= 30 AND SI.BRANCH_CODE = #BRANCH_CODE# -->
                
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT,NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY, NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT:DATE# BETWEEN SI_START_DT AND SI_END_DT AND
        (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR 
        SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE = #SI_TYPE:VARCHAR# 
                <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR# 
        AND ((TO_CHAR(DECODE (NEXT_RUN_DT, NULL, SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') 
        = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')) OR (TO_CHAR(FORWARD_RUN_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'))) AND ((FREQUENCY &gt;= 30) OR (FREQUENCY IS NULL)) AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
        AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where TO_CHAR(SIBI.EXEC_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'))     
        AND EXEC_DT_IF_HOLIDAY IS NULL
        UNION
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT,NEXT_RUN_DT,EXEC_DT_IF_HOLIDAY, NVL(COUNT,0) AS COUNT, SERVICE_TAX,FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT:DATE# BETWEEN SI_START_DT AND SI_END_DT AND
        (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR 
        SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE = #SI_TYPE:VARCHAR# 
                <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#  
        AND ((FREQUENCY &gt;= 30) or (FREQUENCY is null)) AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
        AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where TO_CHAR(SIBI.EXEC_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'))
        AND TO_CHAR(EXEC_DT_IF_HOLIDAY,'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')
        union
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT,FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, 
        COLLECT_REMIT_COMM,REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS,AUTHORIZE_DT, 
        AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE,SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, 
        NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE,FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC,LAST_RUN_DT, 
        FORWARD_RUN_DT, NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY, NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT:DATE# BETWEEN SI_START_DT AND SI_END_DT AND (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') 
        AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR SI.AUTHORIZE_STATUS != 'REJECTED') 
        AND SI_TYPE = #SI_TYPE:VARCHAR# 
                <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#
        AND FREQUENCY is null and si.week_day = trim(TO_CHAR(TO_DATE(#TODAY_DT:DATE#), 'DAY'))
        AND DECODE(WEEK,'FIRSTWEEK',1,'SECONDWEEK',2,'THIRDWEEK',3,'FOURTHWEEK',4,
        DECODE(TO_CHAR(LAST_DAY(#TODAY_DT:DATE#),'W'),4,4,5)) = TO_CHAR(TO_DATE(#TODAY_DT:DATE#), 'W')
        AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR# AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where 
        SIBI.EXEC_DT = #TODAY_DT:DATE#)
        AND ((TO_CHAR(DECODE (NEXT_RUN_DT, NULL, SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') 
        = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')) OR (TO_CHAR(FORWARD_RUN_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')))
        union
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT, 
        FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, COLLECT_REMIT_COMM, 
        REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS, 
        AUTHORIZE_DT, AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE, 
        SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE, 
        FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC, 
        LAST_RUN_DT, FORWARD_RUN_DT,NEXT_RUN_DT, EXEC_DT_IF_HOLIDAY, NVL(COUNT,0) AS COUNT, SERVICE_TAX, FAILURE_ST 
        FROM STANDING_INSTRUCTION SI WHERE 
        SI_END_DT = NEXT_RUN_DT and EXEC_DT_IF_HOLIDAY is not null and EXEC_DT_IF_HOLIDAY = #TODAY_DT:DATE# and
        (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR 
        SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE = #SI_TYPE:VARCHAR# 
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#  
        AND ((FREQUENCY &gt;= 30) OR (FREQUENCY IS NULL)) AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
        AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI 
        where TO_CHAR(SIBI.EXEC_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'))
    </dynamic-mapped-statement>
                
        
    <mapped-statement name="standingBatchRunVariable" result-map="getStandingInst">
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT,FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, 
        COLLECT_REMIT_COMM,REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS,AUTHORIZE_DT, 
        AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE,SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, 
        NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE,FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC,LAST_RUN_DT, 
        FORWARD_RUN_DT, NEXT_RUN_DT,NVL(COUNT,0) AS COUNT, EXEC_DT_IF_HOLIDAY, SERVICE_TAX, FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT# BETWEEN SI_START_DT AND SI_END_DT AND (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') 
        AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR SI.AUTHORIZE_STATUS != 'REJECTED') 
        AND SI_TYPE != 'FIXED' 
                 <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#
        AND FREQUENCY is null and si.week_day = trim(TO_CHAR(TO_DATE(#TODAY_DT:DATE#), 'DAY'))
        AND DECODE(WEEK,'FIRSTWEEK',1,'SECONDWEEK',2,'THIRDWEEK',3,'FOURTHWEEK',4,
        DECODE(TO_CHAR(LAST_DAY(#TODAY_DT:DATE#),'W'),4,4,5)) = TO_CHAR(TO_DATE(#TODAY_DT:DATE#), 'W')
        AND SI.BRANCH_CODE = #BRANCH_CODE# AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where 
        SIBI.EXEC_DT = #TODAY_DT:DATE#)
        AND ((TO_CHAR(DECODE (NEXT_RUN_DT, NULL, SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') 
        = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')) OR (TO_CHAR(FORWARD_RUN_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')))  
        union
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT,FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, 
        COLLECT_REMIT_COMM,REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS,AUTHORIZE_DT, 
        AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE,SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, 
        NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE,FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC,LAST_RUN_DT, 
        FORWARD_RUN_DT, NEXT_RUN_DT,NVL(COUNT,0) AS COUNT, EXEC_DT_IF_HOLIDAY, SERVICE_TAX, FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT# BETWEEN SI_START_DT AND SI_END_DT AND (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') 
        AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE != 'FIXED'  
                 <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#
        AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR# AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where 
        TO_CHAR(SIBI.EXEC_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'))  AND ((FREQUENCY &gt;= 30) or (FREQUENCY IS NULL))
        AND ((TO_CHAR(DECODE (NEXT_RUN_DT, NULL, SI_START_DT, NEXT_RUN_DT), 'DD-MM-YYYY') 
        = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')) OR (TO_CHAR(FORWARD_RUN_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')))
        AND EXEC_DT_IF_HOLIDAY IS NULL
        union
        SELECT SI_ID, SI_DT, SI_TYPE, MULTIPLES_OF, MIN_BALANCE, SI_START_DT, SI_END_DT,FREQUENCY, GRACE_DAYS, COLLECT_SI_COMM, SI_CHARGES, 
        COLLECT_REMIT_COMM,REMIT_CHARGES, REMIT_MODE, BRANCH_CODE, BENEFICIARY, STATUS, AUTHORIZE_STATUS,AUTHORIZE_DT, 
        AUTHORIZE_BY, AUTHORIZE_REMARK, WEEK_DAY, WEEK, SPECIFIC_DATE,SI_HOLIDAY_EXEC, AUTOMATIC_POSTING, 
        NVL(CARRIED_FORWARD_COUNT,0) AS CARRIED_FORWARD_COUNT, EXEC_CHARGE,FAILURE_CHARGE, EXEC_CONFIG, ACCEPTANCE_CHARGE, CHANGE_HOLIDAY_EXEC,LAST_RUN_DT, 
        FORWARD_RUN_DT, NEXT_RUN_DT,NVL(COUNT,0) AS COUNT, EXEC_DT_IF_HOLIDAY, SERVICE_TAX, FAILURE_ST FROM STANDING_INSTRUCTION SI WHERE 
        #TODAY_DT:DATE# BETWEEN SI_START_DT AND SI_END_DT AND (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') 
        AND SI.STATUS IS NOT NULL) AND (SI.AUTHORIZE_STATUS != '' OR SI.AUTHORIZE_STATUS != 'REJECTED') AND SI_TYPE != 'FIXED'  
                 <!--AND DECODE(EXEC_CONFIG, NULL,'DAY_BEGIN',EXEC_CONFIG) = #EXEC_CONFIG#-->
        AND EXEC_CONFIG = #EXEC_CONFIG:VARCHAR#
        AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR# AND SI.SI_ID NOT IN (SELECT SIBI.SI_ID FROM STANDING_INSTRUCTION_BATCH SIBI where 
        TO_CHAR(SIBI.EXEC_DT, 'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY'))  AND ((FREQUENCY &gt;= 30) or (FREQUENCY IS NULL))
        AND TO_CHAR(EXEC_DT_IF_HOLIDAY,'DD-MM-YYYY') = TO_CHAR(#TODAY_DT:DATE#, 'DD-MM-YYYY')
                
    </mapped-statement>
        
        
    <mapped-statement name="updateStandingInstruction" inline-parameters="true">
        UPDATE STANDING_INSTRUCTION SET 
        LAST_RUN_DT = #lastRunDt:DATE#, 
        FORWARD_RUN_DT = #forwardRunDt:DATE#, 
        NEXT_RUN_DT = #nextRunDt:DATE#,
        EXEC_DT_IF_HOLIDAY = #execDtHoliday:DATE#,
        COUNT = #count:NUMERIC#
        WHERE SI_ID = #siId:VARCHAR#
    </mapped-statement>
    <mapped-statement name="updateStandingInstructionFailure" inline-parameters="true">
        UPDATE STANDING_INSTRUCTION SET 
        FORWARD_RUN_DT = #FWD_RUN_DT:DATE#,NEXT_RUN_DT = #NXT_RUN_DT:DATE#,
        LAST_RUN_DT = #LST_RUN_DT:DATE#,
        EXEC_DT_IF_HOLIDAY = #EXE_HOL_DT:DATE#
        WHERE SI_ID = #SI_NO:VARCHAR#<!--AND FORWARD_RUN_DT IS NULL-->
    </mapped-statement>
        
    <mapped-statement name="updateCount" inline-parameters="true">
        UPDATE STANDING_INSTRUCTION SET 
        COUNT = #COUNT:NUMBER#
        WHERE SI_ID = #SI_NO:VARCHAR#<!--AND FORWARD_RUN_DT IS NULL-->
    </mapped-statement>
        
    <mapped-statement name="updateStandingInstrManual" inline-parameters="true">
        update standing_instruction set FORWARD_RUN_DT = null,COUNT=0 where SI_ID = #SI_ID:VARCHAR#
    </mapped-statement>  
    
    <mapped-statement name="updateStandingInstrManual1" inline-parameters="true">
        update STANDING_INSTRUCTION set LAST_RUN_DT=#CURR_DT:DATE#, NEXT_RUN_DT=DECODE(cast(FREQUENCY as integer),1,NULL::DATE,7,SI_DT+7,ADD_MONTHS(SI_DT,1)) where si_id=#SI_ID:VARCHAR#
    </mapped-statement>
    
    <mapped-statement name="updateStandingInstrManual2" inline-parameters="true">
        <!--update STANDING_INSTRUCTION set LAST_RUN_DT=DECODE(FREQUENCY::integer,1::integer,cast(#CURR_DT# as timestamp without time zone),7,last_run_dt+7,add_months(LAST_RUN_DT,1)), 
     	NEXT_RUN_DT= DECODE(FREQUENCY::integer,1::integer,NULL::date,7,next_run_dt+7,(add_months(NEXT_RUN_DT,1))) where si_id=#SI_ID:VARCHAR# --> 
        
        update STANDING_INSTRUCTION set LAST_RUN_DT=DECODE(cast(FREQUENCY as integer),1,cast(#CURR_DT# as date),7,last_run_dt+7,add_months(LAST_RUN_DT,1)), 
     	NEXT_RUN_DT= DECODE(cast(FREQUENCY as integer),1,cast(NULL as date),7,next_run_dt+7,(add_months(NEXT_RUN_DT,1))) where si_id=#SI_ID:VARCHAR#      
    </mapped-statement>
    
     <mapped-statement name="updateNextRunDtSI" inline-parameters="true">
        UPDATE STANDING_INSTRUCTION SET LAST_RUN_DT=#CURR_DT:DATE#, NEXT_RUN_DT=#NEXT_RUN_DT:DATE# WHERE SI_ID=#SI_ID:VARCHAR#
    </mapped-statement>
    
    <mapped-statement name="updateStandingInstrBatchManual" inline-parameters="true">
        update standing_instruction_batch set STATUS = 'SUCCESS' WHERE SI_ID = #SI_ID:VARCHAR# 
        AND EXEC_DT = #EXEC_DT:DATE#
    </mapped-statement>    
            
    <mapped-statement name="getCount" result-class="java.util.HashMap">
        SELECT NVL(COUNT,0) AS COUNT FROM STANDING_INSTRUCTION 
        WHERE SI_ID = #SI_NO:VARCHAR#<!--AND FORWARD_RUN_DT IS NULL-->
    </mapped-statement>
        
    <mapped-statement name="getProdID_OP_AC_PRODUCTOA" result-class="java.util.HashMap">
        SELECT AC_HD_ID, BASE_CURRENCY FROM OP_AC_PRODUCT WHERE PROD_ID = #PROD_ID:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getProdID_OP_AC_PRODUCTTL" result-class="java.util.HashMap">
        SELECT ACCT_HEAD AS AC_HD_ID, BASE_CURRENCY FROM LOANS_PRODUCT WHERE PROD_ID = #PROD_ID:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getProdID_OP_AC_PRODUCTSA" result-class="java.util.HashMap">
        SELECT AC_HD_ID, 'INR' AS BASE_CURRENCY FROM SUSPENSE_PRODUCT WHERE PROD_ID = #PROD_ID:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getProdID_OP_AC_PRODUCTAD" result-class="java.util.HashMap">
        SELECT ACCT_HEAD AS AC_HD_ID, BASE_CURRENCY FROM LOANS_PRODUCT WHERE PROD_ID = #PROD_ID:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getProdID_OP_AC_PRODUCTTD" result-class="java.util.HashMap">
        SELECT ACCT_HEAD AS AC_HD_ID, BASE_CURRENCY FROM DEPOSITS_PRODUCT WHERE PROD_ID = #PROD_ID:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getProdID_OP_AC_PRODUCTRM" result-class="java.util.HashMap">
        SELECT ISSUE_HD AS AC_HD_ID, BASE_CURRENCY FROM remittance_product WHERE PROD_ID = #PROD_ID:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getBranchCode_ACT_MASTEROA" result-class="java.util.HashMap">
        SELECT BRANCH_CODE FROM ACT_MASTER WHERE ACT_NUM = #ACT_NUM:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getBranchCode_ACT_MASTERSA" result-class="java.util.HashMap">
        SELECT BRANCH_CODE FROM SUSPENSE_ACCOUNT_MASTER WHERE SUSPENSE_ACCT_NUM = #ACT_NUM:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getBranchCode_ACT_MASTERTL" result-class="java.util.HashMap">
        SELECT BRANCH_ID AS BRANCH_CODE FROM LOANS_FACILITY_DETAILS WHERE ACCT_NUM = #ACT_NUM:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getBranchCode_ACT_MASTERAD" result-class="java.util.HashMap">
        SELECT BRANCH_ID AS BRANCH_CODE FROM LOANS_FACILITY_DETAILS WHERE ACCT_NUM = #ACT_NUM:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getBranchCode_ACT_MASTERTD" result-class="java.util.HashMap">
        SELECT BRANCH_ID AS BRANCH_CODE FROM DEPOSIT_ACINFO DA, DEPOSIT_SUB_ACINFO DSA
        WHERE DSA.DEPOSIT_NO = DA.DEPOSIT_NO AND 
        DA.DEPOSIT_NO || '_' || DSA.DEPOSIT_SUB_NO = #ACT_NUM:VARCHAR#
    </mapped-statement>
        
        <!-- Use StandingInstructionTaskTO object (JavaBean) properties as parameters for insert. 
	     Each of the parameters in the #hash# symbols is a JavaBeans property. -->
    <mapped-statement name="insertStandingInstructionTaskTO" inline-parameters="true">
        INSERT INTO STANDING_INSTRUCTION_BATCH
        (EXEC_DT, STATUS, SI_ID, INSTALLMENT, BATCH_ID
        ) VALUES (
        #execDt:DATE#, #status:VARCHAR#, #siId:VARCHAR#, #installment:NUMERIC#,#batchID:VARCHAR#)
    </mapped-statement>

	<!-- Use StandingInstructionTaskTO object (JavaBean) properties as parameters for update. 
	     Each of the parameters in the #hash# symbols is a JavaBeans property. -->
    <mapped-statement name="updateStandingInstructionTaskTO" inline-parameters="true">
        UPDATE STANDING_INSTRUCTION_BATCH SET 
        EXEC_DT = #execDt:DATE#,
        STATUS = #status:VARCHAR#
        BATCH_ID =#batchID:VARCHAR#
        WHERE SI_ID = #siId:VARCHAR# AND INSTALLMENT = #installment:NUMERIC#,#batchID:VARCHAR#
    </mapped-statement>


	<!-- Use primitive wrapper type (e.g. Integer) as parameter and allow results to 
	     be auto-mapped results to StandingInstructionTaskTO object (JavaBean) properties -->
    <result-map name="getStandingInstructionTaskTOResult" class="com.see.truetransact.transferobject.batchprocess.supporting.standinginstruction.StandingInstructionTaskTO">
        <property name="execDt" column="EXEC_DT"/>
        <property name="status" column="STATUS"/>
        <property name="siId" column="SI_ID"/>
        <property name="installment" column="INSTALLMENT"/>
    </result-map>
    <mapped-statement name="getSelectStandingInstructionTaskTO" result-map="getStandingInstructionTaskTOResult" >
        SELECT * FROM STANDING_INSTRUCTION_BATCH 
        WHERE SI_ID = #siId:VARCHAR# AND INSTALLMENT = #installment:NUMERIC#
    </mapped-statement>
        
    <mapped-statement name="getWeekCnt" result-class="java.util.HashMap">
        SELECT TO_CHAR(TO_DATE(#TODAY_DT:DATE#), 'W') as CAL_DT FROM DUAL
    </mapped-statement>
        
    <mapped-statement name="checkPendingSI" result-class="java.util.HashMap">
        SELECT DISTINCT SI.SI_ID FROM STANDING_INSTRUCTION SI WHERE 
        ((TO_CHAR(SI.SI_START_DT,'DD-MM-YYYY') = TO_CHAR(#NEXT_DATE:DATE#, 'DD-MM-YYYY')) 
        OR (TO_CHAR(SI.NEXT_RUN_DT,'DD-MM-YYYY') = TO_CHAR(#NEXT_DATE:DATE#, 'DD-MM-YYYY'))
        OR (TO_CHAR(EXEC_DT_IF_HOLIDAY,'DD-MM-YYYY') = TO_CHAR(#NEXT_DATE:DATE#, 'DD-MM-YYYY')))
        AND (SI.STATUS NOT IN ('DELETED','SUSPENDED','CLOSED') AND SI.STATUS IS NOT NULL)
        AND (SI.AUTHORIZE_STATUS != '' OR SI.AUTHORIZE_STATUS != 'REJECTED') 
        AND DECODE(SI.EXEC_CONFIG, NULL,'DAY_BEGIN',SI.EXEC_CONFIG) = 'DAY_BEGIN'
        AND SI.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getDepValidateData" result-class="java.util.HashMap">
        SELECT ACCT_STATUS,MATURITY_DT,TOTAL_INSTALLMENTS,TOTAL_INSTALL_PAID FROM DEPOSIT_SUB_ACINFO WHERE STATUS != 'DELETED'
        AND AUTHORIZE_STATUS = 'AUTHORIZED' AND DEPOSIT_NO = #ACT_NUM:VARCHAR#
    </mapped-statement>
        
    <mapped-statement name="getSiForReExecution" result-class="java.util.LinkedHashMap">
            select distinct si.SI_ID,si.SI_DT AS LODGE_DT,si.SI_START_DT,si.SI_END_DT,sid.ACCT_NO AS DEBIT_ACT,sic.ACCT_NO
            AS CREDIT_ACT,SID.AMOUNT AS DEBIT_AMT,si.LAST_RUN_DT,sib.STATUS
            from STANDING_INSTRUCTION si,STANDING_INSTRUCTION_debit sid,STANDING_INSTRUCTION_credit sic
            ,STANDING_INSTRUCTION_BATCH sib where si.LAST_RUN_DT = TO_DATE(#LAST_RUN_DT:DATE#,'DD-MM-YYYY')
            and si.SI_ID = sid.si_id and si.SI_ID = sic.si_id and si.SI_ID = sib.si_id
            and sib.STATUS = 'FAILURE'
            AND SIB.EXEC_DT = SI.LAST_RUN_DT
     </mapped-statement>
     
     <dynamic-mapped-statement name="getNormalSiForReExecution" result-class="java.util.LinkedHashMap">
         SELECT DISTINCT SI.SI_ID, SI.SI_DT AS LODGE_DT, SI.SI_START_DT, SI.SI_END_DT,
         SID.ACCT_NO AS DEBIT_ACT,
         AMB.AVAILABLE_BALANCE AS DEBIT_ACT_BAL,
         SIC.ACCT_NO AS CREDIT_ACT, 
         <dynamic>
         GET_STANDING_AMT(SIC.PROD_ID,SIC.PROD_TYPE,SIC.ACCT_NO,NVL(SI.INSTALMENT_NO,0),SID.AMOUNT
         <isEqual prepend="," property="SAL_REC_MODULE" compareValue="Y" >
         #ASONDATE:DATE#
         </isEqual>
         ) AS debit_amt,
         </dynamic>
         SI.LAST_RUN_DT, SI.NEXT_RUN_DT
         FROM STANDING_INSTRUCTION SI,
         STANDING_INSTRUCTION_DEBIT SID,
         STANDING_INSTRUCTION_CREDIT SIC,
         ALL_CUSTOMER_BALANCE AMB,
         OP_ACT_MIN_BAL OPB
         WHERE DECODE (SI.NEXT_RUN_DT, NULL, SI.SI_START_DT, SI.NEXT_RUN_DT) &lt;=
         TO_DATE (#NEXT_RUN_DT:DATE#, 'DD-MM-YYYY')
         AND TO_DATE (#NEXT_RUN_DT:DATE#, 'DD-MM-YYYY') BETWEEN SI.SI_START_DT AND SI.SI_END_DT
         AND SI.STATUS NOT IN ('CLOSED','DELETED') AND SI.AUTHORIZE_STATUS ='AUTHORIZED'
         AND SI.SI_ID = SID.SI_ID
         AND SI.SI_ID = SIC.SI_ID
         AND SI.BRANCH_CODE=#BRANCH_CODE:VARCHAR#
         AND AMB.ACT_NUM = SID.ACCT_NO 
         AND OPB.ACT_NUM=SID.ACCT_NO
         AND SIC.PROD_TYPE=#TYPE:VARCHAR#
         AND AMB.SHADOW_DEBIT = 0
         <dynamic>
             <!--  Added by Rishad 16/06/2017 for RBI Purpose (in there list all account avilable for standing .insufficent balance 
             checking need to do in front end 
             -->
             <isEqual prepend="AND" property="SAL_REC_MODULE" compareValue="N" >
                 AMB.AVAILABLE_BALANCE >= SID.AMOUNT + OPB.MIN_BAL
<!--                 AND AMB.AVAILABLE_BALANCE &gt;=((AMB.AVAILABLE_BALANCE-OPB.MIN_BAL)-SID.AMOUNT)-->
             </isEqual>
         </dynamic>
            
         <dynamic>
             <isParameterPresent>
                 <isNotNull prepend="AND" property="SI_TYPE">
                     SI_TYPE = #SI_TYPE:VARCHAR#
                 </isNotNull>
             </isParameterPresent>
         </dynamic>
         AND GET_VALID_ACCOUNT(SIC.ACCT_NO,SIC.PROD_TYPE) > 0
         ORDER BY SI.SI_ID 
     </dynamic-mapped-statement>
        
         <mapped-statement name="getNormalSiForDepositExecution" result-class="java.util.LinkedHashMap">
             <!--  SELECT DISTINCT SI.SI_ID, SI.SI_DT AS LODGE_DT, SI.SI_START_DT, SI.SI_END_DT,
                SID.ACCT_NO AS DEBIT_ACT,
                SIC.ACCT_NO AS CREDIT_ACT, SID.AMOUNT AS DEBIT_AMT,
                SI.LAST_RUN_DT, SI.NEXT_RUN_DT,D.AVAILABLE_BALANCE AS debit_amt
                FROM STANDING_INSTRUCTION SI,
                STANDING_INSTRUCTION_CREDIT SIC JOIN LOANS_FACILITY_DETAILS L ON SIC.ACCT_NO=L.ACCT_NUM, STANDING_INSTRUCTION_DEBIT SID JOIN
                DEPOSIT_SUB_ACINFO D ON SID.ACCT_NO= D.DEPOSIT_NO ||'_'|| D.DEPOSIT_SUB_NO
                WHERE DECODE (SI.NEXT_RUN_DT, NULL, SI.SI_START_DT, SI.NEXT_RUN_DT) &lt;=TO_DATE (#NEXT_RUN_DT:DATE#, 'DD-MM-YYYY')
                AND TO_DATE (#NEXT_RUN_DT:DATE#, 'DD-MM-YYYY') BETWEEN SI.SI_START_DT AND SI.SI_END_DT
                AND SI.SI_ID = SID.SI_ID AND SI.SI_ID = SIC.SI_ID AND L.ACCT_STATUS !='CLOSED' AND D.AVAILABLE_BALANCE>0
                AND SIC.PROD_TYPE=#TYPE:VARCHAR# AND SI.BRANCH_CODE=#BRANCH_CODE:VARCHAR#
                UNION ALL-->
                SELECT DISTINCT SI.SI_ID, SI.SI_DT AS LODGE_DT, SI.SI_START_DT, SI.SI_END_DT,
                SID.ACCT_NO AS DEBIT_ACT,
                SIC.ACCT_NO AS CREDIT_ACT,
                SID.AMOUNT AS DEBIT_AMT,
                SI.LAST_RUN_DT, SI.NEXT_RUN_DT,NVL(D.AVAILABLE_BALANCE,0)- NVL (D.MIN_BALANCE, 0) AS debit_amt
                FROM STANDING_INSTRUCTION SI,
                STANDING_INSTRUCTION_CREDIT SIC JOIN LOANS_FACILITY_DETAILS L ON SIC.ACCT_NO=L.ACCT_NUM, 
                STANDING_INSTRUCTION_DEBIT SID JOIN
                ALL_CUSTOMER_BALANCE D ON SID.ACCT_NO= D.ACT_NUM
                WHERE DECODE (SI.NEXT_RUN_DT, NULL, SI.SI_START_DT, SI.NEXT_RUN_DT) &lt;=TO_DATE (#NEXT_RUN_DT:DATE#, 'DD-MM-YYYY')
                AND TO_DATE (#NEXT_RUN_DT:DATE#, 'DD-MM-YYYY') BETWEEN SI.SI_START_DT AND SI.SI_END_DT
                AND SI.SI_ID = SID.SI_ID AND SI.SI_ID = SIC.SI_ID AND L.ACCT_STATUS !='CLOSED' 
                AND SI.STATUS != 'CLOSED'
                AND D.SHADOW_DEBIT = 0
                AND SIC.PROD_TYPE=#TYPE:VARCHAR# AND SI.BRANCH_CODE=#BRANCH_CODE:VARCHAR#
                AND NVL(D.AVAILABLE_BALANCE,0)-NVL(D.MIN_BALANCE,0)>0
                AND GET_VALID_ACCOUNT(SIC.ACCT_NO,SIC.PROD_TYPE) > 0 AND SI.SI_TYPE=#SI_TYPE:VARCHAR#
        </mapped-statement>
         
        <mapped-statement name="checkHolyDay" result-class="java.util.LinkedHashMap">
        	select hm.HOLIDAY_DT  from HOLIDAY_MASTER hm where HM.HOLIDAY_DT in(#HOLY_NDAY#,#HOLY_PDAY#)
        </mapped-statement>  
        
        <mapped-statement name="getSiBeyondMaturity" result-class="java.util.LinkedHashMap">
            select A.BEHAVES_LIKE,nvl(B.INST_BEYOND_MATURITY_DATE,'N') as INST_BEYOND_MATURITY_DATE from
            deposits_product a join  DEPOSITS_PROD_RD b
            on A.PROD_ID=B.PROD_ID
            where a.prod_id=#PROD_ID:VARCHAR#  AND  A.AUTHORIZE_STATUS = 'AUTHORIZED' 
        </mapped-statement>


        <mapped-statement name="getLastAndNextIntAppDate" result-class="java.util.HashMap">
            select DSA.NEXT_INT_APPL_DT,DSA.LAST_INT_APPL_DT,DSA.DEPOSIT_DT,DSA.STATUS from deposit_sub_acinfo dsa 
            where DSA.DEPOSIT_NO =#DEPOSIT_NO:VARCHAR# and DSA.AUTHORIZE_STATUS = 'AUTHORIZED'
        </mapped-statement>
        
        <mapped-statement name="getCheckCurrentInstRD" result-class="java.util.HashMap">
            SELECT * FROM DEPOSIT_RECURRING WHERE DEPOSIT_NO_SUB = #DEPOSIT_NO# AND  TRANS_DT IS NULL  AND DUE_DATE = #CURRDATE:DATE#
            AND SL_NO = (SELECT MIN(TO_NUMBER(SL_NO)) AS SL_NO FROM DEPOSIT_RECURRING WHERE DEPOSIT_NO_SUB = #DEPOSIT_NO# AND  TRANS_DT IS NULL)
        </mapped-statement>
        
        <mapped-statement name="getCheckCurrentInstForRD" result-class="java.util.HashMap">
            SELECT * FROM DEPOSIT_RECURRING WHERE DEPOSIT_NO_SUB = #DEPOSIT_NO# AND  TRANS_DT IS NULL  AND DUE_DATE = #CURRDATE:DATE#
        </mapped-statement>
        
        <mapped-statement name="getCheckCurrentInstallmentRD" result-class="java.util.HashMap">
            SELECT * FROM DEPOSIT_RECURRING WHERE DEPOSIT_NO_SUB = #DEPOSIT_NO# AND  TRANS_DT IS NULL  AND DUE_DATE &lt;= #CURRDATE:DATE#
        </mapped-statement>
        
        <mapped-statement name="getAccountBalanceForStandingInstruction" result-class="java.util.HashMap">
            select A.ACCOUNT_BALANCE from ALL_ACCOUNT_BALANCE a where A.ACT_NUM = #ACT_NUM:VARCHAR#
        </mapped-statement>
        
        <mapped-statement name="getProductTypeForSIID" result-class="java.util.HashMap">
            select SC.PROD_TYPE from STANDING_INSTRUCTION_CREDIT sc where SC.SI_ID = #SI_ID:VARCHAR#
            AND SC.BRANCH_CODE = #BRANCH_CODE:VARCHAR#
        </mapped-statement>
        
        <mapped-statement name="getOATotalBalanceWithoutMinBal" result-class="java.util.HashMap">
            SELECT CASE
             WHEN NVL (NVL (act.available_balance, 0) - NVL (op.min_bal, 0),
                    0
                   ) > 0
             THEN NVL (NVL (act.available_balance, 0) - NVL (op.min_bal, 0),
                       0)
              ELSE 0
              END AS "TOTAL_BALANCE"
              FROM act_master act, op_act_min_bal op
              WHERE act.prod_id = op.prod_id
              AND act.act_num = op.act_num
              AND act.act_num = #ACT_NUM:VARCHAR# 
        </mapped-statement>
        
   <mapped-statement name="updateStandingInstrRollback" inline-parameters="true">
        update STANDING_INSTRUCTION set LAST_RUN_DT=DECODE(FREQUENCY,1,#CURR_DT:DATE#,add_months(LAST_RUN_DT,-1)), 
     	NEXT_RUN_DT=   DECODE(FREQUENCY,1,NULL,(add_months(NEXT_RUN_DT,-1))) where si_id=#SI_ID:VARCHAR#    
   </mapped-statement>
       
</sql-map>