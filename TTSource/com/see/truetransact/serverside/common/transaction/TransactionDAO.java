/*
 * Copyright 2003-2020 FINCuro Solutions Pvt Ltd. All rights reserved.
 *
 * This software and its components are the property of FINCuro Solutions Pvt Limited and its affiliates, through authorship and acquisition.
 **
 *
 * TransactionDAO.java
 *
 * Created on Fri Jan 09 17:36:32 IST 2004
 */
package com.see.truetransact.serverside.common.transaction;

import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;

import com.ibatis.db.sqlmap.SqlMap;
import com.see.truetransact.serverutil.ServerUtil;
import com.see.truetransact.commonutil.CommonConstants;
import com.see.truetransact.commonutil.NoCommandException;
import com.see.truetransact.transferobject.common.log.*;
import com.see.truetransact.serverside.common.log.*;
import com.see.truetransact.serverside.TTDAO;
import com.see.truetransact.serverutil.ServerConstants;
import com.see.truetransact.servicelocator.ServiceLocator;
import com.see.truetransact.serverexception.TransRollbackException;
import com.see.truetransact.serverexception.ServiceLocatorException;
import com.see.truetransact.commonutil.DateUtil;
import com.see.truetransact.commonutil.CommonUtil;
import com.see.truetransact.transferobject.TOHeader;
import com.see.truetransact.serverside.common.idgenerate.IDGenerateDAO;
import com.see.truetransact.transferobject.common.transaction.TransactionTO;
import com.see.truetransact.serverside.common.transaction.TransferTrans;
import com.see.truetransact.transferobject.transaction.transfer.TxTransferTO;
import com.see.truetransact.serverside.transaction.common.TransactionFactory;
import com.see.truetransact.serverside.transaction.cash.CashTransactionDAO;
import com.see.truetransact.transferobject.transaction.cash.CashTransactionTO;
import com.see.truetransact.commonutil.LocaleConstants;
import com.see.truetransact.serverside.transaction.common.TransactionDAOConstants;
import com.see.truetransact.serverside.transaction.transfer.TransferDAO;
import com.see.truetransact.transferobject.operativeaccount.AccountClosingTO;
import com.see.truetransact.transferobject.remittance.RemittancePaymentTO;
import com.see.truetransact.transferobject.termloan.loanTransaction.LoanTransactionTO;

/**
 * @author Prasath.T
 * @modified Sunil Sreedharan - Added methods to do account head credit and
 * debit for Cash and Transfer transactions - Added common authorization method
 * - Added method to perform local account head updates - Created separate list
 * objects for Cash and Transfer
 *
 */
public class TransactionDAO extends TTDAO {

    public static String TRANSFER = "TRANSFER";
    public static String CASH = "CASH";
    private String CLEARING = "CLEARING";
    private static final String TRANS_ID = "TRANS_ID";
    private static String PRODUCTTYPE = "PRODUCTTYPE";
    private String CURRENCY_INR = "INR";
    private static SqlMap sqlMap = null;
    TransferTrans objTrans = new TransferTrans();
    private LogDAO logDAO;
    private LogTO logTO;
    private TransactionTO objTransactionTO;
    private TxTransferTO objCashTxTo;
    private HashMap insertMap = new HashMap();
    private HashMap auctionMap = new HashMap();
    private LinkedHashMap transactionDetailsMap;// Contains all the Transaction Details TOs
    private LinkedHashMap allowedTransDetailsTO;
    private LinkedHashMap deletedTransDetailsTO;// Contains deleted trans details
    // Auto Generated values which is not present in UI
    private String transactionType;  //Cash, transfer, Clearing
    private String batchId = "";// batchId is used to store batch id used for both Issue & Transaction details
    private String transactionId = "";// transactionId is used to store autogenerated transaction id in transaction details
    private String status = "";
    private String transType = "";
    private Date batchDate;// batchDate is used to store the date of batch created
    private String loanDebitInt = "";
    private boolean forLodgeICC = false;
    private boolean forDebitInt = false;
    // TODO: Remove from class level and put it in TransactionTO
    private String branchID;
    private String initiatedBranch;
    private String userID;
    private ArrayList txList = new ArrayList(); //For Transfer
    private ArrayList txCashList = new ArrayList(); //For Cash
    private String commandMode = CommonConstants.TOSTATUS_INSERT;
    private TransferDAO transferDAO = new TransferDAO();
    private String linkBatchID = null;
    private Double oldAmt = new Double(0.0);
    private static String debitInt = "";
    private String acno = "";
    private String particulars = "";
    private HashMap loanAmtMap = new HashMap();
    private String act_closing = "";
    private String act_closing_min_bal_check = null;
    private String breakLoanHierachy = "N";
    private String generateSingleTransId = "";
    private String screenName = "";
    private String ltdClosing = ""; // Added by nithya on 04-12-2018 for KD 276 - LTD- Deposit Loan Closure- Trans Mod Type for Deposit Head is wrong 

    public String getScreenName() {
        return screenName;
    }

    public void setScreenName(String screenName) {
        this.screenName = screenName;
    }
    public String getGenerateSingleTransId() {
        return generateSingleTransId;
    }

    public void setGenerateSingleTransId(String generateSingleTransId) {
        this.generateSingleTransId = generateSingleTransId;
    }

    /**
     * Creates a new instance of RemittanceIssueDAO
     */
    public TransactionDAO(String transType) throws ServiceLocatorException {
        ServiceLocator locate = ServiceLocator.getInstance();
        sqlMap = (SqlMap) locate.getDAOSqlMap();
        this.transType = transType;
    }
    /* To retrive the data from the database (table REMIT_ISSUE) */

    public List getData(HashMap map) throws Exception {
        System.out.println("###detdatahashmap" + map);
        List list = null;
        if (map.get(CommonConstants.MAP_WHERE) instanceof HashMap) {
            HashMap whereMap = (HashMap) map.get(CommonConstants.MAP_WHERE);
            list = (List) sqlMap.executeQueryForList("getSelectRemittanceIssueTransactionTODate", whereMap);
        } else {
            String where = (String) map.get(CommonConstants.MAP_WHERE);
            list = (List) sqlMap.executeQueryForList("getSelectRemittanceIssueTransactionTO", where);
        }

        return list;
    }

    public HashMap executeQuery(HashMap obj) throws Exception {
        _branchCode = (String) obj.get(CommonConstants.BRANCH_ID);
        List ls = getData(obj);
        System.out.println("checkabi" + ls);
        HashMap hash = new HashMap();
        hash.put("DOCUMENT_LIST", ls);
        if (hash.size() != 0) {
            return hash;
        }
        return null;
    }

    private void destroyObjects() {
        objTransactionTO = null;
        transactionDetailsMap = null;
    }

    /**
     * Generates transactionId for Trans details. Not Used
     */
    private String getTransactionId() throws Exception {
        final IDGenerateDAO dao = new IDGenerateDAO();
        final HashMap where = new HashMap();
        where.put(CommonConstants.MAP_WHERE, "TRANS_DAO_ID");
        return (String) (dao.executeQuery(where)).get(CommonConstants.DATA);
    }

    public void doInsert(String command) throws Exception {
        objTransactionTO = null;
        txCashList = new ArrayList();
        for (int i = 1, j = allowedTransDetailsTO.size(); i <= j; i++) {
            objTransactionTO = (TransactionTO) allowedTransDetailsTO.get(String.valueOf(i));
            System.out.println("objTransactionTO#####" + objTransactionTO);
            setTransactionType(objTransactionTO.getTransType());
            insertRemitTransDetails(command);
            System.out.println("doinsert$$$$#####" + objTransactionTO);
        }
    }

    private HashMap createDebitMap(TransactionTO obj, String branchID)throws Exception {
        HashMap map = new HashMap();
        map.put(TransferTrans.DR_PROD_TYPE, obj.getProductType());
        //Added by sreekrishnan
        if (!obj.getProductType().equals("GL")) {
            HashMap interBranchCodeMap = new HashMap();
            interBranchCodeMap.put("ACT_NUM", obj.getDebitAcctNo());
            List interBranchCodeList = sqlMap.executeQueryForList("getSelectInterBranchCode", interBranchCodeMap);
            if (interBranchCodeList != null && interBranchCodeList.size() > 0) {
                interBranchCodeMap = (HashMap) interBranchCodeList.get(0);
                System.out.println("interBranchCodeMap : " + interBranchCodeMap);
                map.put(TransferTrans.DR_BRANCH, CommonUtil.convertObjToStr(interBranchCodeMap.get("BRANCH_CODE")));
            }else{
                map.put(TransferTrans.DR_BRANCH, branchID);
            }
            if (act_closing.equals("ACCOUNT_CLOSING")) {// Interbranch gold loan closing issue reported after testing of jira KD-196
                if (interBranchCodeMap.containsKey("BRANCH_CODE") && !((CommonUtil.convertObjToStr(interBranchCodeMap.get("BRANCH_CODE"))).equalsIgnoreCase(branchID))) {
                    map.put("ACCOUNT_CLOSING_INTER_BRANCH_TRANS", "ACCOUNT_CLOSING_INTER_BRANCH_TRANS");
                    map.put("INITIATED_BRANCH", _branchCode);
                }
                map.put(TransferTrans.AUTHORIZE_STATUS_2, "ENTERED_AMOUNT");//Added by nithya on 03-12-2019 for KD-989 Gold loan payment and closing on the same day : On reject, the close dt, and status not resetting
            }
        }else{
            map.put(TransferTrans.DR_BRANCH, branchID);
        }
        if (!obj.getProductType().equals("GL")) {
            map.put(TransferTrans.DR_AC_HD, null);
            map.put(TransferTrans.DR_ACT_NUM, obj.getDebitAcctNo());
            map.put(TransferTrans.DR_PROD_ID, obj.getProductId());
        } else {
            map.put(TransferTrans.DR_AC_HD, obj.getDebitAcctNo());
        }
        if (particulars.length() > 0) {
            map.put(TransferTrans.PARTICULARS, particulars);
        }
       // particulars = "";
        map.put(TransferTrans.CURRENCY, CURRENCY_INR);
        map.put(TransferTrans.DR_INSTRUMENT_1, objTransactionTO.getChequeNo());
        map.put(TransferTrans.DR_INSTRUMENT_2, objTransactionTO.getChequeNo2());
        map.put(TransferTrans.DR_INST_TYPE, objTransactionTO.getInstType());
        map.put(TransferTrans.DR_INST_DATE, objTransactionTO.getChequeDt());
        return map;
    }

    private HashMap createCreditMap(TransactionTO obj, String branchID) throws Exception{
        HashMap map = new HashMap();
        map.put(TransferTrans.CR_PROD_TYPE, obj.getProductType());
        map.put(TransferTrans.PARTICULARS, acno);
        if (obj.getProductType().equals("GL")) {
            map.put(TransferTrans.CR_AC_HD, obj.getDebitAcctNo());
        } else {
            map.put(TransferTrans.CR_PROD_ID, CommonUtil.convertObjToStr(obj.getProductId()));
            map.put(TransferTrans.CR_AC_HD, null);
            map.put(TransferTrans.CR_ACT_NUM, CommonUtil.convertObjToStr(obj.getDebitAcctNo()));
        }
        if (!obj.getProductType().equals("GL")) {
            HashMap interBranchCodeMap = new HashMap();
            interBranchCodeMap.put("ACT_NUM", obj.getDebitAcctNo());
            List interBranchCodeList = sqlMap.executeQueryForList("getSelectInterBranchCode", interBranchCodeMap);
            if (interBranchCodeList != null && interBranchCodeList.size() > 0) {
                interBranchCodeMap = (HashMap) interBranchCodeList.get(0);
                System.out.println("interBranchCodeMap : " + interBranchCodeMap);
                map.put(TransferTrans.CR_BRANCH, CommonUtil.convertObjToStr(interBranchCodeMap.get("BRANCH_CODE")));
            }else{
                map.put(TransferTrans.CR_BRANCH, branchID);
            }
        }else{
            map.put(TransferTrans.CR_BRANCH, branchID);
        }
        map.put(TransferTrans.CURRENCY, CURRENCY_INR);
        return map;
    }

    public void addTransferDebit(HashMap txMap, double amount) {
        if (this.transType.equals(CommonConstants.CREDIT)) {
            objCashTxTo = objTrans.getDebitTransferTO(txMap, amount);
        }

        txList.add(objTrans.getDebitTransferTO(txMap, amount));
    }

    /**
     * This method is to be used in the scenario where there are debits and
     * credits which involve add or subtract amount to one account and transfer
     * to another account ie: independent debit/credit to one account and
     * independent transfer to another account
     */
    public TxTransferTO addTransferDebitLocal(HashMap txMap, double amount) {
        return objTrans.getDebitTransferTO(txMap, amount);
    }

    public void addTransferCredit(HashMap txMap, double amount) {
        if (this.transType.equals(CommonConstants.DEBIT)) {
            objCashTxTo = objTrans.getCreditTransferTO(txMap, amount);
        }
        txList.add(objTrans.getCreditTransferTO(txMap, amount));
    }

    public TxTransferTO addTransferCreditLocal(HashMap txMap, double amount) {
        return objTrans.getCreditTransferTO(txMap, amount);
    }

    public void doUpdate(String command) throws Exception {
        deletedTransDetailsTO = (LinkedHashMap) transactionDetailsMap.remove("DELETED_TRANS_TOs");
        if ((deletedTransDetailsTO != null)) {
            for (int i = 1, j = deletedTransDetailsTO.size(); i <= j; i++) {
                objTransactionTO = (TransactionTO) deletedTransDetailsTO.get(String.valueOf(i));
                deleteRemitTransDetails(command);
            }
        }
        if (allowedTransDetailsTO != null) {
            for (int i = 1, j = allowedTransDetailsTO.size(); i <= j; i++) {
                objTransactionTO = (TransactionTO) allowedTransDetailsTO.get(String.valueOf(i));
                setTransactionType(objTransactionTO.getTransType());
                if ((objTransactionTO.getStatus() != null) && (objTransactionTO.getStatus().length() > 0)) {
                    updateRemitTransDetails(command);
                    batchId = objTransactionTO.getBatchId();
                    batchDate = objTransactionTO.getBatchDt();
                } else {
                    objTransactionTO.setBatchId(batchId);
                    objTransactionTO.setBatchDt(batchDate);
                    insertRemitTransDetails(command);
                }
            }
        }
    }

    public void doDelete(String command) throws Exception {
        if (allowedTransDetailsTO != null) {
            for (int i = 1, j = allowedTransDetailsTO.size(); i <= j; i++) {
                objTransactionTO = (TransactionTO) allowedTransDetailsTO.get(String.valueOf(i));
                deleteRemitTransDetails(command);
            }
        }
    }

    public void deleteTxList() throws Exception {
        txList = new ArrayList();
    }

    /**
     * Executes Insert, Update, Delete commands
     */
    public HashMap execute(HashMap map) throws Exception {
        System.out.println("transactiondao map####" + map);
        if (map.containsKey("generateSingleTransId")) {
            generateSingleTransId=CommonUtil.convertObjToStr(map.get("generateSingleTransId"));
        }
        if(map.containsKey("RETURN_MAP") && map.get("RETURN_MAP") != null){
            auctionMap.clear();
            auctionMap = (HashMap)map.get("RETURN_MAP");
        }
        AccountClosingTO tto = null;
        LoanTransactionTO lto = null;
        RemittancePaymentTO rto = null;
        _branchCode = CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID));
        Date currDate = ServerUtil.getCurrentDate(_branchCode);
        branchID = _branchCode;
        System.out.println("#### TransactionDAO branchID set : " + branchID);
        userID = CommonUtil.convertObjToStr(map.get(CommonConstants.USER_ID));
        logDAO = new LogDAO();
        setInitialValuesForLogTO(map);
        final String command = CommonUtil.convertObjToStr(map.get("MODE"));
        setCommandMode(command);
        if (map.containsKey("TransactionTO")) {
            transactionDetailsMap = (LinkedHashMap) map.get("TransactionTO");
            System.out.println("#####transactionDetailsMap :" + transactionDetailsMap);
            if (transactionDetailsMap.size() > 0) {
                if (transactionDetailsMap.containsKey("NOT_DELETED_TRANS_TOs")) {
                    allowedTransDetailsTO = (LinkedHashMap) transactionDetailsMap.get("NOT_DELETED_TRANS_TOs");
                    System.out.println("#####allowedTransDetailsTO :" + allowedTransDetailsTO);

                    if (map.containsKey("accountclosing")) {
                        System.out.println("#####accountclosing inside if:");
                        tto = new AccountClosingTO();
                        tto = (AccountClosingTO) map.get("accountclosing");
                        System.out.println("#####accountclosing tto:" + tto);
                        if (tto != null) {
                            acno = CommonUtil.convertObjToStr(tto.getActNum());
                        }
                        if (map.containsKey(TransferTrans.PARTICULARS)) {
                            particulars = CommonUtil.convertObjToStr(map.get(TransferTrans.PARTICULARS));
                        }
                        if ((map.containsKey("ACCOUNT_CLOSING")) && (map.get("ACCOUNT_CLOSING") != null)) {
                            act_closing = CommonUtil.convertObjToStr(map.get("ACCOUNT_CLOSING"));
                            System.out.println("#####act_closingcheck" + act_closing);
                        }
                    }
                    
                    if (map.containsKey("loantransaction")) {
                        lto = new LoanTransactionTO();
                        lto = (LoanTransactionTO) map.get("loantransaction");
                        if (lto != null) {
                            acno = CommonUtil.convertObjToStr(lto.getActNum());
                        }
                        if (map.containsKey(TransferTrans.PARTICULARS)) {
                            particulars = CommonUtil.convertObjToStr(map.get(TransferTrans.PARTICULARS));
                        }
                    }

                    if (map.containsKey("RemittancePaymentTO")) {
                        System.out.println("#####RemittancePaymentTO inside if:");
                        rto = new RemittancePaymentTO();
                        rto = (RemittancePaymentTO) map.get("RemittancePaymentTO");
                        System.out.println("#####accountclosing rto:" + rto);
                        if (rto != null) {
                            acno = CommonUtil.convertObjToStr(rto.getInstrumentType()) + " " + CommonUtil.convertObjToStr(rto.getPayStatus()) + " " + CommonUtil.convertObjToStr(rto.getInstrumentNo1()) + "" + CommonUtil.convertObjToStr(rto.getInstrumentNo2());
                        }
                    }
                    System.out.println("#####acno :" + acno);
                    if (map.containsKey("accountclosing") && map.containsKey("DEPOSITCLOSINGDAO") && map.get("DEPOSITCLOSINGDAO") != null && map.get("DEPOSITCLOSINGDAO").equals("DEPOSITCLOSING")) {// Added by nithya on 04-12-2018 for KD 276 - LTD- Deposit Loan Closure- Trans Mod Type for Deposit Head is wrong
                        ltdClosing = "Y";
                    }
                    if (command.equals(CommonConstants.TOSTATUS_INSERT)) {
                        //                     if(map.containsKey("PROCCHARGEMAP")){        //This for transfer termloan processingcharge
                        //                        insertMap.put("COMMAND", map.get("COMMAND"));
                        //                        insertMap.put("PROCCHARGEHASH",map.get("PROCCHARGEMAP"));
                        //                        transferDAO.execute(insertMap);
                        //                        updateProcessingChargesFromOperative(insertMap);
                        //                    }
                        doInsert(command);
                    } else if (command.equals(CommonConstants.TOSTATUS_UPDATE)) {
                        doUpdate(command);
                    } else if (command.equals(CommonConstants.TOSTATUS_DELETE)) {
                        doDelete(command);
                    } else {
                        throw new NoCommandException();
                    }
                }
            }
        }
        destroyObjects();
        return null;
    }

    //     private void updateProcessingChargesFromOperative(HashMap procFullHash) throws Exception  {
    //        System.out.println("#####collectfromoperative"+procFullHash);
    //        HashMap procHash = (HashMap) procFullHash.get("PROCCHARGEHASH");
    //        double procAmt = CommonUtil.convertObjToDouble(procHash.get("PROC_AMT")).doubleValue();
    //        HashMap txMap = new HashMap();
    //        if(procAmt > 0){
    //            txMap = new HashMap();
    //            ArrayList transferList = new ArrayList(); // for local transfer
    //            txMap.put(TransferTrans.DR_PROD_ID, (String)procHash.get("OA_PROD_ID"));
    //            txMap.put(TransferTrans.DR_ACT_NUM, (String)procHash.get("OA_ACT_NUM"));
    //            txMap.put(TransferTrans.DR_PROD_TYPE, TransactionFactory.OPERATIVE);
    //            txMap.put(TransferTrans.DR_BRANCH, _branchCode);
    //            List lst = (List) sqlMap.executeQueryForList("getProcChargeAcHd",procHash);
    //            HashMap acHeads = (HashMap) lst.get(0);
    //            txMap.put(TransferTrans.CR_AC_HD, (String)acHeads.get("PROC_CHRG"));
    //            txMap.put(TransferTrans.CR_BRANCH, _branchCode);
    //            txMap.put(TransferTrans.CURRENCY, "INR");
    //            txMap.put(TransferTrans.CR_PROD_TYPE, TransactionFactory.GL);
    //            System.out.println("####### insertAccHead txMap " + txMap);
    //            TransferTrans trans = new TransferTrans();
    //            trans.setTransMode(CommonConstants.TX_TRANSFER);
    //            trans.setInitiatedBranch(_branchCode);
    //            trans.setForProcCharge(true);
    //            trans.setLinkBatchId(CommonUtil.convertObjToStr(procHash.get("LINK_BATCH_ID")));
    //            transferList.add(trans.getDebitTransferTO(txMap,procAmt));
    //            transferList.add(trans.getCreditTransferTO(txMap,procAmt));
    //            String cmd = CommonUtil.convertObjToStr(procFullHash.get("COMMAND"));
    //            trans.doDebitCredit(transferList, _branchCode, false, cmd);
    //        }
    //    }
    public void addCashList(ArrayList cashList) throws Exception {
        this.txCashList = cashList;
        //        doTransfer();
    }

    public void doTransfer() throws Exception {
        //Split the txList into Cash and Transfer lists
        objTrans.setLinkBatchId(getBatchId());
        objTrans.setInitiatedBranch(getInitiatedBranch());
        System.out.println("TRANSACTIONDAO####" + objTrans + "list" + txList +branchID);
        System.out.println("TAXXXXlist" + txList);
        System.out.println("#####act_closingcheck" + act_closing);
        if (txList != null && txList.size() > 1) {
            int size = txList.size();
            double crAmount = 0, drAmount = 0, diffAmount = 0;
            TxTransferTO transferTO;
            for (int i = 0; i < size; i++) {
                transferTO = (TxTransferTO) txList.get(i);
                if (transferTO.getTransType().equals(CommonConstants.CREDIT)) {
                    crAmount += transferTO.getAmount().doubleValue();
                }
                if (transferTO.getTransType().equals(CommonConstants.DEBIT)) {
                    drAmount += transferTO.getAmount().doubleValue();
                }
            }
            diffAmount = Math.abs(crAmount - drAmount);

            for (int i = 0; i < size; i++) {
                transferTO = (TxTransferTO) txList.get(i);
                if (!transferTO.getTransType().equals(this.transType)) {
                    transferTO.setAmount(new Double(transferTO.getAmount().doubleValue() - diffAmount));
                    txList.remove(i);
                    transferTO.setInpAmount(transferTO.getAmount());
                    txList.add(i, transferTO);
                    break;
                }
            }
            if (getLoanAmtMap() != null && getLoanAmtMap().size() > 0) {
                objTrans.setAllAmountMap(getLoanAmtMap());
            }
            if (breakLoanHierachy != null && breakLoanHierachy.equals("Y")) {
                objTrans.setBreakLoanHierachy("Y");
            } else {
                objTrans.setBreakLoanHierachy("N");
            }
            objTrans.doDebitCredit(txList, branchID, false, getCommandMode());
            transferTO = null;
        }
        System.out.println("txCashList===" + txCashList);
        if (txCashList != null && txCashList.size() > 0) {
            doCashTransfer();
        }
        objTrans.setAllAmountMap(new HashMap());
    }

    public static void doCashAuthorize(HashMap cashAuthMap) throws Exception {
        CashTransactionDAO cDAO = new CashTransactionDAO();
        cDAO.execute(cashAuthMap, false);
    }

    private void doCashTransfer() throws Exception {
        TransactionTO objTxTransferTO;
        HashMap cashMap;
        CashTransactionDAO cashDao;
        CashTransactionTO cashTO;

        for (int i = 0, j = txCashList.size(); i < j; i++) {
            objTxTransferTO = (TransactionTO) txCashList.get(i);
            cashDao = new CashTransactionDAO();
            cashTO = new CashTransactionTO();
            cashMap = new HashMap();
//            String prodId = objCashTxTo.getProdId();
            System.out.println("@@@@@@@@@@@@@objCashTxTo" + objCashTxTo);
//            if((!prodId.equals("")) && (prodId != null))
            cashMap.put(PRODUCTTYPE, objCashTxTo.getProdType());
            cashMap.put(CommonConstants.USER_ID, objCashTxTo.getInitTransId());
            cashMap.put(CommonConstants.BRANCH_ID, logTO.getBranchId());
            cashMap.put(CommonConstants.IP_ADDR, logTO.getIpAddr());
            cashMap.put(CommonConstants.MODULE, logTO.getModule());
            cashMap.put(CommonConstants.SCREEN, logTO.getScreen());
            cashMap.put(TransactionDAOConstants.OLDAMT, getOldAmt());
            if (act_closing.equals("ACCOUNT_CLOSING")) {
                cashMap.put("ACCOUNT_CLOSING", "ACCOUNT_CLOSING");
            }

            cashTO.setAmount(objTxTransferTO.getTransAmt());
            cashTO.setAcHdId(objCashTxTo.getAcHdId());
            cashTO.setActNum(objCashTxTo.getActNum());
            cashTO.setProdType(objCashTxTo.getProdType());
            cashTO.setInstType(objTxTransferTO.getInstType());
            cashTO.setInstrumentNo1(objTxTransferTO.getChequeNo());
            cashTO.setInstrumentNo2(objTxTransferTO.getChequeNo2());
            cashTO.setInstDt(objTxTransferTO.getChequeDt());
            cashTO.setProdId(objCashTxTo.getProdId());
            cashTO.setParticulars(objCashTxTo.getParticulars());
            cashTO.setStatus(objTxTransferTO.getStatus());
            cashTO.setStatusBy(objCashTxTo.getInitTransId());
            cashTO.setTransDt(ServerUtil.getCurrentDate(_branchCode));
            cashTO.setTransId(objTxTransferTO.getTransId());
            cashTO.setTransType(objCashTxTo.getTransType());
            if (branchID != null) {
                cashTO.setBranchId(branchID);
            } else {
                cashTO.setBranchId(getInitiatedBranch());
            }
            cashTO.setInitChannType(CommonConstants.CASHIER);
            cashTO.setInitTransId(objCashTxTo.getInitTransId());
            cashTO.setInpAmount(objTxTransferTO.getTransAmt());
            cashTO.setInpCurr(objCashTxTo.getInpCurr());
            cashTO.setAuthorizeRemarks(objCashTxTo.getAuthorizeRemarks());
            cashTO.setAuthorizeStatus_2(objCashTxTo.getAuthorizeStatus_2());
            cashTO.setLinkBatchId(objTxTransferTO.getBatchId());
            cashTO.setInitiatedBranch(getInitiatedBranch());
            cashTO.setCommand(getCommandMode());
            cashTO.setSingleTransId(objCashTxTo.getSingleTransId());
            cashTO.setNarration(objCashTxTo.getNarration());
            cashTO.setInstrumentNo2(objCashTxTo.getInstrumentNo2());
            if((cashTO.getInstrumentNo2()==null || cashTO.getInstrumentNo2().length()<=0) && objTxTransferTO.getChequeNo2()!=null && objTxTransferTO.getChequeNo2().length()>0){
            	cashTO.setInstrumentNo2(objTxTransferTO.getChequeNo2());   
            }
            //Added by sreekrishnan for deposit interbranch closing
            if(cashTO.getInstrumentNo2()!=null && cashTO.getInstrumentNo2().equals("Deposit Closure")){
                cashTO.setBranchId(objCashTxTo.getBranchId());
            }
            cashTO.setTransModType(objCashTxTo.getTransModType());
            if(getScreenName() != null && CommonUtil.convertObjToStr(getScreenName()).length()>0){
                cashTO.setScreenName(getScreenName());
            }else{
                cashTO.setScreenName(objCashTxTo.getScreenName());
            }
            cashMap.put("TRANS_MOD_TYPE",objCashTxTo.getTransModType());
            cashMap.put("CashTransactionTO", cashTO);
            if (getLoanAmtMap() != null && getLoanAmtMap().size() > 0) {
                cashMap.put("ALL_AMOUNT", getLoanAmtMap());
            }
            if(auctionMap!= null && auctionMap.size() > 0){
                cashMap.put("AUCTION_MAP", auctionMap);
            }
            System.out.println("#### doCashTransfer() : cashMap : " + cashMap);
            cashDao.execute(cashMap, false);
            cashTO = null;
            cashDao = null;
            cashMap = null;
            objTxTransferTO = null;
        }
    }

    public void doTransferLocal(ArrayList localTxList, String localBranchID) throws Exception {
        if (CommonUtil.convertObjToStr(getTransactionType()).equals(CASH)) {
            doCashTransfer();
        } else {
            if (loanDebitInt != null && loanDebitInt.length() > 0) {
                objTrans.setLoanDebitInt(loanDebitInt);
            }

            if (getLoanAmtMap() != null && getLoanAmtMap().size() > 0) {
                objTrans.setAllAmountMap(getLoanAmtMap());
            }
            if (isForLodgeICC()) {
                objTrans.setForLodgementICC(true);
            }
            objTrans.setForDebitInt(isForDebitInt());
            objTrans.setInitiatedBranch(getInitiatedBranch());
            objTrans.setLinkBatchId(getLinkBatchID());
            if (breakLoanHierachy != null && breakLoanHierachy.equals("Y")) {
                objTrans.setBreakLoanHierachy("Y");
            } else {
                objTrans.setBreakLoanHierachy("N");
            }
            objTrans.doDebitCredit(localTxList, localBranchID, false, getCommandMode());
            loanDebitInt = null;
            setForDebitInt(false);
        }
    }

    /**
     * To Insert Remittance Transaction Details into REMIT_ISSUE_TRANS table
     */
    private void insertRemitTransDetails(String command) throws Exception {
        HashMap txMap = null;

        objTransactionTO.setStatus(CommonConstants.STATUS_CREATED);
        // Generates transactionId
        transactionId = getTransactionId();

        // Sets the transactionId in the Remit Trans Details TO Object
        System.out.println("#$#$ batchId :" + batchId);
        System.out.println("#$#$ batchDate :" + batchDate);
        objTransactionTO.setBatchId(batchId);
        objTransactionTO.setBatchDt(batchDate);
        objTransactionTO.setTransId(transactionId);

        // for Transfer
        if (getTransactionType().equals(TRANSFER)) {
            if (transType.equals(CommonConstants.DEBIT)) {
                txMap = createDebitMap(objTransactionTO, branchID);
                 if (objTransactionTO.getProductType().equals("OA")){
                         txMap.put("TRANS_MOD_TYPE", "OA");
                    }else if(objTransactionTO.getProductType().equals("AB")){
                         txMap.put("TRANS_MOD_TYPE", "AB");
                    }else if(objTransactionTO.getProductType().equals("SA")){
                         txMap.put("TRANS_MOD_TYPE", "SA");
                    }else if(objTransactionTO.getProductType().equals("TL")){
                         txMap.put("TRANS_MOD_TYPE", "TL");
                    }else if(objTransactionTO.getProductType().equals("AD")){
                         txMap.put("TRANS_MOD_TYPE", "AD");
                    }else
                         txMap.put("TRANS_MOD_TYPE", "GL");
                    if(generateSingleTransId!=null && generateSingleTransId.length()>0){
                        txMap.put("generateSingleTransId", generateSingleTransId);
                    }
                    txMap.put("SCREEN_NAME",objTransactionTO.getScreenName());
                    if(objTransactionTO.getProductType().equals("TD") && ltdClosing.equalsIgnoreCase("Y")){// Added by nithya on 04-12-2018 for KD 276 - LTD- Deposit Loan Closure- Trans Mod Type for Deposit Head is wrong
                      txMap.put("TRANS_MOD_TYPE", "TD");  
                    }
                addTransferDebit(txMap, CommonUtil.convertObjToDouble(objTransactionTO.getTransAmt()).doubleValue());
            } else if (transType.equals(CommonConstants.CREDIT)) {
                txMap = createCreditMap(objTransactionTO, branchID);
                if (objTransactionTO.getProductType().equals("OA")){
                         txMap.put("TRANS_MOD_TYPE", "OA");
                    }else if(objTransactionTO.getProductType().equals("AB")){
                         txMap.put("TRANS_MOD_TYPE", "AB");
                    }else if(objTransactionTO.getProductType().equals("SA")){
                         txMap.put("TRANS_MOD_TYPE", "SA");
                    }else if(objTransactionTO.getProductType().equals("TL")){
                         txMap.put("TRANS_MOD_TYPE", "TL");
                    }else if(objTransactionTO.getProductType().equals("AD")){
                         txMap.put("TRANS_MOD_TYPE", "AD");
                    }else
                         txMap.put("TRANS_MOD_TYPE", "GL");
                    if(generateSingleTransId!=null && generateSingleTransId.length()>0){
                        txMap.put("generateSingleTransId", generateSingleTransId);
                    }
                    txMap.put("SCREEN_NAME",objTransactionTO.getScreenName());
                if (objTransactionTO.getScreenName() != null && objTransactionTO.getScreenName().equals("Account Closing")
                        && objTransactionTO.getProductType().equals("AB") && objTransactionTO.getInstType() != null && objTransactionTO.getInstType().equals("CHEQUE")) {
                    txMap.put(TransferTrans.CURRENCY, CURRENCY_INR);
                    txMap.put(TransferTrans.DR_INSTRUMENT_1, objTransactionTO.getChequeNo());
                    txMap.put(TransferTrans.DR_INSTRUMENT_2, objTransactionTO.getChequeNo2());
                    txMap.put(TransferTrans.DR_INST_TYPE, objTransactionTO.getInstType());
                    txMap.put(TransferTrans.DR_INST_DATE, objTransactionTO.getChequeDt());
               }
                addTransferCredit(txMap, CommonUtil.convertObjToDouble(objTransactionTO.getTransAmt()).doubleValue());
            }
        } else {
            txCashList.add(objTransactionTO);
        }
        System.out.println("txCashList%%%%%" + txCashList);

        logTO.setData(objTransactionTO.toString());
        logTO.setPrimaryKey(objTransactionTO.getKeyData());
        logTO.setStatus(command);
        if (objTransactionTO.getBranchId() != null) {
        } else {
            objTransactionTO.setBranchId(_branchCode);
        }
        sqlMap.executeUpdate("insertRemittanceIssueTransactionTO", objTransactionTO);
        logDAO.addToLog(logTO);
    }

    public static void authorizeCashAndTransfer(String linkBatchId, String authorizationStatus, HashMap map) throws Exception {
        /*
         * TO BE CALLED AS :
         *  cashAuthMap = new HashMap();
         cashAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
         cashAuthMap.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
         TransactionDAO.authorizeCashAndTransfer(linkBatchId, authorizeStatus, cashAuthMap);
         cashAuthMap = null ;
         */
        //Declarations
        TransactionTO transactionTO;
        CashTransactionTO cashTO = null;
        String batchId = null, tempBatchId = null;
        HashMap cashAuthMap, tempMap, transIdMap, transferTransParam;
        ArrayList cashTransList, transferTransList, transactionList;

        //        List remitIssueTransList = sqlMap.executeQueryForList("getSelectRemittanceIssueTransactionTO", linkBatchId);
        //        for(int c = 0 ; c < remitIssueTransList.size() ; c++){
        //            transactionTO = (TransactionTO)remitIssueTransList.get(c) ;
        //            if (transactionTO.getTransType().equals(CASH)){
        //////            cashAuthMap = new HashMap();
        //////            tempMap = new HashMap() ;
        //////            System.out.println("@@@@linkBatchId"+linkBatchId);
        //////            List lst = (List) sqlMap.executeQueryForList("getCashTransactionTOForAuthorzation", linkBatchId);
        //////            if (lst!=null)
        //////            if(lst.size()>0) {
        //////            tempMap.put(CommonConstants.AUTHORIZESTATUS, authorizationStatus) ;
        //////            cashAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        //////            cashAuthMap.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
        //////            cashAuthMap.put(TransactionDAOConstants.OLDAMT, CommonUtil.convertObjToDouble("0.0"));
        //////            for (int i=0; i<lst.size(); i++) {
        //////                cashTO = (CashTransactionTO) lst.get(i);
        //////                if (cashTO != null) {
        //////                    transIdMap = new HashMap();
        //////                    transIdMap.put(TRANS_ID, cashTO.getTransId());
        //////                    cashTransList = new ArrayList();
        //////                    cashTransList.add(transIdMap);
        //////                    tempMap.put(CommonConstants.AUTHORIZEDATA, cashTransList) ;
        //////                    cashAuthMap.put(CommonConstants.AUTHORIZEMAP, tempMap) ;
        //////                    cashAuthMap.put(PRODUCTTYPE, cashTO.getProdType());
        //////                    if(map.containsKey("PRODUCT"))
        //////                        cashAuthMap.put("PRODUCT", "SHARE");
        //////                    doCashAuthorize(cashAuthMap) ;
        //////                }
        //////            }
        //////            transIdMap = null;
        //////            lst = null;
        //////
        //////            }3comment only correct value
        //////            cashTransList = null ;
        //////            cashAuthMap = null;
        //////            tempMap = null;
        //////            cashTO = null;
        //            }
        //            else {
        debitInt = "";
        transactionList = new ArrayList(); //This is the list that is passed to TRANSFER_TRANS
        transferTransParam = new HashMap();
        transferTransParam.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        transferTransParam.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
        transferTransParam.put("LINK_BATCH_ID", linkBatchId);
        //System.out.println("#@#@#@#@#@   map in uth : "+map);
        if(map.containsKey("DEBIT_LOAN_TYPE")){//Added By Revathi.L
          transferTransParam.put("DEBIT_LOAN_TYPE",CommonUtil.convertObjToStr(map.get("DEBIT_LOAN_TYPE"))); 
        }
        tempMap = new HashMap();
        if (map.containsKey("BATCH_ID") && map.get("BATCH_ID") != null) {
            transferTransParam.put("BATCH_ID", map.get("BATCH_ID"));
        }
        if (map.containsKey("INTERBRANCH_CREATION_SCREEN") && map.get("INTERBRANCH_CREATION_SCREEN") != null) {
            transferTransParam.put("INTERBRANCH_CREATION_SCREEN", map.get("INTERBRANCH_CREATION_SCREEN"));
        }
        tempMap.put("ACCOUNTNO", linkBatchId);
        transferTransParam.put("COMMAND", sqlMap.executeQueryForObject("getAccountClosingStatus", tempMap));
        tempMap = null;
        transferTransParam.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        if (map.containsKey("SHARE_PAYMENT_DAO") && map.get("SHARE_PAYMENT_DAO") != null) {
            transferTransParam.put("SINGLE_TRANS_ID", map.get("SINGLE_TRANS_ID"));
            transferTransList = (ArrayList) sqlMap.executeQueryForList("getAuthBatchTxTransferTOsForDiv", transferTransParam);
        } else if (map.containsKey("DEPOSIT_CLOSING_LOAN") && map.get("DEPOSIT_CLOSING_LOAN") != null) {
            transferTransParam.put("SINGLE_TRANS_ID", map.get("SINGLE_TRANS_ID"));
            transferTransList = (ArrayList) sqlMap.executeQueryForList("getAuthBatchTxTransferTOsForDiv", transferTransParam);
        }
        else if (map.containsKey("SALARY_RECOVERY_TRANSACTION") && map.get("SALARY_RECOVERY_TRANSACTION") != null) {
            transferTransParam.put("TRANS_ALL_ID", linkBatchId);
            transferTransParam.put(CommonConstants.INITIATED_BRANCH, map.get(CommonConstants.BRANCH_ID));
            Date currDate = ServerUtil.getCurrentDate(CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID)));
            transferTransParam.put("TRANS_DT", currDate);
            transferTransList = (ArrayList) sqlMap.executeQueryForList("getBatchTxTransferTOsTransAllId", transferTransParam);
        }else if(map.containsKey("SHARE_ACCT") && map.get("SHARE_ACCT") != null){
            transferTransParam.put("BATCH_ID",linkBatchId);
            transferTransParam.put(CommonConstants.INITIATED_BRANCH, map.get(CommonConstants.BRANCH_ID));
            Date currDate = ServerUtil.getCurrentDate(CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID)));
            transferTransParam.put("TRANS_DT", currDate);
            transferTransList = (ArrayList) sqlMap.executeQueryForList("getBatchTxTransferTOsShareAcct", transferTransParam);
        }else if (map.containsKey("AGENT_COLLECTION_DETAILS_DAO") && map.get("AGENT_COLLECTION_DETAILS_DAO") != null) {
            transferTransParam.put("BATCH_ID",linkBatchId);
            transferTransParam.put(CommonConstants.INITIATED_BRANCH, map.get(CommonConstants.BRANCH_ID));
            Date currDate = ServerUtil.getCurrentDate(CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID)));
            transferTransParam.put("TRANS_DT", currDate);
            System.out.println("transferTransParam : "+transferTransParam);
            transferTransList = (ArrayList) sqlMap.executeQueryForList("getBatchTxTransferTOsShareAcct", transferTransParam);
        }else{
            transferTransList = (ArrayList) sqlMap.executeQueryForList("getAuthBatchTxTransferTOs", transferTransParam);
        }
        if (transferTransList != null) {
            for (int x = 0; x < transferTransList.size(); x++) {
                //                System.out.println("#### transferTransList : "+transferTransList);
                //                System.out.println("#### X : "+x);
                batchId = ((TxTransferTO) transferTransList.get(x)).getBatchId();
                //                System.out.println("#### batchId : "+batchId);
                ArrayList transList = getBatch(batchId, transferTransList, map);
                x = 0;
                transferTransParam.put("BATCH_ID", batchId);
                transferTransParam.put(CommonConstants.AUTHORIZESTATUS, authorizationStatus);
                System.out.println("#### transList : " + transList);
                System.out.println("#### debitInt : " + debitInt);
                TransferTrans objTrans = new TransferTrans();
                if (map.containsKey("DEBIT_LOAN_TYPE"))//if (debitInt.equals("DP"))
                {
                    objTrans.setLoanDebitInt(debitInt);
                }                
                transferTransParam.put("DEBIT_LOAN_TYPE", debitInt);
                if(map.containsKey("LOAN_CLOSING_SCREEN")){
                    transferTransParam.put("LOAN_CLOSING_SCREEN", "LOAN_CLOSING_SCREEN"); 
                    transferTransParam.put("DEBIT_LOAN_TYPE", "DP");
                }
                if(map.containsKey("ACCOUNT_CLOSING")){ //Added By Kannan AR For KDSA : 301
                    transferTransParam.put("GROUP_SMS","GROUP_SMS");
                }                
                if(map.containsKey("FROM_RESERVE_SCREEN")){
                    transferTransParam.put("FROM_RESERVE_SCREEN","FROM_RESERVE_SCREEN");
                    transferTransParam.put("BACK_DATED_TRANSACTION","BACK_DATED_TRANSACTION");
                    transferTransParam.put("TRANS_DATE",map.get("TRANS_DATE"));
                }
                if(map.containsKey("FROM_MOBILE_APP_CUST_CREATION") && map.get("FROM_MOBILE_APP_CUST_CREATION") != null && map.get("FROM_MOBILE_APP_CUST_CREATION").equals("FROM_MOBILE_APP_CUST_CREATION") && map.containsKey("CREDIT_TO_DEPOSIT_TRANSFER_SCREEN")){
                    transferTransParam.put("CREDIT_TO_DEPOSIT_TRANSFER_SCREEN","CREDIT_TO_DEPOSIT_TRANSFER_SCREEN");
                }
                if(map.containsKey("DAILY_DEPOSIT_AGENT_ID") && map.get("DAILY_DEPOSIT_AGENT_ID") != null){
                    transferTransParam.put("DAILY_DEPOSIT_AGENT_ID",map.get("DAILY_DEPOSIT_AGENT_ID"));
                    transferTransParam.put("CREDIT_TO_DEPOSIT_TRANSFER_SCREEN","CREDIT_TO_DEPOSIT_TRANSFER_SCREEN");
                }
                System.out.println("DebitType####"+map.get("DEBIT_LOAN_TYPE"));
                objTrans.doTransferAuthorize(transList, transferTransParam);
                debitInt = "";
                transList = null;
            }
        }
        transferTransParam = null;
        transactionList = null;
        //            }
        //        }
        //        remitIssueTransList = null ;
        // first transfer authorize after cash authorize
        cashAuthMap = new HashMap();
        tempMap = new HashMap();
        HashMap getCashForAuthMap = new HashMap();
        Date currDate = ServerUtil.getCurrentDate(CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID)));
        System.out.println("@@@@linkBatchId" + linkBatchId);
        getCashForAuthMap.put("LINK_BATCH_ID", linkBatchId);
        getCashForAuthMap.put("TRANS_DT", currDate);
        getCashForAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        //added by sreekrishnan for cashier
        if (map.containsKey("LOAN_OPENING_PAYMENT") && map.containsKey("TRANS_ID") && map.get("TRANS_ID") != null) { 
            getCashForAuthMap.put("TRANS_ID", map.get("TRANS_ID"));
        }
        if (map.containsKey("INDEND_TRANSACTION")) {
            getCashForAuthMap.put("TRANS_TYPE",CommonConstants.DEBIT);
        }
        if (map.containsKey("GOLD_LOAN_CLOSING_TRANSACTION")) {
            getCashForAuthMap.put("TRANS_TYPE",CommonConstants.CREDIT);
        }
        List lst = null;
        if (map.containsKey("SALARY_RECOVERY_TRANSACTION") && map.get("SALARY_RECOVERY_TRANSACTION") != null) {
            getCashForAuthMap.put("TRANS_ALL_ID", linkBatchId);
            getCashForAuthMap.put(CommonConstants.INITIATED_BRANCH, map.get(CommonConstants.BRANCH_ID));
            lst = (List) sqlMap.executeQueryForList("getCashTransTOsTransAllId", getCashForAuthMap);
        }else{
            lst = (List) sqlMap.executeQueryForList("getCashTransactionTOForAuthorzation", getCashForAuthMap);
        }
        //ends
        if (lst != null) {
            if (lst.size() > 0) {
                tempMap.put(CommonConstants.AUTHORIZESTATUS, authorizationStatus);
                cashAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
                cashAuthMap.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
                cashAuthMap.put(TransactionDAOConstants.OLDAMT, CommonUtil.convertObjToDouble("0.0"));
                if (map.containsKey("GOLD_LOAN_CLOSING_TRANSACTION")) {
                	cashAuthMap.put("GOLD_LOAN_CLOSING_TRANSACTION", "GOLD_LOAN_CLOSING_TRANSACTION");
                 }
                 if (map.containsKey("ACCOUNT_CLOSING")) {
                     cashAuthMap.put("ACCOUNT_CLOSING", "ACCOUNT_CLOSING");
                 }
                if(map.containsKey("DAILY_DEPOSIT_AGENT_ID") && map.get("DAILY_DEPOSIT_AGENT_ID") != null){
                    cashAuthMap.put("DAILY_DEPOSIT_AGENT_ID",map.get("DAILY_DEPOSIT_AGENT_ID"));
                 }
                if (map.containsKey("DAILY")) {
                    tempMap.put("DAILY", "DAILY");
                }
                for (int i = 0; i < lst.size(); i++) {
                    cashTO = (CashTransactionTO) lst.get(i);
                    if (cashTO != null) {
                        transIdMap = new HashMap();
                        transIdMap.put(TRANS_ID, cashTO.getTransId());
                        transIdMap.put("LINK_BATCH_ID", linkBatchId);
                        if (map.containsKey("TERM_LOAN_DAO") && map.get("TERM_LOAN_DAO") != null) {
                            transIdMap.put("IBR_HIERARCHY", cashTO.getIbrHierarchy());
                        }
                        if (map.containsKey("LOAN_CLOSING_SCREEN")) {
                            transIdMap.put("LOAN_CLOSING_SCREEN", "LOAN_CLOSING_SCREEN");
                        }
                        cashTransList = new ArrayList();
                        cashTransList.add(transIdMap);
                        tempMap.put(CommonConstants.AUTHORIZEDATA, cashTransList);
                        if (map.containsKey("LOAN_TRANS_OUT")) {
                            tempMap.put("LOAN_TRANS_OUT", "LOAN_TRANS_OUT");
                        }
                        cashAuthMap.put(CommonConstants.AUTHORIZEMAP, tempMap);
                        cashAuthMap.put(PRODUCTTYPE, cashTO.getProdType());
                        if (map.containsKey("PRODUCT")) {
                            cashAuthMap.put("PRODUCT", "SHARE");
                        }
                        if (cashTO.getAuthorizeRemarks() != null && cashTO.getAuthorizeRemarks().length() > 0) {
                            cashAuthMap.put("DEBIT_LOAN_TYPE", cashTO.getAuthorizeRemarks());
                        }
                        doCashAuthorize(cashAuthMap);
                        if (map.containsKey("DAILY")) {
                            i = lst.size();
                        }
                    }
                }
                transIdMap = null;
                lst = null;

            }
        }
        cashTransList = null;
        cashAuthMap = null;
        tempMap = null;
        cashTO = null;
    }

    public static void authorizeCashAndTransferWithoutRemitIssueDet(String linkBatchId, String authorizationStatus, HashMap map) throws Exception {
        /*
         * TO BE CALLED AS :
         *  cashAuthMap = new HashMap();
         cashAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
         cashAuthMap.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
         TransactionDAO.authorizeCashAndTransfer(linkBatchId, authorizeStatus, cashAuthMap);
         cashAuthMap = null ;
         */
        //Declarations
        TransactionTO transactionTO;
        CashTransactionTO cashTO;
        String batchId = null, tempBatchId = null;
        HashMap cashAuthMap, tempMap, transIdMap, transferTransParam;
        ArrayList cashTransList, transferTransList, transactionList;
        HashMap getCashForAuthMap = new HashMap();
        Date currDate = ServerUtil.getCurrentDate(CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID)));
        System.out.println("@@@@linkBatchId" + linkBatchId);
        getCashForAuthMap.put("LINK_BATCH_ID", linkBatchId);
        getCashForAuthMap.put("TRANS_DT", currDate);
        getCashForAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        //added by sreekrishnan for cashier
        if (map.containsKey("LOAN_OPENING_PAYMENT") && map.containsKey("TRANS_ID") && map.get("TRANS_ID") != null) { 
            getCashForAuthMap.put("TRANS_ID", map.get("TRANS_ID"));
        }
        if (map.containsKey("DEPOSIT_CLOSING_PAYMENT") && map.containsKey("TRANS_ID") && map.get("TRANS_ID") != null) { 
            getCashForAuthMap.put("TRANS_ID", map.get("TRANS_ID"));
        }
        if (map.containsKey("INDEND_TRANSACTION")) {
            getCashForAuthMap.put("TRANS_TYPE",CommonConstants.DEBIT);
        }
        if (map.containsKey("GOLD_LOAN_CLOSING_TRANSACTION")) {
            getCashForAuthMap.put("TRANS_TYPE",CommonConstants.CREDIT);
        }
        //ends
        List allCashTransList = sqlMap.executeQueryForList("getCashTransactionTOForAuthorzation", getCashForAuthMap);
        for (int c = 0; c < allCashTransList.size(); c++) {
            cashTO = (CashTransactionTO) allCashTransList.get(c);
            cashAuthMap = new HashMap();
            tempMap = new HashMap();
            transIdMap = new HashMap();
            cashTransList = new ArrayList();
            transIdMap.put(TRANS_ID, cashTO.getTransId());
            cashTransList.add(transIdMap);
            transIdMap = null;
            tempMap.put(CommonConstants.AUTHORIZESTATUS, authorizationStatus);
            tempMap.put(CommonConstants.AUTHORIZEDATA, cashTransList);
            cashAuthMap.put(CommonConstants.AUTHORIZEMAP, tempMap);
            if (map.containsKey("INTER_BRANCH_TRANS") && map.get("INTER_BRANCH_TRANS") != null) {
                cashAuthMap.put("INTER_BRANCH_TRANS", new Boolean(true));
                cashAuthMap.put("DAILY", "DAILY");

            }
            cashAuthMap.put(TransactionDAOConstants.OLDAMT, CommonUtil.convertObjToDouble("0.0"));
            cashAuthMap.put(PRODUCTTYPE, cashTO.getProdType());
            cashAuthMap.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
            cashAuthMap.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
            doCashAuthorize(cashAuthMap);
            cashTransList = null;
            cashAuthMap = null;
            tempMap = null;
            cashTO = null;
        }
        //            }
        //            else {
        transactionList = new ArrayList(); //This is the list that is passed to TRANSFER_TRANS
        transferTransParam = new HashMap();
        transferTransParam.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        transferTransParam.put(CommonConstants.USER_ID, map.get(CommonConstants.USER_ID));
        transferTransParam.put("LINK_BATCH_ID", linkBatchId);
        if (map.containsKey("MDS_BONUS_ENTRY") && map.get("MDS_BONUS_ENTRY") != null && 
            map.containsKey("LOGGED_BRANCH_ID") && map.get("LOGGED_BRANCH_ID") != null) {
            transferTransParam.put("TRANS_DT", ServerUtil.getCurrentDate(CommonUtil.convertObjToStr(map.get("LOGGED_BRANCH_ID"))));
        }else{
            transferTransParam.put("TRANS_DT", currDate);
        }
        tempMap = new HashMap();
        tempMap.put("ACCOUNTNO", linkBatchId);
        transferTransParam.put("COMMAND", sqlMap.executeQueryForObject("getAccountClosingStatus", tempMap));
        tempMap = null;
        transferTransParam.put(CommonConstants.BRANCH_ID, map.get(CommonConstants.BRANCH_ID));
        transferTransList = (ArrayList) sqlMap.executeQueryForList("getAuthBatchTxTransferTOs", transferTransParam);
        for (int x = 0; x < transferTransList.size(); x++) {
            System.out.println("#### transferTransList : " + transferTransList);
            System.out.println("#### X : " + x);
            batchId = ((TxTransferTO) transferTransList.get(x)).getBatchId();
            System.out.println("#### batchId : " + batchId);
            if (map.containsKey("MDS_STANDING_AD")) {
                String trnTyp = CommonUtil.convertObjToStr(((TxTransferTO) transferTransList.get(x)).getTransType());
                String trnMode = CommonUtil.convertObjToStr(((TxTransferTO) transferTransList.get(x)).getProdType());
                if (trnTyp.equals("DEBIT") && trnMode.equals("AD")) {
                    transferTransParam.put("DEBIT_LOAN_TYPE", "DP");
                }
            }
            ArrayList transList = getBatch(batchId, transferTransList, map);
            if (map.containsKey("DEPOSIT_CLOSING")) {
                debitInt = "";
                transferTransParam.put("DEPOSIT_CLOSING", "DEPOSIT_CLOSING");
            }
            System.out.println("debitInt" + debitInt);
            x = 0;
            //                        if(x == 0){
            //                            transactionList.add(transferTransList.get(x)) ;
            //                            transferTransList.remove(x);
            //                        }
            //                        if(x > 0 && batchId.equals(tempBatchId)){
            //                            transactionList.add(transferTransList.get(x)) ;
            //                        }


            //                        else{
            //                            transactionList.clear();
            //                            transactionList.add(transferTransList.get(x)) ;
            //                        }
            //                        tempBatchId = batchId ;
            transferTransParam.put("BATCH_ID", batchId);
            if (map.containsKey("LOAN_TRANS_OUT")) {
                transferTransParam.put("LOAN_TRANS_OUT", "LOAN_TRANS_OUT");
            }
            if (map.containsKey("PBAL")) {
                transferTransParam.put("PBAL", map.get("PBAL"));
                transferTransParam.put("DEBIT_LOAN_TYPE", "DP");
            }
            transferTransParam.put(CommonConstants.AUTHORIZESTATUS, authorizationStatus);
            if (map.containsKey("DEBIT_LOAN_TYPE")) {
                System.out.println("keyContains######"+map.get("DEBIT_LOAN_TYPE"));
                transferTransParam.put("DEBIT_LOAN_TYPE", "DP");
            }
            if (map.containsKey("INTER_BRANCH_TRANS") && map.get("INTER_BRANCH_TRANS") != null) {
                transferTransParam.put("INTER_BRANCH_TRANS", new Boolean(true));
            }
            if (map.containsKey("INTERBRANCH_CREATION_SCREEN") && map.get("INTERBRANCH_CREATION_SCREEN") != null) {
                transferTransParam.put("INTERBRANCH_CREATION_SCREEN", map.get("INTERBRANCH_CREATION_SCREEN"));
            }
            if (map.containsKey("LOGGED_BRANCH_ID") && map.get("LOGGED_BRANCH_ID") != null) {
                transferTransParam.put("LOGGED_BRANCH_ID", map.get("LOGGED_BRANCH_ID"));
            }
            if (map.containsKey("MDS_BONUS_ENTRY") && map.get("MDS_BONUS_ENTRY") != null) {
                transferTransParam.put("MDS_BONUS_ENTRY", map.get("MDS_BONUS_ENTRY"));
            }
            if (map.containsKey("DEPOSIT_MULTIPLE_RENEWAL") && map.get("DEPOSIT_MULTIPLE_RENEWAL") != null) { //Added By Kannan AR
                transferTransParam.put("DEPOSIT_MULTIPLE_RENEWAL", "DEPOSIT_MULTIPLE_RENEWAL");
            }
            TransferTrans objTrans = new TransferTrans();
            System.out.println("#### transList : " + transList + "transferTransParam" + transferTransParam);
            System.out.println("#### PBAL : " + map.get("PBAL") + "DEBIT_LOAN_TYPE" + map.get("DEBIT_LOAN_TYPE"));
            objTrans.doTransferAuthorize(transList, transferTransParam);
            transList = null;
        }
        transferTransParam = null;
        transactionList = null;
        //            }
        //        }
        allCashTransList = null;
    }

    private static ArrayList getBatch(String batch, ArrayList transList, HashMap map) {
        String id = "";
        ArrayList returnList = new ArrayList();
        TxTransferTO transferTO = null;
        for (int i = 0; i < transList.size();) {
            transferTO = (TxTransferTO) transList.get(i);
            id = transferTO.getBatchId();
            if ((transferTO.getProdType().equals("TL") || transferTO.getProdType().equals("ATL") || transferTO.getProdType().equals("AD")) && map.containsKey("DEBIT_LOAN_TYPE")) {
                debitInt = "DP";
            }
            if (batch.equals(id)) {
                if (transferTO.getAuthorizeRemarks() != null && (transferTO.getProdType().equals("TL") || transferTO.getProdType().equals("ATL") || transferTO.getProdType().equals("AD"))) {
                    debitInt = transferTO.getAuthorizeRemarks();
                }
                returnList.add(transList.get(i));
                transList.remove(i);
                i = -1;
            }
            i = i + 1;
        }
        System.out.println("returnList##"+returnList);
        return returnList;

    }

    public void setInitialValuesForLogTO(HashMap map) throws Exception {
        logTO = new LogTO();

        logTO.setUserId(CommonUtil.convertObjToStr(map.get(CommonConstants.USER_ID)));
        logTO.setBranchId(CommonUtil.convertObjToStr(map.get(CommonConstants.BRANCH_ID)));
        logTO.setIpAddr(CommonUtil.convertObjToStr(map.get(CommonConstants.IP_ADDR)));
        logTO.setModule(CommonUtil.convertObjToStr(map.get(CommonConstants.MODULE)));
        logTO.setScreen(CommonUtil.convertObjToStr(map.get(CommonConstants.SCREEN)));
    }

    /**
     * Updates Remit Transaction Details
     */
    private void updateRemitTransDetails(String command) throws Exception {
        objTransactionTO.setStatus(CommonConstants.STATUS_MODIFIED);



        logTO.setData(objTransactionTO.toString());
        logTO.setPrimaryKey(objTransactionTO.getKeyData());
        logTO.setStatus(command);
         if (objTransactionTO.getBranchId() != null) {
        } else {
            objTransactionTO.setBranchId(_branchCode);
        }
       // objTransactionTO.setBranchId(_branchCode);
        sqlMap.executeUpdate("updateRemittanceIssueTransactionTO", objTransactionTO);
        logDAO.addToLog(logTO);


    }

    /**
     * Update the Status as DELETED in Remit Issue Details
     */
    private void deleteRemitTransDetails(String command) throws Exception {
        objTransactionTO.setStatus(CommonConstants.STATUS_DELETED);



        logTO.setData(objTransactionTO.toString());
        logTO.setPrimaryKey(objTransactionTO.getKeyData());
        logTO.setStatus(command);
        // Update the Status as DELETED
         if (objTransactionTO.getBranchId() != null) {
        } else {
            objTransactionTO.setBranchId(_branchCode);
        }
        //objTransactionTO.setBranchId(_branchCode);
        sqlMap.executeUpdate("deleteRemittanceIssueTransactionTO", objTransactionTO);


        logDAO.addToLog(logTO);
    }

    public static void main(String str[]) {
    }

    /**
     * Getter for property batchId.
     *
     * @return Value of property batchId.
     */
    public java.lang.String getBatchId() {
        return batchId;
    }

    /**
     * Setter for property batchId.
     *
     * @param batchId New value of property batchId.
     */
    public void setBatchId(java.lang.String batchId) {
        this.batchId = batchId;
    }

    /**
     * Getter for property batchDate.
     *
     * @return Value of property batchDate.
     */
    public java.util.Date getBatchDate() {
        return batchDate;
    }

    /**
     * Setter for property batchDate.
     *
     * @param batchDate New value of property batchDate.
     */
    public void setBatchDate(java.util.Date batchDate) {
        this.batchDate = batchDate;
    }

    /**
     * Getter for property transType.
     *
     * @return Value of property transType.
     */
    public java.lang.String getTransType() {
        return transType;
    }

    /**
     * Setter for property transType.
     *
     * @param transType New value of property transType.
     */
    public void setTransType(java.lang.String transType) {
        this.transType = transType;
    }

    /**
     * Getter for property transactionType.
     *
     * @return Value of property transactionType.
     */
    public java.lang.String getTransactionType() {
        return transactionType;
    }

    /**
     * Setter for property transactionType.
     *
     * @param transactionType New value of property transactionType.
     */
    public void setTransactionType(java.lang.String transactionType) {
        this.transactionType = transactionType;
    }

    /**
     * Getter for property commandMode.
     *
     * @return Value of property commandMode.
     */
    public java.lang.String getCommandMode() {
        return commandMode;
    }

    /**
     * Setter for property commandMode.
     *
     * @param commandMode New value of property commandMode.
     */
    public void setCommandMode(java.lang.String commandMode) {
        this.commandMode = commandMode;
    }

    /**
     * Getter for property initiatedBranch.
     *
     * @return Value of property initiatedBranch.
     */
    public java.lang.String getInitiatedBranch() {
        return initiatedBranch;
    }

    /**
     * Setter for property initiatedBranch.
     *
     * @param initiatedBranch New value of property initiatedBranch.
     */
    public void setInitiatedBranch(java.lang.String initiatedBranch) {
        this.initiatedBranch = initiatedBranch;
    }

    /**
     * Getter for property linkBatchID.
     *
     * @return Value of property linkBatchID.
     */
    public java.lang.String getLinkBatchID() {
        return linkBatchID;
    }

    /**
     * Setter for property linkBatchID.
     *
     * @param linkBatchID New value of property linkBatchID.
     */
    public void setLinkBatchID(java.lang.String linkBatchID) {
        this.linkBatchID = linkBatchID;
    }

    /**
     * Getter for property oldAmt.
     *
     * @return Value of property oldAmt.
     */
    public java.lang.Double getOldAmt() {
        return oldAmt;
    }

    /**
     * Setter for property oldAmt.
     *
     * @param oldAmt New value of property oldAmt.
     */
    public void setOldAmt(java.lang.Double oldAmt) {
        this.oldAmt = oldAmt;
    }

    /**
     * Getter for property loanDebitInt.
     *
     * @return Value of property loanDebitInt.
     */
    public java.lang.String getLoanDebitInt() {
        return loanDebitInt;
    }

    /**
     * Setter for property loanDebitInt.
     *
     * @param loanDebitInt New value of property loanDebitInt.
     */
    public void setLoanDebitInt(java.lang.String loanDebitInt) {
        this.loanDebitInt = loanDebitInt;
    }

    /**
     * Getter for property forDebitInt.
     *
     * @return Value of property forDebitInt.
     */
    public boolean isForDebitInt() {
        return forDebitInt;
    }

    /**
     * Setter for property forDebitInt.
     *
     * @param forDebitInt New value of property forDebitInt.
     */
    public void setForDebitInt(boolean forDebitInt) {
        this.forDebitInt = forDebitInt;
    }

    /**
     * Getter for property loanAmtMap.
     *
     * @return Value of property loanAmtMap.
     */
    public java.util.HashMap getLoanAmtMap() {
        return loanAmtMap;
    }

    /**
     * Setter for property loanAmtMap.
     *
     * @param loanAmtMap New value of property loanAmtMap.
     */
    public void setLoanAmtMap(java.util.HashMap loanAmtMap) {
        this.loanAmtMap = loanAmtMap;
    }

    /**
     * Getter for property forLodgeICC.
     *
     * @return Value of property forLodgeICC.
     */
    public boolean isForLodgeICC() {
        return forLodgeICC;
    }

    /**
     * Setter for property forLodgeICC.
     *
     * @param forLodgeICC New value of property forLodgeICC.
     */
    public void setForLodgeICC(boolean forLodgeICC) {
        this.forLodgeICC = forLodgeICC;
    }

    /**
     * Getter for property act_closing_min_bal_check.
     *
     * @return Value of property act_closing_min_bal_check.
     */
    public java.lang.String getAct_closing_min_bal_check() {
        return act_closing_min_bal_check;
    }

    /**
     * Setter for property act_closing_min_bal_check.
     *
     * @param act_closing_min_bal_check New value of property
     * act_closing_min_bal_check.
     */
    public void setAct_closing_min_bal_check(java.lang.String act_closing_min_bal_check) {
        this.act_closing_min_bal_check = act_closing_min_bal_check;
    }

    /**
     * Getter for property breakLoanHierachy.
     *
     * @return Value of property breakLoanHierachy.
     */
    public java.lang.String getBreakLoanHierachy() {
        return breakLoanHierachy;
    }

    /**
     * Setter for property breakLoanHierachy.
     *
     * @param breakLoanHierachy New value of property breakLoanHierachy.
     */
    public void setBreakLoanHierachy(java.lang.String breakLoanHierachy) {
        this.breakLoanHierachy = breakLoanHierachy;
    }
}
