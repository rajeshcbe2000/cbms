--Before SVN consolidated Script Start--------------
--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[02-01-2014] -- by Jithin

alter table LOAN_ARBITRATION add (ARB_TYPE VARCHAR2(30));

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[02-01-2014] -- by Jithin

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[02-01-2014] -- by Babu

alter table SHARE_CONF_DETAILS add IS_OUTSTANDING_REQUIRED varchar2(1);

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[02-01-2014] -- by Babu

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[03-01-2014] -- by Sathiya

ALTER TABLE TRANSFER_TRANS ADD (SINGLE_TRANS_ID VARCHAR(20 BYTE));

ALTER TABLE CASH_TRANS ADD (SINGLE_TRANS_ID VARCHAR(20 BYTE));

Insert into ID_GENERATION (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, BRANCH_CODE) Values
   ('GENERATE_LINK_ID', 0, 'GI', TO_DATE('06/18/2004 17:42:56', 'MM/DD/YYYY HH24:MI:SS'), 8, '0001');

ALTER TABLE TRANSFER_TRANS ADD (AUTHORIZE_BY_2 VARCHAR(20 BYTE));

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[03-01-2014] -- by Sathiya

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[15-01-2014] -- by Babu

CREATE OR REPLACE FUNCTION GET_MDS_BONUS(VAR_CHITTAL_NO VARCHAR,VAR_SUB_NO VARCHAR) RETURN NUMBER IS
    PAID_INST NUMBER(5):=0;
    CURR_INST_NO mds_prized_money_details.INSTALLMENT_NO%TYPE;
    BONUS_AMT NUMBER(16,2):=0;
    DUE_DT DATE;
    CURR_DT DAY_END.CURR_APPL_DT%TYPE;
    CURSOR C1 IS 
    SELECT MS.SCHEME_NAME, MA.BRANCH_CODE, DIVISION_NO,BONUS_ALLOWED,BONUS_FIRST_INSTALLMENT,
        BONUS_GRACE_PERIOD,
        BONUS_GRACE_PERIOD_AFTER,
        BONUS_GRACE_PERIOD_DAYS,    
        BONUS_GRACE_PERIOD_END,    
        BONUS_GRACE_PERIOD_MONTHS,
        BONUS_PRIZED_GRACE_PERIOD,
        BONUS_PRIZED_GRACE_PERIOD_AFT,
        BONUS_PRIZED_GRACE_PERIOD_DAYS,    
        BONUS_PRIZED_GRACE_PERIOD_END,    
        BONUS_PRIZED_GRACE_PERIOD_MNTH, MA.INST_AMT,
        TOTAL_NO_OF_MEMBERS,MULTIPLE_MEMBER FROM MDS_PRODUCT_OTHER_DETAILS MP,MDS_PRODUCT_GENERAL_DETAILS MPG, 
        MDS_SCHEME_DETAILS MS, MDS_APPLICATION MA WHERE MP.PROD_ID=MS.PROD_ID AND MPG.PROD_ID=MP.PROD_ID AND
        MS.SCHEME_NAME=MA.SCHEME_NAME AND MA.CHITTAL_NO=VAR_CHITTAL_NO AND MA.SUB_NO=VAR_SUB_NO;
    PRIZED NUMBER(1):=0;
    bonusGracePeriod MDS_PRODUCT_OTHER_DETAILS.BONUS_GRACE_PERIOD%TYPE;
    bonusGracePeriodAfter MDS_PRODUCT_OTHER_DETAILS.BONUS_GRACE_PERIOD_AFTER%TYPE;
    bonusGracePeriodDays MDS_PRODUCT_OTHER_DETAILS.BONUS_GRACE_PERIOD_DAYS%TYPE;
    bonusGracePeriodEnd MDS_PRODUCT_OTHER_DETAILS.BONUS_GRACE_PERIOD_END%TYPE;
    bonusGracePeriodMonth MDS_PRODUCT_OTHER_DETAILS.BONUS_GRACE_PERIOD_MONTHS%TYPE;
    bonusPrizedGracePeriod MDS_PRODUCT_OTHER_DETAILS.BONUS_PRIZED_GRACE_PERIOD%TYPE;
    bonusPrizedGracePeriodAfter MDS_PRODUCT_OTHER_DETAILS.BONUS_PRIZED_GRACE_PERIOD_AFT%TYPE;
    bonusPrizedGracePeriodDays MDS_PRODUCT_OTHER_DETAILS.BONUS_PRIZED_GRACE_PERIOD_DAYS%TYPE;
    bonusPrizedGracePeriodEnd MDS_PRODUCT_OTHER_DETAILS.BONUS_PRIZED_GRACE_PERIOD_END%TYPE;
    bonusPrizedGracePeriodMonth MDS_PRODUCT_OTHER_DETAILS.BONUS_PRIZED_GRACE_PERIOD_MNTH%TYPE;
    totalNoOfMembers MDS_SCHEME_DETAILS.TOTAL_NO_OF_MEMBERS%TYPE;
    diffDays NUMBER:=0;
    NOOFCOCHITTALS NUMBER(3):=0;
    bonusAmt NUMBER(16,2):=0;
    BONUS_AMOUNT NUMBER(16,2):=0;
BEGIN
    FOR I IN C1 LOOP
         IF I.BONUS_ALLOWED='Y' THEN  
            SELECT SUM(NO_OF_INST) INTO PAID_INST 
            FROM MDS_APPLICATION MA, MDS_TRANS_DETAILS MTD 
            WHERE MA.CHITTAL_NO=MTD.CHITTAL_NO AND MA.SUB_NO=MTD.SUB_NO AND MA.CHITTAL_NO=VAR_CHITTAL_NO  AND MA.SUB_NO=VAR_SUB_NO
            GROUP BY BRANCH_CODE, MA.SCHEME_NAME, MA.CHITTAL_NO, DIVISION_NO;
            SELECT COUNT(*) INTO PRIZED FROM mds_prized_money_details WHERE CHITTAL_NO=VAR_CHITTAL_NO;
            SELECT INSTALLMENT_NO INTO CURR_INST_NO FROM mds_prized_money_details M
            WHERE scheme_name = I.SCHEME_NAME AND division_no = I.DIVISION_NO AND next_installment_date IN 
            ( SELECT MAX (next_installment_date) FROM mds_prized_money_details m1, DAY_END D WHERE m.scheme_name = m1.scheme_name AND 
            ADD_MONTHS (m1.next_installment_date, 0) < D.CURR_APPL_DT AND D.BRANCH_CODE=I.BRANCH_CODE);
            SELECT CURR_APPL_DT INTO CURR_DT FROM DAY_END WHERE BRANCH_CODE=I.BRANCH_CODE;
            IF I.MULTIPLE_MEMBER='Y' THEN 
                        SELECT COUNT(*) INTO NOOFCOCHITTALS FROM MDS_APPLICATION WHERE CHITTAL_NO=VAR_CHITTAL_NO  AND STATUS!='DELETED' AND 
                        AUTHORIZE_STATUS='AUTHORIZED' AND BRANCH_CODE=I.BRANCH_CODE;
            END IF;
            IF PRIZED>0 THEN 
                bonusPrizedGracePeriod := I.BONUS_PRIZED_GRACE_PERIOD;
                bonusPrizedGracePeriodAfter := I.BONUS_PRIZED_GRACE_PERIOD_AFT;
                bonusPrizedGracePeriodDays := I.BONUS_PRIZED_GRACE_PERIOD_DAYS;
                bonusPrizedGracePeriodEnd := I.BONUS_PRIZED_GRACE_PERIOD_END;
                bonusPrizedGracePeriodMonth := I.BONUS_PRIZED_GRACE_PERIOD_MNTH;
            ELSE 
                bonusGracePeriod := I.BONUS_GRACE_PERIOD;
                bonusGracePeriodAfter := I.BONUS_GRACE_PERIOD_AFTER;
                bonusGracePeriodDays := I.BONUS_GRACE_PERIOD_DAYS;
                bonusGracePeriodEnd := I.BONUS_GRACE_PERIOD_END;
                bonusGracePeriodMonth := I.BONUS_GRACE_PERIOD_MONTHS;
            END IF;
            IF CURR_INST_NO>PAID_INST THEN
                WHILE PAID_INST<CURR_INST_NO LOOP
                    SELECT DISTINCT NEXT_INSTALLMENT_DATE, SUM(TOTAL_BONUS_AMOUNT) INTO DUE_DT, BONUS_AMOUNT FROM MDS_PRIZED_MONEY_DETAILS
                    WHERE SCHEME_NAME = I.SCHEME_NAME  AND SL_NO = PAID_INST+1 and DIVISION_NO = i.DIVISION_NO
                    AND STATUS!='DELETED' AND AUTHORIZED_STATUS='AUTHORIZED'
                    GROUP BY NEXT_INSTALLMENT_DATE;
                    bonusAmt :=BONUS_AMOUNT/I.TOTAL_NO_OF_MEMBERS;
                    diffDays:=CURR_DT-DUE_DT;
                    IF I.MULTIPLE_MEMBER='Y' THEN 
                        bonusAmt :=bonusAmt/NOOFCOCHITTALS;
                    END IF;
                    --PRIZED-
                    IF PRIZED>0 THEN
                        IF bonusPrizedGracePeriodDays='D' AND diffDays<=bonusPrizedGracePeriod THEN
                            BONUS_AMT := BONUS_AMT + bonusAmt;
                        ELSIF bonusPrizedGracePeriodMonth='M' AND diffDays<=(bonusPrizedGracePeriod*30) THEN
                            BONUS_AMT := BONUS_AMT + bonusAmt;
                        ELSIF bonusPrizedGracePeriodAfter='A' AND TO_NUMBER(TO_CHAR (CURR_DT,'DD'))<=bonusPrizedGracePeriod THEN
                            BONUS_AMT := BONUS_AMT + bonusAmt;
                        END IF;
                     --NON-PRIZED-   
                    ELSIF PRIZED<=0 THEN
                        IF bonusGracePeriodDays='D' AND diffDays<=bonusGracePeriod THEN
                            BONUS_AMT := BONUS_AMT + bonusAmt;
                        ELSIF bonusGracePeriodMonth='M' AND diffDays<=(bonusGracePeriod*30) THEN
                            BONUS_AMT := BONUS_AMT + bonusAmt;
                        ELSIF bonusGracePeriodAfter='A' AND TO_NUMBER(TO_CHAR (CURR_DT,'DD'))<=bonusGracePeriod THEN
                            BONUS_AMT := BONUS_AMT + bonusAmt;
                        END IF;
                    END IF;

                    BONUS_AMT:=ROUND(BONUS_AMT);
                    PAID_INST:=PAID_INST+1;
                END LOOP;    
            END IF;

        END IF;

    END LOOP;
    RETURN BONUS_AMT;
END;
/

ALTER TABLE BRANCH_ACNO_MAINTENANCE ADD (PREFIX VARCHAR(30 BYTE));

Insert into BRANCH_ACNO_MAINTENANCE
   (BRANCH_ID, PROD_ID, LAST_AC_NO, NEXT_AC_NO, CREATED_BY, 
    CREATED_DT, STATUS, STATUS_BY, STATUS_DT, AUTHORIZE_STATUS, 
    AUTHORIZE_BY, AUTHORIZE_DT, PREFIX)
 Values
   ('0001', '607', '00', '00', 'ADMIN', 
    TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'CREATED', 'ADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'AUTHORIZED', 
    'SYSADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'IC');

ALTER TABLE BILLS_LODGEMENT_MASTER ADD (BILLS_CLEARING VARCHAR(4 BYTE));

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[15-01-2014] -- by Babu

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[15-01-2014] -- by Sreekrishnan

ALTER TABLE DEPO_MASTER ADD PUR_VAT_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD PUR_RTN_VAT_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD SALE_VAT_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD SALE_RTN_VAT_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD DAM_VAT_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD DEF_VAT_AC_HD_ID VARCHAR2(16);

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[15-01-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[23-01-2014] -- by Babu

CREATE OR REPLACE FUNCTION GET_TL_PEN_INTEREST_NEW(ACTNUM VARCHAR,LOANDATE DATE,ASONDT DATE,PENROI NUMBER)
RETURN NUMBER IS
    PENINTRECEIVABLE NUMBER(16,2) := 0;
    PENINTRECEIVED NUMBER(16,2) := 0;
    INSTAMTRECEIVALBE NUMBER(16,2) := 0;
    PRNCOLLECTED NUMBER(16,2) := 0;
    LASTINTCALCDATE DATE;
    STARTDATE DATE;
    CALCPRN NUMBER(16,2) := 0;
    WITHACTUALINST NUMBER(16,2) := 0;
    INSTCOUNT NUMBER(16,2) := 0;
BEGIN
    IF GET_TL_BALANCE(ACTNUM,ASONDT) != 0 THEN
        SELECT F.LAST_INT_CALC_DT INTO LASTINTCALCDATE 
        FROM LOANS_FACILITY_DETAILS F
        WHERE F.ACCT_NUM = ACTNUM;
        IF LASTINTCALCDATE < ASONDT THEN
            STARTDATE := LASTINTCALCDATE + 1;
        ELSE
            SELECT NVL(MAX(T.TRANS_DT),LOANDATE) INTO STARTDATE 
            FROM LOAN_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND UPTO_DT_INT = 'Y';
        END IF;
        SELECT GET_TL_INST_OD(F.ACCT_NUM,ASONDT) INTO INSTAMTRECEIVALBE
        FROM LOANS_FACILITY_DETAILS F 
        WHERE F.ACCT_NUM = ACTNUM;
        IF INSTAMTRECEIVALBE > 0 THEN
            SELECT NVL(SUM(T.PENAL),0) INTO PENINTRECEIVED
            FROM LOAN_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.TRANS_DT > STARTDATE;
            DECLARE CURSOR CURINST IS 
            SELECT I.PRINCIPAL_AMT,I.INSTALLMENT_DT
            FROM LOANS_INSTALLMENT I
            WHERE I.ACCT_NUM = ACTNUM AND I.INSTALLMENT_DT <= ASONDT AND I.INSTALLMENT_DT >= STARTDATE
            UNION ALL
            SELECT 0 AS PRINCIPAL_AMT,ASONDT AS INSTALLMENT_DT
            FROM DUAL
            ORDER BY INSTALLMENT_DT;
            BEGIN
                FOR INST IN CURINST
                LOOP
                    PENINTRECEIVABLE := PENINTRECEIVABLE + (GET_TL_INST_OD(ACTNUM,STARTDATE) * (INST.INSTALLMENT_DT-STARTDATE) * PENROI)/36500;
                    STARTDATE := INST.INSTALLMENT_DT;
                END LOOP;
            END;
            PENINTRECEIVABLE := PENINTRECEIVABLE - PENINTRECEIVED;
            PENINTRECEIVABLE := ROUND(PENINTRECEIVABLE,0);
        END IF;
        IF PENINTRECEIVABLE < 0 THEN
            PENINTRECEIVABLE := 0;
        END IF;
    ELSE
        PENINTRECEIVABLE := 0;
    END IF;
        RETURN PENINTRECEIVABLE;
END;
/


CREATE OR REPLACE FUNCTION GET_MDS_INSTDUE(SCHEMENAME VARCHAR,CHITTALNO VARCHAR, DIVNO VARCHAR,ASONDT DATE)
RETURN NUMBER IS
    ISNTDUE NUMBER(16,2) := 0;
    INSTCNT NUMBER(10) := 0;
    CURINSTNO NUMBER(10) := 0;
    LVAR NUMBER(10) := 0;
    BGPRD NUMBER(10) := 0;
    BGDAYS NUMBER(10) := 0;
    BGMONTHS NUMBER(10) := 0;
    ISPRIZED NUMBER(1) := 0;
    INSTAMT NUMBER(10,2) := 0;
BEGIN
    SELECT S.INSTALLMENT_AMOUNT INTO INSTAMT
    FROM MDS_SCHEME_DETAILS S
    WHERE S.SCHEME_NAME = SCHEMENAME;
    INSTCNT := GET_MDS_PAIDINSTCOUNT(CHITTALNO,ASONDT);
    SELECT MAX(P.INSTALLMENT_NO) INTO CURINSTNO
    FROM MDS_PRIZED_MONEY_DETAILS P
    WHERE P.SCHEME_NAME = SCHEMENAME AND P.DIVISION_NO = DIVNO AND P.NEXT_INSTALLMENT_DATE <= ASONDT AND
          P.AUTHORIZED_STATUS = 'AUTHORIZED' AND P.STATUS = 'CREATED';
    LVAR := INSTCNT + 1;
    SELECT COUNT(MPD.CHITTAL_NO) INTO ISPRIZED
    FROM MDS_PRIZED_MONEY_DETAILS MPD
    WHERE MPD.CHITTAL_NO = CHITTALNO AND MPD.DIVISION_NO = DIVNO AND MPD.DRAW_AUCTION_DATE <= ASONDT;
    SELECT CASE WHEN ISPRIZED > 0 THEN 
                     CASE WHEN PO.BONUS_PRIZED_GRACE_PERIOD_DAYS = 'D' THEN PO.BONUS_PRIZED_GRACE_PERIOD
                          ELSE 0 
                     END
                ELSE
                     CASE WHEN PO.BONUS_GRACE_PERIOD_DAYS = 'D' THEN PO.BONUS_GRACE_PERIOD
                          ELSE 0 
                     END
                END
               INTO BGDAYS
    FROM MDS_PRODUCT_OTHER_DETAILS PO
    WHERE PO.PROD_ID = (SELECT MSD.PROD_ID FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME);
    SELECT CASE WHEN ISPRIZED > 0 THEN 
                     CASE WHEN PO.BONUS_PRIZED_GRACE_PERIOD_MNTH = 'M' THEN PO.BONUS_PRIZED_GRACE_PERIOD
                          ELSE 0 
                     END
                ELSE
                     CASE WHEN PO.BONUS_GRACE_PERIOD_MONTHS = 'M' THEN PO.BONUS_GRACE_PERIOD
                          ELSE 0 
                     END
                END
               INTO BGMONTHS
    FROM MDS_PRODUCT_OTHER_DETAILS PO
    WHERE PO.PROD_ID = (SELECT MSD.PROD_ID FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME);
    DECLARE CURSOR MDSPRIZED IS
        SELECT P.NEXT_INSTALLMENT_DATE,P.NEXT_BONUS_AMOUNT
        FROM MDS_PRIZED_MONEY_DETAILS P
        WHERE P.DIVISION_NO = DIVNO and P.SCHEME_NAME = SCHEMENAME AND P.INSTALLMENT_NO >= LVAR AND P.NEXT_INSTALLMENT_DATE <= ASONDT;
        BONUSAMT NUMBER(10,2) := 0;
    BEGIN
        FOR MDS IN MDSPRIZED
        LOOP
            IF BGDAYS > 0 THEN
                IF ((MDS.NEXT_INSTALLMENT_DATE + BGDAYS) >= ASONDT) THEN
                    BONUSAMT := MDS.NEXT_BONUS_AMOUNT;
                ELSE
                    BONUSAMT := 0;
                END IF;
            ELSE
                IF (ADD_MONTHS(MDS.NEXT_INSTALLMENT_DATE,BGMONTHS) >= ASONDT) THEN
                    BONUSAMT := MDS.NEXT_BONUS_AMOUNT;
                ELSE
                    BONUSAMT := 0;
                END IF;
            END IF;
            ISNTDUE := ISNTDUE + (INSTAMT - BONUSAMT);
        END LOOP;
    END;
    RETURN ISNTDUE;
END;
/

CREATE OR REPLACE FUNCTION GET_MDS_PENALINT(SCHEMENAME VARCHAR,CHITTALNO VARCHAR, DIVNO VARCHAR,ASONDT DATE)
RETURN NUMBER IS
    INTEREST NUMBER(10,2) := 0;
    INSTCNT NUMBER(10) := 0;
    ISPRIZED NUMBER(1) := 0;
    INSTAMT NUMBER(10,2) := 0;
    CURINSTNO NUMBER(10) := 0;
    GRACEPRDDAYS NUMBER(10) := 0;
    GRACEPRDINST NUMBER(10) := 0;
    LVAR NUMBER(10) := 0;
    BASEDON VARCHAR(20) := '';
    ROI NUMBER(10,2) := 0;
    INSTDT DATE;
    MDSSTARTDATE DATE;
BEGIN
    INSTCNT := GET_MDS_PAIDINSTCOUNT(CHITTALNO,ASONDT);
    LVAR := INSTCNT + 1;
    SELECT MAX(P.INSTALLMENT_NO) INTO CURINSTNO
    FROM MDS_PRIZED_MONEY_DETAILS P
    WHERE P.SCHEME_NAME = SCHEMENAME AND P.DIVISION_NO = DIVNO AND P.NEXT_INSTALLMENT_DATE <= ASONDT AND
          P.AUTHORIZED_STATUS = 'AUTHORIZED' AND P.STATUS = 'CREATED';
    SELECT S.INSTALLMENT_AMOUNT INTO INSTAMT
    FROM MDS_SCHEME_DETAILS S
    WHERE S.SCHEME_NAME = SCHEMENAME;
    SELECT S.SCHEME_START_DT INTO MDSSTARTDATE 
    FROM MDS_SCHEME_DETAILS S
    WHERE S.SCHEME_NAME = SCHEMENAME;
    SELECT PO.PENAL_CALC INTO BASEDON
    FROM MDS_PRODUCT_OTHER_DETAILS PO
    WHERE PO.PROD_ID = (SELECT MSD.PROD_ID FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME);
    SELECT COUNT(MPD.CHITTAL_NO) INTO ISPRIZED
    FROM MDS_PRIZED_MONEY_DETAILS MPD
    WHERE MPD.CHITTAL_NO = CHITTALNO AND MPD.DIVISION_NO = DIVNO AND MPD.DRAW_AUCTION_DATE <= ASONDT;
    SELECT CASE WHEN ISPRIZED > 0 THEN 
                     PO.PENAL_PRIZED_INT_AMT 
                ELSE PO.PENAL_INT_AMT END 
           INTO ROI 
    FROM MDS_PRODUCT_OTHER_DETAILS PO
    WHERE PO.PROD_ID = (SELECT MSD.PROD_ID FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME);
    SELECT CASE WHEN ISPRIZED > 0 THEN
                CASE WHEN PO.PENAL_PRIZED_GRACE_PERIOD_TYPE = 'Days' THEN PENAL_PRIZED_GRACE_PERIOD  
                     ELSE 0
                END
           ELSE 
                CASE WHEN PO.PENAL_GRACE_PERIOD_TYPE = 'Days' THEN PO.PENAL_GRACE_PERIOD
                     ELSE 0
                END
           END
           INTO GRACEPRDDAYS
    FROM MDS_PRODUCT_OTHER_DETAILS PO
    WHERE PO.PROD_ID = (SELECT MSD.PROD_ID FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME);
    SELECT CASE WHEN ISPRIZED > 0 THEN
                CASE WHEN PO.PENAL_PRIZED_GRACE_PERIOD_TYPE = 'Installments' THEN PENAL_PRIZED_GRACE_PERIOD  
                     ELSE 0
                END
           ELSE 
                CASE WHEN PO.PENAL_GRACE_PERIOD_TYPE = 'Installments' THEN PO.PENAL_GRACE_PERIOD
                     ELSE 0
                END
           END
           INTO GRACEPRDINST
    FROM MDS_PRODUCT_OTHER_DETAILS PO
    WHERE PO.PROD_ID = (SELECT MSD.PROD_ID FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME);
    DECLARE CURSOR MDSINT IS
        SELECT P.NEXT_INSTALLMENT_DATE,P.DRAW_AUCTION_DATE,P.INSTALLMENT_NO
        FROM MDS_PRIZED_MONEY_DETAILS P
        WHERE P.SCHEME_NAME = SCHEMENAME AND P.DIVISION_NO = DIVNO and  P.INSTALLMENT_NO >= LVAR AND P.NEXT_INSTALLMENT_DATE <= ASONDT;
    BEGIN
        FOR MDS IN MDSINT
        LOOP
            IF GRACEPRDDAYS > 0 THEN
                INSTDT := MDS.DRAW_AUCTION_DATE + GRACEPRDDAYS;
            ELSE
                INSTDT := ADD_MONTHS(MDS.DRAW_AUCTION_DATE,GRACEPRDINST);
            END IF;
            IF INSTDT >= ASONDT THEN
                INTEREST := INTEREST + 0;
            ELSE
                IF BASEDON = 'Installments' THEN
                    INTEREST := INTEREST + INSTAMT * ROI * (MDS.INSTALLMENT_NO-INSTCNT)/1200;
                ELSE
                    INTEREST := INTEREST + INSTAMT * ROI * (ASONDT - ADD_MONTHS(MDSSTARTDATE,MDS.INSTALLMENT_NO))/36500;
                END IF;
            END IF;
        END LOOP;
    END;
    IF INTEREST < 0 THEN
        INTEREST := 0;
    END IF;
    INTEREST := ROUND(INTEREST);
    RETURN INTEREST;
END;
/


CREATE OR REPLACE FUNCTION GET_MDS_BONUS_AVAILBALE(SCHEMENAME VARCHAR2,CHITTALNO VARCHAR2,DIVNO VARCHAR2,ASONDT DATE)
RETURN NUMBER IS
    PAIDNOS NUMBER(10) := 0;
    PAYABLENOS NUMBER(10) := 0;
    PENDINST NUMBER(10) := 0;
    BONUSAMT NUMBER(16,2) := 0;
BEGIN
    BEGIN
        SELECT MAX(MP.INSTALLMENT_NO) INTO PAYABLENOS
        FROM MDS_PRIZED_MONEY_DETAILS MP
        WHERE MP.SCHEME_NAME = SCHEMENAME AND 
              MP.NEXT_INSTALLMENT_DATE <= ASONDT AND
              MP.AUTHORIZED_STATUS = 'AUTHORIZED' AND MP.STATUS != 'DELETED';
    EXCEPTION WHEN OTHERS THEN
        PAYABLENOS := 0;
    END;
    BEGIN
        SELECT SUM(T.NO_OF_INST) INTO PAIDNOS FROM MDS_TRANS_DETAILS T
        WHERE T.SCHEME_NAME = SCHEMENAME AND
              T.CHITTAL_NO = CHITTALNO AND 
              T.TRANS_DT <= ASONDT AND
              T.AUTHORIZE_STATUS = 'AUTHORIZED' AND
              T.STATUS != 'DELETED';
    EXCEPTION WHEN OTHERS THEN
        PAIDNOS := 0;
    END;
    PENDINST := PAYABLENOS - PAIDNOS;
    IF PENDINST > 0 THEN
        BEGIN
        SELECT SUM(MPD.NEXT_BONUS_AMOUNT) INTO BONUSAMT
        FROM MDS_PRIZED_MONEY_DETAILS MPD
        WHERE MPD.SCHEME_NAME = SCHEMENAME AND
              MPD.INSTALLMENT_NO > PAIDNOS AND MPD.INSTALLMENT_NO <= PAYABLENOS AND
              MPD.AUTHORIZED_STATUS = 'AUTHORIZED' AND MPD.STATUS != 'DELETED';
        EXCEPTION WHEN OTHERS THEN
            BONUSAMT := 0;
        END;
    END IF;
    RETURN BONUSAMT;
END;
/

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[23-01-2014] -- by Babu

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[10-02-2014] -- by Anju

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
    RECORD_KEY_COL, SCREEN_DESC)
 VALUES
   ('SCR09999', '110', 'Reprint', 'APP01', 'DONE',
    '8', 'com.see.truetransact.ui.transaction.Reprint.ReprintUI', 2, 'CREATED', NULL,
    NULL, NULL);
   COMMIT;
 
 Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED)
 Values
   ('GRP01014', 'SCR06093', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06093', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06093', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS)
 Values
   ('GRP01015', 'SCR06093', 'CREATED');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06093', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'N', 'Y', 'Y');
   
COMMIT;

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[10-02-2014] -- by Anju

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[12-02-2014] -- by Sathiya

ALTER TABLE CASH_TRANS ADD (TRANS_MOD_TYPE VARCHAR(20 BYTE));
ALTER TABLE TRANSFER_TRANS ADD (TRANS_MOD_TYPE VARCHAR(20 BYTE));
ALTER TABLE TRANSFER_TRANS ADD (GL_TRANS_ACT_NUM VARCHAR(20 BYTE));
ALTER TABLE CASH_TRANS ADD (GL_TRANS_ACT_NUM VARCHAR(20 BYTE));

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[12-02-2014] -- by Sathiya

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[14-02-2014] -- by Rishad

alter table DEPOSIT_ACINFO add(REFERENCE_NO varchar2(20));

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[14-02-2014] -- by Rishad

--Start Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[27-02-2014] -- by Babu

ALTER TABLE BILLS_LODGEMENT_CHEQUE ADD (INSTR_PREFIX VARCHAR2(30));

--End Version [Script Version - 0.0.0] [ReleaseVersion - 9.2.1.25]--[27-02-2014] -- by Babu
--Before SVN consolidated Script End--------------
--Start Version [Script Version - 0.0.01] [ReleaseVersion - 9.2.1.25]--[11-03-2014] -- by Sathiya
ALTER TABLE REMIT_ISSUE_TRANS ADD (PARTICULARS  VARCHAR2(50 BYTE));
--End Version [Script Version - 0.0.01] [ReleaseVersion - 9.2.1.25]--[11-03-2014] -- by Sathiya

--Start Version [Script Version - 0.0.02] [ReleaseVersion - 9.2.1.25]--[12-03-2014] -- by Nidhin
ALTER TABLE LOANS_PROD_ACPARAM ADD (INTEREST_ON_MATURITY VARCHAR2(1 BYTE));
ALTER TABLE DEPOSITS_PROD_INTPAY ADD (SLAB_WISE_INTEREST VARCHAR2(1 BYTE));
ALTER TABLE DEPOSITS_PROD_INTPAY ADD (SLAB_WISE_COMMISION VARCHAR2(1 BYTE));
--End Version [Script Version - 0.0.02] [ReleaseVersion - 9.2.1.25]--[12-03-2014] -- by Nidhin

--Start Version [Script Version - 0.0.04] [ReleaseVersion - 9.2.1.25]--[13-03-2014] -- by Anju
Insert into ID_GENERATION(ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, BRANCH_CODE)
Values ('SUNDRY_ENTRY_ID', 1, 'SE', TO_DATE('05/16/2013 12:40:12', 'MM/DD/YYYY HH24:MI:SS'), 8,'0001');

alter table LOANS_PROD_ACHD add (DEBIT_PRINCIPAl_HEAD varchar2(20));
alter table LOANS_PROD_SUBSIDY_REBATE add(PRINCIPAl_WAIVER  varchar2(20));
alter table LOANS_PROD_ACHD add (DEBIT_NOTICE_HEAD varchar2(20));
alter table LOANS_PROD_SUBSIDY_REBATE add(NOTICE_WAIVER  varchar2(20));
--End Version [Script Version - 0.0.04] [ReleaseVersion - 9.2.1.25]--[13-03-2014] -- by Anju

--Start Version [Script Version - 0.0.05] [ReleaseVersion - 9.2.1.25]--[17-03-2014] -- by Babu

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE', 'MDS', 'MDS', 'CREATED', 'N', 
    'Y');

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('TERMLOAN.CHARGE_TYPE', 'EP_COST', 'EP Cost', 'CREATED', NULL, 
    'Y');
    
--End Version [Script Version - 0.0.05] [ReleaseVersion - 9.2.1.25]--[17-03-2014] -- by Babu

--Start Version [Script Version - 0.0.06] [ReleaseVersion - 9.2.1.25]--[17-03-2014] -- by Anju

alter table PURCHASE_ENTRY add  (CHEQUE_NO varchar2(15),NARRATION varchar2(100));
alter table PURCHASE_ENTRY add  (BANK_NAME varchar2(15),ACCOUNT_NUM varchar2(100));
--End Version [Script Version - 0.0.06] [ReleaseVersion - 9.2.1.25]--[17-03-2014] -- by Anju

--Start Version [Script Version - 0.0.07] [ReleaseVersion - 9.2.1.25]--[19-03-2014] -- by Sreekrishnan
alter table DEPOSITS_PROD_INTPAY add SENIOR_BENIFIT_RATE varchar2(16);
--End Version [Script Version - 0.0.07] [ReleaseVersion - 9.2.1.25]--[19-03-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.08] [ReleaseVersion - 9.2.1.25]--[20-03-2014] -- by Rishad
CREATE TABLE LOAN_WAIVE_OFF
(
  ACCT_NUM        VARCHAR2(16 BYTE),
  WAIVE_OFF_DT    DATE,
  WAIVE_AMT       NUMBER(16,2),
  REMARKS         VARCHAR2(40 BYTE),
  STATUS          VARCHAR2(16 BYTE),
  STATUS_BY       VARCHAR2(25 BYTE),
  AUTH_STATUS     VARCHAR2(16 BYTE),
  AUTH_BY         VARCHAR2(25 BYTE),
  STATUS_DT       DATE,
  AUTH_DT         DATE,
  WAIVE_OFF_ID    VARCHAR2(25 BYTE)
)

CREATE TABLE TEMPDAILY
(
  AGENT_ID      VARCHAR2(20 BYTE),
  REFERENCE_NO  VARCHAR2(20 BYTE),
  AMOUNT        NUMBER(16,2),
  DATE1         DATE,
  BRANCH_ID     VARCHAR2(5 BYTE)
)
--End Version [Script Version - 0.0.08] [ReleaseVersion - 9.2.1.25]--[20-03-2014] -- by Rishad

--Start Version [Script Version - 0.0.09] [ReleaseVersion - 9.2.1.25]--[20-03-2014] -- by Anjulakshmy
alter table PURCHASE_ENTRY add  (CHEQUE_NO varchar2(30),NARRATION varchar2(100));
alter table PURCHASE_ENTRY add  (BANK_NAME varchar2(100),ACCOUNT_NUM varchar2(100));

--End Version [Script Version - 0.0.09] [ReleaseVersion - 9.2.1.25]--[20-03-2014] -- by Anjulakshmy

--Start Version [Script Version - 0.0.10] [ReleaseVersion - 9.2.1.25]--[21-03-2014] -- by Rishad
ALTER TABLE LOAN_TRANS_DETAILS ADD(NOTICE_CHARGES NUMBER(16,2))
--End Version [Script Version - 0.0.10] [ReleaseVersion - 9.2.1.25]--[21-03-2014] -- by Rishad

--Start Version [Script Version - 0.0.11] [ReleaseVersion - 9.2.1.25]--[26-03-2014] -- by Anjulakshmy
Alter table MJR_AC_HD add  SUB_ACCOUNT_TYPE varchar2(100);
--End Version [Script Version - 0.0.11] [ReleaseVersion - 9.2.1.25]--[26-03-2014] -- by Anjulakshmy

--Start Version [Script Version - 0.0.12] [ReleaseVersion - 9.2.1.25]--[28-03-2014] -- by Sreekrishnan
DROP VIEW OP_ACT_MIN_BAL;
CREATE OR REPLACE FORCE VIEW op_act_min_bal (prod_id, act_num, min_bal)
AS
   (SELECT ac.prod_id, ac.act_num,
           CASE
              WHEN ap.chk_book = 'Y'
                 THEN oap.min_bal_w_chk
              ELSE oap.min_bal_wt_chk
           END AS min_bal
      FROM act_master ac, act_param_detail ap, op_ac_account_param oap
     WHERE oap.prod_id = ac.prod_id
       AND ap.act_num = ac.act_num
       AND ac.act_status_id != 'CLOSED');

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06093', '76', 'Standing Instruction Daily', 'APP01', 'DONE', 
    '11', 'com.see.truetransact.ui.supporting.standinginstruction.StandingInstructionDailyUI', 4, 'CREATED', NULL, 
    NULL, 'Standing Instruction Daily');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06093', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06093', 'CREATED', NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06093', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', NULL, 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06093', 'CREATED', NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL);
COMMIT;
--End Version [Script Version - 0.0.12] [ReleaseVersion - 9.2.1.25]--[28-03-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.14] [ReleaseVersion - 9.2.1.25]--[03-04-2014] -- by Babu

DELETE FROM LOOKUP_MASTER WHERE LOOKUP_ID='PRODUCTTYPE' AND LOOKUP_DESC ='MDS';

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'OA', 'Operative Account', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'TD', 'Deposits', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'SA', 'Suspense Account', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'AB', 'Accounts with Other Bank', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'GL', 'General Ledger', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'AD', 'Advances', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'TL', 'Term Loans', 'CREATED', 'N', 
    'Y');
    Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('PRODUCTTYPE_CHARGES', 'MDS', 'MDS', 'CREATED', 'N', 
    'Y');

--End Version [Script Version - 0.0.14] [ReleaseVersion - 9.2.1.25]--[03-04-2014] -- by babu

--Start Version [Script Version - 0.0.15] [ReleaseVersion - 9.2.1.25]--[07-04-2014] -- by Anju
   
 CREATE TABLE TRADE_EXPENSE(
  EFFECT_DT            DATE,
  AMOUNT               NUMBER(10,2),
  FROM_WEIGHT          NUMBER(10,2),
  TO_WEIGHT            NUMBER(10,2),
  AUTHORIZE_STATUS     VARCHAR2(30 BYTE),
  AUTHORIZED_BY        VARCHAR2(40 BYTE),
  AUTHORIZED_DT        DATE,
  STATUS               VARCHAR2(40 BYTE),
  STATUS_BY            VARCHAR2(100 BYTE),
  STATUS_DT            DATE 
)

CREATE TABLE TradeExpense_entry(
  TradeExepense_ID  Varchar2(100),
  Trans_dt          Date,
  AMOUNT            NUMBER(10,2),
  AUTHORIZE_STATUS  VARCHAR2(30 BYTE),
  AUTHORIZED_BY     VARCHAR2(40 BYTE),
  AUTHORIZED_DT     DATE,
  STATUS            VARCHAR2(40 BYTE),
  STATUS_BY         VARCHAR2(100 BYTE),
  STATUS_DT         DATE
)

alter table RECOVERY_PARAMETERS add TRADE_EXPENSE_ACHD VARCHAR2(100 BYTE);

Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('TRADE_EXPENSE_ID', 700, 'TE', TO_DATE('05/16/2013 12:40:12', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0001');
COMMIT;
--End Version [Script Version - 0.0.15] [ReleaseVersion - 9.2.1.25]--[07-04-2014] -- by Anju


--Start Version [Script Version - 0.0.16] [ReleaseVersion - 9.2.1.25]--[04-04-2014] -- by Sreekrishnan

CREATE OR REPLACE FUNCTION GET_GOLD_SECTEXT_gross_wt(ACCTNUM VARCHAR2)
RETURN VARCHAR2 IS
    net_wt VARCHAR2(1000);
BEGIN
    DECLARE CURSOR C1 IS
        SELECT SD.NET_WEIGHT
        FROM SECURITY_DETAILS SD
        WHERE SD.ACCT_NUM = ACCTNUM AND SD.STATUS != 'DELETED'
        ORDER BY SD.ACCT_NUM;
    BEGIN
        FOR S1 IN C1 LOOP
            IF net_wt IS NULL THEN
                net_wt := S1.NET_WEIGHT;
            ELSE
                 net_wt := net_wt || ' ' || S1.NET_WEIGHT;
            END IF;
        END LOOP;
    END;
    RETURN net_wt;
end;
/

CREATE OR REPLACE FUNCTION GET_GOLD_SECTEXT_NET_WT(ACCTNUM VARCHAR2)
RETURN VARCHAR2 IS
    NET_WT VARCHAR2(1000);
BEGIN
    DECLARE CURSOR C1 IS
        SELECT SD.NET_WEIGHT
        FROM SECURITY_DETAILS SD
        WHERE SD.ACCT_NUM = ACCTNUM AND SD.STATUS != 'DELETED'
        ORDER BY SD.ACCT_NUM;
    BEGIN
        FOR S1 IN C1 LOOP
            IF NET_WT IS NULL THEN
                NET_WT := S1.NET_WEIGHT;
            ELSE
                 NET_WT := NET_WT || ' ' || S1.NET_WEIGHT;
            END IF;
        END LOOP;
    END;
    RETURN NET_WT;
END;
/

--End Version [Script Version - 0.0.16] [ReleaseVersion - 9.2.1.25]--[08-04-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.17] [ReleaseVersion - 9.2.1.25]--[06-04-2014] -- by Babu
CREATE TABLE BALANCESHEET_BALANCEUPDATE(
  FROM_DT               DATE,
  TO_DT                 DATE,
  FINAL_ACCOUNT_TYPE    VARCHAR2(64 BYTE),
  AMOUNT                NUMBER(18,2),
  ACCOUNT_HEAD_ID       VARCHAR2(64 BYTE),
  ACCOUNT_HEAD_DESC     VARCHAR2(64 BYTE),
  ACTUAL_AMOUNT         NUMBER(18,2),
  BRANCH_CODE           VARCHAR2(8 BYTE),
  AUTHORIZED_BY         VARCHAR2(64 BYTE),
  AUTHORIZATION_STATUS  VARCHAR2(32 BYTE),
  STATUS                VARCHAR2(16 BYTE),
  STATUS_DT             DATE,
  STATUS_BY             VARCHAR2(32 BYTE),
  BALANCE_TYPE          VARCHAR2(100 BYTE),
  BAL_SHEET_ID          VARCHAR2(100 BYTE),
  AUTHORIZE_DT          DATE
);
CREATE TABLE BALANCESHEET_BALANCEFINAL
(
  FROM_DT               DATE,
  TO_DT                 DATE,
  FINAL_ACCOUNT_TYPE    VARCHAR2(64 BYTE),
  AMOUNT                NUMBER(18,2),
  ACCOUNT_HEAD_ID       VARCHAR2(64 BYTE),
  ACCOUNT_HEAD_DESC     VARCHAR2(64 BYTE),
  ACTUAL_AMOUNT         NUMBER(18,2),
  BRANCH_CODE           VARCHAR2(8 BYTE),
  AUTHORIZED_BY         VARCHAR2(64 BYTE),
  AUTHORIZATION_STATUS  VARCHAR2(32 BYTE),
  STATUS                VARCHAR2(16 BYTE),
  STATUS_DT             DATE,
  STATUS_BY             VARCHAR2(32 BYTE),
  BALANCE_TYPE          VARCHAR2(100 BYTE),
  BAL_SHEET_ID          VARCHAR2(100 BYTE),
  AUTHORIZE_DT          DATE
);
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
    RECORD_KEY_COL, SCREEN_DESC)
 VALUES
   ('SCR06096', '18', 'Balance Update', 'APP01', 'DONE',
    '11', 'com.see.truetransact.ui.supporting.inventory.BalanceUpdateUI', 3, 'CREATED', NULL,
    NULL, NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP01014', 'SCR06096', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00001', 'SCR06096', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00002', 'SCR06096', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00003', 'SCR06096', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);

INSERT INTO ID_GENERATION VALUES('BAL_SHEET_ID','0','BS','31-Mar-2014','8','0001');

ALTER TABLE LOANS_PROD_ACHD ADD AC_INT_RECBLE VARCHAR2(16);

ALTER TABLE DEPOSITS_PROD_ACHD ADD AC_INT_PAYBLE VARCHAR2(16);

CREATE OR REPLACE FORCE VIEW cumulative_deposit_priduct (prod_id,
                                                         prod_desc,
                                                         behaves_like,
                                                         acct_head,
                                                         int_pyble,
                                                         int_pay
                                                        )
AS
   SELECT dp.prod_id, dp.prod_desc, dp.behaves_like, dp.acct_head,
          dpa.ac_int_payble, dpa.int_pay
     FROM deposits_product dp JOIN deposits_prod_achd dpa
          ON dpa.prod_id = dp.prod_id
    WHERE dp.behaves_like = 'CUMMULATIVE'
      AND dp.authorize_status = 'AUTHORIZED'
      AND dp.status != 'DELETED';
CREATE OR REPLACE TYPE TYPE_FIN_ACCT AS OBJECT
    (
        MJR_AC_HD_ID VARCHAR2(4 BYTE),
        MJR_AC_HD_TYPE VARCHAR2(32 BYTE),
        MJR_AC_HD_DESC VARCHAR2(128 BYTE),
        AC_HD_ID VARCHAR2(16 BYTE),
        AC_HD_DESC VARCHAR2(128 BYTE),
        AC_HD_ORDER NUMBER(16,2),
        MJR_AC_ORDER NUMBER(8,2),
        CLOSE_BAL NUMBER(16,2),
        BALANCE_TYPE VARCHAR2(8 BYTE)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_FIN_ACCT AS TABLE OF TYPE_FIN_ACCT;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_ACCT(BRANCH_ID VARCHAR2,AS_ON_DATE IN DATE,FIN_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_FIN_ACCT PIPELINED IS
PRAGMA AUTONOMOUS_TRANSACTION;
    TYPE ref0 IS REF CURSOR;
    trCursor ref0;
    outRec TYPE_FIN_ACCT := TYPE_FIN_ACCT(NULL,NULL,NULL,NULL,NULL,0,0,0,NULL);
BEGIN
    OPEN trCursor FOR
WITH BAL AS
(
SELECT   MAX(m.mjr_ac_hd_id) as mjr_ac_hd_id, MAX(m.mjr_ac_hd_type) as mjr_ac_hd_type, MAX(m.mjr_ac_hd_desc) as mjr_ac_hd_desc, 
    MAX(a.ac_hd_id) as ac_hd_id, MAX(FORMATACHD_NAME(NVL(a.ac_hd_order,a.ac_hd_id),NVL(m.mjr_ac_order,m.mjr_ac_hd_id))) ac_hd_desc,
    MAX(a.ac_hd_order) ac_hd_order, MAX(m.mjr_ac_order) mjr_ac_order, 
    ABS(SUM (CASE
                 WHEN g.balance_type = 'DEBIT'
                    THEN -1
                 ELSE 1
              END * g.close_bal
             )) close_bal, 
         CASE
            WHEN (SUM (  CASE
                            WHEN g.balance_type = 'DEBIT'
                               THEN -1
                            ELSE 1
                         END
                       * g.close_bal
                      )
                 ) < 0
               THEN 'DEBIT'
            ELSE 'CREDIT'
         END balance_type
FROM ac_hd a JOIN mjr_ac_hd m ON a.mjr_ac_hd_id = m.mjr_ac_hd_id
         JOIN gl_abstract g ON g.ac_hd_id = a.ac_hd_id
WHERE m.final_account_type = FIN_ACT_TYPE AND g.dt = AS_ON_DATE AND g.branch_code = NVL(BRANCH_ID,G.branch_code)
GROUP BY a.ac_hd_id
),
BAL_UPD AS
(
SELECT NVL(M.MJR_AC_HD_ID,0) MJR_AC_HD_ID,
NVL(M.MJR_AC_HD_TYPE,DECODE(FIN_ACT_TYPE,'BALANCE SHEET',DECODE(B.BALANCE_TYPE,'CREDIT','LIABILITY','ASSETS'),
DECODE(B.BALANCE_TYPE,'CREDIT','INCOME','EXPENDITURE'))) MJR_AC_HD_TYPE,
NVL(M.MJR_AC_HD_DESC,B.ACCOUNT_HEAD_DESC) MJR_AC_HD_DESC,
NVL(B.ACCOUNT_HEAD_ID,0) AC_HD_ID,NVL(FORMATACHD_NAME(NVL(A.AC_HD_ORDER,A.AC_HD_ID),NVL(M.MJR_AC_ORDER,M.MJR_AC_HD_ID)),B.ACCOUNT_HEAD_DESC) AC_HD_DESC,
NVL(A.AC_HD_ORDER,0) AC_HD_ORDER,NVL(M.MJR_AC_ORDER,0) MJR_AC_ORDER,B.AMOUNT CLOSE_BAL,B.BALANCE_TYPE BALANCE_TYPE
 FROM BALANCESHEET_BALANCEUPDATE B 
LEFT JOIN AC_HD A ON B.ACCOUNT_HEAD_ID = A.AC_HD_ID
LEFT JOIN MJR_AC_HD M ON M.MJR_AC_HD_ID=A.MJR_AC_HD_ID
WHERE B.FINAL_ACCOUNT_TYPE=FIN_ACT_TYPE AND B.TO_DT=AS_ON_DATE AND B.BRANCH_CODE=NVL(BRANCH_ID,B.BRANCH_CODE)
)
SELECT * FROM BAL
UNION ALL 
SELECT * FROM BAL_UPD;
    LOOP
        FETCH trCursor INTO
            outRec.MJR_AC_HD_ID, outRec.MJR_AC_HD_TYPE, outRec.MJR_AC_HD_DESC, outRec.AC_HD_ID, outRec.AC_HD_DESC, outRec.AC_HD_ORDER,
            outRec.MJR_AC_ORDER,outRec.CLOSE_BAL, outRec.BALANCE_TYPE;
        EXIT WHEN trCursor%NOTFOUND;
        PIPE ROW(outRec);        
    END LOOP;
    CLOSE trCursor;
    RETURN;
END;
/
CREATE OR REPLACE TYPE TYPE_INT_RCBL AS OBJECT
    (
        PROD_ID VARCHAR2(16 BYTE),
        INT_RCBL_HD VARCHAR2(16 BYTE),
        INTRCBL NUMBER(16,2)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_INT_RCBL AS TABLE OF TYPE_INT_RCBL;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_RCBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_RCBL PIPELINED IS
    outRec TYPE_INT_RCBL := TYPE_INT_RCBL(NULL,NULL,0);
    PRD_ID VARCHAR2(16 BYTE) := 0;
    ACT_NUM VARCHAR2(16 BYTE) := 0;
    INT_RCBLE_HD VARCHAR2(16 BYTE) := 0;
    CALCTYPE VARCHAR2(32 BYTE) := '';
    INTGETFROM VARCHAR2(8 BYTE);
    FROMDT DATE;
    LOANAMT NUMBER(16,2);
    INTRCBLE NUMBER(16,2) := 0;
BEGIN
    DECLARE CURSOR C1 IS  
        SELECT LP.PROD_ID,LP.BEHAVES_LIKE,LPA.AC_INT_RECBLE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID = AH.MJR_AC_HD_ID
        JOIN LOANS_PROD_ACHD LPA ON LPA.AC_INT_RECBLE = AH.AC_HD_ID
        JOIN LOANS_PRODUCT LP ON LP.PROD_ID = LPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE;
    BEGIN
        FOR L1 IN C1
        LOOP
        PRD_ID := L1.PROD_ID;
        INT_RCBLE_HD := L1.AC_INT_RECBLE;
        CALCTYPE := L1.BEHAVES_LIKE;
            BEGIN
                FOR L2 IN (SELECT LFD.ACCT_NUM,LFD.INT_GET_FROM,LSD.FROM_DT,LSD.LIMIT FROM LOANS_FACILITY_DETAILS LFD 
                JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO=LFD.BORROW_NO
                JOIN LOANS_BORROWER LB ON LB.BORROW_NO=LSD.BORROW_NO
                WHERE LFD.AUTHORIZE_STATUS_1='AUTHORIZED' AND LFD.STATUS != 'DELETED' AND 
                      LFD.BRANCH_ID = NVL(BR_ID,LFD.BRANCH_ID) AND 
                      LFD.ACCT_STATUS = 'NEW' AND LFD.CLEAR_BALANCE < 0 AND 
                      LSD.FROM_DT <= ASONDATE AND 
                      LFD.PROD_ID = PRD_ID)
                        LOOP
                        ACT_NUM := L2.ACCT_NUM;
                        FROMDT := L2.FROM_DT;
                        LOANAMT := L2.LIMIT;
                        INTGETFROM := L2.INT_GET_FROM;
                            IF CALCTYPE = 'SI_BEARING' THEN 
                                INTRCBLE := INTRCBLE + NVL(GET_TL_INTEREST(ACT_NUM,FROMDT,ASONDATE),0) + 
                                        NVL(GET_TL_PEN_INTEREST(ACT_NUM,FROMDT,ASONDATE,GET_TL_PENROI(PRD_ID,ACT_NUM,FROMDT,LOANAMT,INTGETFROM)),0);
                            ELSIF CALCTYPE = 'LOANS_AGAINST_DEPOSITS' THEN 
                                INTRCBLE := INTRCBLE + NVL(GET_TL_INTEREST(ACT_NUM,FROMDT,ASONDATE),0) + 
                                        NVL(GET_TL_PEN_INTEREST(ACT_NUM,FROMDT,ASONDATE,GET_TL_PENROI(PRD_ID,ACT_NUM,FROMDT,LOANAMT,INTGETFROM)),0); 
                            ELSE
                                INTRCBLE := INTRCBLE + GET_ADV_INTEREST_APPLICATION(ACT_NUM,ASONDATE) + GET_ADV_PEN_INT_APPLICATION(ACT_NUM,ASONDATE);
                            END IF;
                        END LOOP;
                        INTRCBLE := ROUND(INTRCBLE);
                        outRec.PROD_ID := PRD_ID;
                        outRec.INT_RCBL_HD := INT_RCBLE_HD;
                        outRec.INTRCBL := INTRCBLE;
                        PIPE ROW (outRec);
            END;
        END LOOP;
    END;
END;
/
CREATE OR REPLACE TYPE TYPE_INT_RCVD AS OBJECT
    (
        PROD_ID VARCHAR2(16 BYTE),
        INT_RCVD_HD VARCHAR2(16 BYTE),
        INTRCVD NUMBER(16,2)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_INT_RCVD AS TABLE OF TYPE_INT_RCVD;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_RCVD(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_RCVD PIPELINED IS
    outRec TYPE_INT_RCVD := TYPE_INT_RCVD(NULL,NULL,0);
    INTRCVD NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_RCVD_HD VARCHAR2(16 BYTE) := 0;
BEGIN
    DECLARE CURSOR C1 IS 
        SELECT LP.PROD_ID,LPA.AC_CREDIT_INT FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID = AH.MJR_AC_HD_ID
        JOIN LOANS_PROD_ACHD LPA ON LPA.AC_INT_RECBLE = AH.AC_HD_ID
        JOIN LOANS_PRODUCT LP ON LP.PROD_ID = LPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_RCVD_HD := PROD.AC_CREDIT_INT;
        INTRCVD := 0;
        SELECT SUM(NVL(GA.CLOSE_BAL,0)) INTO INTRCVD FROM GL_ABSTRACT GA 
        WHERE GA.AC_HD_ID = INT_RCVD_HD AND GA.DT = ASONDATE AND GA.BRANCH_CODE =NVL(BR_ID,GA.BRANCH_CODE);
        outRec.PROD_ID := PRO_ID;
        outRec.INT_RCVD_HD := INT_RCVD_HD;
        outRec.INTRCVD := INTRCVD;
        PIPE ROW (outRec);
        END LOOP;
    END;
    RETURN;
END;
/
CREATE OR REPLACE TYPE TYPE_PREV_INT_RCVBL AS OBJECT
    (
        PROD_ID VARCHAR2(16 BYTE),
        INT_RCVBL_HD VARCHAR2(16 BYTE),
        PREV_RCVBL NUMBER(16,2)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_PREV_INT_RCVBL AS TABLE OF TYPE_PREV_INT_RCVBL;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_PREV_INT_RCVBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_PREV_INT_RCVBL PIPELINED IS
    outRec TYPE_PREV_INT_RCVBL := TYPE_PREV_INT_RCVBL(NULL,NULL,0);
    PREV_INTRCVBL NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_RCVBL_HD VARCHAR2(16 BYTE) := 0;
    CNT NUMBER(16,2) :=0;
BEGIN
DECLARE CURSOR C1 IS 
        SELECT LP.PROD_ID,LPA.AC_INT_RECBLE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID = AH.MJR_AC_HD_ID
        JOIN LOANS_PROD_ACHD LPA ON LPA.AC_INT_RECBLE = AH.AC_HD_ID
        JOIN LOANS_PRODUCT LP ON LP.PROD_ID = LPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_RCVBL_HD := PROD.AC_INT_RECBLE;
        PREV_INTRCVBL := 0;
                SELECT COUNT(*) INTO CNT FROM BALANCESHEET_BALANCEUPDATE BB 
                WHERE BB.ACCOUNT_HEAD_ID = INT_RCVBL_HD AND BB.BRANCH_CODE = BR_ID 
                AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE);
                IF CNT > 0 THEN
                SELECT NVL(BB.AMOUNT,0) INTO PREV_INTRCVBL FROM BALANCESHEET_BALANCEUPDATE BB
                WHERE BB.BRANCH_CODE = BR_ID AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE) AND 
                BB.ACCOUNT_HEAD_ID = INT_RCVBL_HD;
                END IF;
                outRec.PROD_ID := PRO_ID;
                outRec.INT_RCVBL_HD := INT_RCVBL_HD;
                outRec.PREV_RCVBL := PREV_INTRCVBL;
                PIPE ROW (outRec);
        END LOOP;
        RETURN;
    END;
END;
/
CREATE OR REPLACE TYPE TYPE_INT_PAID AS OBJECT
    (
        PROD_ID VARCHAR2(16 BYTE),
        INT_PAID_HD VARCHAR2(16 BYTE),
        INTPAID NUMBER(16,2)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_INT_PAID AS TABLE OF TYPE_INT_PAID;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_PAID(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACCOUNT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_PAID PIPELINED IS
    outRec TYPE_INT_PAID := TYPE_INT_PAID(NULL,NULL,0);
    INTPAID NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_PAID_HD VARCHAR2(16 BYTE) := 0;
BEGIN
    DECLARE CURSOR C1 IS 
        SELECT DPA.PROD_ID,DPA.INT_PAY FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID=AH.MJR_AC_HD_ID
        JOIN DEPOSITS_PROD_ACHD DPA ON DPA.AC_INT_PAYBLE=AH.AC_HD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACCOUNT_TYPE
        ORDER BY DPA.PROD_ID;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_PAID_HD := PROD.INT_PAY;
        INTPAID := 0;
        SELECT SUM(NVL(GA.CLOSE_BAL,0)) INTO INTPAID FROM GL_ABSTRACT GA 
        WHERE GA.AC_HD_ID = INT_PAID_HD AND GA.DT = ASONDATE AND GA.BRANCH_CODE =NVL(BR_ID,GA.BRANCH_CODE);
        outRec.PROD_ID := PRO_ID;
        outRec.INT_PAID_HD := INT_PAID_HD;
        outRec.INTPAID := INTPAID;
        PIPE ROW (outRec);
        END LOOP;
    END;
    RETURN;
END;
/
CREATE OR REPLACE TYPE TYPE_INT_PYBL AS OBJECT
    (
        PROD_ID VARCHAR2(16 BYTE),
        INT_PYBL_HD VARCHAR2(16 BYTE),
        INTPAYABLE NUMBER(16,2)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_INT_PYBL AS TABLE OF TYPE_INT_PYBL;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_PYBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACCOUNT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_PYBL PIPELINED IS
    outRec TYPE_INT_PYBL := TYPE_INT_PYBL(NULL,NULL,0);
    ACT_NUM VARCHAR2(16 BYTE);
    INTPAYABLE NUMBER(16,2) := 0;
    PRD_ID VARCHAR2(16 BYTE) := 0;
    INT_PAYABLE_HD VARCHAR2(16 BYTE) := 0;
    CALCTYPE VARCHAR2(32 BYTE) := '';
BEGIN
DECLARE CURSOR C1 IS 
        SELECT DPA.PROD_ID,DPA.AC_INT_PAYBLE,DP.BEHAVES_LIKE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID=AH.MJR_AC_HD_ID
        JOIN DEPOSITS_PROD_ACHD DPA ON DPA.AC_INT_PAYBLE=AH.AC_HD_ID
        JOIN DEPOSITS_PRODUCT DP ON DP.PROD_ID=DPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACCOUNT_TYPE;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRD_ID := PROD.PROD_ID;
        INT_PAYABLE_HD := PROD.AC_INT_PAYBLE;
        CALCTYPE := PROD.BEHAVES_LIKE;
        INTPAYABLE := 0;
            BEGIN
                    FOR L1 IN (SELECT S.DEPOSIT_NO, S.DEPOSIT_DT,S.MATURITY_DT,S.CLOSE_DT,S.DEPOSIT_AMT,S.RATE_OF_INT,
                         CASE WHEN S.DEPOSIT_PERIOD_DD > 0 THEN 'D' ELSE 'M' END AS PRD_TYPE
                         FROM DEPOSIT_SUB_ACINFO S JOIN DEPOSIT_ACINFO DA ON DA.DEPOSIT_NO = S.DEPOSIT_NO
                         WHERE DA.PROD_ID = PRD_ID AND DA.BRANCH_ID = NVL(BR_ID,DA.BRANCH_ID)
                         AND DA.CREATED_DT <= ASONDATE AND
                         (S.CLOSE_DT IS NULL OR S.CLOSE_DT>ASONDATE) AND
                         (S.AUTHORIZE_STATUS = 'AUTHORIZED' OR S.AUTHORIZE_STATUS IS NULL) AND S.STATUS != 'DELETED') 
                    LOOP
                    ACT_NUM := L1.DEPOSIT_NO;
                        IF CALCTYPE = 'FIXED' THEN
                            INTPAYABLE :=INTPAYABLE + NVL(GET_FD_INTERESTPAYABLE(ACT_NUM,ASONDATE),0);
                        ELSIF CALCTYPE = 'CUMMULATIVE' THEN  
                            INTPAYABLE := INTPAYABLE + NVL(GET_CCUMULATIVE_DEP_INTPAYABLE(ACT_NUM,ASONDATE),0);
                        ELSIF CALCTYPE = 'RECURRING' THEN 
                            INTPAYABLE := INTPAYABLE + NVL(GET_RD_INTEREST(ACT_NUM,ASONDATE),0);
                        ELSE
                            INTPAYABLE := 0;
                        END IF;
                    END LOOP;
                    INTPAYABLE := ROUND(INTPAYABLE);
                    outRec.PROD_ID := PRD_ID;
                    outRec.INT_PYBL_HD := INT_PAYABLE_HD;
                    outRec.INTPAYABLE := INTPAYABLE;
                    PIPE ROW (outRec);
            END;
        END LOOP;
        RETURN;
    END;
END;
/
CREATE OR REPLACE TYPE TYPE_PREV_INT_PYBL AS OBJECT
    (
        PROD_ID VARCHAR2(16 BYTE),
        INT_PAYABLE_HD VARCHAR2(16 BYTE),
        PREV_INTPBL NUMBER(16,2)
    );
/
CREATE OR REPLACE TYPE TAB_TYPE_PREV_INT_PYBL AS TABLE OF TYPE_PREV_INT_PYBL;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_PREV_INT_PYBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACCOUNT_TYPE VARCHAR2) RETURN TAB_TYPE_PREV_INT_PYBL PIPELINED IS
    outRec TYPE_PREV_INT_PYBL := TYPE_PREV_INT_PYBL(NULL,NULL,0);
    PREV_INTPBL NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_PYBL_HD VARCHAR2(16 BYTE) := 0;
    CNT NUMBER(16,2) :=0;
BEGIN
DECLARE CURSOR C1 IS 
        SELECT DPA.PROD_ID,DPA.AC_INT_PAYBLE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID=AH.MJR_AC_HD_ID
        JOIN DEPOSITS_PROD_ACHD DPA ON DPA.AC_INT_PAYBLE=AH.AC_HD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACCOUNT_TYPE;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_PYBL_HD := PROD.AC_INT_PAYBLE;
        PREV_INTPBL := 0;
                SELECT COUNT(*) INTO CNT FROM BALANCESHEET_BALANCEUPDATE BB 
                WHERE BB.ACCOUNT_HEAD_ID = INT_PYBL_HD AND BB.BRANCH_CODE = BR_ID 
                AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE);
                IF CNT > 0 THEN
                SELECT NVL(BB.AMOUNT,0) INTO PREV_INTPBL FROM BALANCESHEET_BALANCEUPDATE BB
                WHERE BB.BRANCH_CODE = BR_ID AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE) AND 
                BB.ACCOUNT_HEAD_ID = INT_PYBL_HD;
                END IF;
                outRec.PROD_ID := PRO_ID;
                outRec.INT_PAYABLE_HD := INT_PYBL_HD;
                outRec.PREV_INTPBL := PREV_INTPBL;
                PIPE ROW (outRec);
        END LOOP;
        RETURN;
    END;
END;
/
--End Version [Script Version - 0.0.17] [ReleaseVersion - 9.2.1.25]--[08-04-2014] -- by Babu

--Start Version [Script Version - 0.0.18] [ReleaseVersion - 9.2.1.25]--[16-04-2014] -- by Shihad
ALTER TABLE RENT_PROFILE ADD ADV_RENT_ACT_HD_ID VARCHAR2(50);

--End Version [Script Version - 0.0.18] [ReleaseVersion - 9.2.1.25]--[16-04-2014] -- by Shihad


--Start Version [Script Version - 0.0.19] [ReleaseVersion - 9.2.1.25]--[16-04-2014] -- by Nidhin
insert into LOOKUP_MASTER (LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC)values('PENELINT_FULLAMT_INSTAMT','Full Amount','Full Amount');
insert into LOOKUP_MASTER (LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC)values('PENELINT_FULLAMT_INSTAMT','Installment Amount','Installment Amount');

ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD (PENEL_INT_FULL_AMT_INST_AMT  VARCHAR2(10 BYTE));

ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD (PENEL_PZ_INT_FULL_AMT_INST_AMT  VARCHAR2(10 BYTE));

--End Version [Script Version - 0.0.19] [ReleaseVersion - 9.2.1.25]--[16-04-2014] -- by Nidhin

--Start Version [Script Version - 0.0.20] [ReleaseVersion - 9.2.1.25]--[26-04-2014] -- by Chithra
 insert into LOOKUP_MASTER values('DEPOSITS_INT_RATE_APPLY','N','LOW','CREATED','','Y');
 insert into LOOKUP_MASTER values('DEPOSITS_INT_RATE_APPLY','Y','HIGH','CREATED','','Y');

--End Version [Script Version - 0.0.20] [ReleaseVersion - 9.2.1.25]--[26-04-2014] -- by Chithra

--Start Version   [Script Version - 0.0.21] [ReleaseVersion - 9.2.1.25]--[29-04-2014] -- by Sathiya
--loan interest report showing in all screen added query and alter scripts
ALTER TABLE LOANS_CLOSING_INT_TMP ADD CURR_DT DATE;
ALTER TABLE LOANS_CLOSING_INT_TMP ADD BRANCH_CODE VARCHAR2 (16 Byte);
ALTER TABLE LOANS_CLOSING_INT_TMP ADD USER_ID VARCHAR2 (16 Byte);
ALTER TABLE LOANS_CLOSING_INT_TMP ADD VALIDATE_TYPE VARCHAR2 (16 Byte);
ALTER TABLE ERROR_SHOWING MODIFY ERROR_MSG varchar2(124);

CREATE OR REPLACE PROCEDURE deleteloanintproc (
   actnum        IN   VARCHAR,
   lastInt_calc_dt in Date
)
AS
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN    
    DELETE FROM LOANS_INTEREST WHERE  ACT_NUM=actnum AND FROM_DT>lastInt_calc_dt; 
    DELETE  FROM LOANS_CLOSING_INT_TMP WHERE ACT_NUM=actnum;   
   COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE insertloanintproc ( 
   actnum        IN   VARCHAR,
   from_dt       IN   DATE,
   to_dt         IN   DATE,
   amt           IN   NUMBER,
   no_of_days    IN   NUMBER,
   tot_product   IN   NUMBER,
   int_amt       IN   NUMBER,
   int_rate      IN   NUMBER,
   prod_id       IN   VARCHAR,
   int_calc_dt   IN   DATE,
   cust_id       IN   VARCHAR,
   remarks       IN   VARCHAR,
   curr_dt       IN   DATE,
   branch_code   IN   VARCHAR,
   user_id       IN   VARCHAR,
   valudate_type in   varchar
)
AS
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN  
    INSERT INTO loans_closing_int_tmp
               (act_num, from_dt, TO_DATE, amt, no_of_days, tot_product,
                int_amt, int_rate, prod_id, int_calc_dt, cust_id, remarks,
                curr_dt, branch_code, user_id,VALIDATE_TYPE
               )
        VALUES (actnum, from_dt, to_dt, amt, no_of_days, tot_product,
                int_amt, int_rate, prod_id, int_calc_dt, cust_id, remarks,
                curr_dt, branch_code, user_id,valudate_type
               );
   COMMIT;
END;
/

CREATE OR REPLACE FUNCTION DELETELOANINTERESTTMP (
   actnum        IN   VARCHAR,
   lastInt_calc_dt in Date  
)
   RETURN VARCHAR2
IS
   curval   VARCHAR2 (16);
BEGIN
   deleteloanintproc (actnum,lastInt_calc_dt);
   RETURN curval;
END;
/

CREATE OR REPLACE FUNCTION insertloaninteresttmp (
   actnum        IN   VARCHAR,
   from_dt       IN   DATE,
   to_dt         IN   DATE,
   amt           IN   NUMBER,
   no_of_days    IN   NUMBER,
   tot_product   IN   NUMBER,
   int_amt       IN   NUMBER,
   int_rate      IN   NUMBER,
   prod_id       IN   VARCHAR,
   int_calc_dt   IN   DATE,
   cust_id       IN   VARCHAR,
   remarks       IN   VARCHAR,
   curr_dt       IN   DATE,
   branch_code   IN   VARCHAR,
   user_id       IN   VARCHAR,
   valudate_type in   VARCHAR    
)
   RETURN VARCHAR2
IS
   curval   VARCHAR2 (16);
BEGIN
   insertloanintproc (actnum,
                      from_dt,
                      to_dt,
                      amt,
                      no_of_days,
                      tot_product,
                      int_amt,
                      int_rate,
                      prod_id,
                      int_calc_dt,
                      cust_id,
                      remarks,
                      curr_dt,
                      branch_code,
                      user_id,
                      valudate_type
                     );
   RETURN curval;
END;
/

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06122', '6121', 'Back Dated Transaction', 'APP01', 'DONE', 
    '14', 'Back Dated Transaction', 4, 'CREATED', NULL, 
    NULL, NULL);
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06122', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06122', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06122', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06122', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00005', 'SCR06122', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00014', 'SCR06122', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'Y');
COMMIT;

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('BACK_DATE.BATCH_ID', 1, 'BDT', TO_DATE('05/05/2004 16:17:44', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0001');
COMMIT;

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('BACK_DATE_TRANS_ID', 1, 'BTT', TO_DATE('05/05/2004 16:17:44', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0001');
COMMIT;

CREATE OR REPLACE FUNCTION BACKDATEDtRANSACTION(P_ACCT_ID IN VARCHAR ,AMOUNT IN NUMBER ,
P_FROM_DT IN DATE,P_TO_DT IN DATE ,P_BALANCE_TYPE IN VARCHAR, P_BRANCH_CODE IN VARCHAR)
RETURN VARCHAR2 IS CUR VARCHAR2(16);

FIRSTIF VARCHAR2(16) :='Y';
SECONDTIF VARCHAR2(16):='Y';
PREVIOUSDT DATE;

PREVIOUSAMT NUMBER (16,2):=0;
PRAGMA  AUTONOMOUS_TRANSACTION; 

BEGIN

FOR I IN (SELECT AC_HD_ID,OPN_BAL,CLOSE_BAL,BRANCH_CODE,DT,BALANCE_TYPE  FROM 
GL_ABSTRACT WHERE BRANCH_CODE=P_BRANCH_CODE AND AC_HD_ID=P_ACCT_ID AND DT>P_FROM_DT ORDER BY DT ) LOOP

IF P_BALANCE_TYPE= I.BALANCE_TYPE   THEN
    IF FIRSTIF ='Y' THEN
    PREVIOUSDT:=TO_DATE(I.DT)-1;
    PREVIOUSAMT:=AMOUNT*2;
    UPDATE  GL_ABSTRACT SET CLOSE_BAL=CLOSE_BAL+AMOUNT   
    WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=PREVIOUSDT ;
    --DBMS_OUTPUT.PUT_LINE('FIRST TO_DATE(I.DT)-1   ' || PREVIOUSDT);
   END IF;
   UPDATE  GL_ABSTRACT SET OPN_BAL=OPN_BAL+ AMOUNT, CLOSE_BAL=CLOSE_BAL+AMOUNT   
   WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=I.DT ;
   FIRSTIF :='N';
   SECONDTIF:='Y';
END IF;

IF P_BALANCE_TYPE != I.BALANCE_TYPE   THEN

    IF SECONDTIF ='Y' THEN
    PREVIOUSDT:=TO_DATE(I.DT)-1;
    PREVIOUSAMT:=AMOUNT*2;
    UPDATE  GL_ABSTRACT SET CLOSE_BAL=CLOSE_BAL-AMOUNT 
    WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=PREVIOUSDT ;
     --DBMS_OUTPUT.PUT_LINE('TO_DATE(I.DT)  ' ||PREVIOUSDT);
    END IF;
UPDATE  GL_ABSTRACT SET OPN_BAL=OPN_BAL- AMOUNT  ,CLOSE_BAL=CLOSE_BAL-AMOUNT  
WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=I.DT ;
SECONDTIF:='N';
 FIRSTIF :='Y';
END IF;

END LOOP;

COMMIT;
RETURN CUR ;
END;
/

--End Version   [Script Version - 0.0.21] [ReleaseVersion - 9.2.1.25]--[29-04-2014] -- by Sathiya

--Start Version   [Script Version - 0.0.22] [ReleaseVersion - 9.2.1.25]--[05-05-2014] -- by Babu
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_PYBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_PYBL PIPELINED IS
    outRec TYPE_INT_PYBL := TYPE_INT_PYBL(NULL,NULL,0);
    ACT_NUM VARCHAR2(16 BYTE);
    INTPAYABLE NUMBER(16,2) := 0;
    PRD_ID VARCHAR2(16 BYTE) := 0;
    INT_PAYABLE_HD VARCHAR2(16 BYTE) := 0;
    CALCTYPE VARCHAR2(32 BYTE) := '';
BEGIN
DECLARE CURSOR C1 IS 
        SELECT DPA.PROD_ID,DPA.AC_INT_PAYBLE,DP.BEHAVES_LIKE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID=AH.MJR_AC_HD_ID
        JOIN DEPOSITS_PROD_ACHD DPA ON DPA.INT_PAY=AH.AC_HD_ID
        JOIN DEPOSITS_PRODUCT DP ON DP.PROD_ID=DPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE
        ORDER BY DP.PROD_ID;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRD_ID := PROD.PROD_ID;
        INT_PAYABLE_HD := PROD.AC_INT_PAYBLE;
        CALCTYPE := PROD.BEHAVES_LIKE;
        INTPAYABLE := 0;
            BEGIN
                    FOR L1 IN (SELECT S.DEPOSIT_NO, S.DEPOSIT_DT,S.MATURITY_DT,S.CLOSE_DT,S.DEPOSIT_AMT,S.RATE_OF_INT,
                         CASE WHEN S.DEPOSIT_PERIOD_DD > 0 THEN 'D' ELSE 'M' END AS PRD_TYPE
                         FROM DEPOSIT_SUB_ACINFO S JOIN DEPOSIT_ACINFO DA ON DA.DEPOSIT_NO = S.DEPOSIT_NO
                         WHERE DA.PROD_ID = PRD_ID AND DA.BRANCH_ID = NVL(BR_ID,DA.BRANCH_ID)
                         AND DA.CREATED_DT <= ASONDATE AND
                         (S.CLOSE_DT IS NULL OR S.CLOSE_DT>ASONDATE) AND
                         (S.AUTHORIZE_STATUS = 'AUTHORIZED' OR S.AUTHORIZE_STATUS IS NULL) AND S.STATUS != 'DELETED') 
                    LOOP
                    ACT_NUM := L1.DEPOSIT_NO;
                        IF CALCTYPE = 'FIXED' THEN
                            INTPAYABLE := INTPAYABLE + NVL(GET_FD_INTERESTPAYABLE(ACT_NUM,ASONDATE),0);
                        ELSIF CALCTYPE = 'CUMMULATIVE' THEN  
                            INTPAYABLE := INTPAYABLE + NVL(GET_CCUMULATIVE_DEP_INTPAYABLE(ACT_NUM,ASONDATE),0);
                        ELSIF CALCTYPE = 'RECURRING' THEN 
                            INTPAYABLE := INTPAYABLE + NVL(GET_RD_INTEREST(ACT_NUM,ASONDATE),0);
                        ELSE
                            INTPAYABLE := 0;
                        END IF;
                    END LOOP;
                    INTPAYABLE := ROUND(INTPAYABLE);
                    --DBMS_OUTPUT.PUT_LINE('INTPAYABLE ' || INTPAYABLE || 'PROD_ID '|| PROD_ID || 'INT_PAYABLE_HD ' || INT_PAYABLE_HD);
                    outRec.PROD_ID := PRD_ID;
                    outRec.INT_PYBL_HD := INT_PAYABLE_HD;
                    outRec.INTPAYABLE := INTPAYABLE;
                    PIPE ROW (outRec);
            END;
        END LOOP;
        RETURN;
    END;
END;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_PAID(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_PAID PIPELINED IS
    outRec TYPE_INT_PAID := TYPE_INT_PAID(NULL,NULL,0);
    INTPAID NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_PAID_HD VARCHAR2(16 BYTE) := 0;
BEGIN
    DECLARE CURSOR C1 IS 
        SELECT DPA.PROD_ID,DPA.INT_PAY FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID=AH.MJR_AC_HD_ID
        JOIN DEPOSITS_PROD_ACHD DPA ON DPA.INT_PAY=AH.AC_HD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE
        ORDER BY DPA.PROD_ID;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_PAID_HD := PROD.INT_PAY;
        INTPAID := 0;
        SELECT SUM(NVL(GA.CLOSE_BAL,0)) INTO INTPAID FROM GL_ABSTRACT GA 
        WHERE GA.AC_HD_ID = INT_PAID_HD AND GA.DT = ASONDATE AND GA.BRANCH_CODE =NVL(BR_ID,GA.BRANCH_CODE);
        --DBMS_OUTPUT.PUT_LINE('INTPAID ' || INTPAID || 'PROD_ID '|| PRO_ID || 'INT_PAID_HD ' || INT_PAID_HD);
        outRec.PROD_ID := PRO_ID;
        outRec.INT_PAID_HD := INT_PAID_HD;
        outRec.INTPAID := INTPAID;
        PIPE ROW (outRec);
        END LOOP;
    END;
    RETURN;
END;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_PREV_INT_PYBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_PREV_INT_PYBL PIPELINED IS
    outRec TYPE_PREV_INT_PYBL := TYPE_PREV_INT_PYBL(NULL,NULL,0);
    PREV_INTPBL NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_PYBL_HD VARCHAR2(16 BYTE) := 0;
    CNT NUMBER(16,2) :=0;
BEGIN
DECLARE CURSOR C1 IS 
        SELECT DPA.PROD_ID,DPA.AC_INT_PAYBLE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID=AH.MJR_AC_HD_ID
        JOIN DEPOSITS_PROD_ACHD DPA ON DPA.INT_PAY=AH.AC_HD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE
        ORDER BY DPA.PROD_ID;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_PYBL_HD := PROD.AC_INT_PAYBLE;
        PREV_INTPBL := 0;
                SELECT COUNT(*) INTO CNT FROM BALANCESHEET_BALANCEUPDATE BB 
                WHERE BB.ACCOUNT_HEAD_ID = INT_PYBL_HD AND BB.BRANCH_CODE = BR_ID 
                AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE);
                IF CNT > 0 THEN
                SELECT NVL(BB.AMOUNT,0) INTO PREV_INTPBL FROM BALANCESHEET_BALANCEUPDATE BB
                WHERE BB.BRANCH_CODE = BR_ID AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE) AND 
                BB.ACCOUNT_HEAD_ID = INT_PYBL_HD;
                END IF;
                --DBMS_OUTPUT.PUT_LINE('PREV_INTPBL ' || PREV_INTPBL || 'PROD_ID '|| PRO_ID || 'INT_PYBL_HD ' || INT_PYBL_HD);
                outRec.PROD_ID := PRO_ID;
                outRec.INT_PAYABLE_HD := INT_PYBL_HD;
                outRec.PREV_INTPBL := PREV_INTPBL;
                PIPE ROW (outRec);
        END LOOP;
        RETURN;
    END;
END;
/


CREATE OR REPLACE FUNCTION LOAD_FIN_INT_RCBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_RCBL PIPELINED IS
    outRec TYPE_INT_RCBL := TYPE_INT_RCBL(NULL,NULL,0);
    PRD_ID VARCHAR2(16 BYTE) := 0;
    ACT_NUM VARCHAR2(16 BYTE) := 0;
    INT_RCBLE_HD VARCHAR2(16 BYTE) := 0;
    CALCTYPE VARCHAR2(32 BYTE) := '';
    INTGETFROM VARCHAR2(8 BYTE);
    FROMDT DATE;
    LOANAMT NUMBER(16,2);
    INTRCBLE NUMBER(16,2) := 0;
BEGIN
    DECLARE CURSOR C1 IS  
        SELECT LP.PROD_ID,LP.BEHAVES_LIKE,LPA.AC_INT_RECBLE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID = AH.MJR_AC_HD_ID
        JOIN LOANS_PROD_ACHD LPA ON LPA.AC_CREDIT_INT = AH.AC_HD_ID
        JOIN LOANS_PRODUCT LP ON LP.PROD_ID = LPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE;
    BEGIN
        FOR L1 IN C1
        LOOP
        PRD_ID := L1.PROD_ID;
        INT_RCBLE_HD := L1.AC_INT_RECBLE;
        CALCTYPE := L1.BEHAVES_LIKE;
        INTRCBLE := 0;
            BEGIN
                FOR L2 IN (SELECT LFD.ACCT_NUM,LFD.INT_GET_FROM,LSD.FROM_DT,LSD.LIMIT FROM LOANS_FACILITY_DETAILS LFD 
                JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO=LFD.BORROW_NO
                JOIN LOANS_BORROWER LB ON LB.BORROW_NO=LSD.BORROW_NO
                WHERE LFD.AUTHORIZE_STATUS_1='AUTHORIZED' AND LFD.STATUS != 'DELETED' AND 
                      LFD.BRANCH_ID = NVL(BR_ID,LFD.BRANCH_ID) AND 
                      LFD.ACCT_STATUS = 'NEW' AND LFD.CLEAR_BALANCE < 0 AND 
                      LSD.FROM_DT <= ASONDATE AND 
                      LFD.PROD_ID = PRD_ID)
                        LOOP
                        ACT_NUM := L2.ACCT_NUM;
                        FROMDT := L2.FROM_DT;
                        LOANAMT := L2.LIMIT;
                        INTGETFROM := L2.INT_GET_FROM;
                            IF CALCTYPE = 'SI_BEARING' THEN 
                                INTRCBLE := INTRCBLE + NVL(GET_TL_INTEREST(ACT_NUM,FROMDT,ASONDATE),0) + 
                                        NVL(GET_TL_PEN_INTEREST(ACT_NUM,FROMDT,ASONDATE,GET_TL_PENROI(PRD_ID,ACT_NUM,FROMDT,LOANAMT,INTGETFROM)),0);
                            ELSIF CALCTYPE = 'LOANS_AGAINST_DEPOSITS' THEN 
                                INTRCBLE := INTRCBLE + NVL(GET_TL_INTEREST(ACT_NUM,FROMDT,ASONDATE),0) + 
                                        NVL(GET_TL_PEN_INTEREST(ACT_NUM,FROMDT,ASONDATE,GET_TL_PENROI(PRD_ID,ACT_NUM,FROMDT,LOANAMT,INTGETFROM)),0); 
                            ELSE
                                INTRCBLE := INTRCBLE + GET_ADV_INTEREST_APPLICATION(ACT_NUM,ASONDATE) + GET_ADV_PEN_INT_APPLICATION(ACT_NUM,ASONDATE);
                            END IF;
                        END LOOP;
                        INTRCBLE := ROUND(INTRCBLE);
                        --DBMS_OUTPUT.PUT_LINE('INTRCBLE ' || INTRCBLE || 'PRD_ID '|| PRD_ID || 'INT_RCBLE_HD ' || INT_RCBLE_HD);
                        outRec.PROD_ID := PRD_ID;
                        outRec.INT_RCBL_HD := INT_RCBLE_HD;
                        outRec.INTRCBL := INTRCBLE;
                        PIPE ROW (outRec);
            END;
        END LOOP;
    END;
END;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_INT_RCVD(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_INT_RCVD PIPELINED IS
    outRec TYPE_INT_RCVD := TYPE_INT_RCVD(NULL,NULL,0);
    INTRCVD NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_RCVD_HD VARCHAR2(16 BYTE) := 0;
BEGIN
    DECLARE CURSOR C1 IS 
        SELECT LP.PROD_ID,LPA.AC_CREDIT_INT FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID = AH.MJR_AC_HD_ID
        JOIN LOANS_PROD_ACHD LPA ON LPA.AC_CREDIT_INT = AH.AC_HD_ID
        JOIN LOANS_PRODUCT LP ON LP.PROD_ID = LPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = 'INTEREST RECEIVED';
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_RCVD_HD := PROD.AC_CREDIT_INT;
        INTRCVD := 0;
        SELECT SUM(NVL(GA.CLOSE_BAL,0)) INTO INTRCVD FROM GL_ABSTRACT GA 
        WHERE GA.AC_HD_ID = INT_RCVD_HD AND GA.DT = ASONDATE AND GA.BRANCH_CODE =NVL(BR_ID,GA.BRANCH_CODE);
        --DBMS_OUTPUT.PUT_LINE('INTRCVD ' || INTRCVD || 'PROD_ID '|| PRO_ID || 'INT_RCVD_HD ' || INT_RCVD_HD);
        outRec.PROD_ID := PRO_ID;
        outRec.INT_RCVD_HD := INT_RCVD_HD;
        outRec.INTRCVD := INTRCVD;
        PIPE ROW (outRec);
        END LOOP;
    END;
    RETURN;
END;
/
CREATE OR REPLACE FUNCTION LOAD_FIN_PREV_INT_RCVBL(BR_ID VARCHAR2,ASONDATE DATE,SUB_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_PREV_INT_RCVBL PIPELINED IS
    outRec TYPE_PREV_INT_RCVBL := TYPE_PREV_INT_RCVBL(NULL,NULL,0);
    PREV_INTRCVBL NUMBER(16,2) := 0;
    PRO_ID VARCHAR2(16 BYTE) := 0;
    INT_RCVBL_HD VARCHAR2(16 BYTE) := 0;
    CNT NUMBER(16,2) :=0;
BEGIN
DECLARE CURSOR C1 IS 
        SELECT LP.PROD_ID,LPA.AC_INT_RECBLE FROM MJR_AC_HD MAH 
        JOIN AC_HD AH ON MAH.MJR_AC_HD_ID = AH.MJR_AC_HD_ID
        JOIN LOANS_PROD_ACHD LPA ON LPA.AC_CREDIT_INT = AH.AC_HD_ID
        JOIN LOANS_PRODUCT LP ON LP.PROD_ID = LPA.PROD_ID
        WHERE MAH.SUB_ACCOUNT_TYPE = SUB_ACT_TYPE;
     BEGIN
        FOR PROD IN C1
        LOOP
        PRO_ID := PROD.PROD_ID;
        INT_RCVBL_HD := PROD.AC_INT_RECBLE;
        PREV_INTRCVBL := 0;
                SELECT COUNT(*) INTO CNT FROM BALANCESHEET_BALANCEUPDATE BB 
                WHERE BB.ACCOUNT_HEAD_ID = INT_RCVBL_HD AND BB.BRANCH_CODE = BR_ID 
                AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE);
                IF CNT > 0 THEN
                SELECT NVL(BB.AMOUNT,0) INTO PREV_INTRCVBL FROM BALANCESHEET_BALANCEUPDATE BB
                WHERE BB.BRANCH_CODE = BR_ID AND BB.TO_DT = GET_LAST_FINENDDATE(ASONDATE) AND 
                BB.ACCOUNT_HEAD_ID = INT_RCVBL_HD;
                END IF;
                --DBMS_OUTPUT.PUT_LINE('PREV_INTRCVBL ' || PREV_INTRCVBL || 'PROD_ID '|| PRO_ID || 'INT_RCVBL_HD ' || INT_RCVBL_HD);
                outRec.PROD_ID := PRO_ID;
                outRec.INT_RCVBL_HD := INT_RCVBL_HD;
                outRec.PREV_RCVBL := PREV_INTRCVBL;
                PIPE ROW (outRec);
        END LOOP;
        RETURN;
    END;
END;
/
--End Version   [Script Version - 0.0.22] [ReleaseVersion - 9.2.1.25]--[05-05-2014] -- by Babu

--Start Version   [Script Version - 0.0.23] [ReleaseVersion - 9.2.1.25]--[14-05-2014] -- by Babu
CREATE OR REPLACE FUNCTION LOAD_FIN_ACCT(BRANCH_ID VARCHAR2,AS_ON_DATE IN DATE,FIN_ACT_TYPE VARCHAR2) RETURN TAB_TYPE_FIN_ACCT PIPELINED IS
PRAGMA AUTONOMOUS_TRANSACTION;
    TYPE ref0 IS REF CURSOR;
    trCursor ref0;
    outRec TYPE_FIN_ACCT := TYPE_FIN_ACCT(NULL,NULL,NULL,NULL,NULL,0,0,0,NULL);
BEGIN
IF FIN_ACT_TYPE = 'TRADING' THEN
    OPEN trCursor FOR
    WITH BAL AS
    (
    SELECT   MAX(m.mjr_ac_hd_id) as mjr_ac_hd_id, MAX(m.mjr_ac_hd_type) as mjr_ac_hd_type, MAX(m.mjr_ac_hd_desc) as mjr_ac_hd_desc, 
        MAX(a.ac_hd_id) as ac_hd_id, MAX(FORMATACHD_NAME(NVL(a.ac_hd_order,a.ac_hd_id),NVL(m.mjr_ac_order,m.mjr_ac_hd_id))) ac_hd_desc,
        MAX(a.ac_hd_order) ac_hd_order, MAX(m.mjr_ac_order) mjr_ac_order, 
        ABS(SUM (CASE
                     WHEN g.balance_type = 'DEBIT'
                        THEN -1
                     ELSE 1
                  END * g.close_bal
                 )) close_bal,CASE
                WHEN (SUM (  CASE
                                WHEN g.balance_type = 'DEBIT'
                                   THEN -1
                                ELSE 1
                             END
                           * g.close_bal
                          )
                     ) < 0
                   THEN 'DEBIT'
                ELSE 'CREDIT'
             END balance_type
    FROM ac_hd a JOIN mjr_ac_hd m ON a.mjr_ac_hd_id = m.mjr_ac_hd_id
             JOIN gl_abstract g ON g.ac_hd_id = a.ac_hd_id
    WHERE m.final_account_type = FIN_ACT_TYPE AND g.dt = AS_ON_DATE AND g.branch_code = NVL(BRANCH_ID,G.branch_code)
    GROUP BY a.ac_hd_id
    ),
    BAL_UPD AS
    (   
    SELECT NVL(M.MJR_AC_HD_ID,0) MJR_AC_HD_ID,
        NVL(M.MJR_AC_HD_TYPE,DECODE(FIN_ACT_TYPE,'BALANCE SHEET',DECODE(B.BALANCE_TYPE,'CREDIT','LIABILITY','ASSETS'),DECODE(B.BALANCE_TYPE,'CREDIT','INCOME','EXPENDITURE'))) MJR_AC_HD_TYPE,
        NVL(M.MJR_AC_HD_DESC,B.ACCOUNT_HEAD_DESC) MJR_AC_HD_DESC,
        NVL(B.ACCOUNT_HEAD_ID,0) AC_HD_ID,NVL(FORMATACHD_NAME(NVL(A.AC_HD_ORDER,A.AC_HD_ID),NVL(M.MJR_AC_ORDER,M.MJR_AC_HD_ID)),B.ACCOUNT_HEAD_DESC) AC_HD_DESC,
        NVL(A.AC_HD_ORDER,0) AC_HD_ORDER,NVL(M.MJR_AC_ORDER,0) MJR_AC_ORDER,B.AMOUNT CLOSE_BAL,B.BALANCE_TYPE BALANCE_TYPE
         FROM BALANCESHEET_BALANCEUPDATE B 
        LEFT JOIN AC_HD A ON B.ACCOUNT_HEAD_ID = A.AC_HD_ID
        LEFT JOIN MJR_AC_HD M ON M.MJR_AC_HD_ID=A.MJR_AC_HD_ID
        WHERE B.FINAL_ACCOUNT_TYPE=FIN_ACT_TYPE AND B.TO_DT=AS_ON_DATE AND 
        (CASE WHEN BRANCH_ID IS NULL THEN '1' ELSE BRANCH_ID END)=NVL(B.BRANCH_CODE,'1') 
        AND B.AUTHORIZATION_STATUS='AUTHORIZED' AND B.STATUS NOT IN ('DELETED','REJECTED')  
    )
    SELECT * FROM BAL WHERE CLOSE_BAL<>0 AND ac_hd_id 
    NOT IN (SELECT ac_hd_id FROM BAL_UPD WHERE CLOSE_BAL<>0)
    UNION ALL 
    SELECT * FROM BAL_UPD WHERE CLOSE_BAL<>0;
ELSIF FIN_ACT_TYPE = 'PROFIT AND LOSS' THEN
    OPEN trCursor FOR
    WITH BAL AS
    (
    SELECT   MAX(m.mjr_ac_hd_id) as mjr_ac_hd_id, MAX(m.mjr_ac_hd_type) as mjr_ac_hd_type, MAX(m.mjr_ac_hd_desc) as mjr_ac_hd_desc, 
        MAX(a.ac_hd_id) as ac_hd_id, MAX(FORMATACHD_NAME(NVL(a.ac_hd_order,a.ac_hd_id),NVL(m.mjr_ac_order,m.mjr_ac_hd_id))) ac_hd_desc,
        MAX(a.ac_hd_order) ac_hd_order, MAX(m.mjr_ac_order) mjr_ac_order, 
        ABS(SUM (CASE
                     WHEN g.balance_type = 'DEBIT'
                        THEN -1
                     ELSE 1
                  END * g.close_bal
                 )) close_bal, 
             CASE
                WHEN (SUM (  CASE
                                WHEN g.balance_type = 'DEBIT'
                                   THEN -1
                                ELSE 1
                             END
                           * g.close_bal
                          )
                     ) < 0
                   THEN 'DEBIT'
                ELSE 'CREDIT'
             END balance_type
    FROM ac_hd a JOIN mjr_ac_hd m ON a.mjr_ac_hd_id = m.mjr_ac_hd_id
             JOIN gl_abstract g ON g.ac_hd_id = a.ac_hd_id
    WHERE m.final_account_type = FIN_ACT_TYPE AND g.dt = AS_ON_DATE AND g.branch_code = NVL(BRANCH_ID,G.branch_code)
    GROUP BY a.ac_hd_id
    ),
    BAL_UPD AS
    (
    SELECT NVL(M.MJR_AC_HD_ID,0) MJR_AC_HD_ID,
    NVL(M.MJR_AC_HD_TYPE,DECODE(FIN_ACT_TYPE,'BALANCE SHEET',DECODE(B.BALANCE_TYPE,'CREDIT','LIABILITY','ASSETS'),DECODE(B.BALANCE_TYPE,'CREDIT','INCOME','EXPENDITURE'))) MJR_AC_HD_TYPE,
    NVL(M.MJR_AC_HD_DESC,B.ACCOUNT_HEAD_DESC) MJR_AC_HD_DESC,
    NVL(B.ACCOUNT_HEAD_ID,0) AC_HD_ID,NVL(FORMATACHD_NAME(NVL(A.AC_HD_ORDER,A.AC_HD_ID),NVL(M.MJR_AC_ORDER,M.MJR_AC_HD_ID)),B.ACCOUNT_HEAD_DESC) AC_HD_DESC,
    NVL(A.AC_HD_ORDER,0) AC_HD_ORDER,NVL(M.MJR_AC_ORDER,0) MJR_AC_ORDER,B.AMOUNT CLOSE_BAL,B.BALANCE_TYPE BALANCE_TYPE
     FROM BALANCESHEET_BALANCEUPDATE B 
    LEFT JOIN AC_HD A ON B.ACCOUNT_HEAD_ID = A.AC_HD_ID
    LEFT JOIN MJR_AC_HD M ON M.MJR_AC_HD_ID=A.MJR_AC_HD_ID
    WHERE B.FINAL_ACCOUNT_TYPE=FIN_ACT_TYPE AND B.TO_DT=AS_ON_DATE AND 
    (CASE WHEN BRANCH_ID IS NULL THEN '1' ELSE BRANCH_ID END)=NVL(B.BRANCH_CODE,'1') AND 
    B.AUTHORIZATION_STATUS='AUTHORIZED'  AND 
    B.STATUS NOT IN ('DELETED','REJECTED')
    ),
    TRADING AS
    (
    SELECT '0' AS MJR_AC_HD_ID,DECODE(BB.BALANCE_TYPE,'CREDIT','INCOME','EXPENDITURE') MJR_AC_HD_TYPE,
    BB.ACCOUNT_HEAD_DESC MJR_AC_HD_DESC,'0' AS AC_HD_ID,BB.ACCOUNT_HEAD_DESC AC_HD_DESC,
    0 AS AC_HD_ORDER,0 AS MJR_AC_ORDER,BB.AMOUNT CLOSE_BAL,BB.BALANCE_TYPE BALANCE_TYPE 
    FROM BALANCESHEET_BALANCEFINAL BB WHERE BB.FINAL_ACCOUNT_TYPE='TRADING' AND BB.ACCOUNT_HEAD_DESC IN  ('GROSS LOSS','GROSS PROFIT') 
    AND (CASE WHEN BRANCH_ID IS NULL THEN '1' ELSE BRANCH_ID END)=NVL(BB.BRANCH_CODE,'1') 
    AND BB.AUTHORIZATION_STATUS='AUTHORIZED' AND BB.TO_DT=AS_ON_DATE  AND BB.STATUS NOT IN ('DELETED','REJECTED')
    )
    SELECT * FROM BAL WHERE CLOSE_BAL<>0 AND ac_hd_id 
    NOT IN (SELECT ac_hd_id FROM BAL_UPD WHERE CLOSE_BAL<>0) AND ac_hd_id 
    NOT IN (SELECT ac_hd_id FROM TRADING WHERE CLOSE_BAL<>0)
    UNION ALL 
    SELECT * FROM BAL_UPD WHERE CLOSE_BAL<>0
    UNION ALL
    SELECT * FROM TRADING WHERE CLOSE_BAL<>0;
ELSE 
    OPEN trCursor FOR
    WITH BAL AS
    (
    SELECT   MAX(m.mjr_ac_hd_id) as mjr_ac_hd_id, MAX(m.mjr_ac_hd_type) as mjr_ac_hd_type, MAX(m.mjr_ac_hd_desc) as mjr_ac_hd_desc, 
        MAX(a.ac_hd_id) as ac_hd_id, MAX(FORMATACHD_NAME(NVL(a.ac_hd_order,a.ac_hd_id),NVL(m.mjr_ac_order,m.mjr_ac_hd_id))) ac_hd_desc,
        MAX(a.ac_hd_order) ac_hd_order, MAX(m.mjr_ac_order) mjr_ac_order, 
        ABS(SUM (CASE
                     WHEN g.balance_type = 'DEBIT'
                        THEN -1
                     ELSE 1
                  END * g.close_bal
                 )) close_bal, 
             CASE
                WHEN (SUM (  CASE
                                WHEN g.balance_type = 'DEBIT'
                                   THEN -1
                                ELSE 1
                             END
                           * g.close_bal
                          )
                     ) < 0
                   THEN 'DEBIT'
                ELSE 'CREDIT'
             END balance_type
    FROM ac_hd a JOIN mjr_ac_hd m ON a.mjr_ac_hd_id = m.mjr_ac_hd_id
             JOIN gl_abstract g ON g.ac_hd_id = a.ac_hd_id
    WHERE m.final_account_type = FIN_ACT_TYPE AND g.dt = AS_ON_DATE AND g.branch_code = NVL(BRANCH_ID,G.branch_code)
    GROUP BY a.ac_hd_id
    ),
    BAL_UPD AS
    (
    SELECT NVL(M.MJR_AC_HD_ID,0) MJR_AC_HD_ID,
    NVL(M.MJR_AC_HD_TYPE,DECODE(FIN_ACT_TYPE,'BALANCE SHEET',DECODE(B.BALANCE_TYPE,'CREDIT','LIABILITY','ASSETS'),DECODE(B.BALANCE_TYPE,'CREDIT','INCOME','EXPENDITURE'))) MJR_AC_HD_TYPE,
    NVL(M.MJR_AC_HD_DESC,B.ACCOUNT_HEAD_DESC) MJR_AC_HD_DESC,
    NVL(B.ACCOUNT_HEAD_ID,0) AC_HD_ID,NVL(FORMATACHD_NAME(NVL(A.AC_HD_ORDER,A.AC_HD_ID),NVL(M.MJR_AC_ORDER,M.MJR_AC_HD_ID)),B.ACCOUNT_HEAD_DESC) AC_HD_DESC,
    NVL(A.AC_HD_ORDER,0) AC_HD_ORDER,NVL(M.MJR_AC_ORDER,0) MJR_AC_ORDER,B.AMOUNT CLOSE_BAL,B.BALANCE_TYPE BALANCE_TYPE
     FROM BALANCESHEET_BALANCEUPDATE B 
    LEFT JOIN AC_HD A ON B.ACCOUNT_HEAD_ID = A.AC_HD_ID
    LEFT JOIN MJR_AC_HD M ON M.MJR_AC_HD_ID=A.MJR_AC_HD_ID
    WHERE B.FINAL_ACCOUNT_TYPE=FIN_ACT_TYPE AND B.TO_DT=AS_ON_DATE AND 
    (CASE WHEN BRANCH_ID IS NULL THEN '1' ELSE BRANCH_ID END)=NVL(B.BRANCH_CODE,'1') AND 
    B.AUTHORIZATION_STATUS='AUTHORIZED'  AND B.STATUS NOT IN ('DELETED','REJECTED')
    ),
    STOCK AS
    (
    SELECT MAH.MJR_AC_HD_ID AS MJR_AC_HD_ID,'ASSETS' MJR_AC_HD_TYPE,
    MAH.MJR_AC_HD_DESC MJR_AC_HD_DESC,AH.AC_HD_ID AS AC_HD_ID,AH.AC_HD_DESC AC_HD_DESC,
    1 AS AC_HD_ORDER,1 AS MJR_AC_ORDER,BB.AMOUNT CLOSE_BAL,'DEBIT' BALANCE_TYPE FROM MJR_AC_HD MAH
    JOIN AC_HD AH ON AH.MJR_AC_HD_ID=MAH.MJR_AC_HD_ID
    JOIN BALANCESHEET_BALANCEFINAL BB ON BB.ACCOUNT_HEAD_ID = AH.AC_HD_ID
    WHERE (CASE WHEN BRANCH_ID IS NULL THEN '1' ELSE BRANCH_ID END)=NVL(BB.BRANCH_CODE,'1') AND 
    MAH.SUB_ACCOUNT_TYPE='CLOSING STOCK' AND BB.TO_DT=AS_ON_DATE AND BB.AUTHORIZATION_STATUS='AUTHORIZED' 
    AND BB.STATUS NOT IN ('DELETED','REJECTED')),
    PANDL AS 
    (
    SELECT '0' AS MJR_AC_HD_ID,DECODE(BB.BALANCE_TYPE,'CREDIT','ASSETS','LIABILITY') MJR_AC_HD_TYPE,
    BB.ACCOUNT_HEAD_DESC MJR_AC_HD_DESC,'0' AS AC_HD_ID,BB.ACCOUNT_HEAD_DESC AC_HD_DESC,
    0 AS AC_HD_ORDER,0 AS MJR_AC_ORDER,BB.AMOUNT CLOSE_BAL,DECODE(BB.ACCOUNT_HEAD_DESC,'NET PROFIT','CREDIT','DEBIT') BALANCE_TYPE 
    FROM BALANCESHEET_BALANCEFINAL BB WHERE BB.FINAL_ACCOUNT_TYPE='PROFIT AND LOSS' AND BB.ACCOUNT_HEAD_DESC IN  ('NET LOSS','NET PROFIT') 
    AND (CASE WHEN BRANCH_ID IS NULL THEN '1' ELSE BRANCH_ID END)=NVL(BB.BRANCH_CODE,'1') AND 
    BB.AUTHORIZATION_STATUS='AUTHORIZED' AND BB.TO_DT=AS_ON_DATE  AND BB.STATUS NOT IN ('DELETED','REJECTED')
    )
    SELECT * FROM BAL WHERE CLOSE_BAL<>0 AND ac_hd_id 
    NOT IN (SELECT ac_hd_id FROM BAL_UPD WHERE CLOSE_BAL<>0) AND ac_hd_id 
    NOT IN (SELECT ac_hd_id FROM STOCK WHERE CLOSE_BAL<>0)
    UNION ALL 
    SELECT * FROM BAL_UPD WHERE CLOSE_BAL<>0
    UNION ALL
    SELECT * FROM STOCK WHERE CLOSE_BAL<>0
    UNION ALL
    SELECT * FROM PANDL WHERE CLOSE_BAL<>0;
END IF;
    LOOP
        FETCH trCursor INTO
            outRec.MJR_AC_HD_ID, outRec.MJR_AC_HD_TYPE, outRec.MJR_AC_HD_DESC, outRec.AC_HD_ID, outRec.AC_HD_DESC, outRec.AC_HD_ORDER,
            outRec.MJR_AC_ORDER,outRec.CLOSE_BAL, outRec.BALANCE_TYPE;
        EXIT WHEN trCursor%NOTFOUND;
        PIPE ROW(outRec);        
    END LOOP;
    CLOSE trCursor;
    RETURN;
END;
/

--End Version   [Script Version - 0.0.23] [ReleaseVersion - 9.2.1.25]--[14-05-2014] -- by Babu

--Start Version   [Script Version - 0.0.24] [ReleaseVersion - 9.2.1.25]--[14-05-2014] -- by Anju

ALTER TABLE BORROWING_MASTER ADD (CREATED_BY VARCHAR2(16 BYTE));
ALTER TABLE BORROWING_DISBURSAL ADD (CREATED_BY VARCHAR2(16 BYTE));
--End Version   [Script Version - 0.0.24] [ReleaseVersion - 9.2.1.25]--[05-05-2014] -- by Anju

--Start Version   [Script Version - 0.0.25] [ReleaseVersion - 9.2.1.25]--[17-05-2014] -- by Sathiya
ALTER TABLE OTHER_BANKS_ACT_MASTER ADD BRANCH_ID VARCHAR2(16);

DROP VIEW ALL_PRODUCT_ACCTS1;

CREATE OR REPLACE FORCE VIEW all_product_accts1 (act_num,
                                                               prod_type,
                                                               prod_id,
                                                               rep_act_num,
                                                               branch_id,
                                                               salary_recovery,
                                                               lock_status,
                                                               acct_status
                                                              )
AS
   (SELECT am.act_num AS act_num, 'OA' AS prod_type, prod_id,
           am.act_num || '_1' AS rep_act_num, branch_code AS branch_id,
           'N' AS salary_recovery, 'N' AS lock_status,
           am.act_status_id AS acct_status
      FROM act_master am
     WHERE am.authorization_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT da.deposit_no AS act_num, 'TD' AS prod_type, prod_id,
           da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status
      FROM deposit_acinfo da, deposit_sub_acinfo ds
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.deposit_no = da.deposit_no
    UNION ALL
    SELECT lfd.acct_num AS act_num, 'TL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status
      FROM loans_facility_details lfd
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, 'AD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status
      FROM loans_facility_details lfd
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.status != 'DELETED'
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, 'ATL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status
      FROM agri_loans_facility_details lfd
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, 'AAD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status
      FROM agri_loans_facility_details lfd
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.status != 'DELETED'
       AND EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, 'SA' AS prod_type,
           am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status
      FROM suspense_account_master am
     WHERE am.authorize_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num, 'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.status != 'DELETED'
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
       UNION ALL
       
       SELECT am.ACT_MASTER_ID AS act_num, 'AB' AS prod_type, prod_id,
           am.ACT_MASTER_ID || '_1' AS rep_act_num, branch_ID AS branch_id,
           'N' AS salary_recovery, 'N' AS lock_status,
           am.STATUS AS acct_status
      FROM OTHER_BANKS_ACT_MASTER am
     WHERE am.AUTHORIZED_STATUS = 'AUTHORIZED' AND am.status != 'DELETED');

--End Version   [Script Version - 0.0.25] [ReleaseVersion - 9.2.1.25]--[17-05-2014] -- by Sathiya

--Start Version [Script Version - 0.0.26] [ReleaseVersion - 9.2.1.25]--[17-05-2014] -- by Ajay

ALTER TABLE DEPOSIT_SUB_ACINFO ADD(TEMP_CLEAR_BALANCE NUMBER(16,2),TEMP_AVAILABLE_BALANCE NUMBER(16,2),TEMP_TOTAL_BALANCE NUMBER(16,2));

--ALTER TABLE DEPOSIT_SUB_ACINFO_SAMENO ADD(TEMP_CLEAR_BALANCE NUMBER(16,2),TEMP_AVAILABLE_BALANCE NUMBER(16,2),TEMP_TOTAL_BALANCE NUMBER(16,2));

ALTER TABLE LOANS_FACILITY_DETAILS ADD(TEMP_LAST_INT_CALC_DT DATE);

--End Version [Script Version - 0.0.26] [ReleaseVersion - 9.2.1.25]--[17-05-2014] -- by Ajay

--Start Version [Script Version - 0.0.28] [ReleaseVersion - 9.2.1.25]--[23-05-2014] -- by Ajay

ALTER TABLE DEPOSIT_SUB_ACINFO ADD(TEMP_DELAYED_AMOUNT NUMBER(12),TEMP_DELAYED_MONTH NUMBER(6));

--End Version [Script Version - 0.0.28] [ReleaseVersion - 9.2.1.25]--[23-05-2014] -- by Ajay

--Start Version [Script Version - 0.0.29] [ReleaseVersion - 9.2.1.25]--[24-05-2014] -- by Sathiya
ALTER TABLE TRANS_ALL ADD(STATUS_DT DATE,STATUS_BY VARCHAR(16),TRANS_TYPE VARCHAR(16),CREATED_DT DATE,BRANCH_ID VARCHAR(16),AUTHORIZE_DATE_TIME DATE,DESCRIPTION VARCHAR(124));
ALTER TABLE LOCKER_SURRENDER ADD(PENAL_AMOUNT NUMBER(16,2));
--End Version [Script Version - 0.0.29] [ReleaseVersion - 9.2.1.25]--[24-05-2014] -- by Sathiya

--Start Version [Script Version - 0.0.30] [ReleaseVersion - 9.3.1.25]--[24-05-2014] -- by Babu
CREATE OR REPLACE FUNCTION GET_NO_OF_HOLIDAYS(CUR_DT DATE, BR_ID VARCHAR2) RETURN NUMBER IS
    NO_BRHOLI NUMBER := 0;
    SUM_BRHOLI NUMBER := 0;
    NO_DHOLI NUMBER := 0;
    SUM_DHOLI NUMBER := 0;
    END_DT DATE := CUR_DT;
BEGIN
    SELECT MAX(DAYEND_DT)+1 INTO END_DT FROM DAILY_DAYEND_STATUS_FINAL WHERE DAYEND_DT <= CUR_DT AND 
        BRANCH_ID = BR_ID AND BRANCH_DAY_END_STATUS = 'COMPLETED';
        
    WHILE(END_DT < CUR_DT) LOOP
       SELECT COUNT(*) INTO NO_BRHOLI FROM WEEKLY_OFF W 
            WHERE W.BRANCH_ID = BR_ID AND W.WEEKLY_OFF = 'Y' AND
            W.WEEKLY_OFF1 = TO_CHAR(END_DT,'D');
            
      SELECT COUNT(*) INTO NO_DHOLI FROM HOLIDAY_MASTER WHERE BRANCH_ID = BR_ID AND HOLIDAY_DT = END_DT
        AND STATUS!='DELETED' AND AUTHORIZED_STATUS = 'AUTHORIZED';
      SUM_DHOLI := SUM_DHOLI + NO_DHOLI;  
      SUM_BRHOLI := SUM_BRHOLI + NO_BRHOLI; 
      END_DT := END_DT + 1;
    END LOOP;
    RETURN (SUM_DHOLI + SUM_BRHOLI);
EXCEPTION WHEN OTHERS THEN
  RETURN 0;
END;
/
--End Version [Script Version - 0.0.30] [ReleaseVersion - 9.3.1.25]--[24-05-2014] -- by Babu

--Strart Version [Script Version - 0.0.31] [ReleaseVersion - 9.2.1.25]--[24-05-2014] -- by Sathiya
DROP VIEW ALL_CUSTOMER_BALANCE;

CREATE OR REPLACE FORCE VIEW all_customer_balance (act_num,
                                                                 cust_id,
                                                                 customer_name,
                                                                 available_balance,
                                                                 branch_code
                                                                )
AS
   (SELECT act_num, cust_id, acct_name AS customer_name,
           NVL (available_balance, 0) AS available_balance, branch_code
      FROM act_master
     WHERE act_status_id != 'CLOSED'
       AND status != 'DELETED'
       AND authorization_status = 'AUTHORIZED'
    UNION ALL
    SELECT suspense_acct_num AS act_num, suspense_customer_id AS cust_id,
           suspense_name AS customer_name,
           NVL (clear_balance, 0) AS available_balance, branch_code
      FROM suspense_account_master
     WHERE status != 'DELETED' AND authorize_status = 'AUTHORIZED'
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           NVL (available_balance, 0) AS available_balance,
           branch_id AS branch_code
      FROM loans_borrower lb, customer cu, loans_facility_details lfd
     WHERE lb.cust_id = cu.cust_id
       AND lb.borrow_no = lfd.borrow_no
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.prod_id IN (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like = 'OD'
                 AND status != 'DELETED'
                 AND authorize_status = 'AUTHORIZED')
    UNION ALL
    SELECT b.ac_hd_id AS act_num, '' AS cust_id,
           b.ac_hd_desc AS customer_name,
           NVL (cur_bal, 0) AS available_balance, branch_code
      FROM gl a, ac_hd b
     WHERE a.authorize_status = 'AUTHORIZED' AND a.ac_hd_id = b.ac_hd_id
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id,
           agency_name AS customer_name, available_balance, branch_id
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

--End Version [Script Version - 0.0.31] [ReleaseVersion - 9.2.1.25]--[24-05-2014] -- by Sathiya

--Start Version [Script Version - 0.0.32] [ReleaseVersion - 9.2.1.25]--[30-05-2014] -- by Sreekrishnan

ALTER TABLE LOANS_PRODUCT ADD(TOT_KCC_LIMIT NUMBER(16,2),KCC_NATURE VARCHAR(16));

CREATE OR REPLACE FUNCTION get_kcc_penal_int(ACTNUM VARCHAR,LOANDATE DATE,ASONDT DATE)
RETURN NUMBER IS
--DECLARE
--ACTNUM VARCHAR2(16) := '0001276000160';
--ASONDT DATE := '01-MAR-2014' ;
    PENINTRECEIVABLE NUMBER(16,2) := 0;
    PENINTRECEIVED NUMBER(16,2) := 0;
    BALANCE NUMBER(16,2) := 0;
    PENROI NUMBER(8,2) := 0;
    DUEDATE DATE;
    LASTINTDATE DATE;
    PENRECFRM DATE;
    STARTDATE DATE;
    TRNDATE DATE;
    PRNBAL NUMBER(16,2) := 0;
    CATG VARCHAR2(25);
    PRIN_CREDIT NUMBER(16,2):= 0;
    DATE_DIFF number(16);
BEGIN
    BALANCE := GET_ADV_BALANCE(ACTNUM,ASONDT);
    IF BALANCE <= 0 THEN
         PENINTRECEIVABLE := 0;
    END IF; 
    SELECT 
          CASE WHEN
                    (
                        SELECT P.CALENDAR_FREQ
                        FROM LOANS_FACILITY_DETAILS F
                        JOIN LOANS_PROD_INTREC P ON P.PROD_ID = F.PROD_ID
                        WHERE F.ACCT_NUM = ACTNUM
                    ) = 'Y' 
                THEN
                    (     
                        SELECT P.LAST_DR_INT_APPLDT 
                        FROM ADVANCES_PARAM_DETAILS P
                        WHERE P.ACT_NUM = ACTNUM AND P.STATUS != 'DELETED'
                    )
                ELSE
                    F.LAST_INT_CALC_DT
          END,
          SD.TO_DT,GET_TL_PENROI(F.PROD_ID,F.ACCT_NUM,SD.FROM_DT,SD.LIMIT,F.INT_GET_FROM),
          CASE WHEN
                    (
                        SELECT P.CALENDAR_FREQ
                        FROM LOANS_FACILITY_DETAILS F
                        JOIN LOANS_PROD_INTREC P ON P.PROD_ID = F.PROD_ID
                        WHERE F.ACCT_NUM = ACTNUM
                    ) = 'Y' 
                THEN
                    (     
                        SELECT P.LAST_DR_INT_APPLDT 
                        FROM ADVANCES_PARAM_DETAILS P
                        WHERE P.ACT_NUM = ACTNUM AND P.STATUS != 'DELETED'
                    )
                ELSE
                    F.LAST_INT_CALC_DT + 1
          END INTO LASTINTDATE,DUEDATE,PENROI,PENRECFRM
    FROM LOANS_SANCTION_DETAILS SD
    JOIN LOANS_FACILITY_DETAILS F ON SD.BORROW_NO = F.BORROW_NO
    WHERE F.ACCT_NUM = ACTNUM;
    DECLARE 
      CURSOR LOANTRANS IS 
        SELECT T.TRANS_DT,T.PRINCIPLE,T.TRN_CODE,(CASE WHEN LSD.TO_DT < ADD_MONTHS(T.TRANS_DT,12) THEN LSD.TO_DT ELSE ADD_MONTHS(T.TRANS_DT,12) END) AS DUEDATE
        FROM ADV_TRANS_DETAILS T
        JOIN LOANS_FACILITY_DETAILS LFD ON LFD.ACCT_NUM = T.ACT_NUM
        JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
        WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.PRINCIPLE > 0 AND T.TRN_CODE = 'DP'
--        UNION
--        SELECT TO_DATE(ASONDT,'DD-MM-YYYY') AS TRANS_DT,0 AS PRINCIPLE,'DP' AS TRN_CODE,NULL AS DUEDATE
--        FROM DUAL
        ORDER BY TRANS_DT ASC;
        TRANSDT ADV_TRANS_DETAILS.TRANS_DT%TYPE;
        I NUMBER(16,2) := 0;
        PRN_CREDIT NUMBER(16,2);
    BEGIN
        FOR TRN IN LOANTRANS LOOP
            SELECT NVL(SUM(NVL(T.PRINCIPLE,0)),0) INTO PRN_CREDIT FROM ADV_TRANS_DETAILS T 
            WHERE  T.ACT_NUM = ACTNUM AND T.TRN_CODE = 'C*' AND T.TRANS_DT <= TRN.DUEDATE;
            BALANCE := TRN.PRINCIPLE - PRN_CREDIT;
            IF BALANCE  > 0 THEN
                PENINTRECEIVABLE  := PENINTRECEIVABLE  +  (BALANCE * (ASONDT - (TRN.DUEDATE + 1)  ) * PENROI/ 36500);
--                DBMS_OUTPUT.PUT_LINE(PENINTRECEIVABLE||' ' ||BALANCE|| ' '||TRN.DUEDATE||' '||ASONDT||' ' ||DATE_DIFF );
            ELSE
                PENINTRECEIVABLE := 0;
            END IF;
        END LOOP;
    END;
    SELECT NVL(SUM(T.PENAL),0) INTO PENINTRECEIVED
    FROM ADV_TRANS_DETAILS T
    WHERE T.ACT_NUM = ACTNUM AND
          T.TRANS_DT > PENRECFRM AND T.TRANS_DT <= ASONDT AND
          T.TRANS_TYPE = 'CREDIT';
    PENINTRECEIVABLE := PENINTRECEIVABLE - PENINTRECEIVED;
    PENINTRECEIVABLE := ROUND(PENINTRECEIVABLE,0); 
    IF PENINTRECEIVABLE < 0 THEN
        PENINTRECEIVABLE := 0;
    END IF;
   RETURN  PENINTRECEIVABLE;
END;
/


--End Version [Script Version - 0.0.32] [ReleaseVersion - 9.2.1.25]--[30-05-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.33] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Chithra
ALTER TABLE DEPOSITS_PROD_RENEWAL ADD (SBRATE_PRODID VARCHAR2(30 BYTE));
--End Version [Script Version - 0.0.33] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Chithra

--Start Version [Script Version - 0.0.34] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Nidhin
ALTER TABLE LOAN_CHARGE_DEFINITION ADD (IS_DEPOSIT_OR_LOAN VARCHAR2(1 BYTE));

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06123', '6122', 'Deposit Charge Definition', 'APP01', 'DONE', 
    '3', NULL, 5, 'CREATED', NULL, 
    NULL, NULL);
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00007', 'SCR06123', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', NULL, 'Y', 'Y');
COMMIT;
--End Version [Script Version - 0.0.34] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Nidhin

--Start Version [Script Version - 0.0.35] [ReleaseVersion - 9.2.1.25]--[30-05-2014] -- by Sreekrishnan
--There is bank specific scripts also in perigandoor bank folder,
--Please take that script only incase of peringandoor bank.
UPDATE PARAMETERS SET CASHIER_AUTH_ALLOWED = 'N';
--End Version [Script Version - 0.0.35] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.36] [ReleaseVersion - 9.2.1.25]--[4-06-2014] -- by Sreekrishnan
DROP TABLE KCC_RENEWAL_DETAILS CASCADE CONSTRAINTS;

CREATE TABLE KCC_RENEWAL_DETAILS
(
  ACT_NUM    VARCHAR2(16 BYTE),
  FROM_DT    DATE,
  TO_DT      DATE,
  STATUS     VARCHAR2(16 BYTE),
  BRANCH     VARCHAR2(16 BYTE),
  STATUS_DT  DATE
)

ALTER TABLE MDS_ACCT_HEAD ADD  MISCELLANEOUS_CHARGES VARCHAR(16)

ALTER TABLE MDS_ACCT_HEAD ADD  OTHER_CHARGES VARCHAR(16)

ALTER TABLE MDS_ACCT_HEAD ADD  LEGAL_CHARGES VARCHAR(16)

ALTER TABLE MDS_ACCT_HEAD ADD  INSURANCE_CHARGES VARCHAR(16)

update LOOKUP_MASTER set LOOKUP_REF_ID = 'MISCELLANEOUS CHARGES' where  LOOKUP_REF_ID = 'MISCELLANEOUS_CHARGES' and LOOKUP_ID = 'TERMLOAN.CHARGE_TYPE'

update LOOKUP_MASTER set LOOKUP_REF_ID = 'OTHER CHARGES' where  LOOKUP_REF_ID = 'OTHER_CHARGES' and LOOKUP_ID = 'TERMLOAN.CHARGE_TYPE'

update LOOKUP_MASTER set LOOKUP_REF_ID = 'LEGAL CHARGES' where  LOOKUP_REF_ID = 'LEGAL_CHARGES' and LOOKUP_ID = 'TERMLOAN.CHARGE_TYPE'

update LOOKUP_MASTER set LOOKUP_REF_ID = 'INSURANCE CHARGES' where  LOOKUP_REF_ID = 'INSURANCE_CHARGES' and LOOKUP_ID = 'TERMLOAN.CHARGE_TYPE'

--End Version [Script Version - 0.0.36] [ReleaseVersion - 9.2.1.25]--[4-06-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.37] [ReleaseVersion - 9.2.1.25]--[4-06-2014] -- by Chithra
 ALTER TABLE DEPOSITS_PROD_RENEWAL ADD (CLOSURE_INT_YN VARCHAR2(20 BYTE));
--End Version [Script Version - 0.0.37] [ReleaseVersion - 9.2.1.25]--[4-06-2014] -- by Chithra

--Start Version [Script Version - 0.0.38] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Anju

ALTER TABLE MDS_RECEIPT_ENTRY ADD (SINGLE_TRANS_ID VARCHAR2(20 BYTE));

--End Version [Script Version - 0.0.38] [ReleaseVersion - 9.2.1.25]--[02-06-2014] -- by Anju

--Start Version [Script Version - 0.0.39] [ReleaseVersion - 9.2.1.25]--[09-06-2014] -- by Jeffin John

UPDATE PARAMETERS SET HEAD_OFFICE = '0001';

UPDATE LOOKUP_MASTER L SET L.LOOKUP_DESC = 'A Class' where L.LOOKUP_ID='SHARE_TYPE' AND L.LOOKUP_REF_ID  LIKE 'A%';

--End Version [Script Version - 0.0.39] [ReleaseVersion - 9.2.1.25]--[09-06-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.40] [ReleaseVersion - 9.2.1.25]--[09-06-2014] -- by Babu

ALTER TABLE BILLS_PRODUCT ADD (BANK_CHARGE_HEAD VARCHAR(50 BYTE)); 
ALTER TABLE LOAN_ARBITRATION ADD (MISC_CHARGES NUMBER(16,2)); 

--End Version [Script Version - 0.0.40] [ReleaseVersion - 9.2.1.25]--[09-06-2014] -- by Babu

--Start Version [Script Version - 0.0.41] [ReleaseVersion - 9.2.1.25]--[09-06-2014] -- by Nidhin
ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS ADD (WHICHEVER_IS_LESS_PRZ_INS VARCHAR2 (2 Byte)); 
--End Version [Script Version - 0.0.41] [ReleaseVersion - 9.2.1.25]--[09-06-2014] -- by Nidhin

--Start Version [Script Version - 0.0.42] [ReleaseVersion - 9.2.1.25]--[12-06-2014] -- by Babu
DROP VIEW AUTHORIZATION_VIEW;

CREATE OR REPLACE FORCE VIEW authorization_view (table_name,
                                                        column_name,
                                                        err_count,
                                                        branch_column,
                                                        branch_id
                                                       )
AS
   SELECT   'CASH_TRANS' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM cash_trans
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TRANSFER_TRANS' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM transfer_trans
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'INWARD_CLEARING' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM inward_clearing
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'OUTWARD_CLEARING' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM outward_clearing
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'OUTWARD_RETURN' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM outward_return
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CLEARING_PARAM' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM clearing_param
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CUSTOMER' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM customer
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CUST_SECURITY_DETAILS' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_CODE' AS branch_column, branch_code
       FROM cust_security_details
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'ACT_MASTER' AS table_name, 'AUTHORIZATION_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM act_master
      WHERE (authorization_status IS NULL OR authorization_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'LOANS_FACILITY_DETAILS' AS table_name,
            'AUTHORIZE_STATUS_1' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM loans_facility_details
      WHERE (authorize_status_1 IS NULL OR authorize_status_1 = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'LOANS_DRAWING_POWER' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_CODE' AS branch_column, branch_code
       FROM loans_drawing_power
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CASH_MOVEMENT' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM cash_movement
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CHEQUE_ISSUE' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM cheque_issue
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CHEQUE_LOOSE_LEAF' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM cheque_loose_leaf
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CHEQUE_STOP_PAYMENT' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM cheque_stop_payment
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'AGENT_MASTER' AS table_name, 'AUTHORIZED_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM agent_master
      WHERE (authorized_status IS NULL OR authorized_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'DD_STOP_PAYMENT' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM dd_stop_payment
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'DEPOSIT_ACINFO' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM deposit_acinfo
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'INVENTORY_MASTER' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM inventory_master
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'SHARE_ACCT' AS table_name, 'AUTHORIZE' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM share_acct
      WHERE (authorize IS NULL OR authorize = '') AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'STANDING_INSTRUCTION' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_CODE' AS branch_column, branch_code
       FROM standing_instruction
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TDS_EXEMPTION' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM tds_exemption
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TOKEN_CONFIG' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM token_config
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TOKEN_ISSUE' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM token_issue
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TOKEN_LOST' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM token_lost
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'ACT_MASTER' AS table_name, 'AUTHORIZATION_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM act_master
      WHERE (authorization_status IS NULL OR authorization_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT a."TABLE_NAME", a."COLUMN_NAME", a."ERR_COUNT", a."BRANCH_COLUMN",
          b.branch_code
     FROM (SELECT 'INVESTMENT_MASTER' AS table_name,
                  'AUTHORIZED_STATUS' AS column_name, COUNT (*) AS err_count,
                  'BRANCH_CODE' AS branch_column
             FROM investment_master
            WHERE (   (status != 'DELETED' AND authorized_status IS NULL)
                   OR (    status = 'DELETED'
                       AND authorized_status IS NULL
                       AND authorized_dt IS NOT NULL
                      )
                  )
           HAVING COUNT (*) > 0) a,
          (SELECT DISTINCT head_office AS branch_code
                      FROM PARAMETERS) b
   UNION
   SELECT a."TABLE_NAME", a."COLUMN_NAME", a."ERR_COUNT", a."BRANCH_COLUMN",
          b.branch_code
     FROM (SELECT 'BORROWING_MASTER' AS table_name,
                  'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
                  'BRANCH_CODE' AS branch_column
             FROM borrowing_master
            WHERE (   (status != 'DELETED' AND authorize_status IS NULL)
                   OR (    status = 'DELETED'
                       AND authorize_status IS NULL
                       AND authorized_dt IS NOT NULL
                      )
                  )
           HAVING COUNT (*) > 0) a,
          (SELECT DISTINCT head_office AS branch_code
                      FROM PARAMETERS) b
                      Union
                     SELECT a."TABLE_NAME", a."COLUMN_NAME", a."ERR_COUNT", a."BRANCH_COLUMN",
                              b.branch_id
                     from (select 'MDS_PRIZED_MONEY_DETAILS' as Table_name,
                           'AUTHORIZED_STATUS' as column_name,count(*) as err_count,
                           'BRANCH_ID' AS branch_column
                           from MDS_PRIZED_MONEY_DETAILS
                           where (   (status != 'DELETED' AND AUTHORIZED_STATUS IS NULL)
                                       OR (    status = 'DELETED'
                                           AND AUTHORIZED_STATUS IS NULL
                                           AND authorized_dt IS NOT NULL
                                          )
                                      )
                               HAVING COUNT (*) > 0) a,
                              (SELECT DISTINCT head_office AS branch_id
                                          FROM PARAMETERS) b
                                          

ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD BRANCH_ID VARCHAR2(16);

UPDATE MDS_PRIZED_MONEY_DETAILS SET BRANCH_ID = SUBSTR(CHITTAL_NO,1,4);      

--End Version [Script Version - 0.0.42] [ReleaseVersion - 9.2.1.25]--[12-06-2014] -- by Babu

--Start Version [Script Version - 0.0.43] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Sathiya

ALTER TABLE TRANS_REF_GL ADD IBR_HIERARCHY VARCHAR2(3);

ALTER TABLE CASH_TRANS ADD IBR_HIERARCHY VARCHAR2(3);

--End Version [Script Version - 0.0.43] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Sathiya

--Start Version [Script Version - 0.0.44] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Sathiya

ALTER TABLE DEPOSIT_ACINFO ADD ROLLED_BACK_STATUS VARCHAR2(32);

ALTER TABLE ACT_MASTER ADD ROLLED_BACK_STATUS VARCHAR2(32);

ALTER TABLE LOANS_FACILITY_DETAILS ADD ROLLED_BACK_STATUS VARCHAR2(32);

--End Version [Script Version - 0.0.44] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Sathiya

--Start Version [Script Version - 0.0.45] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Sathiya
CREATE OR REPLACE FUNCTION GET_SUS_INTEREST(ACTNUM VARCHAR,ASONDT DATE)
RETURN NUMBER IS 
   StartDate            Date;
   Int_Days             Number(16,2);
   Inst_Pend_Amt        Number(16,2);
   Interest             Number(16,2) :=0;
   ROI                  Number(16,2) := 0;
   Grace_Period         Number(16,2);
BEGIN
SELECT S.INTEREST_RATE INTO ROI FROM SHOP_MASTER_TABLE S;
SELECT S.GRACE_PERIOD_DAYS INTO Grace_Period FROM SHOP_MASTER_TABLE S;
DECLARE CURSOR curPenal IS  
    SELECT TO_DATE('01/' || EXTRACT (MONTH FROM installment_date) || '/' || EXTRACT (YEAR FROM installment_date),'DD-MM-YYYY') AS installment_date,
   NVL (NVL (SUM (installment_amount), 0) - NVL (SUM (paid_amount), 0),0) AS installment_amount
   FROM suspense_installment
   WHERE acct_num = ACTNUM AND installment_date < ASONDT
HAVING NVL (NVL (SUM (installment_amount), 0) - NVL (SUM (paid_amount), 0),0) > 0
GROUP BY EXTRACT (MONTH FROM installment_date),EXTRACT (YEAR FROM installment_date)
ORDER BY TO_DATE(installment_date,'DD-MM-YYYY');   
         BEGIN
            FOR Penal IN curPenal
            LOOP
            Inst_Pend_Amt := Penal.installment_amount;
            StartDate := Penal.installment_date;
            Int_Days := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(StartDate,'DD-MM-YYYY')) + 1;
            Interest := Interest +  (Inst_Pend_Amt * Int_Days * ROI / 36500);
            END LOOP;
         END;
Interest := ROUND(Interest);
RETURN Interest;
END;
--End Version [Script Version - 0.0.45] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Sathiya

--Start Version [Script Version - 0.0.46] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Anju

ALTER TABLE BORROWING_REP_INT_CLS ADD (CREATED_BY VARCHAR2(16 BYTE));

--End Version [Script Version - 0.0.46] [ReleaseVersion - 9.2.1.25]--[15-06-2014] -- by Anju

--Start Version [Script Version - 0.0.47] [ReleaseVersion - 9.2.1.25]--[19-06-2014] -- by Jeffin John

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
    RECORD_KEY_COL, SCREEN_DESC)
 VALUES
   ('SCR06124', '6124', 'Multiple Deposit Accounts', 'APP01', 'DONE',
    '6', 'com.see.truetransact.deposit,miltipledeposit.MultipleTermDepositUI', 3, 'CREATED', NULL,
    NULL, NULL);
   COMMIT;
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP01014', 'SCR06124', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00001', 'SCR06124', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00002', 'SCR06124', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00003', 'SCR06124', 'CREATED', 'Y', 'Y',
    'Y', 'Y' , 'Y', 'Y', NULL);

--End Version [Script Version - 0.0.47] [ReleaseVersion - 9.2.1.25]--[19-06-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.48] [ReleaseVersion - 9.2.1.25]--[26-06-2014] -- by Anju
ALTER TABLE EMP_SERVICEWISE_LOAN_ELG ADD(SERVICE_PERIOD_REQUIRED VARCHAR2(15),NO_OF_SURETIES_INCLUDING_LOAN VARCHAR2(100));
ALTER TABLE PURCHASE_ENTRY ADD PURCHASE_TYPE VARCHAR2(16);
--End Version [Script Version - 0.0.48] [ReleaseVersion - 9.2.1.25]--[26-06-2014] -- by Anju


--Start Version [Script Version - 0.0.49] [ReleaseVersion - 9.2.1.25]--[28-06-2014] -- by Chithra

CREATE OR REPLACE FUNCTION GET_RD_INSTALL (ACTNUM VARCHAR,ASONDATE DATE,BRANCHCODE VARCHAR ) RETURN
NUMBER IS
PENDING_INSTALL NUMBER(10);
BEGIN
SELECT FLOOR (MONTHS_BETWEEN (TO_DATE (ASONDATE) - 1,
                              r.due_date + get_no_of_holidays (ASONDATE, BRANCHCODE)
                             )
             ) AS pending INTO PENDING_INSTALL
  FROM deposit_recurring r JOIN deposit_sub_acinfo d
       ON r.deposit_no_sub = d.deposit_no || '_' || d.deposit_sub_no
     AND d.total_install_paid = r.sl_no
 WHERE d.deposit_no = ACTNUM ;
  IF  PENDING_INSTALL > 0 THEN 
   PENDING_INSTALL := PENDING_INSTALL ;
 ELSE
   PENDING_INSTALL := 0;
  END IF;
 
 RETURN PENDING_INSTALL ;
END;

--End Version [Script Version - 0.0.49] [ReleaseVersion - 9.2.1.25]--[28-06-2014] -- by Chithra

--Start Version [Script Version - 0.0.50] [ReleaseVersion - 9.2.1.25]--[28-06-2014] -- by Jeffin John

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','TitleDeed','Title Deed','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Prior Title Deed','Prior Title Deed','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Tax Receipt','Tax Receipt','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Possession Certificate','Possession Certificate','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Location Sketch','Location Sketch','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Encumbrance certificate','Encumbrance certificate','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Plan & Estimate','Plan & Estimate','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','NOC from Panchayath/Municipality','NOC from Panchayath/Municipality','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Contract Agreement','Contract Agreement','CREATED','Y');

INSERT INTO LOOKUP_MASTER L(L.LOOKUP_ID,L.LOOKUP_REF_ID,L.LOOKUP_DESC,L.STATUS,L.AUTHORIZED) VALUES ('GAHAN.DOCUMENTS_SUBMITTED','Legal Advice','Legal Advice','CREATED','Y');

ALTER TABLE GAHAN_CUSTOMER_DETAILS ADD (DOCUMENTS_SUBMITTED VARCHAR2(500)); 

ALTER TABLE TRANS_ALL ADD (PARTICULARS VARCHAR2(30));

ALTER TABLE SHARE_ACCT ADD (INITIATED_BRANCH VARCHAR2(16));  

--End Version [Script Version - 0.0.50] [ReleaseVersion - 9.2.1.25]--[28-06-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.51] [ReleaseVersion - 9.2.1.25]--[28-06-2014] -- by Nidhin
ALTER TABLE LOANS_PROD_ACPARAM ADD (IS_ADDED_PRINCIPAL_FIRST VARCHAR2 (2 Byte));
--End Version [Script Version - 0.0.51] [ReleaseVersion - 9.2.1.25]--[28-06-2014] -- by Nidhin

--Start Version [Script Version - 0.0.52] [ReleaseVersion - 9.2.1.25]--[04-07-2014] -- by Sathiya
DROP VIEW ALL_TRANSACTIONS_VIEW;

CREATE OR REPLACE FORCE VIEW all_transactions_view (trans_id,
                                                                    batch_id,
                                                                    ac_hd_id,
                                                                    act_num,
                                                                    amount,
                                                                    trans_dt,
                                                                    trans_type,
                                                                    inst_type,
                                                                    inst_dt,
                                                                    particulars,
                                                                    status,
                                                                    instrument_no1,
                                                                    instrument_no2,
                                                                    prod_id,
                                                                    prod_type,
                                                                    authorize_status,
                                                                    authorize_by,
                                                                    status_by,
                                                                    status_dt,
                                                                    trans_mode,
                                                                    branch_id,
                                                                    initiated_branch,
                                                                    authorize_status_2,
                                                                    single_trans_id,LINK_BATCH_ID
                                                                   )
AS
   SELECT trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt, trans_type,
          inst_type, inst_dt, particulars, status, instrument_no1,
          instrument_no2, prod_id, prod_type, authorize_status, authorize_by,
          status_by, status_dt, trans_mode, branch_id, initiated_branch,
          authorize_status_2, single_trans_id,LINK_BATCH_ID
     FROM (SELECT   trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt,
                    trans_type, inst_type, inst_dt, particulars, status,
                    instrument_no1, instrument_no2, prod_id, prod_type,
                    authorize_status, authorize_by, status_by, status_dt,
                    trans_mode, branch_id, initiated_branch,
                    authorize_status_2, single_trans_id,LINK_BATCH_ID
               FROM all_trans
           ORDER BY status_dt);
--End Version [Script Version - 0.0.52] [ReleaseVersion - 9.2.1.25]--[04-07-2014] -- by Sathiya

--Start Version [Script Version - 0.0.53] [ReleaseVersion - 9.2.1.25]--[09-07-2014] -- by Jeffin John

ALTER TABLE LOANS_PROD_ACPARAM ADD DISB_AFTR_MORA_PERD VARCHAR2(16 BYTE) DEFAULT 'N';

--End Version [Script Version - 0.0.53] [ReleaseVersion - 9.2.1.25]--[09-07-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.54] [ReleaseVersion - 9.2.1.25]--[09-07-2014] -- by Babu
ALTER TABLE LOANS_PROD_ACPARAM ADD MAX_OD_EXLCUDED_RPT NUMBER(16,2) DEFAULT(0);

CREATE OR REPLACE FUNCTION GET_ADV_PEN_INT_APPLICATION(ACTNUM VARCHAR,ASONDT DATE)
RETURN NUMBER IS
    PENINTRECEIVABLE NUMBER(16,2) := 0;
    PENINTRECEIVED NUMBER(16,2) := 0;
    BALANCE NUMBER(16,2) := 0;
    PENROI NUMBER(8,2) := 0;
    DUEDATE DATE;
    LASTINTDATE DATE;
    PENRECFRM DATE;
    STARTDATE DATE;
    TRNDATE DATE;
    PRNBAL NUMBER(16,2) := 0;
BEGIN
    BALANCE := GET_ADV_BALANCE(ACTNUM,ASONDT);
    IF BALANCE <= 0 THEN
        RETURN PENINTRECEIVABLE;
    END IF;
    SELECT 
          CASE WHEN
                    (
                        SELECT P.CALENDAR_FREQ
                        FROM LOANS_FACILITY_DETAILS F
                        JOIN LOANS_PROD_INTREC P ON P.PROD_ID = F.PROD_ID
                        WHERE F.ACCT_NUM = ACTNUM
                    ) = 'Y' 
                THEN
                    (     
                        SELECT P.LAST_DR_INT_APPLDT 
                        FROM ADVANCES_PARAM_DETAILS P
                        WHERE P.ACT_NUM = ACTNUM AND P.STATUS != 'DELETED'
                    )
                ELSE
                    F.LAST_INT_CALC_DT
          END,
          SD.TO_DT,GET_TL_PENROI(F.PROD_ID,F.ACCT_NUM,SD.FROM_DT,SD.LIMIT,F.INT_GET_FROM),
          CASE WHEN
                    (
                        SELECT P.CALENDAR_FREQ
                        FROM LOANS_FACILITY_DETAILS F
                        JOIN LOANS_PROD_INTREC P ON P.PROD_ID = F.PROD_ID
                        WHERE F.ACCT_NUM = ACTNUM
                    ) = 'Y' 
                THEN
                    (     
                        SELECT P.LAST_DR_INT_APPLDT 
                        FROM ADVANCES_PARAM_DETAILS P
                        WHERE P.ACT_NUM = ACTNUM AND P.STATUS != 'DELETED'
                    )
                ELSE
                    F.LAST_INT_CALC_DT + 1
          END INTO LASTINTDATE,DUEDATE,PENROI,PENRECFRM
    FROM LOANS_SANCTION_DETAILS SD
    JOIN LOANS_FACILITY_DETAILS F ON SD.BORROW_NO = F.BORROW_NO
    WHERE F.ACCT_NUM = ACTNUM;
    IF DUEDATE >= ASONDT THEN
        PENINTRECEIVABLE:=0;
    END IF;
    IF LASTINTDATE <= ASONDT AND LASTINTDATE > DUEDATE THEN
        STARTDATE := LASTINTDATE;
    ELSE
        STARTDATE := DUEDATE;
    END IF;
    --PUT_LINE(' STARTDATE ' || STARTDATE );
    DECLARE 
      CURSOR LOANTRANS IS 
        SELECT T.TRANS_DT,T.PRINCIPLE,T.TRN_CODE
        FROM ADV_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.TRANS_DT >= STARTDATE AND T.PRINCIPLE > 0 
        UNION
        SELECT ASONDT AS TRANS_DT,0 AS PRINCIPLE,'DP' AS TRN_CODE
        FROM DUAL
        ORDER BY TRANS_DT ASC;
        TRANSDT ADV_TRANS_DETAILS.TRANS_DT%TYPE;
        I NUMBER(16,2) := 0;
    BEGIN
        FOR TRN IN LOANTRANS LOOP
            PRNBAL:=0;
            SELECT NVL(SUM(CASE WHEN T.TRN_CODE = 'DP' THEN 1 ELSE -1 END * T.PRINCIPLE),0) +
                NVL(SUM(CASE WHEN T.TRN_CODE ='DI' THEN (NVL(T.INTEREST,0)+NVL(T.PENAL,0))END),0)
                INTO PRNBAL  
            FROM ADV_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT < TRN.TRANS_DT;
            TRNDATE := TRN.TRANS_DT ;
            IF  DUEDATE < TRN.TRANS_DT THEN
                PENINTRECEIVABLE  := PENINTRECEIVABLE  +  (PRNBAL * (TRN.TRANS_DT - STARTDATE) * PENROI/ 36500);
                --DBMS_OUTPUT.PUT_LINE(' STARTDATE ' || TRN.TRANS_DT || ' PRNBAL ' || PRNBAL || ' DIFF DAYS ' || (TRN.TRANS_DT - STARTDATE));
            END IF;
            STARTDATE := TRN.TRANS_DT;
        END LOOP;
    END;
    SELECT NVL(SUM(T.PENAL),0) INTO PENINTRECEIVED
    FROM ADV_TRANS_DETAILS T
    WHERE T.ACT_NUM = ACTNUM AND
          T.TRANS_DT > PENRECFRM AND T.TRANS_DT <= ASONDT AND
          T.TRANS_TYPE = 'CREDIT';
    PENINTRECEIVABLE := PENINTRECEIVABLE - PENINTRECEIVED;
    PENINTRECEIVABLE := ROUND(PENINTRECEIVABLE,0); 
    IF PENINTRECEIVABLE < 0 THEN
        PENINTRECEIVABLE := 0;
    END IF;
    RETURN PENINTRECEIVABLE;
END;
/


CREATE OR REPLACE FUNCTION GET_TL_INST_OD_PENINT(ACTNUM VARCHAR,INSTDATE DATE,ASONDT DATE)
RETURN NUMBER IS
  PRNOD NUMBER(16,2) := 0;
  INST_RECEIVABLE NUMBER(16,2) := 0;
  INST_RECEIVED NUMBER(16,2) := 0;
  BALANCE NUMBER(16,2) := 0;
  OD_EXCLUDE_AMT NUMBER(16,2) := 0;
BEGIN
    BALANCE := GET_TL_BALANCE(ACTNUM,ASONDT);
    IF (BALANCE < 0) THEN
        RETURN PRNOD;
    END IF;
    SELECT SUM(I.PRINCIPAL_AMT) INTO INST_RECEIVABLE FROM LOANS_INSTALLMENT I
    WHERE I.ACCT_NUM = ACTNUM AND I.INSTALLMENT_DT <= INSTDATE AND I.STATUS != 'DELETED' ;
    SELECT SUM(T.PRINCIPLE) INTO INST_RECEIVED FROM LOAN_TRANS_DETAILS T 
    WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.TRANS_TYPE = 'CREDIT';
    PRNOD := NVL(INST_RECEIVABLE,0) - NVL(INST_RECEIVED,0) ;
    SELECT NVL(LPA.MAX_OD_EXLCUDED_RPT,0) INTO OD_EXCLUDE_AMT
    FROM LOANS_FACILITY_DETAILS F
    JOIN LOANS_PROD_ACPARAM LPA ON F.PROD_ID = LPA.PROD_ID
    WHERE F.ACCT_NUM = ACTNUM;
    IF PRNOD < 0 OR PRNOD <= OD_EXCLUDE_AMT THEN
        PRNOD := 0;
    END IF;
    IF BALANCE < PRNOD THEN
        PRNOD :=  BALANCE;
    END IF;
    RETURN PRNOD;
END;
/
CREATE OR REPLACE FUNCTION GET_TL_OD_INTEREST(ACNUM IN VARCHAR2,ASONDATE DATE)
RETURN NUMBER IS
--DECLARE
--    ACNUM VARCHAR2(13) := '0001201012889';
--    ASONDATE DATE := '28-JAN-2014';
    PENROI NUMBER(4,2) := 0;
    PENAMT NUMBER(16,2) := 0;
    LSTINTDATE DATE;
    INSTODDATE DATE;
    ODAMT NUMBER(16,2) := 0;
    PENINT_RECEIVED NUMBER(16,2) := 0;
BEGIN
    BEGIN
        SELECT GET_TL_PENROI(F.PROD_ID,F.ACCT_NUM,SD.FROM_DT,SD.LIMIT,F.INT_GET_FROM) INTO PENROI
        FROM LOANS_FACILITY_DETAILS F
        JOIN LOANS_SANCTION_DETAILS SD ON SD.BORROW_NO = F.BORROW_NO
        WHERE F.ACCT_NUM = ACNUM;
        IF PENROI IS NULL OR PENROI = 0 THEN
            RETURN PENAMT;
        END IF;
        IF GET_TL_BALANCE(ACNUM,ASONDATE) < 0 THEN
            RETURN PENAMT;
            --DBMS_OUTPUT.PUT_LINE(' NO BALANCE');
        END IF;
        SELECT (F.LAST_INT_CALC_DT + 1),GET_TL_INST_ODDATE(F.ACCT_NUM,ASONDATE) INTO LSTINTDATE,INSTODDATE
        FROM LOANS_FACILITY_DETAILS F
        WHERE F.ACCT_NUM = ACNUM;
        --DBMS_OUTPUT.PUT_LINE(' LSTINTDATE : ' || LSTINTDATE || '    INSTODDATE : ' || INSTODDATE);
        IF INSTODDATE IS NULL THEN
            SELECT GET_TL_INST_OD(ACNUM,ASONDATE) INTO ODAMT
            FROM DUAL;
            PENAMT := (ODAMT * (ASONDATE - LSTINTDATE) * PENROI/36500);
        ELSE
            SELECT SUM(ODAMT * NOD * PENROI/36500) INTO PENAMT
            FROM
                (
                    SELECT (ASONDATE - INST) AS NOD,PEN_AMT_OD AS ODAMT,INST
                    FROM
                        (        
                            SELECT CASE WHEN (I.INSTALLMENT_DT) < LSTINTDATE THEN LSTINTDATE ELSE I.INSTALLMENT_DT END AS INST,
                                   I.PRINCIPAL_AMT,
                                   CASE WHEN I.INSTALLMENT_DT <= INSTODDATE THEN 
                                             GET_TL_INST_OD_PENINT(I.ACCT_NUM,I.INSTALLMENT_DT,ASONDATE) 
                                        ELSE I.PRINCIPAL_AMT 
                                   END AS PEN_AMT_OD
                            FROM LOANS_INSTALLMENT I
                            WHERE I.ACCT_NUM = ACNUM AND I.INSTALLMENT_DT >= INSTODDATE AND I.INSTALLMENT_DT <= ASONDATE AND I.STATUS != 'DELETED'  
                        )
                );
        END IF;
        SELECT SUM(NVL(T.PENAL,0)) INTO PENINT_RECEIVED
        FROM LOAN_TRANS_DETAILS T
        WHERE T.ACT_NUM = ACNUM AND T.TRANS_DT > LSTINTDATE AND T.TRANS_DT <= ASONDATE AND T.AUTHORIZE_STATUS = 'AUTHORIZED';
        PENINT_RECEIVED := NVL(PENINT_RECEIVED,0);
        --DBMS_OUTPUT.PUT_LINE(' PENAL AMOUNT ' || PENAMT);    
    EXCEPTION WHEN OTHERS THEN
        RETURN 0;
    END;
    PENAMT := PENAMT - PENINT_RECEIVED;
    IF PENAMT < 0 THEN 
        PENAMT := 0; 
    END IF;
    PENAMT := ROUND(PENAMT);
    --DBMS_OUTPUT.PUT_LINE(' PENAL AMOUNT ' || PENAMT);
    RETURN(PENAMT);  
END;
/


DROP VIEW REP_TMPDATA;

CREATE OR REPLACE FORCE VIEW rep_tmpdata (branch_code,
                                                    fdate,
                                                    tdate,
                                                    acnum,
                                                    accountno
                                                   )
AS
   SELECT bm.branch_code, p.last_financial_year_end AS fdate,
          p.last_financial_year_end AS tdate, p.cash_ac_hd AS acnum,
          p.cash_ac_hd AS accountno
     FROM branch_master bm, PARAMETERS p;


Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
    RECORD_KEY_COL, SCREEN_DESC)
 VALUES
   ('SCR09988', '54', 'Loan Status', 'APP01', 'DONE',
    '8', 'com.see.truetransact.ui.termloan.LoanStatusUI', 2, 'CREATED', NULL,
    NULL, NULL);
   COMMIT;
 
 Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED)
 Values
   ('GRP01014', 'SCR09988', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR09988', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR09988', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS)
 Values
   ('GRP01015', 'SCR09988', 'CREATED');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR09988', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'N', 'Y', 'Y');
   
COMMIT;
--End Version [Script Version - 0.0.54] [ReleaseVersion - 9.2.1.25]--[09-07-2014] -- by Babu

--Start Version [Script Version - 0.0.55] [ReleaseVersion - 9.2.1.25]--[17-07-2014] -- by Jeffin John

ALTER TABLE MDS_RECEIPT_ENTRY ADD CALLING_SCREEN VARCHAR2(32 BYTE);

--End Version [Script Version - 0.0.55] [ReleaseVersion - 9.2.1.25]--[17-07-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.56] [ReleaseVersion - 9.2.1.25]--[19-07-2014] -- by Sreekrishnan

CREATE TABLE GL_OPENING_UPDATE
(
  AC_HD_ID      VARCHAR2(16 BYTE),
  CLOS_BAL      NUMBER,
  NEW_CLOS_BAL  NUMBER,
  STATUS        VARCHAR2(16 BYTE),
  FROM_DT       DATE,
  BRANCH        VARCHAR2(16 BYTE),
  CREATED_BY    VARCHAR2(16 BYTE),
  OPENING       NUMBER
)

CREATE OR REPLACE PROCEDURE GLUPDATE (FRM_date date ,brcode varchar2 ,ACHDID VARCHAR2) AS
 /*

  EXECUTE GLUPDATE ('31-MAR-2013','0001','1091001002');
  
  */
    Start_date date := FRM_date;
    BALTYPE VARCHAR2(20); 
    End_date date;
     
    
 BEGIN
        DELETE from GL_ABSTRACT WHERE DT > FRM_date  AND BRANCH_CODE=brcode
        AND  AC_HD_ID =ACHDID; 
        SELECT CURR_APPL_DT INTO End_date FROM DAY_END WHERE BRANCH_CODE=brcode;
 
   WHILE Start_date< End_date
    LOOP   
       Start_date := Start_date + 1;
       --(BALTYPE ='INCOME' OR BALTYPE ='LIABILITY')   
       SELECT MJR_AC_HD_TYPE INTO BALTYPE FROM MJR_AC_HD MJ WHERE MJ.MJR_AC_HD_ID = SUBSTR(ACHDID,1,4); 
       INSERT INTO  GL_ABSTRACT
        (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT, BALANCE_TYPE)
       select GLA.AC_HD_ID, GLA.CLOSE_BAL,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 
        ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.DR,0))-NVL(TR.CR,0))
        ELSE   ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.CR,0))-NVL(TR.DR,0))  END)    
       ,GLA.BRANCH_CODE, Start_date  ,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 'DEBIT' 
        ELSE  'CREDIT' END) AS BALANCE_TYPE
        from GL_ABSTRACT GLA
         LEFT OUTER JOIN
            (SELECT AC_HD_ID,SUM(NVL(CR,0)) AS CR ,
            SUM(NVL(DR,0)) AS DR    
             FROM ALL_GRP_TRN WHERE TRANS_DT  = Start_date AND BRANCH_ID =brcode AND AC_HD_ID =ACHDID    
               AND  AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
             UNION SELECT IBR_AC_HD FROM PARAMETERS) GROUP BY AC_HD_ID) TR ON TR.AC_HD_ID = GLA.AC_HD_ID
            
        WHERE GLA.DT = Start_date-1 AND GLA.BRANCH_CODE=brcode AND  GLA.AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
        UNION SELECT IBR_AC_HD FROM PARAMETERS)  AND GLA.AC_HD_ID =ACHDID;
        
       COMMIT;  
       
    END LOOP;
    
    
    DELETE FROM GL WHERE BRANCH_CODE = brcode AND AC_HD_ID = ACHDID; 
    COMMIT;
    insert into  GL(ac_hd_id,opn_bal,cur_bal,branch_code,last_trans_dt,authorize_status,balance_type) 
    (select ac_hd_id,opn_bal,CLOSE_BAL,branch_code,dt,'AUTHORIZED',balance_type from  "GL_ABSTRACT"
     WHERE DT =(SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode) AND AC_HD_ID = ACHDID  ); 
    COMMIT;
        UPDATE GL_ABSTRACT SET  CLOSE_BAL =NULL WHERE BRANCH_CODE =brcode AND AC_HD_ID =ACHDID AND DT=(
        SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode);
    COMMIT; 
    
 END;
/

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06125', '3', 'GL Opening Update', 'APP01', 'DONE', 
    '14', 'com.see.truetransact.ui.generalledger.GLOpeningUpdateUI', 6, 'CREATED', NULL, 
    NULL, 'Account Head Maintenance');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06125', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06125', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06125', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06125', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
COMMIT;

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06126', '3', 'Schedule View', 'APP01', 'DONE', 
    '8', '', '6', 'CREATED', NULL, 
    NULL, 'Schedule View');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06126', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06126', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06126', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06126', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
COMMIT;




SSET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('AD_SCHEDULE', 'REPORT NAME','LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('MMBS_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SHARE_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('TD_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SHARE_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('OA_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('TL_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INVESTMENT_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('BORROWING_SCHEDULE', 'REPORT NAME', 'LOOKUP DESCRIPTION', 'CREATED', 'Y', 
    'Y');
COMMIT;

--End Version [Script Version - 0.0.56] [ReleaseVersion - 9.2.1.25]--[19-07-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.57] [ReleaseVersion - 9.2.1.25]--[18-07-2014] -- by Nidhin
ALTER TABLE LOAN_APPLICATION_REGISTER ADD (BRANCH_ID VARCHAR2 (5 Byte));
--End Version [Script Version - 0.0.56] [ReleaseVersion - 9.2.1.25]--[18-07-2014] -- by Nidhi

--Start Version [Script Version - 0.0.57] [ReleaseVersion - 9.2.1.25]--[18-07-2014] -- by Chithra
ALTER TABLE DEPOSIT_ACINFO ADD (ACC_ZERO_BAL_YN VARCHAR2(5 BYTE));
--End Version [Script Version - 0.0.57] [ReleaseVersion - 9.2.1.25]--[18-07-2014] -- by Chithra

--Start Version [Script Version - 0.0.58] [ReleaseVersion - 9.2.1.25]--[21-07-2014] -- by Babu
alter table PASS_BOOK_TMP add TRANS_ID varchar2(16);

alter table PASS_BOOK_TMP add BATCH_ID varchar2(16);
--End Version [Script Version - 0.0.58] [ReleaseVersion - 9.2.1.25]--[21-07-2014] -- by Babu

--Start Version [Script Version - 0.0.59] [ReleaseVersion - 9.2.1.25]--[25-07-2014] -- by Anju
alter table BILLS_LODGEMENT_MASTER add BRANCH_CODE varchar2(8);
--End Version [Script Version - 0.0.59] [ReleaseVersion - 9.2.1.25]--[25-07-2014] -- by Anju

--Start Version [Script Version - 0.0.60] [ReleaseVersion - 9.2.1.25]--[26-07-2014] -- by Anju Anand

 CREATE TABLE  PAY_PF_MASTER
(
  PF_ACT_NO         VARCHAR2(13 BYTE),
  EMP_ID            VARCHAR2(20 BYTE),
  PF_DT             DATE,
  PF_ROI            INTEGER,
  PF_NOM            VARCHAR2(50 BYTE),
  PF_OP_BAL         NUMBER,
  PF_OP_DT          DATE,
  PF_INT_DT         DATE,
  PF_NOM_RL         VARCHAR2(50 BYTE),
  CREATED_BY        VARCHAR2(10 BYTE),
  CREATED_DATE      DATE,
  AUTHORIZE_STATUS  VARCHAR2(20 BYTE),
  AUTHORIZED_BY     VARCHAR2(10 BYTE),
  PRN_BAL           NUMBER,
  BRANCHID          VARCHAR2(10 BYTE),
  EMPLOYER_CONTRI   NUMBER(20)
);

CREATE TABLE   PAY_PF_TRANS
(
  PF_NO             VARCHAR2(13 BYTE),
  TRAN_DT           DATE,
  TRANS_ID          VARCHAR2(20 BYTE),
  BATCH_ID          VARCHAR2(20 BYTE),
  TRANS_MODE        VARCHAR2(10 BYTE),
  AMOUNT            NUMBER,
  STATUS            VARCHAR2(10 BYTE),
  REMARK            VARCHAR2(50 BYTE),
  PROD_TYPE         VARCHAR2(20 BYTE),
  CREATED_BY        VARCHAR2(10 BYTE),
  CREATED_DATE      DATE,
  AUTHORIZED_BY     VARCHAR2(10 BYTE),
  AUTHORIZE_STATUS  VARCHAR2(10 BYTE),
  BRANCHID          VARCHAR2(10 BYTE),
  PF_TRANS_TYPE     VARCHAR2(20 BYTE),
  PROD_ID           VARCHAR2(20 BYTE),
  TRANS_TYPE        VARCHAR2(20 BYTE)
);

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCR05011', '111', 'PF Transfer', 'APP01', 'DONE', '41', 'com.see.truetransact.ui.payroll.pftransfer.PFTransferUI', 37, 'CREATED', 'PF Transfer');

Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS)
 Values
   ('GRP00003', 'SCR05011', 'CREATED');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, AUTH_REJ_ALLOWED, PRINT_ALLOWED)
 Values
   ('GRP01014', 'SCR05011', 'CREATED', 'Y', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, AUTH_REJ_ALLOWED, PRINT_ALLOWED)
 Values
   ('GRP00007', 'SCR05011', 'CREATED', 'Y', 'Y', 'Y');

--End Version [Script Version - 0.0.60] [ReleaseVersion - 9.2.1.25]--[26-07-2014] -- by Anju Anand

--Start Version [Script Version - 0.0.61] [ReleaseVersion - 9.2.1.27]--[29-07-2014] -- by Babu

/* Formatted on 2014/07/29 12:02 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_grp_trn_new (branch_id,
                                                 trans_dt,
                                                 ac_hd_id,
                                                 cr,
                                                 dr
                                                )
AS
   SELECT   branch_id, trans_dt, ac_hd_id,
            NVL (SUM ((CASE
                          WHEN trans_type = 'CREDIT'
                             THEN amount
                          ELSE 0
                       END)),
                 0
                ) AS cr,
            NVL (SUM ((CASE
                          WHEN trans_type = 'DEBIT'
                             THEN amount
                          ELSE 0
                       END)),
                 0
                ) AS dr
       FROM all_trans
      WHERE trans_dt >= '01-APR-2011'
        AND status != 'DELETED'
        AND authorize_status = 'AUTHORIZED'
   GROUP BY branch_id, trans_dt, ac_hd_id;


CREATE OR REPLACE PROCEDURE GLUPDATE (FRM_date date ,brcode varchar2 ,ACHDID VARCHAR2) AS
 /*

  EXECUTE GLUPDATE ('31-MAR-2013','0001','1091001002');
  
  */
    Start_date date := FRM_date;
    BALTYPE VARCHAR2(20); 
    End_date date;
     
    
 BEGIN
        DELETE from GL_ABSTRACT WHERE DT > FRM_date  AND BRANCH_CODE=brcode
        AND  AC_HD_ID =ACHDID; 
        SELECT CURR_APPL_DT INTO End_date FROM DAY_END WHERE BRANCH_CODE=brcode;
 
   WHILE Start_date< End_date
    LOOP   
       Start_date := Start_date + 1;
       --(BALTYPE ='INCOME' OR BALTYPE ='LIABILITY')   
       SELECT MJR_AC_HD_TYPE INTO BALTYPE FROM MJR_AC_HD MJ WHERE MJ.MJR_AC_HD_ID = SUBSTR(ACHDID,1,4); 
       INSERT INTO  GL_ABSTRACT
        (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT, BALANCE_TYPE)
       select GLA.AC_HD_ID, GLA.CLOSE_BAL,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 
        ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.DR,0))-NVL(TR.CR,0))
        ELSE   ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.CR,0))-NVL(TR.DR,0))  END)    
       ,GLA.BRANCH_CODE, Start_date  ,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 'DEBIT' 
        ELSE  'CREDIT' END) AS BALANCE_TYPE
        from GL_ABSTRACT GLA
         LEFT OUTER JOIN
            (SELECT AC_HD_ID,SUM(NVL(CR,0)) AS CR ,
            SUM(NVL(DR,0)) AS DR    
             FROM ALL_GRP_TRN_NEW WHERE TRANS_DT  = Start_date AND BRANCH_ID =brcode AND AC_HD_ID =ACHDID    
               AND  AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
             UNION SELECT IBR_AC_HD FROM PARAMETERS) GROUP BY AC_HD_ID) TR ON TR.AC_HD_ID = GLA.AC_HD_ID
            
        WHERE GLA.DT = Start_date-1 AND GLA.BRANCH_CODE=brcode AND  GLA.AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
        UNION SELECT IBR_AC_HD FROM PARAMETERS)  AND GLA.AC_HD_ID =ACHDID;
        
       COMMIT;  
       
    END LOOP;
    
    
    DELETE FROM GL WHERE BRANCH_CODE = brcode AND AC_HD_ID = ACHDID; 
    COMMIT;
    insert into  GL(ac_hd_id,opn_bal,cur_bal,branch_code,last_trans_dt,authorize_status,balance_type) 
    (select ac_hd_id,opn_bal,CLOSE_BAL,branch_code,dt,'AUTHORIZED',balance_type from  "GL_ABSTRACT"
     WHERE DT =(SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode) AND AC_HD_ID = ACHDID  ); 
    COMMIT;
        UPDATE GL_ABSTRACT SET  CLOSE_BAL =NULL WHERE BRANCH_CODE =brcode AND AC_HD_ID =ACHDID AND DT=(
        SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode);
    COMMIT; 
    
 END;
/

CREATE TABLE SUPPLIER_TABLE
(
  SUPPLIER_PID        NUMBER(11)                NOT NULL,
  SUPPLIER_ID         VARCHAR2(15 BYTE)         NOT NULL,
  SUPPLIER_NAME       VARCHAR2(255 BYTE),
  SUPPLIER_PLACE      VARCHAR2(255 BYTE),
  SUPPLIER_ADDR       VARCHAR2(255 BYTE),
  SUPPLIER_POST       VARCHAR2(255 BYTE),
  SUPPLIER_CST        VARCHAR2(255 BYTE),
  SUPPLIER_TIN        VARCHAR2(255 BYTE),
  SUPPLIER_PHONE      VARCHAR2(255 BYTE),
  SUPPLIER_CRTD_DATE  VARCHAR2(20 BYTE),
  SUP_ACT_NUM         VARCHAR2(20 BYTE),
  SUNDRY_ACT_NUM      VARCHAR2(20 BYTE)
)
--End Version [Script Version - 0.0.61] [ReleaseVersion - 9.2.1.27]--[29-07-2014] -- by Babu

--Start Version [Script Version - 0.0.62] [ReleaseVersion - 9.2.1.27]--[05-08-2014] -- by Jeffin John

alter table GAHAN_CUSTOMER_DETAILS modify DOCUMENTS_SUBMITTED varchar2(1024 byte);

--End Version [Script Version - 0.0.62] [ReleaseVersion - 9.2.1.27]--[05-08-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.63] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by Jeffin John

INSERT INTO ID_GENERATION VALUES('MULTIPLE_DEPOSIT_ID',0,'MD',sysdate,12,'0001');

ALTER TABLE DEPOSIT_ACINFO ADD MULTIPLE_DEPOSIT_ID VARCHAR(16 BYTE);

ALTER TABLE DEPOSIT_SUB_ACINFO ADD MULTIPLE_DEPOSIT_ID VARCHAR(16 BYTE);

ALTER TABLE DEPOSIT_SUB_ACINFO_SAMENO ADD MULTIPLE_DEPOSIT_ID VARCHAR(16 BYTE);

--End Version [Script Version - 0.0.63] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.64][ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by Anju
alter table LOANS_PROD_ACPARAM add MAX_AMT_OF_CASH_PAYMENT varchar2(16);
update LOANS_PROD_ACPARAM set MAX_AMT_OF_CASH_PAYMENT = '9999999999';
--End Version [Script Version - 0.0.64] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by Anju

--Start Version [Script Version - 0.0.65] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by JiBiN
CREATE OR REPLACE FORCE VIEW rep_loan_notice_two (acct_num,
                                                       membership_no,
                                                       borrow_no,
                                                       fname,
                                                       from_dt,
                                                       to_dt,
                                                       LIMIT,
                                                       principal,
                                                       last_int_calc_dt,
                                                       branch_code,
                                                       interest,
                                                       due_dt,
                                                       prod_id,
                                                       NO,
                                                       prin_demand,
                                                       prin_paid,
                                                       amt_penultimate_install,
                                                       install_type,
                                                       cust_id,
                                                       comm_addr_type,
                                                       lonestreet,
                                                       lonearea,
                                                       lonecity,
                                                       lonestate,
                                                       lonepin_code,
                                                       MEMBER,
                                                       prod_desc,
                                                       day_end_dt,
                                                       last_int_calc_dt2,
                                                       tel_no,
                                                       ord_not_chg,
                                                       reg_not_chg,
                                                       interest_demand,
                                                       int_paid,
                                                       penal,
                                                       charges,
                                                       no_month_due,
                                                       prod_type,
                                                       last_notice_sent_dt
                                                      )
AS
   SELECT rnm."ACCT_NUM", rnm.membership_no, rnm.borrow_no, rnm."FNAME",
          rnm."FROM_DT", rnm."TO_DT", rnm."LIMIT", rnm."PRINCIPAL",
          rnm."LAST_INT_CALC_DT", rnm."BRANCH_CODE", rnm."INTEREST",
          rnm."DUE_DT", rnm."PROD_ID", rnm."NO", rnm."PRIN_DEMAND",
          rnm."PRIN_PAID", rnm."AMT_PENULTIMATE_INSTALL", rnm."INSTALL_TYPE",
          rnm."CUST_ID", rnm."COMM_ADDR_TYPE", rnm."LONESTREET",
          rnm."LONEAREA", rnm."LONECITY", rnm."LONESTATE", rnm."LONEPIN_CODE",
          rnm."MEMBER", rnm."PROD_DESC", rnm."DAY_END_DT",
          rnm."LAST_INT_CALC_DT2", rnm."TEL_NO",
          NVL ((SELECT lpc.notice_charge_amt
                  FROM loans_prod_chqchrg lpc
                 WHERE lpc.prod_id = rnm.prod_id
                   AND lpc.notice_type = 'Ordinary Notice'),
               0
              ) AS ord_not_chg,
          NVL ((SELECT lpc.notice_charge_amt
                  FROM loans_prod_chqchrg lpc
                 WHERE lpc.prod_id = rnm.prod_id
                   AND lpc.notice_type = 'Registered Notice'),
               0
              ) AS reg_not_chg,
          CASE
             WHEN install_type = 'EMI'
                THEN loans_emi_int (acct_num,
                                    due_dt,
                                    day_end_dt,
                                    interest
                                   )
             WHEN (day_end_dt - last_int_calc_dt) > 0
                  AND install_type != 'EMI'
                THEN CASE
                       WHEN last_int_calc_dt2 != '31-JUL-2010'
                          THEN CASE
                                 WHEN last_int_calc_dt != '02-AUG-2010'
                                    THEN CEIL ((  (  day_end_dt
                                                   - last_int_calc_dt
                                                  )
                                                * interest
                                                * principal
                                                / 36500
                                               )
                                              )
                                 WHEN (get_migration_interest (acct_num)) < 0
                                 AND last_int_calc_dt = '02-AUG-2010'
                                    THEN CEIL ((  (  day_end_dt
                                                   - TO_DATE ('31-JUL-2010')
                                                  )
                                                * interest
                                                * principal
                                                / 36500
                                               )
                                              )
                                 ELSE CEIL ((  (day_end_dt - last_int_calc_dt2+1
                                               )
                                             * interest
                                             * principal
                                             / 36500
                                            )
                                           )
                              END
                       ELSE CEIL ((  (day_end_dt - last_int_calc_dt2)
                                   * interest
                                   * principal
                                   / 36500
                                  )
                                 )
                    END
             ELSE 0
          END AS interest_demand,
          CASE
             WHEN install_type != 'EMI'
                THEN CASE
                       WHEN last_int_calc_dt2 != '31-jul-2010'
                          THEN CASE
                                 WHEN last_int_calc_dt !=
                                                    '02-AUG-2010'
                                    THEN NVL
                                           ((SELECT SUM (interest)
                                               FROM loan_trans_details
                                              WHERE trans_dt
                                                       BETWEEN   last_int_calc_dt
                                                               + 1
                                                           AND day_end_dt
                                                AND act_num = acct_num
                                                AND last_int_calc_dt <
                                                                    day_end_dt),
                                            0
                                           )
                                 WHEN (get_migration_interest (acct_num)) < 0
                                    THEN NVL
                                           ((SELECT SUM (interest)
                                               FROM loan_trans_details
                                              WHERE trans_dt
                                                       BETWEEN '01-AUG-2010'
                                                           AND day_end_dt
                                                AND act_num = acct_num
                                                AND last_int_calc_dt <
                                                                    day_end_dt),
                                            0
                                           )
                                 ELSE NVL
                                        ((SELECT SUM (interest)
                                            FROM loan_trans_details
                                           WHERE trans_dt
                                                    BETWEEN   last_int_calc_dt
                                                            + 1
                                                        AND day_end_dt
                                             AND act_num = acct_num
                                             AND last_int_calc_dt < day_end_dt),
                                         0
                                        )
                              END
                       ELSE NVL
                              ((SELECT SUM (interest)
                                  FROM loan_trans_details
                                 WHERE trans_dt BETWEEN last_int_calc_dt2 + 1
                                                    AND day_end_dt
                                   AND act_num = acct_num
                                   AND last_int_calc_dt < day_end_dt),
                               0
                              )
                    END
             ELSE 0
          END AS int_paid,
          NVL (get_tl_pen_interest (acct_num,
                                    last_int_calc_dt2,
                                    day_end_dt - 1,
                                    2
                                   ),
               0
              ) AS penal,
          (SELECT NVL (SUM (amount - NVL (paid_amt, 0)), 0)
             FROM loans_acct_charge_details
            WHERE act_num = acct_num AND status != 'DELETED') AS charges,
          ROUND
             (CASE
                 WHEN install_type = 'EMI'
                    THEN CASE
                           WHEN CEIL (MONTHS_BETWEEN (day_end_dt, due_dt)) > 0
                              THEN CEIL (MONTHS_BETWEEN (day_end_dt, due_dt))
                           ELSE 0
                        END
                 WHEN prin_demand - prin_paid > 0
                    THEN CASE
                           WHEN (SELECT lp.authorize_remark
                                   FROM loans_product lp
                                  WHERE lp.prod_id = rnm.prod_id) =
                                                                   'GOLD_LOAN'
                              THEN 1
                           ELSE   (prin_demand - prin_paid)
                                / amt_penultimate_install
                        END
                 ELSE 0
              END,
              0
             ) AS no_month_due,
          (SELECT lp.authorize_remark
             FROM loans_product lp
            WHERE lp.prod_id = rnm.prod_id) AS prod_type,
          (SELECT MAX (sent_dt)
             FROM loans_notice_charge_details
            WHERE rnm.acct_num = act_num) AS last_notice_sent_dt
     FROM rep_loan_notice_one rnm;
--End Version [Script Version - 0.0.65] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by JiBiN

--Start Version [Script Version - 0.0.66] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by Chithra
ALTER TABLE LOANS_PRODUCT ADD (DEFAULT_PROD VARCHAR2(5 BYTE) DEFAULT 'N');
--End Version [Script Version - 0.0.66] [ReleaseVersion - 9.2.1.27]--[06-08-2014] -- by Chithra

--Start Version [Script Version - 0.0.67] [ReleaseVersion - 9.2.1.27]--[07-08-2014] -- by Nidhin
alter table DEPOSITS_PROD_INTPAY add(PRODUCT_DEFAULT_VALUE varchar(2) default 'N')
--End Version [Script Version - 0.0.67] [ReleaseVersion - 9.2.1.27]--[07-08-2014] -- by Nidhin

--Start Version [Script Version - 0.0.68] [ReleaseVersion - 9.2.1.27]--[07-08-2014] -- by Jeffin John

ALTER TABLE SHARE_ACCT_DETAILS ADD LOAN_ACCT_NUMBER VARCHAR2(32 BYTE);

UPDATE SCREEN_MASTER SM SET SM.SCREEN_NAME = 'Multiple Deposit Creation' WHERE SM.SCREEN_ID = 'SCR06124';

--End Version [Script Version - 0.0.68] [ReleaseVersion - 9.2.1.27]--[07-08-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.69] [ReleaseVersion - 9.2.1.27]--[08-08-2014] -- by Shihad

 ALTER TABLE LOCKER_MASTER ADD (ACT_NUM VARCHAR2(64 BYTE));

 ALTER TABLE LOCKER_SURRENDER ADD (ACT_NUM VARCHAR2(64 BYTE)); 

 ALTER TABLE LOCKER_SURRENDER ADD (DEFAULTER VARCHAR2(64 BYTE)); 

 ALTER TABLE RENT_TRANS ADD (RRID VARCHAR2(16 BYTE));
 
 ALTER TABLE RENT_REGISTER ADD (ACCOUNT_STATUS VARCHAR2(50 BYTE));

 ALTER TABLE RENT_REGISTER ADD (BRANCH_CODE VARCHAR2(20 BYTE));

 ALTER TABLE RENT_REGISTER ADD (CLOSES_DATE DATE);

--End Version [Script Version - 0.0.69] [ReleaseVersion - 9.2.1.27]--[8-08-2014] -- by Shihad

--Start Version [Script Version - 0.0.70] [ReleaseVersion - 9.2.1.27]--[08-08-2014] -- by Chithra
ALTER TABLE PARAMETERS ADD (TOKEN_NO_REQ VARCHAR2(3 BYTE) DEFAULT 'N');
--End Version [Script Version - 0.0.70] [ReleaseVersion - 9.2.1.27]--[8-08-2014] -- by Chithra

--Start Version [Script Version - 0.0.71] [ReleaseVersion - 9.2.1.27]--[19-08-2014] -- by Sathiya

UPDATE ACT_MASTER SET OPT_MODE_ID = 'SELF' WHERE OPT_MODE_ID = 'Self';

ALTER TABLE PAY_IN_SLIP ADD SCHEDULE_NO VARCHAR2(16);

--Start Version [Script Version - 0.0.71] [ReleaseVersion - 9.2.1.27]--[19-08-2014] -- by Sathiya

--Start Version [Script Version - 0.0.72] [ReleaseVersion - 9.2.1.27]--[18-08-2014] -- by Babu
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
    RECORD_KEY_COL, SCREEN_DESC)
 VALUES
   ('SCR01063', '1400', 'Deposit Multiple Renewal', 'APP01', 'DONE',
    '6', 'com.see.truetransact.ui.deposit.multiplerenewal.DepositMultiRenewal', 2, 'CREATED', NULL,
    NULL, NULL);
   COMMIT;
 
 Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED)
 Values
   ('GRP01014', 'SCR01063', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR01063', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR01063', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS)
 Values
   ('GRP01015', 'SCR01063', 'CREATED');
   
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR01063', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'N', 'Y', 'Y');

ALTER TABLE BILLS_PRODUCT ADD DEBIT_BANK_CHRG_HEAD VARCHAR(100 BYTE);

--End Version [Script Version - 0.0.72] [ReleaseVersion - 9.2.1.27]--[18-08-2014] -- by Babu

--Start Version [Script Version - 0.0.73] [ReleaseVersion - 9.2.1.27]--[26-08-2014] -- by Jeffin John

DROP VIEW AUTHORIZATION_VIEW;

/* Formatted on 2014/08/23 11:28 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW authorization_view (table_name,
                                                         column_name,
                                                         err_count,
                                                         branch_column,
                                                         branch_id
                                                        )
AS
   SELECT   'CASH_TRANS' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, BRANCH_ID
       FROM cash_trans
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY BRANCH_ID
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TRANSFER_TRANS' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, BRANCH_ID
       FROM transfer_trans
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY BRANCH_ID
     HAVING COUNT (*) > 0
   UNION
   SELECT   'INWARD_CLEARING' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM inward_clearing
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'OUTWARD_CLEARING' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM outward_clearing
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'OUTWARD_RETURN' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM outward_return
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CLEARING_PARAM' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM clearing_param
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CUSTOMER' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM customer
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CUST_SECURITY_DETAILS' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_CODE' AS branch_column, branch_code
       FROM cust_security_details
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'ACT_MASTER' AS table_name, 'AUTHORIZATION_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM act_master
      WHERE (authorization_status IS NULL OR authorization_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'LOANS_FACILITY_DETAILS' AS table_name,
            'AUTHORIZE_STATUS_1' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM loans_facility_details
      WHERE (authorize_status_1 IS NULL OR authorize_status_1 = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'LOANS_DRAWING_POWER' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_CODE' AS branch_column, branch_code
       FROM loans_drawing_power
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CASH_MOVEMENT' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM cash_movement
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CHEQUE_ISSUE' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM cheque_issue
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CHEQUE_LOOSE_LEAF' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM cheque_loose_leaf
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'CHEQUE_STOP_PAYMENT' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM cheque_stop_payment
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'AGENT_MASTER' AS table_name, 'AUTHORIZED_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM agent_master
      WHERE (authorized_status IS NULL OR authorized_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'DD_STOP_PAYMENT' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM dd_stop_payment
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'DEPOSIT_ACINFO' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM deposit_acinfo
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'INVENTORY_MASTER' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_ID' AS branch_column, branch_id
       FROM inventory_master
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'SHARE_ACCT' AS table_name, 'AUTHORIZE' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            Initiated_branch
       FROM share_acct
      WHERE (authorize IS NULL OR authorize = '') AND status != 'DELETED'
   GROUP BY Initiated_branch
     HAVING COUNT (*) > 0
   UNION
   SELECT   'STANDING_INSTRUCTION' AS table_name,
            'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
            'BRANCH_CODE' AS branch_column, branch_code
       FROM standing_instruction
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TDS_EXEMPTION' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM tds_exemption
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TOKEN_CONFIG' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM token_config
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TOKEN_ISSUE' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM token_issue
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'TOKEN_LOST' AS table_name, 'AUTHORIZE_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_ID' AS branch_column, branch_id
       FROM token_lost
      WHERE (authorize_status IS NULL OR authorize_status = '')
        AND status != 'DELETED'
   GROUP BY branch_id
     HAVING COUNT (*) > 0
   UNION
   SELECT   'ACT_MASTER' AS table_name, 'AUTHORIZATION_STATUS' AS column_name,
            COUNT (*) AS err_count, 'BRANCH_CODE' AS branch_column,
            branch_code
       FROM act_master
      WHERE (authorization_status IS NULL OR authorization_status = '')
        AND status != 'DELETED'
   GROUP BY branch_code
     HAVING COUNT (*) > 0
   UNION
   SELECT a."TABLE_NAME", a."COLUMN_NAME", a."ERR_COUNT", a."BRANCH_COLUMN",
          b.branch_code
     FROM (SELECT 'INVESTMENT_MASTER' AS table_name,
                  'AUTHORIZED_STATUS' AS column_name, COUNT (*) AS err_count,
                  'BRANCH_CODE' AS branch_column
             FROM investment_master
            WHERE (   (status != 'DELETED' AND authorized_status IS NULL)
                   OR (    status = 'DELETED'
                       AND authorized_status IS NULL
                       AND authorized_dt IS NOT NULL
                      )
                  )
           HAVING COUNT (*) > 0) a,
          (SELECT DISTINCT head_office AS branch_code
                      FROM PARAMETERS) b
   UNION
   SELECT a."TABLE_NAME", a."COLUMN_NAME", a."ERR_COUNT", a."BRANCH_COLUMN",
          b.branch_code
     FROM (SELECT 'BORROWING_MASTER' AS table_name,
                  'AUTHORIZE_STATUS' AS column_name, COUNT (*) AS err_count,
                  'BRANCH_CODE' AS branch_column
             FROM borrowing_master
            WHERE (   (status != 'DELETED' AND authorize_status IS NULL)
                   OR (    status = 'DELETED'
                       AND authorize_status IS NULL
                       AND authorized_dt IS NOT NULL
                      )
                  )
           HAVING COUNT (*) > 0) a,
          (SELECT DISTINCT head_office AS branch_code
                      FROM PARAMETERS) b
   UNION
   SELECT a."TABLE_NAME", a."COLUMN_NAME", a."ERR_COUNT", a."BRANCH_COLUMN",
          b.branch_id
     FROM (SELECT 'MDS_PRIZED_MONEY_DETAILS' AS table_name,
                  'AUTHORIZED_STATUS' AS column_name, COUNT (*) AS err_count,
                  'BRANCH_ID' AS branch_column
             FROM mds_prized_money_details
            WHERE (   (status != 'DELETED' AND authorized_status IS NULL)
                   OR (    status = 'DELETED'
                       AND authorized_status IS NULL
                       AND authorized_dt IS NOT NULL
                      )
                  )
           HAVING COUNT (*) > 0) a,
          (SELECT DISTINCT head_office AS branch_id
                      FROM PARAMETERS) b;

alter table DEPOSIT_ACINFO add (MDS_GROUP VARCHAR2(32 BYTE))
					  
insert into LOOKUP_MASTER lm (LM.LOOKUP_ID,LM.LOOKUP_REF_ID,LM.LOOKUP_DESC,LM.STATUS,LM.AUTHORIZED) values ('MDS.GROUP','G1','GROUP 1','CREATED','Y')

insert into LOOKUP_MASTER lm (LM.LOOKUP_ID,LM.LOOKUP_REF_ID,LM.LOOKUP_DESC,LM.STATUS,LM.AUTHORIZED) values ('MDS.GROUP','G2','GROUP 2','CREATED','Y')

insert into LOOKUP_MASTER lm (LM.LOOKUP_ID,LM.LOOKUP_REF_ID,LM.LOOKUP_DESC,LM.STATUS,LM.AUTHORIZED) values ('MDS.GROUP','G3','GROUP 3','CREATED','Y')

insert into LOOKUP_MASTER lm (LM.LOOKUP_ID,LM.LOOKUP_REF_ID,LM.LOOKUP_DESC,LM.STATUS,LM.AUTHORIZED) values ('MDS.GROUP','G4','GROUP 4','CREATED','Y')

CREATE OR REPLACE PROCEDURE  SAVPASSBOOK4APERIOD (ACTNUM   VARCHAR2,
 FRDT  DATE)AS
 
 /*  EXECUTE    SAVPASSBOOK4APERIOD   ('0001102001521','31-MAR-2000' )   */
 
 
 MxSlNo NUMBER;

BEGIN
 

 
 DELETE FROM PASS_BOOK WHERE ACT_NUM =ACTNUM AND TRANS_DT >=FRDT  ;

 COMMIT;

  SELECT MAX(SLNO) INTO MxSlNo FROM PASS_BOOK WHERE ACT_NUM =ACTNUM AND TRANS_DT =(
    SELECT MAX(TRANS_DT)  FROM PASS_BOOK WHERE ACT_NUM =ACTNUM AND TRANS_DT <FRDT )  
    and NVL(PAGENO,0) =(SELECT MAX(nvl(PAGENO,0)) FROM PASS_BOOK WHERE ACT_NUM =ACTNUM);
 
  
 
 Insert into PASS_BOOK
   (ACT_NUM, SLNO, TRANS_DT, PARTICULARS, DEBIT, 
    CREDIT, PBOOK_FLAG, BALANCE, INSTRUMENT_NO1, INSTRUMENT_NO2, 
    TRANS_ID, BATCH_ID, INST_TYPE, INST_DT, STATUS, 
    AUTHORIZE_STATUS, AUTHORIZE_DT, PAGENO, CREATED_DT, AUTHORIZE_STATUS_2 )
 
  select ACT_NUM,(SUM(1) OVER (order by act_num,trans_dt, TRANS_TYPE,rownum)) + NVL(MxSlNo,0),TRANS_DT,PARTICULARS,
   (CASE when AT.TRANS_TYPE='DEBIT' THEN AMOUNT ELSE 0 END) AS DEBIT, 
   (CASE when AT.TRANS_TYPE='CREDIT' THEN AMOUNT ELSE 0 END) AS CREDIT ,PROD_ID,
  
   (NVL((SELECT BALANCE FROM PASS_BOOK WHERE ACT_NUM =AT.ACT_NUM AND TRANS_DT =(
    SELECT MAX(TRANS_DT)  FROM PASS_BOOK WHERE ACT_NUM =AT.ACT_NUM  AND TRANS_DT <FRDT )
    AND SLNO = NVL(MxSlNo,0)  ),0) +
 
    SUM( (CASE when AT.TRANS_TYPE='CREDIT' THEN AMOUNT ELSE 0 END)-
    (CASE when AT.TRANS_TYPE='DEBIT' THEN AMOUNT ELSE 0 END) ) OVER (order by act_num,trans_dt, TRANS_TYPE,rownum) ) 
    AS BALANCE,  INSTRUMENT_NO1, INSTRUMENT_NO2, 
    TRANS_ID, BATCH_ID, INST_TYPE, INST_DT, STATUS, 
    AUTHORIZE_STATUS, AUTHORIZE_DT,
    (SELECT MAX(nvl(PAGENO,0)) FROM PASS_BOOK WHERE ACT_NUM =AT.ACT_NUM) AS  PAGENO, STATUS_DT, AUTHORIZE_STATUS_2
    from all_trans AT where AT.AUTHORIZE_STATUS='AUTHORIZED' AND AT.STATUS!='DELETED' AND  trans_dt >= FRDT and act_num = ACTNUM   
 order by act_num,trans_dt,TRANS_TYPE ;

COMMIT;

END;
/

CREATE OR REPLACE PROCEDURE SAVDAYEND4APERIOD (ACTNUM   VARCHAR2,
 FRDT  DATE)AS
 
 /*  EXECUTE    SAVDAYEND4APERIOD   ('0001103007043','01-apr-2013' )   */
 

BEGIN
 

DELETE FROM ACT_DAYEND_BALANCE WHERE ACT_NUM =ACTNUM AND DAY_END_DT >=FRDT;

COMMIT;
 
Insert into  ACT_DAYEND_BALANCE
   (PROD_ID, ACT_NUM, DAY_END_DT, AMT )

WITH DE AS
(SELECT ACT_NUM,AMT  FROM ACT_DAYEND_BALANCE WHERE ACT_NUM =ACTNUM AND DAY_END_DT =(
    SELECT MAX(DAY_END_DT)  FROM ACT_DAYEND_BALANCE WHERE ACT_NUM =ACTNUM  AND
     DAY_END_DT < FRDT )
       ),
 TR AS 
 ( select  ACT_NUM ,TRANS_DT,  
 
    (SUM( (CASE WHEN AT.TRANS_TYPE='CREDIT' THEN AMOUNT ELSE 0 END)-
    (CASE when AT.TRANS_TYPE='DEBIT' THEN AMOUNT ELSE 0 END) ) ) 
    AS TRBALANCE 
     
    from all_trans AT where  AT.AUTHORIZE_STATUS='AUTHORIZED' AND AT.STATUS!='DELETED' AND  
    trans_dt >= FRDT
      and act_num = ACTNUM
    GROUP BY ACT_NUM ,TRANS_DT  )
    
    
select SUBSTR( TR.ACT_NUM,5,3),  TR.ACT_NUM,  TR.TRANS_DT,nvl((SELECT DE.AMT FROM DE WHERE 
 DE.ACT_NUM = TR.ACT_NUM ),0) + 
 SUM(TR.TRBALANCE) OVER (order by  TR.trans_dt) AS BAL 

FROM TR  order by  TR.trans_dt;
COMMIT;

end;
/

--End Version [Script Version - 0.0.73] [ReleaseVersion - 9.2.1.27]--[26-08-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.74] [ReleaseVersion - 9.2.1.27]--[27-08-2014] -- by Chithra
insert into MODULE_MASTER values('40','Service Tax','11 aug 2014','40','CREATED');

Insert into SCREEN_MASTER (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,RECORD_KEY_COL, SCREEN_DESC)
 VALUES ('SCR06127', '6127', 'Service Tax Settings', 'APP01', 'DONE', '40', 'com.see.truetransact.ui.servicetax.servicetaxSettings.ServiceTaxSettingsUI', 3, 'CREATED', NULL,
    NULL, 'Service Tax Settings');
  
Insert into GROUP_SCREENS (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES ('GRP01014', 'SCR06127', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'N');
 
Insert into GROUP_SCREENS (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES  ('GRP00001', 'SCR06127', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES ('GRP00002', 'SCR06127', 'CREATED', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES ('GRP00003', 'SCR06127', 'CREATED', 'Y', 'Y', 'Y', 'Y' , 'Y', 'Y', NULL);

Insert into GROUP_SCREENS (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES ('GRP00004', 'SCR06127', 'CREATED', '', '', '', '' , '', '', NULL);

Insert into GROUP_SCREENS (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES  ('GRP01015', 'SCR06127', 'CREATED', '', '', '', '' , '', '', NULL);
 
INSERT INTO ID_GENERATION VALUES('SERVICETAX_GEN_ID','1','STG','11 AUG 2014','8','0001');


CREATE TABLE SERVICE_TAX_SETTINGS
(
  SERVICETAX_GEN_ID  VARCHAR2(30)               NOT NULL,
  WEF_DATE           DATE                       NOT NULL,
  SERVICE_TAX        NUMBER(10,8)               NOT NULL,
  EDUCATION_CESS     NUMBER(10,8)               NOT NULL,
  HIGHER_EDU_CESS    NUMBER(10,8)               NOT NULL,
  BRANCH_ID          VARCHAR2(30),
  CREATED_DT         DATE,
  CREATED_BY         VARCHAR2(50),
  STATUS             VARCHAR2(30),
  STATUS_BY          VARCHAR2(50),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(30),
  AUTHORIZED_BY      VARCHAR2(50),
  AUTHORIZED_DATE    DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
NOMONITORING;


ALTER TABLE SERVICE_TAX_SETTINGS ADD ( CONSTRAINT SERVICE_TAX_SETTINGS_PK PRIMARY KEY (SERVICETAX_GEN_ID));

ALTER TABLE PARAMETERS ADD (SERVICE_TAX_REQ VARCHAR2(3 BYTE) DEFAULT 'N');

ALTER TABLE AC_HD_PARAM ADD (SERVICE_TAX_APPLICABLE VARCHAR2(5 BYTE) DEFAULT 'N');

ALTER TABLE SERVICE_TAX_SETTINGS ADD (END_DATE DATE);

CREATE TABLE SERVICE_TAX_DETAILS
(
  SERVICETAX_DET_ID  VARCHAR2(30)               NOT NULL,
  ACCT_NUM           VARCHAR2(30)               NOT NULL,
  PARTICULARS        VARCHAR2(50),
  SERVICE_TAX_AMT    NUMBER(10,8),              
  EDUCATION_CESS     NUMBER(10,8),               
  HIGHER_EDU_CESS    NUMBER(10,8), 
  ROUND_VAL          VARCHAR2(30),
  BRANCH_ID          VARCHAR2(30),
  CREATED_DT         DATE,
  CREATED_BY         VARCHAR2(50),
  STATUS             VARCHAR2(30),
  STATUS_BY          VARCHAR2(50),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(30),
  AUTHORIZED_BY      VARCHAR2(50),
  AUTHORIZED_DATE    DATE,
  TOTAL_TAX_AMOUNT   NUMBER(10,3)
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
NOMONITORING;


ALTER TABLE SERVICE_TAX_DETAILS ADD ( CONSTRAINT SERVICE_TAX_DETAILS_PK PRIMARY KEY (SERVICETAX_DET_ID));


INSERT INTO ID_GENERATION VALUES('SERVICETAX_DET_ID','1','STD','11 AUG 2014','8','0001');
ALTER TABLE SERVICE_TAX_SETTINGS ADD (TAX_HEAD_ID VARCHAR2(30 BYTE));


--End Version [Script Version - 0.0.74] [ReleaseVersion - 9.2.1.27]--[27-08-2014] -- by Chithra

--Start Version [Script Version - 0.0.75] [ReleaseVersion - 9.2.1.27]--[08-08-2014] -- by Rishad
       
   alter table STANDING_INSTRUCTION_CREDIT add(BRANCH_CODE varchar2(7));
   alter table STANDING_INSTRUCTION_DEBIT add(BRANCH_CODE varchar2(7));

--End Version [Script Version - 0.0.75] [ReleaseVersion - 9.2.1.27]--[8-08-2014] -- by Rishad
--Start Version [Script Version - 0.0.76] [ReleaseVersion - 9.2.1.27]--[27-08-2014] -- by Anju

ALTER TABLE LOANS_PRODUCT ADD GROUP_LOAN VARCHAR2(16);

alter table LOANS_PROD_ACPARAM add (EMI_IN_SIMPLEINTEREST VARCHAR2(2 byte));

CREATE TABLE GROUP_LOAN_PRODUCT
(
  PROD_ID              VARCHAR2(16 BYTE),
  PROD_DESC            VARCHAR2(128 BYTE),
  HOLIDAY_EXEC         VARCHAR2(16 BYTE),
  INT_DAY              NUMBER(16,2),
  INT_MONTH            NUMBER(16,2),
  DEBIT_ALLOW_FOR_DUE  CHAR(1 BYTE),
  STATUS               VARCHAR2(16 BYTE),
  STATUS_DT            DATE,
  AUTHORIZED_STATUS    VARCHAR2(16 BYTE),
  AUTHORIZED_DT        DATE,
  STATUS_BY            VARCHAR2(16 BYTE),
  AUTHORIZED_BY        VARCHAR2(16 BYTE)
)

alter table LOANS_PROD_ACPARAM drop(MAX_AMT_OF_CASH_PAYMENT);

alter table LOANS_PROD_ACPARAM add( MAX_AMT_OF_CASH_PAYMENT NUMBER(16,2));

update LOANS_PROD_ACPARAM set MAX_AMT_OF_CASH_PAYMENT = '9999999999';

INSERT INTO GROUP_LOAN_PRODUCT
SELECT LP.PROD_ID,LP.PROD_DESC,NULL,0,0,NULL,LP.STATUS,LP.STATUS_DT,LP.AUTHORIZE_STATUS,
LP.AUTHORIZE_DT,LP.STATUS_BY,LP.AUTHORIZE_USER FROM LOANS_PRODUCT LP WHERE LP.BEHAVES_LIKE = 'OD';

--End Version [Script Version - 0.0.75] [ReleaseVersion - 9.2.1.27]--[27-08-2014] -- by Anju

--Start Version [Script Version - 0.0.76] [ReleaseVersion - 9.2.1.27]--[28-08-2014] -- by Nidhin

ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD (USER_DEFINED_Y_N VARCHAR2(2 BYTE) DEFAULT 'N');

ALTER TABLE MDS_TRANS_DETAILS ADD (NOTICE_AMT number(18,2) DEFAULT '0');

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS ADD (FROM_AUCTION_ENTRY VARCHAR2(2 BYTE) DEFAULT 'Y');

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS ADD (AFTER_CASH_PAYMENT VARCHAR2(2 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.76] [ReleaseVersion - 9.2.1.27]--[28-08-2014] -- by Nidhin

--Start Version [Script Version - 0.0.77] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Anju Anand

ALTER TABLE USER_MASTER MODIFY EMPLOYEE_ID VARCHAR2 (15 BYTE);

--End Version [Script Version - 0.0.77] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Anju Anand

--Start Version [Script Version - 0.0.78] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Anju

ALTER TABLE gahan_document_details ADD GAHAN_YESNO VARCHAR2(16);
ALTER TABLE INDEND_REGISTER ADD BRANCH_CODE VARCHAR2(16);
ALTER TABLE mds_scheme_details ADD BRANCH_CODE VARCHAR2(16);

update mds_scheme_details msd set branch_code=(select branch_code from 
(select distinct scheme_name,branch_code from mds_application) a 
where a.scheme_name=msd.scheme_name);

--End Version [Script Version - 0.0.78] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Anju

--Start Version [Script Version - 0.0.79] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Jeffin John

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
    RECORD_KEY_COL, SCREEN_DESC)
 VALUES
   ('SCR06130', '6130', 'Back Dated Entry Deletion', 'APP01', 'DONE',
    '14', 'com.see.truetransact.ui.batchprocess.backdatedentrydeletion.BackDatedEntryDeletion', 3, 'CREATED', NULL,
    NULL, NULL);
   COMMIT;
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP01014', 'SCR06130', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00001', 'SCR06130', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00002', 'SCR06130', 'CREATED', 'Y', 'Y',
    'Y', 'Y', 'Y', 'Y', NULL);
 
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 VALUES
   ('GRP00003', 'SCR06130', 'CREATED', 'Y', 'Y',
    'Y', 'Y' , 'Y', 'Y', NULL);	
	
DROP VIEW ALL_TRANS;

/* Formatted on 2014/09/09 13:01 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_trans (trans_id,
                                             batch_id,
                                             ac_hd_id,
                                             act_num,
                                             amount,
                                             trans_dt,
                                             trans_type,
                                             inst_type,
                                             inst_dt,
                                             token_no,
                                             init_trans_id,
                                             init_chann_type,
                                             particulars,
                                             status,
                                             instrument_no1,
                                             instrument_no2,
                                             prod_id,
                                             prod_type,
                                             authorize_status,
                                             authorize_by,
                                             authorize_dt,
                                             authorize_remarks,
                                             status_by,
                                             branch_id,
                                             status_dt,
                                             trans_mode,
                                             initiated_branch,
                                             authorize_status_2,
                                             link_batch_id,
                                             payment_status,
                                             gl_trans_act_num,
                                             narration,
                                             single_trans_id,
                                             trans_mod_type
                                            )
AS
   (SELECT "TRANS_ID", '' AS "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
           "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT", "TOKEN_NO",
           "INIT_TRANS_ID", "INIT_CHANN_TYPE", "PARTICULARS", "STATUS",
           "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID", "PROD_TYPE",
           "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID", "STATUS_DT",
           'CASH' AS "TRANS_MODE", "INITIATED_BRANCH", "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID", "PAYMENT_STATUS",
           gl_trans_act_num AS "GL_TRANS_ACT_NUM", narration AS "NARRATION",
           single_trans_id AS "SINGLE_TRANS_ID",
           trans_mod_type AS "TRANS_MOD_TYPE"
      FROM "CASH_TRANS"
    UNION ALL
    SELECT "TRANS_ID", "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
           "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT",
           NULL AS "TOKEN_NO", "INIT_TRANS_ID", "INIT_CHANN_TYPE",
           "PARTICULARS", "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2",
           "PROD_ID", "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY",
           "AUTHORIZE_DT", "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID",
           "STATUS_DT", "TRANS_MODE", "INITIATED_BRANCH",
           "AUTHORIZE_STATUS_2", "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", gl_trans_act_num AS "GL_TRANS_ACT_NUM",
           narration AS "NARRATION", single_trans_id AS "SINGLE_TRANS_ID",
           trans_mod_type AS "TRANS_MOD_TYPE"
      FROM transfer_trans
    UNION ALL
    SELECT "INWARD_ID" AS "TRANS_ID", NULL AS "BATCH_ID", "AC_HD_ID",
           "ACCT_NO" AS "ACT_NUM", "AMOUNT", "CLEARING_DT" AS "TRANS_DT",
           'DEBIT' AS "TRANS_TYPE", "INSTRUMENT_TYPE" AS "INST_TYPE",
           "INSTRUMENT_DT" AS "INST_DT", NULL AS "TOKEN_NO",
           "SUSER_ID" AS "INIT_TRANS_ID",
           "INITIATED_BRANCH" AS "INIT_CHANN_TYPE", '' AS "PARTICULARS",
           "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID",
           "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS", "CREATED_BY" AS "STATUS_BY", "BRANCH_ID",
           "S_DATE" AS "STATUS_DT", 'CLEARING' AS "TRANS_MODE",
           "INITIATED_BRANCH", '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID", '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM", '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE"
      FROM inward_clearing
     WHERE authorize_status != 'REJECTED'
       AND inward_id NOT IN (SELECT inward_id
                               FROM inward_bouncing)
    UNION ALL
    SELECT ib.bouncing_id AS trans_id, NULL AS batch_id, ic.ac_hd_id,
           ic.acct_no AS act_num, ib.amount, ib.clearing_date AS trans_dt,
           'CREDIT' AS trans_type, ic.instrument_type AS "INST_TYPE",
           ic.instrument_dt AS "INST_DT", NULL AS "TOKEN_NO",
           ib.status_by AS "INIT_TRANS_ID",
           ic.initiated_branch AS init_chann_type,
           'INWARD RETURN : ' || ib.bouncing_reason AS particulars, ib.status,
           ic.instrument_no1, ic.instrument_no2, ic.prod_id, ic.prod_type,
           ib.authorize_status, ib.authorize_by, ib.authorize_dt,
           ic.authorize_remarks, ib.status_by, ib.branch_id, ib.status_dt,
           'CLEARING' AS "TRANS_MODE", ib.branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE"
      FROM inward_bouncing ib, inward_clearing ic
     WHERE ic.authorize_status = 'REJECTED' AND ib.inward_id = ic.inward_id
    UNION ALL
    SELECT oc.batch_id AS "TRANS_ID", oc.schedule_no AS "BATCH_ID",
           pis.ac_hd_id AS "AC_HD_ID", pis.acct_no AS "ACT_NUM",
           DECODE (t.table_name,
                   'OUTWARD_CLEARING', oc.amount,
                   pis.amount
                  ) AS amount,
           oc.outward_dt AS "TRANS_DT", 'CREDIT' AS "TRANS_TYPE",
           '' AS "INST_TYPE", NULL AS "INST_DT", NULL AS "TOKEN_NO",
           oc.status_by AS "INIT_TRANS_ID", oc.branch_id AS "INIT_CHANN_TYPE",
           'By oclg' AS "PARTICULARS", oc.status, '' AS "instrument_no1",
           '' AS "instrument_no2", '' AS "PROD_ID", '' AS "PROD_TYPE",
           'AUTHORIZED' AS authorize_status, oc.authorize_by, oc.authorize_dt,
           oc.authorize_remarks, oc.status_by, oc.branch_id, oc.status_dt,
           'CLEARING' AS "TRANS_MODE", oc.branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE"
      FROM outward_clearing oc,
           pay_in_slip pis,
           outward_tally ot,
           (SELECT   batch_id,
                     DECODE (COUNT (*),
                             1, 'PAY_IN_SLIP',
                             'OUTWARD_CLEARING'
                            ) AS table_name
                FROM outward_clearing
            GROUP BY batch_id) t
     WHERE oc.batch_id = t.batch_id
       AND pis.batch_id = t.batch_id
       AND ot.schedule_no = oc.schedule_no
       AND ot.tally_status = 'CLOSED'
    UNION ALL
    SELECT trans_id AS "TRANS_ID", NULL AS "BATCH_ID", ac_hd_id,
           NULL AS "ACT_NUM", amount, trans_dt, trans_type, inst_type,
           inst_dt, NULL AS "TOKEN_NO", init_trans_id, init_chann_type,
           particulars, status, instrument_no1, instrument_no2, prod_id,
           prod_type, 'AUTHORIZED' AS authorize_status, NULL AS authorize_by,
           NULL AS authorize_dt, NULL AS authorize_remarks, NULL AS status_by,
           branch_id, status_dt, trans_mode, branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE"
      FROM trans_ref_gl
     WHERE trans_mode = 'CLEARING'
    UNION ALL
    SELECT otr.return_id AS "TRANS_ID", otr.batch_id AS "BATCH_ID",
           '' AS "AC_HD_ID", otr.acct_no AS actnum, otr.amount,
           otr.clearing_date AS "TRANS_DT", 'DEBIT' AS trans_type,
           otc.instrument_type AS inst_type, otc.instrument_dt AS "INST_DT",
           NULL AS "TOKEN_NO", otr.status_by AS "INIT_TRANS_ID",
           otr.branch_id AS "INIT_CHANN_TYPE",
           'OUTWARD RETURN : ' || otc.authorize_remarks AS patriculars,
           otr.status, otr.instrument_no1, otr.instrument_no2,
           '' AS "PROD_ID", '' AS "PROD_TYPE", otr.authorize_status,
           otr.authorize_by, otr.authorize_dt, otr.authorize_remarks,
           otr.status_by, otr.branch_id, otr.status_dt,
           'CLEARING' AS "TRANS_MODE", otr.initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE"
      FROM outward_return otr, outward_clearing otc
     WHERE otc.authorize_status = 'REJECTED' AND otr.batch_id = otc.batch_id);	
					  
DROP VIEW ALL_TRANSACTIONS_VIEW;

/* Formatted on 2014/09/01 15:59 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_transactions_view (trans_id,
                                                         batch_id,
                                                         ac_hd_id,
                                                         act_num,
                                                         amount,
                                                         trans_dt,
                                                         trans_type,
                                                         inst_type,
                                                         inst_dt,
                                                         particulars,
                                                         status,
                                                         instrument_no1,
                                                         instrument_no2,
                                                         prod_id,
                                                         prod_type,
                                                         authorize_status,
                                                         authorize_by,
                                                         status_by,
                                                         status_dt,
                                                         trans_mode,
                                                         branch_id,
                                                         initiated_branch,
                                                         authorize_status_2,
                                                         single_trans_id,
                                                         link_batch_id,
                                                         trans_mod_type
                                                        )
AS
   SELECT trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt, trans_type,
          inst_type, inst_dt, particulars, status, instrument_no1,
          instrument_no2, prod_id, prod_type, authorize_status, authorize_by,
          status_by, status_dt, trans_mode, branch_id, initiated_branch,
          authorize_status_2, single_trans_id, link_batch_id, trans_mod_type
     FROM (SELECT   trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt,
                    trans_type, inst_type, inst_dt, particulars, status,
                    instrument_no1, instrument_no2, prod_id, prod_type,
                    authorize_status, authorize_by, status_by, status_dt,
                    trans_mode, branch_id, initiated_branch,
                    authorize_status_2, single_trans_id, link_batch_id,
                    trans_mod_type
               FROM all_trans
           ORDER BY status_dt);
		   
DROP VIEW all_grp_trn_new;		   

/* Formatted on 2014/08/23 11:33 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_grp_trn_new (branch_id,
                                                     trans_dt,
                                                     ac_hd_id,trans_type,
                                                     cr,
                                                     dr
                                                    )
AS
   SELECT   branch_id, trans_dt, ac_hd_id,trans_type,
            NVL (SUM ((CASE
                          WHEN trans_type = 'CREDIT'
                             THEN amount
                          ELSE 0
                       END)),
                 0
                ) AS cr,
            NVL (SUM ((CASE
                          WHEN trans_type = 'DEBIT'
                             THEN amount
                          ELSE 0
                       END)),
                 0
                ) AS dr
       FROM all_trans
      WHERE trans_dt >= '01-APR-2011'
        AND status != 'DELETED'
        AND authorize_status = 'AUTHORIZED'
   GROUP BY branch_id, trans_dt, ac_hd_id,trans_type;



CREATE OR REPLACE PROCEDURE  GLUPDATE (FRM_date date ,brcode varchar2 ,ACHDID VARCHAR2) AS
 /*

  EXECUTE GLUPDATE ('31-MAR-2013','0001','1091001002');
  
  */
    Start_date date := FRM_date;
    BALTYPE VARCHAR2(20); 
    End_date date;
     
    
 BEGIN
        DELETE from GL_ABSTRACT WHERE DT > FRM_date  AND BRANCH_CODE=brcode
        AND  AC_HD_ID =ACHDID; 
        SELECT CURR_APPL_DT INTO End_date FROM DAY_END WHERE BRANCH_CODE=brcode;
 
   WHILE Start_date< End_date
    LOOP   
       Start_date := Start_date + 1;
       --(BALTYPE ='INCOME' OR BALTYPE ='LIABILITY')   
       SELECT MJR_AC_HD_TYPE INTO BALTYPE FROM MJR_AC_HD MJ WHERE MJ.MJR_AC_HD_ID = SUBSTR(ACHDID,1,4); 
       INSERT INTO  GL_ABSTRACT
        (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT, BALANCE_TYPE)
       select GLA.AC_HD_ID, GLA.CLOSE_BAL,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 
        ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.DR,0))-NVL(TR.CR,0))
        ELSE   ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.CR,0))-NVL(TR.DR,0))  END)    
       ,GLA.BRANCH_CODE, Start_date  ,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 'DEBIT' 
        ELSE  'CREDIT' END) AS BALANCE_TYPE
        from GL_ABSTRACT GLA
         LEFT OUTER JOIN
            (SELECT AC_HD_ID,SUM(NVL(CR,0)) AS CR ,
            SUM(NVL(DR,0)) AS DR    
             FROM ALL_GRP_TRN_NEW WHERE TRANS_DT  = Start_date AND BRANCH_ID =brcode AND AC_HD_ID =ACHDID    
               AND  AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
             UNION SELECT IBR_AC_HD FROM PARAMETERS) GROUP BY AC_HD_ID) TR ON TR.AC_HD_ID = GLA.AC_HD_ID
            
        WHERE GLA.DT = Start_date-1 AND GLA.BRANCH_CODE=brcode AND  GLA.AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
        UNION SELECT IBR_AC_HD FROM PARAMETERS)  AND GLA.AC_HD_ID =ACHDID;
        
       COMMIT;  
       
    END LOOP;
    
    
    DELETE FROM GL WHERE BRANCH_CODE = brcode AND AC_HD_ID = ACHDID; 
    COMMIT;
    insert into  GL(ac_hd_id,opn_bal,cur_bal,branch_code,last_trans_dt,authorize_status,balance_type) 
    (select ac_hd_id,opn_bal,CLOSE_BAL,branch_code,dt,'AUTHORIZED',balance_type from  "GL_ABSTRACT"
     WHERE DT =(SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode) AND AC_HD_ID = ACHDID  ); 
    COMMIT;
        UPDATE GL_ABSTRACT SET  CLOSE_BAL =NULL WHERE BRANCH_CODE =brcode AND AC_HD_ID =ACHDID AND DT=(
        SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode);
    COMMIT; 
    
    --- WHOLE BRANCHES VALUE IS UPDATED IN THIS TABLE
  UPDATE  AC_HD_PARAM  SET 
   BALANCETYPE =(select (CASE WHEN (MJR_AC_HD_TYPE ='ASSETS' OR MJR_AC_HD_TYPE='EXPENDITURE') THEN 'DEBIT'
         ELSE 'CREDIT' END)   from MJR_AC_HD where  MJR_AC_HD_ID=SUBSTR(ACHDID,1,4)),
   GLBALANCE= ( SELECT SUM(CUR_BAL) FROM GL WHERE  AC_HD_ID = ACHDID)
   where AC_HD_ID =ACHDID;   
   
  COMMIT; 
  
     UPDATE  AC_HD_PARAM  SET    
     BALANCETYPE =      ( CASE WHEN BALANCETYPE='DEBIT' THEN 'CREDIT' ELSE 'DEBIT'
                         END )  WHERE GLBALANCE <0 AND AC_HD_ID = ACHDID;
    
  COMMIT;
 END;
/
					  
CREATE OR REPLACE FUNCTION BACKDATEDtRANSACTION(P_ACCT_ID IN VARCHAR ,AMOUNT IN NUMBER ,
P_FROM_DT IN DATE,P_TO_DT IN DATE ,P_BALANCE_TYPE IN VARCHAR, P_BRANCH_CODE IN VARCHAR)
RETURN VARCHAR2 IS CUR VARCHAR2(16);

FIRSTIF VARCHAR2(16) :='Y';
SECONDTIF VARCHAR2(16):='Y';
PREVIOUSDT DATE;

PREVIOUSAMT NUMBER (16,2):=0;
PRAGMA  AUTONOMOUS_TRANSACTION; 

BEGIN

FOR I IN (SELECT AC_HD_ID,OPN_BAL,CLOSE_BAL,BRANCH_CODE,DT,BALANCE_TYPE  FROM 
GL_ABSTRACT WHERE BRANCH_CODE=P_BRANCH_CODE AND AC_HD_ID=P_ACCT_ID AND DT>P_FROM_DT ORDER BY DT ) LOOP

IF P_BALANCE_TYPE= I.BALANCE_TYPE   THEN
    IF FIRSTIF ='Y' THEN
    PREVIOUSDT:=TO_DATE(I.DT)-1;
    PREVIOUSAMT:=AMOUNT*2;
    UPDATE  GL_ABSTRACT SET CLOSE_BAL=CLOSE_BAL+AMOUNT   
    WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=PREVIOUSDT ;
    --DBMS_OUTPUT.PUT_LINE('FIRST TO_DATE(I.DT)-1   ' || PREVIOUSDT);
   END IF;
   UPDATE  GL_ABSTRACT SET OPN_BAL=OPN_BAL+ AMOUNT, CLOSE_BAL=CLOSE_BAL+AMOUNT   
   WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=I.DT ;
   FIRSTIF :='N';
   SECONDTIF:='Y';
END IF;

IF P_BALANCE_TYPE != I.BALANCE_TYPE   THEN

    IF SECONDTIF ='Y' THEN
    PREVIOUSDT:=TO_DATE(I.DT)-1;
    PREVIOUSAMT:=AMOUNT*2;
    UPDATE  GL_ABSTRACT SET CLOSE_BAL=CLOSE_BAL-AMOUNT 
    WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=PREVIOUSDT ;
     --DBMS_OUTPUT.PUT_LINE('TO_DATE(I.DT)  ' ||PREVIOUSDT);
    END IF;
UPDATE  GL_ABSTRACT SET OPN_BAL=OPN_BAL- AMOUNT  ,CLOSE_BAL=CLOSE_BAL-AMOUNT  
WHERE AC_HD_ID =I.AC_HD_ID AND BRANCH_CODE=I.BRANCH_CODE AND DT=I.DT ;
SECONDTIF:='N';
 FIRSTIF :='Y';
END IF;

END LOOP;

COMMIT;
RETURN CUR ;
END;
/		

update TRANSFER_TRANS t set T.TRANS_MOD_TYPE = 'GL' where T.TRANS_MOD_TYPE = '15';

update TRANSFER_TRANS t set T.TRANS_MOD_TYPE = 'AB' where T.TRANS_MOD_TYPE = '9';

update TRANSFER_TRANS t set T.TRANS_MOD_TYPE = 'OA' where T.TRANS_MOD_TYPE = '2';			  

--End Version [Script Version - 0.0.79] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.80] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Shihad

ALTER TABLE DED_EXEMPTION_LIST_DETAIL MODIFY EXEMPTION_MODE VARCHAR2(32 BYTE);

--End Version [Script Version - 0.0.80] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Shihad

--Start Version [Script Version - 0.0.81] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Anju

update screen_master sm set status ='DELETED' where SM.SCREEN_NAME = 'Account Head' and SM.MODULE_ID = 1 ;

--End Version [Script Version - 0.0.81] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Anju

--Start Version [Script Version - 0.0.82] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Babu

ALTER TABLE DAILY_LOAN_COLLECTION_DETAILS ADD BRANCH_ID VARCHAR2(22);

ALTER TABLE DAILY_LOAN_ADJUSTMENT_DETAILS ADD BRANCH_ID VARCHAR2(22);

--End Version [Script Version - 0.0.82] [ReleaseVersion - 9.2.1.27]--[09-09-2014] -- by Babu

--Start Version [Script Version - 0.0.83] [ReleaseVersion - 9.2.1.27]--[12-09-2014] -- by Jeffin John

alter table LOAN_CHARGE_DEFINITION modify CHARGE_DESC varchar2(32 byte);  

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'RISK FUND', 'Risk Fund', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'LEGAL CHARGE', 'Legal Charge', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'MISC INCOME', 'Miscelaneous Income', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'MISC INCOME MBS', 'Miscelaneous Income MBS', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'ESTIMATION FEE', 'Estimation Fee', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'SITE INSPECTION FEE', 'Site Inspection Fee', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'BUILDING FEE', 'Building Fee', 'CREATED', 'Y', 
    'Y');

Insert into LOOKUP_MASTER_DESC
   (LOOKUP_ID, LOOKUP_ID_DESC, EDITABLE, AUTHORIZE_STATUS, AUTHORIZE_BY, 
    AUTHORIZE_DT, STATUS_BY, STATUS_DT)
 Values
   ('CHARGE DESC', 'Charge Descriptions', 'Y', 'AUTHORIZED', 'admin', 
    NULL, 'sysadmin', NULL);

--End Version [Script Version - 0.0.83] [ReleaseVersion - 9.2.1.27]--[12-09-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.84] [ReleaseVersion - 9.2.1.27]--[12-09-2014] -- by sreekrishnan
    UPDATE LOANS_PRODUCT SET GROUP_LOAN = 'N' ; 
  
    ALTER TABLE GROUP_LOAN_PRODUCT ADD BRANCH_CODE VARCHAR2(16);
    
    SET DEFINE OFF;
    Insert into SCREEN_MASTER
        (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
        MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
        RECORD_KEY_COL, SCREEN_DESC)
    Values
        ('SCR08886', '3', 'Group Loan', 'APP01', 'DONE', 
        '5', NULL, 41, 'CREATED', NULL, 
        NULL, 'Group Loan');
    Insert into SCREEN_MASTER
        (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
        MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
        RECORD_KEY_COL, SCREEN_DESC)
    Values
        ('SCR08885', '3', 'Group Loan Payment', 'APP01', 'DONE', 
        '5', NULL, 40, 'CREATED', NULL, 
        NULL, 'Group Loan Payment');
    Insert into SCREEN_MASTER
        (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
        MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
        RECORD_KEY_COL, SCREEN_DESC)
    Values
        ('SCR08884', '3', 'Group Loan Customer', 'APP01', 'DONE', 
        '5', NULL, 39, 'CREATED', NULL, 
        NULL, 'Group Loan Payment');
    COMMIT;
    
    call INSERT_REPORT_GROUP('SCR08884');
    call INSERT_REPORT_GROUP('SCR08885');
    call INSERT_REPORT_GROUP('SCR08886');

    CREATE OR REPLACE FUNCTION GET_CUST_LOAN_MEMBER_NO(ACTNUM IN VARCHAR2) RETURN VARCHAR2 IS
        SHARE_NO VARCHAR2(10);
    BEGIN
        BEGIN
            SELECT SA.SHARE_ACCT_NO INTO SHARE_NO FROM LOANS_FACILITY_DETAILS LF,LOANS_BORROWER LB,SHARE_ACCT SA WHERE
            LB.BORROW_NO = LF.BORROW_NO
            AND SA.CUST_ID = LB.CUST_ID
            AND LF.ACCT_NUM= ACTNUM;
        EXCEPTION
            WHEN OTHERS THEN SHARE_NO := NULL;
        END;
        RETURN SHARE_NO;
    END;
    /

    CREATE TABLE GROUP_LOAN__TRANS_DETAILS
    (
        CUST_ID            VARCHAR2(16 BYTE),
        PRINCIPLE          NUMBER,
        INTEREST           NUMBER,
        PENAL              NUMBER,
        CHARGES            NUMBER,
        STATUS             VARCHAR2(16 BYTE),
        STATUS_DT          DATE,
        AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
        AUTHORIZED_DT      DATE,
        TRANS_TYPE         VARCHAR2(16 BYTE),
        STATUS_BY          VARCHAR2(16 BYTE),
        AUTHORIZED_BY      VARCHAR2(16 BYTE),
        TRANS_DT           DATE,
        ACT_NUM            VARCHAR2(16 BYTE),
        REPAY_DT           DATE,
        TRANS_ID           VARCHAR2(16 BYTE),
        TRANS_SLNO         NUMBER,
        NARRATION          VARCHAR2(200 BYTE)
    )

   CREATE TABLE GROUP_LOAN_DETAILS
    (
        ACT_NUM            VARCHAR2(16 BYTE),
        CUST_ID            VARCHAR2(16 BYTE),
        LIMIT              NUMBER,
        STATUS             VARCHAR2(16 BYTE),
        STATUS_DT          DATE,
        AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
        AUTHORIZED_DT      DATE,
        STATUS_BY          VARCHAR2(16 BYTE),
        AUTHORIZED_BY      VARCHAR2(16 BYTE),
        CREDIT_CARD_NO     VARCHAR2(16 BYTE)
        )
    TABLESPACE CBMSDATA
    PCTUSED    0
    PCTFREE    10
    INITRANS   1
    MAXTRANS   255
    STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
    LOGGING 
    NOCOMPRESS 
    NOCACHE
    NOPARALLEL
    MONITORING;

    CREATE UNIQUE INDEX GROUP_LOAN_DETAILS_PK ON GROUP_LOAN_DETAILS
    (CREDIT_CARD_NO)
    LOGGING
    TABLESPACE CBMSDATA
    PCTFREE    10
    INITRANS   2
    MAXTRANS   255
    STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
        NOPARALLEL;


        ALTER TABLE GROUP_LOAN_DETAILS ADD (
            CONSTRAINT GROUP_LOAN_DETAILS_PK
        PRIMARY KEY
        (CREDIT_CARD_NO)
        USING INDEX 
        TABLESPACE CBMSDATA
        PCTFREE    10
        INITRANS   2
        MAXTRANS   255
        STORAGE    (
                INITIAL          64K
                MINEXTENTS       1
                MAXEXTENTS       UNLIMITED
                PCTINCREASE      0
               ));

       CREATE OR REPLACE FUNCTION GET_CUST_NAME(CUSTID IN VARCHAR2) RETURN VARCHAR2 IS
        CUSTNAME VARCHAR2(50);
        BEGIN
        SELECT 
        CASE WHEN  CUST_TYPE='INDIVIDUAL' THEN 
        FNAME||' '||MNAME||' '||LNAME
        ELSE
            COMP_NAME 
        END INTO CUSTNAME
        FROM CUSTOMER
        WHERE CUST_ID = CUSTID AND STATUS !='DELETED';
        RETURN CUSTNAME;
        END;
        /

        CREATE OR REPLACE FUNCTION GET_GROUP_LOAN_INTEREST(ACTNUM VARCHAR,CUSTID VARCHAR,ASONDT DATE)
        RETURN NUMBER IS
        /* Function for Calculating Interest For Group_Loan in Peringadur SCB */
        --DECLARE
        --    ACTNUM VARCHAR2(13) := '0001500000001';
        --    ASONDT DATE := '28-JUN-2014';    
        --    CUSTID VARCHAR2(13) := 'C010000222';
            LOANDATE DATE;
            INTRECEIVABLE NUMBER(16,2) := 0;
            INTRECEIVED NUMBER(16,2) := 0;
            ROI NUMBER(16,2) := 0;
            TRNDATE DATE; 
            PRNBAL NUMBER(16,2) := 0;
            STARTDATE DATE;
            LOANBAL NUMBER(16,2) := 0;
            FIRST_PAY_DATE DATE;
        BEGIN
            SELECT GET_GROUP_LOAN_BALANCE(ACTNUM,CUSTID,ASONDT) INTO LOANBAL FROM DUAL;
            IF LOANBAL <= 0 THEN
                INTRECEIVABLE := 0;
                RETURN INTRECEIVABLE;
                --DBMS_OUTPUT.PUT_LINE( ' INTRECEIVABLE ' || INTRECEIVABLE);
            END IF;
            SELECT MIN(GLTD.TRANS_DT) INTO LOANDATE FROM GROUP_LOAN__TRANS_DETAILS GLTD 
            WHERE GLTD.ACT_NUM = ACTNUM AND GLTD.CUST_ID = CUSTID AND GLTD.TRANS_TYPE='DEBIT';
            SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM GROUP_LOAN__TRANS_DETAILS LT
            WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > LOANDATE AND LT.TRANS_DT <= ASONDT;
            SELECT CASE WHEN LFD.INT_GET_FROM = 'ACT' THEN
                            (SELECT MAX(LIM.INTEREST) FROM LOANS_INT_MAINTENANCE LIM WHERE LIM.ACCT_NUM = LFD.ACCT_NUM AND LIM.STATUS != 'DELETED' )
                        WHEN LFD.INT_GET_FROM = 'PROD' THEN
                             GET_TL_ROI(LFD.PROD_ID,LSD.FROM_DT,LSD.LIMIT)
                        ELSE 0 END INTO ROI
            FROM LOANS_FACILITY_DETAILS LFD
            JOIN LOANS_SANCTION_DETAILS LSD ON LFD.BORROW_NO = LSD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            --DBMS_OUTPUT.PUT_LINE( ' ROI ' || ROI);
            STARTDATE := LOANDATE;
        DECLARE CURSOR LOANTRANS IS 
            SELECT T.TRANS_DT,T.PRINCIPLE,T.TRANS_TYPE,T.REPAY_DT AS INSTDATE
            FROM GROUP_LOAN__TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.CUST_ID = CUSTID AND T.TRANS_DT <= TRUNC(ASONDT,'MM')-1 
            AND T.TRANS_DT >= LOANDATE AND T.PRINCIPLE > 0 AND T.TRANS_TYPE='DEBIT' 
            AND T.STATUS != 'DELETED' AND T.AUTHORIZED_STATUS = 'AUTHORIZED'
            UNION
            SELECT T.TRANS_DT,T.PRINCIPLE,T.TRANS_TYPE,T.REPAY_DT AS INSTDATE
            FROM GROUP_LOAN__TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.CUST_ID = CUSTID AND T.TRANS_DT <= ASONDT
            AND T.TRANS_DT >= LOANDATE AND T.TRANS_TYPE='CREDIT' AND
            T.STATUS != 'DELETED' AND T.AUTHORIZED_STATUS = 'AUTHORIZED'
            UNION
            SELECT ASONDT AS TRANS_DT,0 AS PRINCIPLE,'DEBIT' AS TRANS_TYPE,NULL AS INSTDATE
            FROM DUAL
            ORDER BY TRANS_DT ASC;
            TRANSDT GROUP_LOAN__TRANS_DETAILS.TRANS_DT%TYPE;
            I NUMBER(16,2) := 0;
            BEGIN
                FOR TRN IN LOANTRANS LOOP
                    SELECT NVL(SUM(CASE WHEN T.TRANS_TYPE = 'DEBIT' THEN 1 ELSE -1 END * T.PRINCIPLE),0) INTO PRNBAL  
                    FROM GROUP_LOAN__TRANS_DETAILS T
                    WHERE T.ACT_NUM = ACTNUM AND T.CUST_ID = CUSTID AND T.TRANS_DT < TRN.TRANS_DT AND (T.REPAY_DT < ASONDT OR T.REPAY_DT IS NULL) 
                    AND T.STATUS != 'DELETED' AND T.AUTHORIZED_STATUS = 'AUTHORIZED';
                    TRNDATE := TRN.TRANS_DT ;
                    --DBMS_OUTPUT.PUT_LINE( ' INTRECEIVABLE ' || INTRECEIVABLE || 'PRNBAL ' || PRNBAL || ' TRN.TRANS_DT ' || TRN.TRANS_DT || ' STARTDATE ' || STARTDATE || 'ROI ' || ROI);
                    INTRECEIVABLE := INTRECEIVABLE +  (PRNBAL * (TRN.TRANS_DT - STARTDATE) * ROI/ 36500);
                    --DBMS_OUTPUT.PUT_LINE( ' INTRECEIVABLE ' || INTRECEIVABLE);
                    STARTDATE := TRN.TRANS_DT;
                END LOOP;
            END;
            INTRECEIVABLE := INTRECEIVABLE - NVL(INTRECEIVED,0);
            IF INTRECEIVABLE < 0 THEN
                INTRECEIVABLE := 0;
            END IF;
            INTRECEIVABLE := ROUND(INTRECEIVABLE);
            --DBMS_OUTPUT.PUT_LINE(' PRNBAL ' || PRNBAL || ' INTRECEIVABLE ' || INTRECEIVABLE || ' ROI ' || ROI);    
            RETURN INTRECEIVABLE;
        END;
        /

                CREATE OR REPLACE FUNCTION GET_GROUP_LOAN_PENINT(ACTNUM VARCHAR,ASONDT DATE,CUSTID VARCHAR2)
        RETURN NUMBER IS
        --DECLARE
        --    ACTNUM VARCHAR2(13) := '0001500000001';
        --    ASONDT DATE := '28-JUN-2014';    
        --    CUSTID VARCHAR2(13) := 'C010000222';
            PENINTRECEIVABLE NUMBER(16,2) := 0;
            PENINTRECEIVED NUMBER(16,2) := 0;
            PENROI NUMBER(16,2) := 0;
            BALANCE NUMBER(16,2) := 0;
            DUEDATE DATE;
            LOANDATE DATE;
        BEGIN
            SELECT GET_GROUP_LOAN_BALANCE(ACTNUM,CUSTID,ASONDT) INTO BALANCE FROM DUAL;
            IF BALANCE <= 0 THEN
                PENINTRECEIVABLE := 0;
                RETURN PENINTRECEIVABLE;
                --DBMS_OUTPUT.PUT_LINE( ' PENINTRECEIVABLE ' || PENINTRECEIVABLE);
            END IF;
            SELECT MIN(GLTD.TRANS_DT) INTO LOANDATE FROM GROUP_LOAN__TRANS_DETAILS GLTD 
            WHERE GLTD.ACT_NUM = ACTNUM AND GLTD.CUST_ID = CUSTID AND GLTD.TRANS_TYPE='DEBIT' 
            AND GLTD.STATUS != 'DELETED' AND GLTD.AUTHORIZED_STATUS = 'AUTHORIZED';
            SELECT MAX(I.PENAL_INTEREST) INTO PENROI FROM LOANS_INT_MAINTENANCE I 
                WHERE I.ACCT_NUM = ACTNUM AND NVL(I.AUTHORIZE_STATUS,'AUTHORIZED') = 'AUTHORIZED' AND
                      I.STATUS != 'DELETED';
            SELECT SD.TO_DT INTO DUEDATE
            FROM LOANS_SANCTION_DETAILS SD
            JOIN LOANS_FACILITY_DETAILS F ON SD.BORROW_NO = F.BORROW_NO
            WHERE F.ACCT_NUM = ACTNUM;
            IF DUEDATE >= ASONDT THEN
                RETURN PENINTRECEIVABLE;
            END IF;
            PENINTRECEIVABLE := (BALANCE * (ASONDT-DUEDATE) * PENROI/36500);
            SELECT NVL(SUM(T.PENAL),0) INTO PENINTRECEIVED
            FROM GROUP_LOAN__TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.CUST_ID = CUSTID AND
                  T.TRANS_DT BETWEEN LOANDATE AND ASONDT AND
                  T.TRANS_TYPE = 'CREDIT' AND T.STATUS != 'DELETED' AND T.AUTHORIZED_STATUS = 'AUTHORIZED';
            PENINTRECEIVABLE := PENINTRECEIVABLE - PENINTRECEIVED;
            PENINTRECEIVABLE := ROUND(PENINTRECEIVABLE,0); 
            IF PENINTRECEIVABLE < 0 THEN
                PENINTRECEIVABLE := 0;
            END IF;
            RETURN PENINTRECEIVABLE;
            --DBMS_OUTPUT.PUT_LINE( ' PENINTRECEIVABLE ' || PENINTRECEIVABLE );
        END;
        /

                CREATE OR REPLACE FUNCTION GET_GROUP_LOAN_BALANCE(ACTNUM VARCHAR,CUSTID VARCHAR,ASONDT DATE)
        RETURN NUMBER IS
        COLLECTEDPRN NUMBER(16,2) := 0;
        BEGIN
            SELECT NVL(SUM(CASE WHEN T.TRANS_TYPE = 'DEBIT' THEN 1 ELSE -1 END * T.PRINCIPLE),0) INTO COLLECTEDPRN
            FROM GROUP_LOAN__TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.CUST_ID = CUSTID AND T.STATUS != 'DELETED' AND T.AUTHORIZED_STATUS = 'AUTHORIZED' AND T.TRANS_DT <= ASONDT;
            RETURN COLLECTEDPRN; 
        END;
        /

        CREATE OR REPLACE FUNCTION GET_GROUP_LOAN_ODBAL(ACTNUM VARCHAR,CUSTID VARCHAR,ASONDT DATE)
        RETURN NUMBER IS
        --DECLARE ACTNUM VARCHAR(13) := '0001500000001';
        --        CUSTID VARCHAR(13) := 'C010005549';
        --        ASONDT DATE := '10-JUL-2014';
          PRNOD NUMBER(16,2) := 0;
          INST_RECEIVABLE NUMBER(16,2) := 0;
          INST_RECEIVED NUMBER(16,2) := 0;
          BALANCE NUMBER(16,2) := 0;
        BEGIN
            BALANCE := GET_GROUP_LOAN_BALANCE(ACTNUM,CUSTID,ASONDT);
            IF (BALANCE < 0) THEN
                RETURN PRNOD;
            END IF;
            SELECT SUM(NVL(GLTD.PRINCIPLE,0)) INTO INST_RECEIVABLE 
            FROM GROUP_LOAN__TRANS_DETAILS GLTD 
            WHERE GLTD.ACT_NUM = ACTNUM AND GLTD.CUST_ID = CUSTID AND 
                  GLTD.TRANS_TYPE ='DEBIT' AND GLTD.REPAY_DT < ASONDT AND
                  GLTD.STATUS != 'DELETED' AND GLTD.AUTHORIZED_STATUS = 'AUTHORIZED';
            SELECT SUM(NVL(GLTD.PRINCIPLE,0)) INTO INST_RECEIVED FROM GROUP_LOAN__TRANS_DETAILS GLTD 
            WHERE GLTD.ACT_NUM = ACTNUM AND GLTD.CUST_ID = CUSTID 
                  AND GLTD.TRANS_TYPE ='CREDIT' AND GLTD.TRANS_DT <= ASONDT AND
                  GLTD.STATUS != 'DELETED' AND GLTD.AUTHORIZED_STATUS = 'AUTHORIZED';
            PRNOD := NVL(INST_RECEIVABLE,0) - NVL(INST_RECEIVED,0);
            IF BALANCE < PRNOD THEN
                PRNOD :=  BALANCE;
            END IF;
            --DBMS_OUTPUT.PUT_LINE( ' PRNOD ' || PRNOD);
            RETURN PRNOD;
        END;
        /

        ALTER TABLE INDEND_REGISTER DROP COLUMN BRANCH_ID;
        ALTER TABLE INDEND_REGISTER ADD BRANCH_ID VARCHAR2(16);
        
--End Version [Script Version - 0.0.84] [ReleaseVersion - 9.2.1.27]--[12-09-2014] -- by sreekrishnan

--Start Version [Script Version - 0.0.85] [ReleaseVersion - 9.2.1.27]--[13-09-2014] -- by Shihad
    
        ALTER TABLE RENT_REGISTER ADD (STATUS_BY VARCHAR2(20 BYTE));
    
        ALTER TABLE RENT_REGISTER ADD (STATUS_DT DATE);
    
        ALTER TABLE RENT_TRANS ADD (STATUS_BY VARCHAR2(20 BYTE));
    
        ALTER TABLE RENT_TRANS ADD (STATUS_DT DATE);

        ALTER TABLE RENT_PROFILE ADD (BRANCH_CODE VARCHAR2(20 BYTE));

--End Version [Script Version - 0.0.85] [ReleaseVersion - 9.2.1.27]--[13-09-2014] -- by Shihad

--Start Version [Script Version - 0.0.86] [ReleaseVersion - 9.2.1.27]--[15-09-2014] -- by Jeffin John

DROP VIEW ALL_PRODUCT_ACCTS1;

/* Formatted on 2014/09/13 15:42 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_product_accts1 (act_num,
                                                      cust_id,
                                                      prod_type,
                                                      prod_id,
                                                      rep_act_num,
                                                      branch_id,
                                                      salary_recovery,
                                                      lock_status,
                                                      acct_status
                                                     )
AS
   (SELECT am.act_num AS act_num, am.cust_id, 'OA' AS prod_type, prod_id,
           am.act_num || '_1' AS rep_act_num, branch_code AS branch_id,
           'N' AS salary_recovery, 'N' AS lock_status,
           am.act_status_id AS acct_status
      FROM act_master am
     WHERE am.authorization_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT da.deposit_no AS act_num, da.cust_id, 'TD' AS prod_type, prod_id,
           da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status
      FROM deposit_acinfo da, deposit_sub_acinfo ds
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.deposit_no = da.deposit_no
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'TL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'ATL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AAD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, am.suspense_customer_id,
           'SA' AS prod_type, am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status
      FROM suspense_account_master am
     WHERE am.authorize_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num, sa.cust_id, 'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.member_no = sa.share_acct_no(+)
       AND am.status != 'DELETED'
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id, 'AB' AS prod_type,
           prod_id, am.act_master_id || '_1' AS rep_act_num,
           branch_id AS branch_id, 'N' AS salary_recovery, 'N' AS lock_status,
           am.status AS acct_status
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

--End Version [Script Version - 0.0.86] [ReleaseVersion - 9.2.1.27]--[15-09-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.87] [ReleaseVersion - 9.2.1.28]--[18-09-2014] -- by Jeffin John

DROP VIEW ALL_PRODUCT_ACCTS1;

/* Formatted on 2014/09/17 18:29 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_product_accts1 (act_num,
                                                           cust_id,
                                                           prod_type,
                                                           prod_id,
                                                           rep_act_num,
                                                           branch_id,
                                                           salary_recovery,
                                                           lock_status,
                                                           acct_status,
                                                           authorization_status
                                                          )
AS
   (SELECT am.act_num AS act_num, am.cust_id, 'OA' AS prod_type, prod_id,
           am.act_num || '_1' AS rep_act_num, branch_code AS branch_id,
           'N' AS salary_recovery, 'N' AS lock_status,
           am.act_status_id AS acct_status,am.authorization_status
      FROM act_master am
     WHERE am.authorization_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT da.deposit_no AS act_num, da.cust_id, 'TD' AS prod_type, prod_id,
           da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status,da.authorize_status
      FROM deposit_acinfo da, deposit_sub_acinfo ds
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.deposit_no = da.deposit_no
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'TL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,lfd.authorize_status_1
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,lfd.authorize_status_1
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'ATL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,lfd.authorize_status_1
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AAD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,lfd.authorize_status_1
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, am.suspense_customer_id,
           'SA' AS prod_type, am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status,am.authorize_status
      FROM suspense_account_master am
     WHERE am.authorize_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num, sa.cust_id, 'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status,am.authorize_status
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.member_no = sa.share_acct_no(+)
       AND am.status != 'DELETED'
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id, 'AB' AS prod_type,
           prod_id, am.act_master_id || '_1' AS rep_act_num,
           branch_id AS branch_id, 'N' AS salary_recovery, 'N' AS lock_status,
           am.status AS acct_status,am.authorized_status
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

--End Version [Script Version - 0.0.87] [ReleaseVersion - 9.2.1.28]--[18-09-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.88] [ReleaseVersion - 9.2.1.28]--[22-09-2014] -- by Jeffin John

DROP VIEW OPERATIVE_SUSPENSE_PROD;

/* Formatted on 2014/09/22 15:21 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW operative_suspense_prod (prod_id,
                                                            prod_desc)
AS
   (SELECT oap.prod_id, oap.prod_desc
      FROM op_ac_product oap
     WHERE oap.authorized_status = 'AUTHORIZED'
       AND oap.status != 'DELETED'
       AND oap.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT sam.prod_id, sam.prod_desc
      FROM suspense_product sam
     WHERE sam.authorized_status = 'AUTHORIZED'
       AND sam.status != 'DELETED'
       AND sam.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL));

--End Version [Script Version - 0.0.88] [ReleaseVersion - 9.2.1.28]--[22-09-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.89] [ReleaseVersion - 9.2.1.28]--[22-09-2014] -- by Babu

CREATE OR REPLACE PROCEDURE GLUPDATE (FRM_date date ,brcode varchar2 ,ACHDID VARCHAR2) AS
 /*

  EXECUTE GLUPDATE ('31-MAR-2013','0001','1091001002');
  
  */
    Start_date date := FRM_date;
    BALTYPE VARCHAR2(20); 
    End_date date;
     
    
 BEGIN
        DELETE from GL_ABSTRACT WHERE DT > FRM_date  AND BRANCH_CODE=brcode
        AND  AC_HD_ID =ACHDID; 
        SELECT CURR_APPL_DT INTO End_date FROM DAY_END WHERE BRANCH_CODE=brcode;
 
   WHILE Start_date< End_date
    LOOP   
       Start_date := Start_date + 1;
       --(BALTYPE ='INCOME' OR BALTYPE ='LIABILITY')   
       SELECT MJR_AC_HD_TYPE INTO BALTYPE FROM MJR_AC_HD MJ WHERE MJ.MJR_AC_HD_ID = SUBSTR(ACHDID,1,4); 
       INSERT INTO  GL_ABSTRACT
        (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT, BALANCE_TYPE)
       select GLA.AC_HD_ID, GLA.CLOSE_BAL,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 
        ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.DR,0))-NVL(TR.CR,0))
        ELSE   ((NVL(GLA.CLOSE_BAL,0)+NVL(TR.CR,0))-NVL(TR.DR,0))  END)    
       ,GLA.BRANCH_CODE, Start_date  ,
        (CASE WHEN (BALTYPE ='ASSETS' OR BALTYPE ='EXPENDITURE') THEN 'DEBIT' 
        ELSE  'CREDIT' END) AS BALANCE_TYPE
        from GL_ABSTRACT GLA
         LEFT OUTER JOIN
            (SELECT AC_HD_ID,SUM(NVL(CR,0)) AS CR ,
            SUM(NVL(DR,0)) AS DR    
             FROM ALL_GRP_TRN_NEW WHERE TRANS_DT  = Start_date AND BRANCH_ID =brcode AND AC_HD_ID =ACHDID    
               AND  AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
             UNION SELECT IBR_AC_HD FROM PARAMETERS) GROUP BY AC_HD_ID) TR ON TR.AC_HD_ID = GLA.AC_HD_ID
            
        WHERE GLA.DT = Start_date-1 AND GLA.BRANCH_CODE=brcode AND  GLA.AC_HD_ID NOT IN(SELECT CASH_AC_HD FROM PARAMETERS 
        UNION SELECT IBR_AC_HD FROM PARAMETERS)  AND GLA.AC_HD_ID =ACHDID;
        
       COMMIT;  
       
    END LOOP;
    
    
    DELETE FROM GL WHERE BRANCH_CODE = brcode AND AC_HD_ID = ACHDID; 
    COMMIT;
    insert into  GL(ac_hd_id,opn_bal,cur_bal,branch_code,last_trans_dt,authorize_status,balance_type) 
    (select ac_hd_id,opn_bal,CLOSE_BAL,branch_code,dt,'AUTHORIZED',balance_type from  "GL_ABSTRACT"
     WHERE DT =(SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode) AND AC_HD_ID = ACHDID AND BRANCH_CODE=brcode);
     --WHERE DT =(SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode) AND AC_HD_ID = ACHDID );   --> Old Code Missing Branch_Code checking outside. 
    COMMIT;
        UPDATE GL_ABSTRACT SET  CLOSE_BAL =NULL WHERE BRANCH_CODE =brcode AND AC_HD_ID =ACHDID AND DT=(
        SELECT CURR_APPL_DT FROM DAY_END WHERE BRANCH_CODE=brcode);
    COMMIT; 
    
 END;
/

ALTER TABLE DAILY_DEPOSIT_TRANS ADD PROD_TYPE VARCHAR(22) ;

ALTER TABLE SUSPENSE_ACCOUNT_MASTER ADD AGENT_ID VARCHAR2(100 Byte);

ALTER TABLE ACT_MASTER ADD AGENT_ID VARCHAR2(100 Byte);

CREATE TABLE TEMPDAILY_KOR
(
  AGENT_ID      VARCHAR2(20 BYTE),
  REFERENCE_NO  VARCHAR2(20 BYTE),
  AMOUNT        NUMBER(16,2),
  DATE1         DATE,
  BRANCH_ID     VARCHAR2(5 BYTE),
  COMM_AMT      NUMBER(16,2)
)

CREATE TABLE AGENT_PROD_MAPPING
(
  PROD_TYPE          VARCHAR2(40 BYTE),
  PROD_ID            VARCHAR2(40 BYTE),
  AGENT_MACHINE_ID   VARCHAR2(40 BYTE),
  COL_AC_HD_ID       VARCHAR2(60 BYTE),
  AGENT_ID           VARCHAR2(16 BYTE),
  COMM_PER_BANK      NUMBER(16,2),
  COMM_PER_AC_HOLDR  NUMBER(16,2),
  COMM_COL_AC_HD_ID  VARCHAR2(60 BYTE),
  PROD_EXP_CODE      VARCHAR2(20 BYTE)
)

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '330', '11 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '60', '2 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '120', '4 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '150', '5 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '210', '7 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '240', '8 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '270', '9 Months', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('DEPOSITSPRODUCT.DEPOSITPERIOD', '300', '10 Months', 'CREATED', NULL, 
    'Y');

--End Version [Script Version - 0.0.89] [ReleaseVersion - 9.2.1.28]--[22-09-2014] -- by Babu

--Start Version [Script Version - 0.0.90] [ReleaseVersion - 9.2.1.28]--[24-09-2014] -- by Jeffin John

CREATE OR REPLACE FUNCTION get_curr_id (
   idkey     VARCHAR2,
   branchid  VARCHAR2
)
   RETURN VARCHAR2
IS
Pragma Autonomous_Transaction;
   id_prefix        ID_GENERATION.PREFIX%TYPE;
   id_currvalue     ID_GENERATION.CURR_VALUE%TYPE;
   id_length        ID_GENERATION.ID_LENGTH%TYPE;
   new_id           VARCHAR2(20);
BEGIN
--    DBMS_OUTPUT.PUT_LINE('idkey :'||idkey||' / branchid'||branchid);
    IF branchid is not null THEN
        SELECT PREFIX, CURR_VALUE, ID_LENGTH INTO id_prefix, id_currvalue, id_length 
            FROM ID_GENERATION WHERE ID_KEY = idkey AND BRANCH_CODE = branchid;
        new_id:=UPPER(id_prefix)||LPAD(id_currvalue+1, id_length-LENGTH(id_prefix), '0');
        UPDATE ID_GENERATION SET CURR_VALUE=CURR_VALUE+1 WHERE ID_KEY=idkey AND BRANCH_CODE = branchid;
    ELSE
        SELECT PREFIX, CURR_VALUE, ID_LENGTH INTO id_prefix, id_currvalue, id_length 
                FROM ID_GENERATION WHERE ID_KEY = idkey;
            new_id:=UPPER(id_prefix)||LPAD(id_currvalue+1, id_length-LENGTH(id_prefix), '0');
            UPDATE ID_GENERATION SET CURR_VALUE=CURR_VALUE+1 WHERE ID_KEY=idkey;
    END IF;
    COMMIT;
    return new_id;
END;
/

--End Version [Script Version - 0.0.90] [ReleaseVersion - 9.2.1.28]--[24-09-2014] -- by Jeffin John

--Strart Version [Script Version - 0.0.91] [ReleaseVersion - 9.2.1.28]--[25-09-2014] -- by Sathiya
CREATE TABLE ACT_INTEREST_TRIAL(
  ACT_NUM         VARCHAR2(16 BYTE),
  INT_DT          DATE,
  INT_TYPE        VARCHAR2(8 BYTE),
  AC_HD_ID        VARCHAR2(16 BYTE),
  APPL_DT         DATE,
  INT_AMT         NUMBER(16,8),
  INT_RATE        NUMBER(11,8),
  PRINCIPLE_AMT   NUMBER(22,8),
  PRODUCT_ID      VARCHAR2(16 BYTE),
  PRODUCT_TYPE    VARCHAR2(8 BYTE),
  TRANS_LOG_ID    VARCHAR2(16 BYTE),
  CUST_ID         VARCHAR2(16 BYTE),
  IS_TDS_APPLIED  VARCHAR2(1 BYTE),
  TDS_AMT         NUMBER(16,2),
  USER_ID         VARCHAR2(32 BYTE),
  BRANCH_CODE     VARCHAR2(32 BYTE)
)

CREATE OR REPLACE FUNCTION deleteaccountinttrail (account_no IN VARCHAR)
   RETURN VARCHAR2
IS
   curval   VARCHAR2 (16);
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   DELETE FROM act_interest_trial
         WHERE act_num = account_no;
   COMMIT;
   RETURN curval;
END;

UPDATE PARAMETERS SET LAST_FINANCIAL_YEAR_END='31-MAR-2014', YEAREND_PROCESS_DT='31-MAR-2014';

UPDATE OP_AC_INTPAY_PARAM  SET CR_INT_APPL_FREQ = 180;

DELETE DEPOSIT_PROVISION WHERE PROD_TYPE IN ('OA');

DECLARE CURSOR A IS SELECT PROD_ID,BRANCH_CODE  FROM OP_AC_PRODUCT, DAY_END ORDER BY 1,2;
  BEGIN
        FOR I IN A LOOP
        INSERT INTO DEPOSIT_PROVISION VALUES('OA',I.PROD_ID,'31-MAR-2014',I.BRANCH_CODE,'','APPLICATION', '31-MAR-2014');
        END LOOP;
 
  END ;
 
CREATE OR REPLACE function deleteAccountIntTrail (ACCOUNT_NO IN   VARCHAR, TODATE IN DATE )
        RETURN VARCHAR2
      IS
         curval   VARCHAR2 (16);
         PRAGMA AUTONOMOUS_TRANSACTION;
      BEGIN    
          DELETE FROM ACT_INTEREST_TRIAL WHERE  ACT_NUM=ACCOUNT_NO AND APPL_DT=TODATE;        
         COMMIT;   
            RETURN curval;
      END;

UPDATE ACT_PARAM_DETAIL SET LAST_CR_INT_APPLDT = '31-MAR-2014' WHERE LAST_CR_INT_APPLDT IS NOT NULL;

--UPDATE ACT_PARAM_DETAIL SET MIN_ACT_BAL=10  WHERE SUBSTR(ACT_NUM,5,3) IN ('101','102' ,'103','103'); (Need to check with their team)

--(Same changes needs to make other SB Product)
Insert into DEPOSIT_ROI_GROUP_TYPE_RATE
   (ROI_GROUP_ID, RATE_TYPE_ID, ROI_DATE, FROM_AMOUNT, TO_AMOUNT, 
    FROM_PERIOD, TO_PERIOD, ROI, PENAL_INT, STATUS, 
    ROI_END_DATE, AGAINST_CLEARING_INT, LIMIT_AMOUNT, INT_EXPIRY_LIMIT, STATEMENT_PENEL, 
    OD_INT_RATE, AUTHORIZE_STATUS, AUTHORIZE_BY, AUTHORIZE_DT, INT_TYPE, 
    ROI_ACTIVE_STATUS, CREATE_DT)
 Values
   ('SB', NULL, TO_DATE('06/10/1990 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 1, 9999999999, 
    1, 364635, 4, 1, 'MODIFIED', 
    NULL, 0, 0, 0, 0, 
    0, 'AUTHORIZED', 'sysadmin', NULL, 'C', 
    'R', NULL);

--(Same changes needs to make other SB Product)
UPDATE DEPOSIT_ROI_GROUP SET PRODUCT_TYPE = 'OA',int_type = 'C' WHERE ROI_GROUP_ID = 'SB'; 

CREATE OR REPLACE FUNCTION Prod_disc(prodid varchar2) RETURN VARCHAR2 IS
VAR_prod_desc VARCHAR2(100);
BEGIN
   SELECT prod_desc INTO VAR_prod_desc FROM all_products where prod_id = prodid;
   RETURN VAR_prod_desc;
END;

--End Version [Script Version - 0.0.91] [ReleaseVersion - 9.2.1.28]--[25-09-2014] -- by Sathiya

--Strart Version [Script Version - 0.0.92] [ReleaseVersion - 9.2.1.28]--[29-09-2014] -- by Chithra

ALTER TABLE DEPOSITS_PROD_INTPAY ADD (INTRATE_EdITABLE VARCHAR2(5 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.92] [ReleaseVersion - 9.2.1.28]--[29-09-2014] -- by Chithra

--Strart Version [Script Version - 0.0.93] [ReleaseVersion - 9.2.1.28]--[01-10-2014] -- by Shihad

ALTER TABLE LOAN_CHARGE_DEFINITION MODIFY CHARGE_BASE VARCHAR2(32 BYTE);

ALTER TABLE DEPOSITS_PROD_INTPAY MODIFY SENIOR_BENIFIT_RATE varchar2(32 BYTE);

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE BASE', 'TOTAL MARKET VALUE', 'Total Market Value', 'CREATED', NULL, 
    'Y');
COMMIT;

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CHARGE DESC', 'INSURANCE CHARGE', 'Insurance Charge', 'CREATED', 'Y', 
    'Y');
COMMIT;


--End Version [Script Version - 0.0.93] [ReleaseVersion - 9.2.1.28]--[01-10-2014] -- by Shihad

--Strart Version [Script Version - 0.0.94] [ReleaseVersion - 9.2.1.28]--[09-10-2014] -- by NidiN

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS ADD (IS_SPLIT_MDS_TRANSACTION VARCHAR2(2 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.94] [ReleaseVersion - 9.2.1.28]--[09-10-2014] -- by NidiN

--Strart Version [Script Version - 0.0.95] [ReleaseVersion - 9.2.1.28]--[09-10-2014] -- by Babu

CREATE OR REPLACE function deleteAccountIntTrailAll (TODATE IN DATE,BRANCH_ID VARCHAR )
        RETURN VARCHAR2
      IS
         curval   VARCHAR2 (16);
         PRAGMA AUTONOMOUS_TRANSACTION;
      BEGIN    
          DELETE FROM ACT_INTEREST_TRIAL WHERE  
          APPL_DT=TODATE AND BRANCH_CODE=BRANCH_ID;        
         COMMIT;   
            RETURN curval;
      END;

--End Version [Script Version - 0.0.95] [ReleaseVersion - 9.2.1.28]--[09-10-2014] -- by Babu

--Strart Version [Script Version - 0.0.96] [ReleaseVersion - 9.2.1.28]--[13-10-2014] -- by Chithra
ALTER TABLE SERVICE_TAX_DETAILS MODIFY SERVICE_TAX_AMT NUMBER(16,2);

ALTER TABLE SERVICE_TAX_DETAILS MODIFY EDUCATION_CESS NUMBER(16,2);

ALTER TABLE SERVICE_TAX_DETAILS MODIFY HIGHER_EDU_CESS NUMBER(16,2);

ALTER TABLE SERVICE_TAX_DETAILS MODIFY TOTAL_TAX_AMOUNT NUMBER(16,2);
--End Version [Script Version - 0.0.96] [ReleaseVersion - 9.2.1.28]--[13-10-2014] -- by Chithra

--Strart Version [Script Version - 0.0.97] [ReleaseVersion - 9.2.1.28]--[14-10-2014] -- by NidiN

ALTER TABLE MDS_SCHEME_DETAILS ADD (IS_SPECIAL_SCHEME VARCHAR2(2 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.97] [ReleaseVersion - 9.2.1.28]--[14-10-2014] -- by NidiN

--Strart Version [Script Version - 0.0.98] [ReleaseVersion - 9.2.1.28]--[15-10-2014] -- by Jeffin John

ALTER TABLE DEPOSIT_ACINFO add MDS_REMARKS VARCHAR2(500);

--End Version [Script Version - 0.0.98] [ReleaseVersion - 9.2.1.28]--[15-10-2014] -- by Jeffin John
--Strart Version [Script Version - 0.0.99] [ReleaseVersion - 9.2.1.28]--[15-10-2014] -- by Anju

 ALTER TABLE LOAN_APPLICATION_REGISTER ADD (NO_OF_INSTALLMENT NUMBER);
  
 ALTER TABLE LOAN_APPLICATION_REGISTER ADD (INSTALLMENT_TYPE VARCHAR(50 BYTE));
  
 ALTER TABLE LOAN_APPLICATION_REGISTER ADD (MORATORIUM_PERIOD NUMBER);

--End Version [Script Version - 0.0.99] [ReleaseVersion - 9.2.1.28]--[15-10-2014] -- by Anju

--Start Version [Script Version - 0.0.100] [ReleaseVersion - 9.2.1.28]--[18-10-2014] -- by Chithra
ALTER TABLE DEPOSITS_PROD_INTPAY ADD (PRE_MAT_INT_TYPE VARCHAR2(40 BYTE));

ALTER TABLE ACT_PARAM_DETAIL ADD (TEMP_LAST_CR_INT_APPLDT DATE);

UPDATE DEPOSITS_PROD_INTPAY D SET D.PRE_MAT_INT_TYPE='COMPOUND' WHERE D.PRE_MAT_INT_TYPE='Compound Interest';

UPDATE DEPOSITS_PROD_INTPAY D SET D.PRE_MAT_INT_TYPE='SIMPLE' WHERE D.PRE_MAT_INT_TYPE='Simple Interest';

--End Version [Script Version - 0.0.100] [ReleaseVersion - 9.2.1.28]--[18-10-2014] -- by Chithra

--Strart Version [Script Version - 0.0.101] [ReleaseVersion - 9.2.1.28]--[23-10-2014] -- by NiDHiN
CREATE OR REPLACE FUNCTION GetCurrInstDtW(curr_dt date,scheme VARCHAR2) RETURN date
IS
    next_dt date;
    start_dt date;
    date_diff number(2):=0;
BEGIN
    SELECT SCHEME_START_DT INTO start_dt FROM mds_scheme_details WHERE scheme_name=scheme;
    date_diff:=to_date(curr_dt)-to_date(start_dt);
    date_diff:=date_diff-(mod(date_diff,7));
    next_dt:=start_dt+date_diff+7;
    RETURN next_dt;
END;
/
--End Version [Script Version - 0.0.101] [ReleaseVersion - 9.2.1.28]--[23-10-2014] -- by NiDHiN

--Strart Version [Script Version - 0.0.102] [ReleaseVersion - 9.2.1.28]--[30-10-2014] -- by Anju
 ALTER TABLE LOANS_PROD_ACPARAM ADD (IS_LOANCLOSING_ALLOWED VARCHAR(20 BYTE));

 ALTER TABLE LOANS_PROD_ACHD ADD (SUSPENSE_CREDIT_ACHD VARCHAR(60 BYTE));

 ALTER TABLE LOANS_PROD_ACHD ADD (SUSPENSE_DEBIT_ACHD VARCHAR(60 BYTE));

--End Version [Script Version - 0.0.102] [ReleaseVersion - 9.2.1.28]--[30-10-2014] -- by Anju

--Strart Version [Script Version - 0.0.103] [ReleaseVersion - 9.2.1.28]--[30-10-2014] -- by Chithra

 ALTER TABLE MDS_RECEIPT_ENTRY ADD (SERVICE_TAX_AMT NUMBER(16,2) DEFAULT 0);

--End Version [Script Version - 0.0.103] [ReleaseVersion - 9.2.1.28]--[30-10-2014] -- by Chithra

--Strart Version [Script Version - 0.0.104] [ReleaseVersion - 9.2.1.28]--[03-11-2014] -- by Rishad
UPDATE STANDING_INSTRUCTION_CREDIT S set S.BRANCH_CODE=SUBSTR(S.ACCT_NO,0,4)

UPDATE STANDING_INSTRUCTION_DEBIT S set S.BRANCH_CODE=SUBSTR(S.ACCT_NO,0,4)
--End Version [Script Version - 0.0.104] [ReleaseVersion - 9.2.1.28]--[03-11-2014] -- by Rishad
--Strart Version [Script Version - 0.0.105] [ReleaseVersion - 9.2.1.28]--[11-11-2014] -- by Anju
ALTER TABLE SHARE_CONF_DETAILS ADD (MANDATORY_DATA VARCHAR(4000 BYTE));
ALTER TABLE SHARE_CONF_DETAILS ADD (MANDATORY_ADDR_DATA VARCHAR(4000 BYTE));

CREATE OR REPLACE FUNCTION data_Check(PARAM_VALUE VARCHAR2,FIELD VARCHAR2,WHERE_FIELD VARCHAR2,TBL VARCHAR2) return varchar is 
MSG VARCHAR2(350):='';
CNT NUMBER(16):=0;
sql_stmt VARCHAR2(200);
BEGIN
    sql_stmt:='SELECT COUNT(*) FROM '||TBL||' WHERE '||WHERE_FIELD||'= :CID';
    EXECUTE IMMEDIATE sql_stmt INTO CNT USING PARAM_VALUE;
    IF CNT>0 THEN
        sql_stmt:='SELECT COUNT(*) FROM '||TBL||' WHERE '||FIELD||' IS NULL AND '||WHERE_FIELD||'= :CID';
        EXECUTE IMMEDIATE sql_stmt INTO CNT USING PARAM_VALUE;
        IF CNT>0 THEN
            MSG:=INITCAP(FIELD)||' needs proper value';
        ELSE
            MSG:='';
        END IF;
    ELSE
        MSG:=INITCAP(FIELD)||' needs proper value';
    END IF;
    RETURN MSG;
END;
/

--End Version [Script Version - 0.0.105] [ReleaseVersion - 9.2.1.28]--[11-11-2014] -- by Anju

--Strart Version [Script Version - 0.0.106] [ReleaseVersion - 9.2.1.28]--[13-11-2014] -- by Chithra
	ALTER TABLE MDS_RECEIPT_ENTRY ADD (SERVICE_TAX_AMT NUMBER(16,2) DEFAULT 0);

	ALTER TABLE SERVICE_TAX_DETAILS ADD (TRANS_TYPE VARCHAR2(2 BYTE) DEFAULT 'C');

	ALTER TABLE PARAMETERS ADD (GAHAN_PERIOD NUMBER(8) DEFAULT 13);

--End Version [Script Version - 0.0.106] [ReleaseVersion - 9.2.1.28]--[13-11-2014] -- by Chithra

--Start Version [Script Version - 0.0.107] [ReleaseVersion - 9.2.1.28]--[20-11-2014] -- by Jeffin John

DROP VIEW MDS_SCHEME_CUR_INSTALLMENT;


CREATE OR REPLACE FORCE VIEW mds_scheme_cur_installment (scheme_name,
                                                         installment_day,
                                                         scheme_start_dt,
                                                         cur_inst_no,
                                                         branch_code
                                                        )
AS
   SELECT   scheme_name, installment_day, scheme_start_dt,
            CASE
               WHEN TO_NUMBER (TO_CHAR (curr_appl_dt, 'DD')) >
                      TO_NUMBER (TO_CHAR (scheme_start_dt, 'DD')
                                )
                  THEN   (  (  TO_NUMBER (TO_CHAR (curr_appl_dt, 'YYYY'))
                             - TO_NUMBER (TO_CHAR (scheme_start_dt, 'YYYY'))
                            )
                          * 12
                         )
                       + (  TO_NUMBER (TO_CHAR (curr_appl_dt, 'MM'))
                          - TO_NUMBER (TO_CHAR (scheme_start_dt, 'MM'))
                         )
                       + 1
               ELSE   (  (  TO_NUMBER (TO_CHAR (curr_appl_dt, 'YYYY'))
                          - TO_NUMBER (TO_CHAR (scheme_start_dt, 'YYYY'))
                         )
                       * 12
                      )
                    + (  TO_NUMBER (TO_CHAR (curr_appl_dt, 'MM'))
                       - TO_NUMBER (TO_CHAR (scheme_start_dt, 'MM'))
                      )
            END AS cur_inst_no,
            m.branch_code
       FROM mds_scheme_details m, day_end d
      WHERE status != 'DELETED'
        AND authorized_status = 'AUTHORIZED'
        AND m.branch_code = d.branch_code
   GROUP BY scheme_name,
            installment_day,
            scheme_start_dt,
            curr_appl_dt,
            m.branch_code;

--End Version [Script Version - 0.0.107] [ReleaseVersion - 9.2.1.28]--[20-11-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.108] [ReleaseVersion - 9.2.1.28]--[25-11-2014] -- by NiDhin

ALTER TABLE MDS_TRANS_DETAILS  ADD (ARBITRATION_AMT NUMBER(16,2) DEFAULT 0);
ALTER TABLE MDS_TRANS_DETAILS ADD (NARRATION VARCHAR2(50 BYTE));
ALTER TABLE SECURITY_DETAILS ADD (IS_RELEASE VARCHAR2(2 BYTE) DEFAULT 'N');
ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD (PRIZED_MONEY_PAYMENT_TYPE VARCHAR2(2 BYTE));
ALTER TABLE MDS_PRODUCT_OTHER_DETAILS  ADD (PRIZED_MONEY_PAYMENT_AMT NUMBER(16,2) DEFAULT 0);

CREATE OR REPLACE FUNCTION get_tl_total(ACTNUM VARCHAR, ASONDT DATE)
RETURN NUMBER IS
Balance NUMBER(16,2) := 0;
BEGIN
SELECT  sum(a.balance) into balance 
    FROM (
    WITH cte_a AS
               (
               SELECT   t.act_num, 'NOTICE CHARGES' AS charge_type,
                         SUM (NVL (t.expense, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num                
                UNION ALL                
                SELECT   t.act_num, 'INSURANCE CHARGES' AS charge_type,
                         SUM (NVL (t.insurance_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'ARBITRARY CHARGES' AS charge_type,
                         SUM (NVL (t.arbitary_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'LEGAL CHARGES' AS charge_type,
                         SUM (NVL (t.legal_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'MISCELLANEOUS CHARGES' AS charge_type,
                         SUM (NVL (t.misc_charges, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'EXECUTION DECREE CHARGES' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'POSTAGE CHARGES' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'OTHERS' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num),
               cte_b AS
               (SELECT   a.act_num, a.charge_type, SUM (a.amount) AS amount
                    FROM loans_acct_charge_details a
                   WHERE a.act_num = ACTNUM
                     AND a.charge_date <=  ASONDT
                     AND a.authorize_status = 'AUTHORIZED'
                     AND a.status != 'DELETED'
                GROUP BY a.act_num, a.charge_type)
          SELECT b.act_num, a.charge_type, b.amount - a.amount AS balance,
                 NULL AS s_order, 'A' AS mod_type
            FROM cte_b b LEFT JOIN cte_a a
                 ON a.act_num = b.act_num
               AND a.charge_type = NVL (b.charge_type, 'OTHERS')
          UNION ALL
          SELECT f.acct_num AS act_num, 'PRINCIPAL' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_balance (f.acct_num,  ASONDT)
                    ELSE get_adv_balance (f.acct_num,  ASONDT)
                 END AS balance,
                 1 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num = ACTNUM
          UNION ALL
          SELECT f.acct_num AS act_num, 'INTEREST' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_interest (f.acct_num,
                                             sd.from_dt,
                                              ASONDT
                                            )
                    ELSE get_adv_interest_application (f.acct_num,  ASONDT)
                 END AS balance,
                 2 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num =  ACTNUM
          UNION ALL
          SELECT f.acct_num AS act_num, 'PENAL INTEREST' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_od_interest(f.acct_num,ASONDT)
                    ELSE get_adv_pen_int_application (f.acct_num,
                                                       ASONDT
                                                     )
                 END AS balance,
                 3 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num =  ACTNUM
           ) a;
RETURN balance;
End;
/

DROP VIEW OP_ACT_MIN_BAL;

CREATE OR REPLACE FORCE VIEW op_act_min_bal (prod_id, act_num, min_bal)
AS
   (SELECT ac.prod_id, ac.act_num,
           CASE
              WHEN ap.chk_book = 'Y'
                 THEN oap.min_bal_w_chk
              ELSE oap.min_bal_wt_chk
           END AS min_bal
      FROM act_master ac, act_param_detail ap, op_ac_account_param oap
     WHERE oap.prod_id = ac.prod_id
       AND ap.act_num = ac.act_num
       AND ac.act_status_id != 'CLOSED'
    UNION ALL
    SELECT lp.prod_id, lfd.acct_num AS act_num,
           DECODE (lfd.available_balance, 0, 0, 0) AS min_bal
      FROM loans_borrower lb, loans_facility_details lfd, loans_product lp
     WHERE lb.borrow_no = lfd.borrow_no
       AND lfd.prod_id = lp.prod_id
       AND lp.behaves_like = 'OD'
       AND lp.status != 'DELETED'
       AND lp.authorize_status = 'AUTHORIZED'
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED');

--End Version [Script Version - 0.0.108] [ReleaseVersion - 9.2.1.28]--[25-11-2014] -- by NiDhin

--Start Version [Script Version - 0.0.109] [ReleaseVersion - 9.2.1.28]--[25-11-2014] -- by Shihad

ALTER TABLE PASS_BOOK ADD (NARRATION VARCHAR2(500 BYTE));

ALTER TABLE INDEND_REGISTER ADD SL_NO1 NUMBER(10);

UPDATE INDEND_REGISTER IRINDEND SET IR.SL_NO1 = IR.SL_NO;

UPDATE INDEND_REGISTER IR SET IR.SL_NO = NULL;

ALTER TABLE INDEND_REGISTER MODIFY SL_NO NUMBER(10);

UPDATE INDEND_REGISTER IR SET IR.SL_NO = IR.SL_NO1;

ALTER TABLE INDEND_REGISTER DROP COLUMN SL_NO1;

--End Version [Script Version - 0.0.109] [ReleaseVersion - 9.2.1.28]--[25-11-2014] -- by Shihad

--Start Version [Script Version - 0.0.110] [ReleaseVersion - 9.2.1.29]--[03-12-2014] -- by Chithra
CREATE OR REPLACE FORCE VIEW all_transactions_view (trans_id,
                                                    batch_id,
                                                    ac_hd_id,
                                                    act_num,
                                                    amount,
                                                    trans_dt,
                                                    trans_type,
                                                    inst_type,
                                                    inst_dt,
                                                    particulars,
                                                    status,
                                                    instrument_no1,
                                                    instrument_no2,
                                                    prod_id,
                                                    prod_type,
                                                    authorize_status,
                                                    authorize_by,
                                                    status_by,
                                                    status_dt,
                                                    trans_mode,
                                                    branch_id,
                                                    initiated_branch,
                                                    authorize_status_2,
                                                    single_trans_id,
                                                    link_batch_id,
                                                    trans_mod_type
                                                   )
AS
   SELECT trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt, trans_type,
          inst_type, inst_dt, particulars, status, instrument_no1,
          instrument_no2, prod_id, prod_type, authorize_status, authorize_by,
          status_by, status_dt, trans_mode, branch_id, initiated_branch,
          authorize_status_2, single_trans_id, link_batch_id, trans_mod_type
     FROM (
  SELECT   trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt,
                    trans_type, inst_type, inst_dt, particulars, status,
                    instrument_no1, instrument_no2, prod_id, prod_type,
                    authorize_status, authorize_by, status_by, status_dt,
                    trans_mode, branch_id, initiated_branch,
                    authorize_status_2, single_trans_id, link_batch_id,
                    trans_mod_type
               FROM all_trans
/* Script added for updating dayend balance of Daily Deposit accounts */
           union all 
           SELECT   to_char(trans_id), batch_id,(select acct_head from deposits_product where prod_id=substr(acc_num,5,3)) as  ac_hd_id, acc_num as  act_num,  amount, TRN_DT as trans_dt,
                    trans_type, '' as inst_type,null as inst_dt, particulars, status,
                    '' as instrument_no1, '' as instrument_no2, substr(acc_num,5,3) as prod_id, prod_type,
                    authorize_status, authorize_by, '' as status_by,TRN_DT as status_dt,
                    trans_mode, substr(acc_num,1,4) as branch_id, initiated_branch,
                    '' as authorize_status_2, '' as single_trans_id, '' as link_batch_id,
                    '' as trans_mod_type
               FROM DAILY_DEPOSIT_TRANS
           ORDER BY status_dt
);

--END Version [Script Version - 0.0.110] [ReleaseVersion - 9.2.1.29]--[03-12-2014] -- by Chithra

--Start Version [Script Version - 0.0.111] [ReleaseVersion - 9.2.1.29]--[05-12-2014] -- by Shihad

ALTER TABLE SECURITY_DETAILS ADD GR_WT NUMBER(16,3);  
   
UPDATE SECURITY_DETAILS SD SET SD.GR_WT = SD.GROSS_WEIGHT;

UPDATE SECURITY_DETAILS SD SET SD.GROSS_WEIGHT = NULL;

ALTER TABLE SECURITY_DETAILS MODIFY GROSS_WEIGHT NUMBER(16,3);

UPDATE SECURITY_DETAILS SD SET SD.GROSS_WEIGHT = SD.GR_WT;

ALTER TABLE SECURITY_DETAILS DROP COLUMN GR_WT;

ALTER TABLE SECURITY_DETAILS ADD NET_WT NUMBER(16,3);  
   
UPDATE SECURITY_DETAILS SD SET SD.NET_WT = SD.NET_WEIGHT;

UPDATE SECURITY_DETAILS SD SET SD.NET_WEIGHT = NULL;

ALTER TABLE SECURITY_DETAILS MODIFY NET_WEIGHT NUMBER(16,3);

UPDATE SECURITY_DETAILS SD SET SD.NET_WEIGHT = SD.NET_WT;

ALTER TABLE SECURITY_DETAILS DROP COLUMN NET_WT;

MERGE INTO RENT_TRANS RT USING RENT_REGISTER RR ON (RT.ROOM_NO=RR.ROOM_NO AND RT.BUILDING_NO=RR.BUILDING_NO)
WHEN MATCHED THEN
UPDATE SET RT.RRID = RR.RRID 
--END Version [Script Version - 0.0.111] [ReleaseVersion - 9.2.1.29]--[05-12-2014] -- by Shihad
--Start Version [Script Version - 0.0.112] [ReleaseVersion - 9.2.1.29]--[05-12-2014] -- by Anju

CREATE OR REPLACE FORCE VIEW all_customer_balance (act_num,
                                                             cust_id,
                                                             customer_name,
                                                             available_balance,
                                                             branch_code
                                                            )
AS
   (SELECT act_num, cust_id, acct_name AS customer_name,
           NVL (available_balance, 0) AS available_balance, branch_code
      FROM act_master
     WHERE act_status_id != 'CLOSED'
       AND status != 'DELETED'
       AND authorization_status = 'AUTHORIZED'
    UNION ALL
    SELECT suspense_acct_num AS act_num, suspense_customer_id AS cust_id,
           suspense_name AS customer_name,
           NVL (clear_balance, 0) AS available_balance, branch_code
      FROM suspense_account_master
     WHERE status != 'DELETED' AND authorize_status = 'AUTHORIZED'
    UNION ALL
         SELECT DSA.DEPOSIT_NO||'_'||DSA.DEPOSIT_SUB_NO AS act_num,DA.CUST_ID,
     DECODE (CU.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,DSA.AVAILABLE_BALANCE,DA.BRANCH_ID As branch_code FROM DEPOSIT_SUB_ACINFO DSA,
                   DEPOSIT_ACINFO DA, customer cu
                   WHERE DA.CUST_ID=CU.CUST_ID
                   AND DA.DEPOSIT_NO=DSA.DEPOSIT_NO
                   AND DA.DEPOSIT_STATUS!='CLOSED'AND DA.AUTHORIZE_STATUS='AUTHORIZED'
                   AND DSA.AVAILABLE_BALANCE>0
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           NVL (available_balance, 0) AS available_balance,
           branch_id AS branch_code
      FROM loans_borrower lb, customer cu, loans_facility_details lfd
     WHERE lb.cust_id = cu.cust_id
       AND lb.borrow_no = lfd.borrow_no
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.prod_id IN (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like = 'OD'
                 AND status != 'DELETED'
                 AND authorize_status = 'AUTHORIZED')
    UNION ALL
    SELECT b.ac_hd_id AS act_num, '' AS cust_id,
           b.ac_hd_desc AS customer_name,
           NVL (cur_bal, 0) AS available_balance, branch_code
      FROM gl a, ac_hd b
     WHERE a.authorize_status = 'AUTHORIZED' AND a.ac_hd_id = b.ac_hd_id
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id,
           agency_name AS customer_name, available_balance, branch_id
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');









CREATE OR REPLACE FORCE VIEW operative_suspense_prod (prod_id, prod_desc)
AS
   (SELECT oap.prod_id, oap.prod_desc
      FROM op_ac_product oap
     WHERE oap.authorized_status = 'AUTHORIZED'
       AND oap.status != 'DELETED'
       AND oap.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT sam.prod_id, sam.prod_desc
      FROM suspense_product sam
     WHERE sam.authorized_status = 'AUTHORIZED'
       AND sam.status != 'DELETED'
       AND sam.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
                                     UNION ALL
    SELECT dp.prod_id, dp.prod_desc
      FROM  DEPOSITS_PRODUCT dp
     WHERE dp.authorize_status = 'AUTHORIZED'
       AND dp.status != 'DELETED'
       AND dp.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
                                     );






alter table LOANS_PROD_ACHD drop (SUSPENSE_CREDIT_ACHD, SUSPENSE_DEBIT_ACHD);

alter table LOANS_PROD_ACPARAM ADD SUSPENSE_CREDIT_ACHD VARCHAR(16 BYTE);
alter table LOANS_PROD_ACPARAM ADD SUSPENSE_DEBIT_ACHD VARCHAR(16 BYTE);
--End Version [Script Version - 0.0.112] [ReleaseVersion - 9.2.1.29]--[05-12-2014] -- by Anju

--Start Version [Script Version - 0.0.113] [ReleaseVersion - 9.2.1.29]--[06-12-2014] -- by Nidhin
CREATE OR REPLACE FUNCTION get_tl_total(ACTNUM VARCHAR, ASONDT DATE)
RETURN NUMBER IS
Balance NUMBER(16,2) := 0;
BEGIN
SELECT  sum(a.balance) into balance 
    FROM (
    WITH cte_a AS
               (
               SELECT   t.act_num, 'NOTICE CHARGES' AS charge_type,
                         SUM (NVL (T.NOTICE_CHARGES, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num                
                UNION ALL                
                SELECT   t.act_num, 'INSURANCE CHARGES' AS charge_type,
                         SUM (NVL (t.insurance_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL                
                SELECT   t.act_num, 'ARBITRARY CHARGES' AS charge_type,
                         SUM (NVL (t.arbitary_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'LEGAL CHARGES' AS charge_type,
                         SUM (NVL (t.legal_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'MISCELLANEOUS CHARGES' AS charge_type,
                         SUM (NVL (t.misc_charges, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'EXECUTION DECREE CHARGES' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'POSTAGE CHARGES' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'OTHERS' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num                
                UNION 
                   SELECT   t.act_num, t.charge_type  AS charge_type,sum(nvl(t.PAID_AMT,0)) AS amount
                    FROM loans_acct_charge_details t
                   WHERE t.act_num = ACTNUM
                     AND t.charge_date <= ASONDT
                     --and t.charge_type='EP_COST' 
                     AND t.authorize_status = 'AUTHORIZED'
                     AND t.status != 'DELETED'
                    GROUP BY t.act_num,t.charge_type),
               cte_b AS
               (SELECT   a.act_num, a.charge_type, SUM (a.amount) AS amount
                    FROM loans_acct_charge_details a
                   WHERE a.act_num = ACTNUM
                     AND a.charge_date <=  ASONDT
                     AND a.authorize_status = 'AUTHORIZED'
                     AND a.status != 'DELETED'
                GROUP BY a.act_num, a.charge_type)
          SELECT b.act_num, a.charge_type, b.amount - a.amount AS balance,
                 NULL AS s_order, 'A' AS mod_type
            FROM cte_b b LEFT JOIN cte_a a
                 ON a.act_num = b.act_num
               AND a.charge_type = NVL (b.charge_type, 'OTHERS')
          UNION ALL
          SELECT f.acct_num AS act_num, 'PRINCIPAL' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_balance (f.acct_num,  ASONDT)
                    ELSE get_adv_balance (f.acct_num,  ASONDT)
                 END AS balance,
                 1 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num = ACTNUM
          UNION ALL
          SELECT f.acct_num AS act_num, 'INTEREST' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_interest (f.acct_num,
                                             sd.from_dt,
                                              ASONDT
                                            )
                    ELSE get_adv_interest_application (f.acct_num,  ASONDT)
                 END AS balance,
                 2 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num =  ACTNUM
          UNION ALL
          SELECT f.acct_num AS act_num, 'PENAL INTEREST' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_od_interest(f.acct_num,ASONDT)
                    ELSE get_adv_pen_int_application (f.acct_num,
                                                       ASONDT
                                                     )
                 END AS balance,
                 3 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num =  ACTNUM
           ) a;
RETURN balance;
End;
/

ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD (PRIZED_MONEY_PAYMENT_TYPE VARCHAR2(30 BYTE));

--End Version [Script Version - 0.0.113] [ReleaseVersion - 9.2.1.29]--[06-12-2014] -- by Nidhin

--Start Version [Script Version - 0.0.114] [ReleaseVersion - 9.2.1.29]--[11-12-2014] -- by Nidhin

ALTER table LOANS_PROD_ACPARAM drop(SUSPENSE_DEBIT_ACHD,SUSPENSE_CREDIT_ACHD);
ALTER TABLE MDS_TRANS_DETAILS ADD (SERVICE_TAX_AMT NUMBER(16,2) DEFAULT 0);
ALTER TABLE SUSPENSE_ACCOUNT_MASTER ADD (ISAUCTION VARCHAR(10 BYTE) DEFAULT 'N');
ALTER TABLE LOANS_PROD_ACPARAM ADD (SUSPENSE_DEBIT_PROD_ID VARCHAR(60 BYTE));
ALTER TABLE LOANS_PROD_ACPARAM ADD (SUSPENSE_CREDIT_PROD_ID VARCHAR(60 BYTE));
--End Version [Script Version - 0.0.114] [ReleaseVersion - 9.2.1.29]--[11-12-2014] -- by Nidhin
--Start Version [Script Version - 0.0.115] [ReleaseVersion - 9.2.1.29]--[12-12-2014] -- by Anju

ALTER TABLE LOAN_APPLICATION_REGISTER ADD (IS_TRANSACTION VARCHAR(20 BYTE));

--End Version [Script Version - 0.0.115] [ReleaseVersion - 9.2.1.29]--[12-12-2014] -- by Anju

--Start Version [Script Version - 0.0.116] [ReleaseVersion - 9.2.1.29]--[17-12-2014] -- by Sreekrishnan

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR09992', '6133', 'Deposit Receipt Print Between Periods', 'APP01', 'DONE', 
    '6', 'com.see.truetransact.ui.deposit.print.DepositReprintUI', 8, 'CREATED', NULL, 
    NULL, 'Deposit Receipt Print Between Periods');
COMMIT;

call INSERT_REPORT_GROUP('SCR09992');

ALTER TABLE INDEND_SUPPLIER_MASTER ADD (BRANCH_CODE VARCHAR(5 BYTE));

ALTER TABLE INDEND_SUPPLIER_MASTER ADD (SUSPENSE_ACHD VARCHAR(10 BYTE));
--End Version [Script Version - 0.0.116] [ReleaseVersion - 9.2.1.29]--[17-12-2014] -- by Sreekrishnan

--Start Version [Script Version - 0.0.117] [ReleaseVersion - 9.2.1.29]--[19-12-2014] -- by Jeffin John

alter table SUSPENSE_INSTALLMENT add interest number(16,2);

alter table SUSPENSE_INSTALLMENT add trans_all_id varchar2(16 byte);

alter table SUSPENSE_INSTALLMENT add trans_type varchar2(16 byte); 

CREATE OR REPLACE FUNCTION GET_SUS_INTEREST(ACTNUM VARCHAR,ASONDT DATE)
RETURN NUMBER IS
--DECLARE
--ACTNUM VARCHAR2(16) := '0001603000966';
--ASONDT DATE := '19-dec-2014'; 
   STARTDATE            DATE;
   INT_DAYS             NUMBER(16,2);
   INST_PEND_AMT        NUMBER(16,2);
   INTEREST             NUMBER(16,2) :=0;
   ROI                  NUMBER(16,2) := 0;
   GRACE_PERIOD         NUMBER(16,2);
   PAIDAMT              NUMBER(16,2):=0; 
   PAIDINT              NUMBER(16,2);
   INSTALLMENT_AMOUNT   NUMBER(16,2);
   LASTPAIDDATE         DATE;
   PENDINGAMT           NUMBER(16,2);
   INSTSTARTDATE        DATE;
   FLAG                 NUMBER(1) :=0;
   NEXTINSTDUEDT        DATE;
   DUEDT                DATE;    
BEGIN
    SELECT S.INTEREST_RATE, S.GRACE_PERIOD_DAYS
    INTO ROI, GRACE_PERIOD
    FROM SHOP_MASTER_TABLE S;
    SELECT NVL (SUM (SI.PAID_AMOUNT), 0), NVL (SUM (SI.INTEREST), 0)
     INTO PAIDAMT, PAIDINT
     FROM SUSPENSE_INSTALLMENT SI
    WHERE SI.PAID_DATE <= ASONDT AND SI.ACCT_NUM = ACTNUM;
    SELECT LAST_DAY(ADD_MONTHS(ASONDT,-2))+ 1 INTO DUEDT FROM DUAL;
    IF PAIDAMT > 0 THEN
        --DBMS_OUTPUT.PUT_LINE('inside loop PAIDAMT  ='||PAIDAMT);
        DECLARE CURSOR INSTDUE IS 
        SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
           NVL (SUM (INSTALLMENT_AMOUNT),0) AS INSTALLMENT_AMOUNT
           FROM SUSPENSE_INSTALLMENT   
           WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE < DUEDT and installment_amount > 0
        GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
        ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');
        BEGIN
            FOR I IN INSTDUE 
                LOOP
                PAIDAMT := PAIDAMT - I.INSTALLMENT_AMOUNT;
                if flag = 0 then
                    IF PAIDAMT <0 AND FLAG =0 THEN
                    LASTPAIDDATE := I.INSTALLMENT_DATE;
                    PENDINGAMT   := PAIDAMT * (-1);
                    SELECT LAST_DAY(LASTPAIDDATE) INTO NEXTINSTDUEDT FROM DUAL;
                    SELECT LAST_DAY(LASTPAIDDATE )+ GRACE_PERIOD INTO INSTSTARTDATE FROM DUAL;
                    INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(INSTSTARTDATE,'DD-MM-YYYY')) + 1;
                    INTEREST := INTEREST +  (PENDINGAMT * INT_DAYS * ROI / 36500);
                    FLAG := 1;
                    END IF;
                end if;
                END LOOP;
        END;
        IF FLAG = 1 THEN
                DECLARE CURSOR CURPENAL IS
                SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
                   NVL (SUM (INSTALLMENT_AMOUNT),0) AS INSTALLMENT_AMOUNT
                   FROM SUSPENSE_INSTALLMENT   
                   WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE >  NEXTINSTDUEDT AND INSTALLMENT_DATE < DUEDT
                GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
                ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');
                BEGIN
                    FOR J IN CURPENAL LOOP
                        INST_PEND_AMT := J.INSTALLMENT_AMOUNT;
                        STARTDATE := J.INSTALLMENT_DATE;
                        INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(STARTDATE,'DD-MM-YYYY')) + 1;
                        INTEREST := INTEREST +  (INST_PEND_AMT * INT_DAYS * ROI / 36500);
                    END LOOP;
                END;
        END IF;
    ELSE
    DECLARE CURSOR CURPENAL IS  
    SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
    NVL (SUM (INSTALLMENT_AMOUNT), 0) AS INSTALLMENT_AMOUNT
    FROM SUSPENSE_INSTALLMENT
    WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE < DUEDT
    GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
    ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');   
         BEGIN
            FOR PENAL IN CURPENAL
            LOOP
            INST_PEND_AMT := PENAL.INSTALLMENT_AMOUNT;
            STARTDATE := PENAL.INSTALLMENT_DATE;
            SELECT LAST_DAY(STARTDATE) + GRACE_PERIOD INTO STARTDATE FROM DUAL;
            INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(STARTDATE,'DD-MM-YYYY')) + 1;
            INTEREST := INTEREST +  (INST_PEND_AMT * INT_DAYS * ROI / 36500);
            END LOOP;
         END;
    INTEREST := ROUND(INTEREST);
    END IF;
    INTEREST := ROUND(INTEREST);
    INTEREST := INTEREST - nvl(PAIDINT,0);
    IF INTEREST < 0  THEN
    INTEREST := 0;
    END IF;
    RETURN INTEREST;
END;
/

--End Version [Script Version - 0.0.117] [ReleaseVersion - 9.2.1.29]--[19-12-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.118] [ReleaseVersion - 9.2.1.30]--[23-12-2014] -- by Nidhin

ALTER TABLE DEPOSITS_PRODUCT ADD (DEFAULT_PAY_FREQ NUMBER(16,2) DEFAULT 0);

--End Version [Script Version - 0.0.118] [ReleaseVersion - 9.2.1.30]--[23-12-2014] -- by Nidhin

--Start Version [Script Version - 0.0.119] [ReleaseVersion - 9.2.1.30]--[01-01-2015] -- by Jeffin John

alter table RECOVERY_PARAMETERS add grace_period number(16,2) default '0' 

alter table DEPOSIT_ROI_GROUP_TYPE_RATE add INST_TYPE varchar2(16 byte)

--End Version [Script Version - 0.0.119] [ReleaseVersion - 9.2.1.30]--[01-01-2015] -- by Jeffin John

--Start Version [Script Version - 0.0.120] [ReleaseVersion - 9.2.1.30]--[01-01-2015] -- by Sreekrishnan

UPDATE SCREEN_MASTER SET SCREEN_NAME = 'Risk Fund and Loan Charges' WHERE SCREEN_NAME = 'Risk Fund' AND SCREEN_TYPE IS NULL

CREATE TABLE SMS_ACKNOWLEDGMENT
(
  MESSAGE         VARCHAR2(300 BYTE),
  ACKNOWLEDGMENT  VARCHAR2(64 BYTE),
  SEND_DATE       DATE,
  PHONE_NO        NUMBER,
  SMS_ID          VARCHAR2(8 BYTE)
)

--End Version [Script Version - 0.0.120] [ReleaseVersion - 9.2.1.30]--[01-01-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.121] [ReleaseVersion - 9.2.1.30]--[01-01-2015] -- by Babu

/* Formatted on 2015/01/01 16:03 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_trans_tl (trans_id,
                                           batch_id,
                                           ac_hd_id,
                                           act_num,
                                           amount,
                                           trans_dt,
                                           trans_type,
                                           inst_type,
                                           inst_dt,
                                           token_no,
                                           init_trans_id,
                                           init_chann_type,
                                           particulars,
                                           status,
                                           instrument_no1,
                                           instrument_no2,
                                           prod_id,
                                           prod_type,
                                           authorize_status,
                                           authorize_by,
                                           authorize_dt,
                                           authorize_remarks,
                                           status_by,
                                           branch_id,
                                           status_dt,
                                           trans_mode,
                                           initiated_branch,
                                           link_batch_id,
                                           single_trans_id
                                          )
AS
   (SELECT "TRANS_ID", '' AS "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
           "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT", "TOKEN_NO",
           "INIT_TRANS_ID", "INIT_CHANN_TYPE", "PARTICULARS", "STATUS",
           "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID", "PROD_TYPE",
           "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID", "STATUS_DT",
           'CASH' AS "TRANS_MODE", "INITIATED_BRANCH", "LINK_BATCH_ID","SINGLE_TRANS_ID"
      FROM "CASH_TRANS"
    UNION
    SELECT "TRANS_ID", "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
           "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT",
           NULL AS "TOKEN_NO", "INIT_TRANS_ID", "INIT_CHANN_TYPE",
           "PARTICULARS", "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2",
           "PROD_ID", "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY",
           "AUTHORIZE_DT", "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID",
           "STATUS_DT", "TRANS_MODE", "INITIATED_BRANCH", "LINK_BATCH_ID","SINGLE_TRANS_ID"
      FROM transfer_trans
    UNION
    SELECT "INWARD_ID" AS "TRANS_ID", NULL AS "BATCH_ID", "AC_HD_ID",
           "ACCT_NO" AS "ACT_NUM", "AMOUNT", "CLEARING_DT" AS "TRANS_DT",
           'DEBIT' AS "TRANS_TYPE", "INSTRUMENT_TYPE" AS "INST_TYPE",
           "INSTRUMENT_DT" AS "INST_DT", NULL AS "TOKEN_NO",
           "SUSER_ID" AS "INIT_TRANS_ID",
           "INITIATED_BRANCH" AS "INIT_CHANN_TYPE", '' AS "PARTICULARS",
           "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID",
           "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS", "CREATED_BY" AS "STATUS_BY", "BRANCH_ID",
           "S_DATE" AS "STATUS_DT", 'CLEARING' AS "TRANS_MODE",
           "INITIATED_BRANCH", NULL AS link_batch_id,null as single_trans_id
      FROM inward_clearing
     WHERE authorize_status != 'REJECTED'
       AND inward_id NOT IN (SELECT inward_id
                               FROM inward_bouncing)
    UNION
    SELECT ib.bouncing_id AS trans_id, NULL AS batch_id, ic.ac_hd_id,
           ic.acct_no AS act_num, ib.amount, ib.clearing_date AS trans_dt,
           'CREDIT' AS trans_type, ic.instrument_type AS "INST_TYPE",
           ic.instrument_dt AS "INST_DT", NULL AS "TOKEN_NO",
           ib.status_by AS "INIT_TRANS_ID",
           ic.initiated_branch AS init_chann_type,
           'INWARD RETURN : ' || ib.bouncing_reason AS particulars, ib.status,
           ic.instrument_no1, ic.instrument_no2, ic.prod_id, ic.prod_type,
           ib.authorize_status, ib.authorize_by, ib.authorize_dt,
           ic.authorize_remarks, ib.status_by, ib.branch_id, ib.status_dt,
           'CLEARING' AS "TRANS_MODE", ib.branch_id AS initiated_branch,
           NULL AS link_batch_id,null as single_trans_id
      FROM inward_bouncing ib, inward_clearing ic
     WHERE ic.authorize_status = 'REJECTED' AND ib.inward_id = ic.inward_id
    UNION
    SELECT oc.batch_id AS "TRANS_ID", oc.schedule_no AS "BATCH_ID",
           pis.ac_hd_id AS "AC_HD_ID", pis.acct_no AS "ACT_NUM",
           DECODE (t.table_name,
                   'OUTWARD_CLEARING', oc.amount,
                   pis.amount
                  ) AS amount,
           oc.outward_dt AS "TRANS_DT", 'CREDIT' AS "TRANS_TYPE",
           '' AS "INST_TYPE", NULL AS "INST_DT", NULL AS "TOKEN_NO",
           oc.status_by AS "INIT_TRANS_ID", oc.branch_id AS "INIT_CHANN_TYPE",
           'By oclg' AS "PARTICULARS", oc.status, '' AS "instrument_no1",
           '' AS "instrument_no2", '' AS "PROD_ID", '' AS "PROD_TYPE",
           'AUTHORIZED' AS authorize_status, oc.authorize_by, oc.authorize_dt,
           oc.authorize_remarks, oc.status_by, oc.branch_id, oc.status_dt,
           'CLEARING' AS "TRANS_MODE", oc.branch_id AS initiated_branch,
           NULL AS link_batch_id,null as single_trans_id
      FROM outward_clearing oc,
           pay_in_slip pis,
           outward_tally ot,
           (SELECT   batch_id,
                     DECODE (COUNT (*),
                             1, 'PAY_IN_SLIP',
                             'OUTWARD_CLEARING'
                            ) AS table_name
                FROM outward_clearing
            GROUP BY batch_id) t
     WHERE oc.batch_id = t.batch_id
       AND pis.batch_id = t.batch_id
       AND ot.schedule_no = oc.schedule_no
       AND ot.tally_status = 'CLOSED'
    UNION
    SELECT trans_id AS "TRANS_ID", NULL AS "BATCH_ID", ac_hd_id,
           NULL AS "ACT_NUM", amount, trans_dt, trans_type, inst_type,
           inst_dt, NULL AS "TOKEN_NO", init_trans_id, init_chann_type,
           particulars, status, instrument_no1, instrument_no2, prod_id,
           prod_type, 'AUTHORIZED' AS authorize_status, NULL AS authorize_by,
           NULL AS authorize_dt, NULL AS authorize_remarks, NULL AS status_by,
           branch_id, status_dt, trans_mode, branch_id AS initiated_branch,
           NULL AS link_batch_id,null as single_trans_id
      FROM trans_ref_gl
     WHERE trans_mode = 'CLEARING'
    UNION
    SELECT otr.return_id AS "TRANS_ID", otr.batch_id AS "BATCH_ID",
           '' AS "AC_HD_ID", otr.acct_no AS actnum, otr.amount,
           otr.clearing_date AS "TRANS_DT", 'DEBIT' AS trans_type,
           otc.instrument_type AS inst_type, otc.instrument_dt AS "INST_DT",
           NULL AS "TOKEN_NO", otr.status_by AS "INIT_TRANS_ID",
           otr.branch_id AS "INIT_CHANN_TYPE",
           'OUTWARD RETURN : ' || otc.authorize_remarks AS patriculars,
           otr.status, otr.instrument_no1, otr.instrument_no2,
           '' AS "PROD_ID", '' AS "PROD_TYPE", otr.authorize_status,
           otr.authorize_by, otr.authorize_dt, otr.authorize_remarks,
           otr.status_by, otr.branch_id, otr.status_dt,
           'CLEARING' AS "TRANS_MODE", otr.initiated_branch,
           NULL AS link_batch_id,null as single_trans_id
      FROM outward_return otr, outward_clearing otc
     WHERE otc.authorize_status = 'REJECTED' AND otr.batch_id = otc.batch_id);

--End Version [Script Version - 0.0.121] [ReleaseVersion - 9.2.1.30]--[01-01-2015] -- by Babu

--Start Version [Script Version - 0.0.122] [ReleaseVersion - 9.2.1.30]--[02-01-2015] -- by Chithra
DROP VIEW ALL_PRODUCT_ACCTS_GL;

/* Formatted on 2015/01/01 11:59 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_product_accts_gl (act_num,
                                                   prod_type,
                                                   prod_id,
                                                   rep_act_num,
                                                   branch_id,
                                                   salary_recovery,
                                                   lock_status,
                                                   acct_status,
                                                   cust_id
                                                  )
AS
   (SELECT act_num, prod_type, prod_id, rep_act_num, branch_id,
           salary_recovery, lock_status, acct_status, cust_id
      FROM all_product_accts1
    UNION ALL
    SELECT act_num, prod_type, prod_id, old_act_num AS rep_act_num, branch_id,
           salary_recovery, lock_status, acct_status, cust_id
      FROM old_ac_nos tt, all_product_accts1 apa
     WHERE new_act_num = act_num);
--End Version [Script Version - 0.0.122] [ReleaseVersion - 9.2.1.30]--[02-01-2015] -- by Chithra

--Start Version [Script Version - 0.0.123] [ReleaseVersion - 9.2.1.30]--[15-01-2015] -- by Chithra
ALTER TABLE PARAMETERS ADD (SENIOR_CITIZEN_AGE NUMBER(2,0) DEFAULT 60);
DROP VIEW ALL_PRODUCT_ACCTS_RECOVERYDE;

/* Formatted on 2014/12/26 10:40 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_product_accts_recoveryde (act_num,
                                                           cust_id,
                                                           prod_type,
                                                           prod_id,
                                                           rep_act_num,
                                                           branch_id,
                                                           salary_recovery,
                                                           lock_status,
                                                           acct_status,
                                                           authorization_status,
                                                           emp_refno_new,
                                                           due_status
                                                          )
AS   (   
   SELECT am.act_num AS act_num, am.cust_id, 'OA' AS prod_type, prod_id,
           am.act_num || '_1' AS rep_act_num, branch_code AS branch_id,
           'N' AS salary_recovery, 'N' AS lock_status,
           am.act_status_id AS acct_status, am.authorization_status,
           NULL AS emp_refno_new, 'NOT_DUE' AS due_status
      FROM act_master am
     WHERE am.authorization_status = 'AUTHORIZED' AND am.status != 'DELETED' AND AM.ACT_STATUS_ID != 'CLOSED'
    UNION ALL
    SELECT da.deposit_no AS act_num, da.cust_id, 'TD' AS prod_type, prod_id,
           da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status,
           da.authorize_status, dem.emp_ref_no,
           DECODE (NVL (get_rd_install (da.deposit_no,
                                        de.curr_appl_dt,
                                        da.branch_id
                                       ),
                        0
                       ),
                   0, 'NOT_DUE',
                   'DUE'
                  ) AS due_status
      FROM deposit_acinfo da,
           deposit_sub_acinfo ds,
           day_end de,
           share_acct sa,
           deduction_exemption_mapping dem
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.acct_status != 'CLOSED'
       AND ds.deposit_no = da.deposit_no
       AND de.branch_code = da.branch_id
       AND da.cust_id = sa.cust_id(+)
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'TL' AS prod_type,
           lfd.prod_id, lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, dem.emp_ref_no,
           DECODE
              (CASE
                  WHEN lrs.emi_in_simpleintrest = 'Y'
                  AND lrs.install_type = 'UNIFORM_PRINCIPLE_EMI'
                     THEN get_tl_inst_od_emi (lfd.acct_num, de.curr_appl_dt)
                  WHEN lrs.install_type = 'UNIFORM_PRINCIPLE_EMI'
                  AND lrs.emi_in_simpleintrest IS NULL
                     THEN get_tl_inst_od (lfd.acct_num, de.curr_appl_dt)
               END,
               0, 'NOT_DUE',
               'DUE'
              ) AS due_status
      FROM loans_facility_details lfd,
           loans_borrower lb,
           day_end de,
           share_acct sa,
           loans_repay_schedule lrs,
           deduction_exemption_mapping dem
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.acct_status != 'CLOSED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
       AND de.branch_code = lfd.branch_id
       AND lrs.acct_num = lfd.acct_num
       AND lb.cust_id = sa.cust_id(+)
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, dem.emp_ref_no,
           CASE
              WHEN (SELECT lsd.to_dt
                      FROM loans_sanction_details lsd
                     WHERE lsd.borrow_no = lfd.borrow_no) >
                                                   de.curr_appl_dt
                 THEN 'NOT_DUE'
              ELSE 'DUE'
           END due_status
      FROM loans_facility_details lfd,
           loans_borrower lb,
           day_end de,
           share_acct sa,
           deduction_exemption_mapping dem
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.acct_status != 'CLOSED'
       AND lfd.status != 'DELETED'
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
       AND de.branch_code = lfd.branch_id
       AND lb.cust_id = sa.cust_id(+)
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'ATL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, NULL AS emp_refno_new, NULL AS due_status
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AAD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, NULL AS emp_refno_new, NULL AS due_status
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, am.suspense_customer_id,
           'SA' AS prod_type, am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status, am.authorize_status,
           NULL AS emp_refno_new, NULL AS due_status
      FROM suspense_account_master am
     WHERE am.authorize_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num, sa.cust_id, 'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status, am.authorize_status, dem.emp_ref_no,
           DECODE (get_mds_instdue (mm.scheme_name,
                                    am.chittal_no,
                                    am.division_no,
                                    de.curr_appl_dt
                                   ),
                   0, 'NOT_DUE',
                   'DUE'
                  ) AS due_status
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa,
           day_end de,
           deduction_exemption_mapping dem
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.member_no = sa.share_acct_no(+)
       AND am.status != 'DELETED'
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
       AND de.branch_code = am.branch_code
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id, 'AB' AS prod_type,
           prod_id, am.act_master_id || '_1' AS rep_act_num,
           branch_id AS branch_id, 'N' AS salary_recovery, 'N' AS lock_status,
           am.status AS acct_status, am.authorized_status,
           NULL AS emp_refno_new, NULL AS due_status
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

ALTER TABLE SALARY_RECOVERY_LIST_DETAIL ADD (RECOVERY_TYPE VARCHAR2(10 BYTE));
ALTER TABLE SALARY_RECOVERY_LIST_DETAIL ADD (UNRECOVERY VARCHAR2(5 BYTE));

--End Version [Script Version - 0.0.123] [ReleaseVersion - 9.2.1.30]--[15-01-2015] -- by Chithra

--Start Version [Script Version - 0.0.124] [ReleaseVersion - 9.2.1.30]--[15-01-2015] -- by Jeffin John

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12229', '6133', 'Cheque Leaf Enquiry', 'APP01', 'DONE', 
    '8', 'com.see.truetransact.ui.transaction.chequeenquiry.ChequeEnquiryUI', 8, 'CREATED', NULL, 
    NULL, 'Cheque Leaf Enquiry');
COMMIT;

call INSERT_REPORT_GROUP('SCR12229');

--End Version [Script Version - 0.0.124] [ReleaseVersion - 9.2.1.30]--[15-01-2015] -- by Jeffin John

--Start Version [Script Version - 0.0.125] [ReleaseVersion - 9.2.1.30]--[16-01-2015] -- by Babu

ALTER TABLE BALANCESHEET_BALANCEFINAL MODIFY ACCOUNT_HEAD_DESC varchar2(150 Byte);

ALTER TABLE BALANCESHEET_BALANCEUPDATE MODIFY ACCOUNT_HEAD_DESC varchar2(150 Byte);

--End Version [Script Version - 0.0.125] [ReleaseVersion - 9.2.1.30]--[16-01-2015] -- by Babu

--Start Version [Script Version - 0.0.126] [ReleaseVersion - 9.2.1.30]--[16-01-2015] -- by Anju Anand

CREATE TABLE OTHER_BANK_PASSBOOK
(
  BANK_CODE       VARCHAR2(16 BYTE),
  BRANCH_CODE     VARCHAR2(32 BYTE),
  TRANS_ID        VARCHAR2(16 BYTE),
  TRANS_TYPE      VARCHAR2(32 BYTE),
  TRANS_DATE      DATE,
  INST_TYPE       VARCHAR2(32 BYTE),
  INST_DT         DATE,
  INSTRUMENT_NO1  VARCHAR2(32 BYTE),
  INSTRUMENT_NO2  VARCHAR2(32 BYTE),
  PARTICULARS     VARCHAR2(128 BYTE),
  AMOUNT          NUMBER(16,2),
  BALANCE         NUMBER(16,2),
  SRL_NO          NUMBER
);


Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06137', '6099', 'Other Bank PassBook Data Entry', 'APP01', 'DONE', 
    '39', 'com.see.truetransact.ui.passbookDataEntry.PassbookDataEntryUI', 2, 'CREATED', NULL, 
    NULL, 'Other Bank PassBook Data Entry');


Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, 
INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06137', 'CREATED', 'Y', 'Y', 
    'N', 'N', 'N', 'N', NULL);
COMMIT;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, 
INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06137', 'CREATED', 'Y', 'Y', 
    'N', 'N', 'N', 'N', NULL);
COMMIT;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, 
INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06137', 'CREATED', 'Y', 'Y', 
    'N', 'N', 'N', 'N', NULL);
COMMIT;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, 
INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06137', 'CREATED', 'Y', 'Y', 
    'N', 'N', 'N', 'N', NULL);
COMMIT;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, 
INTERBRANCH_ALLOWED)
 Values
   ('GRP00007', 'SCR06137', 'CREATED', 'Y', 'Y', 
    'N', 'N', 'N', 'N', NULL);
COMMIT;

--End Version [Script Version - 0.0.126] [ReleaseVersion - 9.2.1.30]--[16-01-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.127] [ReleaseVersion - 9.2.2.0]--[23-01-2015] -- by Anju Anand

ALTER TABLE DRF_INTEREST_RATES MODIFY AUTHORIZE_DATE DATE;

--End Version [Script Version - 0.0.127] [ReleaseVersion - 9.2.2.0]--[23-01-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.128] [ReleaseVersion - 9.2.2.0]--[28-01-2015] -- by Anju Anand

CREATE OR REPLACE PROCEDURE other_bank_bal_update (
   bankcode     VARCHAR2,
   branchcode   VARCHAR2
)
AS
    --DECLARE
    --BANKCODE VARCHAR2(16) := '5';
    --BRANCHCODE VARCHAR2(32) := '5';
   opening      NUMBER (16, 2) := 0;
   newbalance   NUMBER (16, 2) := 0;
BEGIN
   SELECT NVL (obp.balance, 0)
     INTO opening
     FROM other_bank_passbook obp
    WHERE obp.srl_no = 1;
   DECLARE
      CURSOR b
      IS
         SELECT   DECODE (trans_type,
                          'DEBIT', obp.amount * (-1),
                          obp.amount
                         ) AS amount,
                  obp.balance, obp.srl_no, obp.trans_type
             FROM other_bank_passbook obp
            WHERE obp.srl_no > 1
         ORDER BY obp.srl_no;
   BEGIN
      newbalance := opening;
      FOR i IN b
      LOOP
         newbalance := newbalance + i.amount;
        --DBMS_OUTPUT.PUT_LINE(I.SRL_NO ||'  '|| NEWBALANCE||' '||I.AMOUNT);
         UPDATE other_bank_passbook obp
            SET obp.balance = newbalance
          WHERE obp.srl_no = i.srl_no
            AND obp.bank_code = bankcode
            AND obp.branch_code = branchcode;
         COMMIT;
      END LOOP;
   END;
END;

--End Version [Script Version - 0.0.128] [ReleaseVersion - 9.2.2.0]--[28-01-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.129] [ReleaseVersion - 9.2.2.0]--[29-01-2015] -- by Chithra

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_FINAL_ACC_TYPE','TRADING','Trading','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_FINAL_ACC_TYPE','PROFIT AND LOSS','Profit And Loss','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_FINAL_ACC_TYPE','BALANCE SHEET','Balance Sheet','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','INTEREST PAYABLE','Interest Payable','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','INTEREST RECEIVABLE','Interest Receivable','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','RESERVES','Reserves','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','NET PROFIT','Net Profit','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','NET LOSS','Netloss','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','INTEREST PAID','Interest Paid','CREATED',NULL,'Y');

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values ('GL_SUB_ACC_TYPE','INTEREST RECEIVED','Interest Received','CREATED',NULL,'Y');

--End Version [Script Version - 0.0.129] [ReleaseVersion - 9.2.2.0]--[29-01-2015] -- by Chithra

--Start Version [Script Version - 0.0.130] [ReleaseVersion - 9.2.2.0]--[03-02-2015] -- by Jeffin John

ALTER TABLE history_master MODIFY primary_id VARCHAR2(50 BYTE)

ALTER TABLE history_master_details MODIFY primary_id VARCHAR2(50 BYTE)

DROP VIEW ALL_PRODUCT_ACCTS_RECOVERYDE;

CREATE OR REPLACE FORCE VIEW all_product_accts_recoveryde (act_num,
                                                           cust_id,
                                                           fname,
                                                           prod_type,
                                                           prod_id,
                                                           rep_act_num,
                                                           branch_id,
                                                           salary_recovery,
                                                           lock_status,
                                                           acct_status,
                                                           authorization_status,
                                                           emp_refno_new,
                                                           due_status,
                                                           behaves_like,
                                                           authorize_remark,
                                                           customergroup
                                                          )
AS
   (
    SELECT da.deposit_no AS act_num, da.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS fname,
           'TD' AS prod_type, da.prod_id,
           da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status,
           da.authorize_status, dem.emp_ref_no,
           DECODE (NVL (get_rd_install (da.deposit_no,
                                        de.curr_appl_dt,
                                        da.branch_id
                                       ),
                        0
                       ),
                   0, 'NOT_DUE',
                   'DUE'
                  ) AS due_status,
           NULL AS behaves_like, NULL AS authorize_remark, c.customergroup
      FROM deposit_acinfo da,
           deposit_sub_acinfo ds,
           day_end de,
           share_acct sa,
           deduction_exemption_mapping dem,
           customer c,
           deposits_product dp
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.acct_status != 'CLOSED'
       AND sa.status != 'CLOSED'
       AND ds.deposit_no = da.deposit_no
       AND de.branch_code = da.branch_id
       AND da.cust_id = c.cust_id
       AND da.prod_id = dp.prod_id
       AND dp.behaves_like = 'RECURRING'
       AND c.cust_type_id IN ('MEMBER', 'CANTEEN')
       AND da.cust_id = sa.cust_id(+)
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS fname,
           'TL' AS prod_type, lfd.prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, dem.emp_ref_no,
           DECODE
              (CASE
                  WHEN lrs.emi_in_simpleintrest = 'Y'
                  AND lrs.install_type = 'UNIFORM_PRINCIPLE_EMI'
                     THEN get_tl_inst_od_emi (lfd.acct_num, de.curr_appl_dt)
                  WHEN (    lrs.install_type = 'UNIFORM_PRINCIPLE_EMI'
                        AND NVL (lrs.emi_in_simpleintrest, 'N') = 'N'
                       )
                   OR (   lrs.install_type = 'LUMP_SUM'
                       OR lrs.install_type = 'EYI'
                      )
                     THEN get_tl_inst_od_recovery (lfd.acct_num,
                                                   de.curr_appl_dt
                                                  )
               END,
               0, 'NOT_DUE',
               'DUE'
              ) AS due_status,
           lp.behaves_like, lp.authorize_remark, c.customergroup
      FROM loans_facility_details lfd,
           loans_borrower lb,
           day_end de,
           share_acct sa,
           loans_repay_schedule lrs,
           deduction_exemption_mapping dem,
           loans_product lp,
           customer c
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.acct_status != 'CLOSED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.prod_id = lp.prod_id
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like IN ('OD', 'CC')
                 AND prod_id = lfd.prod_id
                 AND (   behaves_like = 'LOANS_AGAINST_DEPOSITS'
                      OR authorize_remark = 'GOLD LOAN'
                     ))
       AND de.branch_code = lfd.branch_id
       AND lrs.acct_num = lfd.acct_num
       AND c.cust_id = lb.cust_id
       AND lb.cust_id = sa.cust_id(+)
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS fname,
           'AD' AS prod_type, prod_id, lfd.acct_num || '_1' AS rep_act_num,
           branch_id, NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, dem.emp_ref_no,
           CASE
              WHEN (SELECT lsd.to_dt
                      FROM loans_sanction_details lsd
                     WHERE lsd.borrow_no = lfd.borrow_no) >
                                                   de.curr_appl_dt
                 THEN 'NOT_DUE'
              ELSE 'DUE'
           END due_status,
           NULL AS behaves_like, NULL AS authorize_remark, c.customergroup
      FROM loans_facility_details lfd,
           loans_borrower lb,
           day_end de,
           share_acct sa,
           deduction_exemption_mapping dem,
           customer c
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.acct_status != 'CLOSED'
       AND sa.status != 'CLOSED'
       AND lfd.status != 'DELETED'
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
       AND c.cust_id = lb.cust_id
       AND de.branch_code = lfd.branch_id
       AND c.cust_type_id IN ('MEMBER', 'CANTEEN')
       AND lb.cust_id = sa.cust_id(+)
       AND sa.emp_refno_new = dem.emp_ref_no(+)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, am.suspense_customer_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS fname,
           'SA' AS prod_type, am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           am.branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status, am.authorize_status,
           NULL AS emp_refno_new, 'NOT_DUE' AS due_status,
           NULL AS behaves_like, NULL AS authorize_remark, c.customergroup
      FROM suspense_account_master am, customer c
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.status != 'DELETED'
       AND am.suspense_customer_id = c.cust_id
    UNION ALL
    SELECT am.chittal_no AS act_num, sa.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS fname,
           'MDS' AS prod_type, am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status, am.authorize_status, dem.emp_ref_no,
           DECODE (get_mds_instdue (mm.scheme_name,
                                    am.chittal_no,
                                    am.division_no,
                                    de.curr_appl_dt
                                   ),
                   0, 'NOT_DUE',
                   'DUE'
                  ) AS due_status,
           NULL AS behaves_like, NULL AS authorize_remark, c.customergroup
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa,
           day_end de,
           deduction_exemption_mapping dem,
           customer c
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.member_no = sa.share_acct_no(+)
       AND am.status != 'DELETED'
       AND sa.status != 'CLOSED'
       AND msd.scheme_end_dt >= de.curr_appl_dt
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
       AND de.branch_code = am.branch_code
       AND c.cust_id = sa.cust_id
       AND c.cust_type_id IN ('MEMBER', 'CANTEEN')
       AND sa.emp_refno_new = dem.emp_ref_no(+)
   );

CREATE OR REPLACE function getRecoveryDueEmp(emprefno varchar2) return varchar2 is 
            retNo varchar2(32);
        begin
            begin
                select distinct emp_refno_new into retNo from all_product_accts_recoveryde apr1 where 
                emprefno = apr1.emp_refno_new AND due_status = 'DUE' and apr1.emp_refno_new is not null ;   
            exception when others then retNo:=null;
            end;
            return retNo;
        end;
/

--End Version [Script Version - 0.0.130] [ReleaseVersion - 9.2.2.0]--[03-02-2015] -- by Jeffin John

--Start Version [Script Version - 0.0.131] [ReleaseVersion - 9.2.2.0]--[05-02-2015] -- by Rishad

CREATE OR REPLACE FORCE VIEW operative_suspense_prod (prod_id, prod_desc)
AS
   (SELECT oap.prod_id, oap.prod_desc
      FROM op_ac_product oap
     WHERE oap.authorized_status = 'AUTHORIZED'
       AND oap.status != 'DELETED'
       AND oap.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT sam.prod_id, sam.prod_desc
      FROM suspense_product sam
     WHERE sam.authorized_status = 'AUTHORIZED'
       AND sam.status != 'DELETED'
       AND sam.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT dp.prod_id, dp.prod_desc
      FROM deposits_product dp
     WHERE dp.authorize_status = 'AUTHORIZED'
       AND dp.status != 'DELETED'
       AND dp.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                     FROM mds_application ma
                                    WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT a.prod_id, a.prod_desc
      FROM advance_product a
     WHERE a.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                    FROM mds_application ma
                                   WHERE ma.prod_id IS NOT NULL));

--End Version [Script Version - 0.0.131] [ReleaseVersion - 9.2.2.0]--[05-02-2015] -- by Rishad

--Start Version [Script Version - 0.0.132] [ReleaseVersion - 9.2.2.0]--[09-02-2015] -- by Sreekrishnan
    ALTER TABLE LOANS_PRODUCT ADD(ZERO_INTEREST VARCHAR(2) DEFAULT 'N')
    ALTER TABLE LOANS_PRODUCT ADD ZERO_INTEREST_PERIOD NUMBER(16,2) DEFAULT(0);
--End Version [Script Version - 0.0.132] [ReleaseVersion - 9.2.2.0]--[09-02-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.133] [ReleaseVersion - 9.2.2.0]--[09-02-2015] -- by Babu
CREATE OR REPLACE FUNCTION get_curr_id (
idkey VARCHAR2,
branchid VARCHAR2
)
RETURN VARCHAR2
IS
Pragma Autonomous_Transaction;
id_prefix ID_GENERATION.PREFIX%TYPE;
id_currvalue ID_GENERATION.CURR_VALUE%TYPE;
id_length ID_GENERATION.ID_LENGTH%TYPE;
new_id VARCHAR2(20);
BEGIN
-- DBMS_OUTPUT.PUT_LINE('idkey :'||idkey||' / branchid'||branchid);
IF branchid is not null THEN
UPDATE ID_GENERATION SET CURR_VALUE=CURR_VALUE+1 WHERE ID_KEY=idkey AND BRANCH_CODE = branchid;
commit;
SELECT PREFIX, CURR_VALUE, ID_LENGTH INTO id_prefix, id_currvalue, id_length 
FROM ID_GENERATION WHERE ID_KEY = idkey AND BRANCH_CODE = branchid;
new_id:=UPPER(id_prefix)||LPAD(id_currvalue, id_length-LENGTH(id_prefix), '0');
ELSE
UPDATE ID_GENERATION SET CURR_VALUE=CURR_VALUE+1 WHERE ID_KEY=idkey;
commit;
SELECT PREFIX, CURR_VALUE, ID_LENGTH INTO id_prefix, id_currvalue, id_length 
FROM ID_GENERATION WHERE ID_KEY = idkey;
new_id:=UPPER(id_prefix)||LPAD(id_currvalue, id_length-LENGTH(id_prefix), '0');
END IF;
COMMIT;
return new_id;
END;
/

  

/* Formatted on 2015/02/04 16:46 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_product_accts_new (act_num,
                                                 cust_id,
                                                 prod_type,
                                                 prod_id,
                                                 rep_act_num,
                                                 branch_id,
                                                 salary_recovery,
                                                 lock_status,
                                                 acct_status,
                                                 authorization_status,
                                                 int_pay_acc_no
                                                )
AS   (
   SELECT am.act_num AS act_num, am.cust_id, 'OA' AS prod_type, prod_id,
           am.act_num || '_1' AS rep_act_num, branch_code AS branch_id,
           'N' AS salary_recovery, 'N' AS lock_status,
           am.act_status_id AS acct_status, am.authorization_status, '' as int_pay_acc_no 
      FROM act_master am
     WHERE am.authorization_status = 'AUTHORIZED' AND am.status != 'DELETED'
     and am.ACT_STATUS_ID != 'CLOSED'
    UNION ALL    
    SELECT da.deposit_no AS act_num, da.cust_id, 'TD' AS prod_type, prod_id,
           da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status,
           da.authorize_status,DS.INT_PAY_ACC_NO
      FROM deposit_acinfo da, deposit_sub_acinfo ds
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.deposit_no = da.deposit_no and dS.acct_status !='CLOSED'       
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'TL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, '' as int_pay_acc_no
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED' and LFD.ACCT_STATUS!='CLOSED'
       AND NOT EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1,'' as int_pay_acc_no
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id) and LFD.ACCT_STATUS != 'CLOSED'
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'ATL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,
           lfd.authorize_status_1,'' AS int_pay_acc_no
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id) AND  LFD.ACCT_STATUS != 'CLOSED' 
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AAD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,
           lfd.authorize_status_1,'' AS  int_pay_acc_no 
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id) and LFD.ACCT_STATUS != 'CLOSED'
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, am.suspense_customer_id,
           'SA' AS prod_type, am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status, am.authorize_status, '' AS int_pay_acc_no
      FROM suspense_account_master am
     WHERE am.authorize_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num, sa.cust_id, 'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status, am.authorize_status,'' AS int_pay_acc_no
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.member_no = sa.share_acct_no(+)
       AND am.status != 'DELETED'
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id, 'AB' AS prod_type,
           prod_id, am.act_master_id || '_1' AS rep_act_num,
           branch_id AS branch_id, 'N' AS salary_recovery, 'N' AS lock_status,
           am.status AS acct_status, am.authorized_status,'' AS  int_pay_acc_no
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED'
     );




CREATE OR REPLACE FORCE VIEW all_product_accts_new1 (act_num,
                                                prod_type,
                                                prod_id,
                                                rep_act_num,
                                                branch_id,
                                                salary_recovery,
                                                lock_status,
                                                acct_status
                                               )
AS
   (SELECT act_num, prod_type, prod_id, rep_act_num, branch_id,
           salary_recovery, lock_status, acct_status
      FROM all_product_accts_new
    UNION ALL
    SELECT act_num, prod_type, prod_id, old_act_num AS rep_act_num, branch_id,
           salary_recovery, lock_status, acct_status
      FROM old_ac_nos tt, all_product_accts_new apa
     WHERE new_act_num = act_num);





 CREATE OR REPLACE FUNCTION GET_SI_ACTNO_DEPOSIT (ACTNUM VARCHAR) RETURN VARCHAR IS
        ACT_NUM VARCHAR(20);     
        BEGIN
        SELECT INT_PAY_ACC_NO INTO ACT_NUM  FROM DEPOSIT_SUB_ACINFO WHERE 
        DEPOSIT_NO=ACTNUM AND STATUS!='DELETED' AND ACCT_STATUS!='CLOSED' AND
        AUTHORIZE_STATUS='AUTHORIZED';
        RETURN ACT_NUM;
        END;
        /
--End Version [Script Version - 0.0.133] [ReleaseVersion - 9.2.2.0]--[09-02-2015] -- by Babu

--Start Version [Script Version - 0.0.134] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by jeffin John

alter table LOANS_PROD_ACPARAM add is_interest_paid_first varchar (2 byte) default 'N'

CREATE OR REPLACE FUNCTION GET_TL_INIT_INTEREST(LOAN_NO VARCHAR2) RETURN NUMBER IS
--DECLARE
--    LOAN_NO LOANS_FACILITY_DETAILS.ACCT_NUM%TYPE := '0001201014959';
    LOAN_AMOUNT LOANS_SANCTION_DETAILS.LIMIT%TYPE := 0;
    FDATE LOANS_SANCTION_DETAILS.FROM_DT%TYPE;
    TDATE LOANS_SANCTION_DETAILS.TO_DT%TYPE;
    ROI LOANS_INT_MAINTENANCE.INTEREST%TYPE;
    INT_AMOUNT LOAN_TRANS_DETAILS.INTEREST%TYPE := 0;
BEGIN
    BEGIN
        SELECT SD.LIMIT,SD.FROM_DT,SD.TO_DT,
               CASE WHEN F.INT_GET_FROM = 'ACT' THEN
                        (SELECT LI.INTEREST FROM LOANS_INT_MAINTENANCE LI WHERE LI.ACCT_NUM = F.ACCT_NUM AND LI.STATUS != 'DELETED')
                    WHEN F.INT_GET_FROM = 'PROD' THEN 
                         GET_TL_ROI(F.PROD_ID,SD.FROM_DT,SD.LIMIT)
                    ELSE 0
               END INTO LOAN_AMOUNT,FDATE,TDATE,ROI
        FROM LOANS_SANCTION_DETAILS SD
        JOIN LOANS_FACILITY_DETAILS F ON F.BORROW_NO = SD.BORROW_NO
        WHERE F.ACCT_NUM = LOAN_NO AND F.AUTHORIZE_STATUS_1 IS NULL;
        INT_AMOUNT := (LOAN_AMOUNT * (TDATE - FDATE) * ROI) / 36500;
    EXCEPTION
        WHEN OTHERS THEN
             INT_AMOUNT := 0;
    END;
    RETURN round(INT_AMOUNT);
--    DBMS_OUTPUT.PUT_LINE(' INT_AMOUNT ' || TO_CHAR(INT_AMOUNT) || ' LOAN_AMOUNT ' || LOAN_AMOUNT ||
--                         ' NOD ' || (TDATE - FDATE) || ' ROI ' || ROI );
END;

--End Version [Script Version - 0.0.134] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by jeffin John

--Start Version [Script Version - 0.0.135] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Babu
/* Formatted on 2015/02/16 11:51 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW rep_mds_notice_one (chittal_no,
                                                               member_no,
                                                               chittal_name,
                                                               scheme_start_dt,
                                                               scheme_end_dt,
                                                               total_amount,
                                                               paid_amount,
                                                               last_paid_dt,
                                                               branch_code,
                                                               mds_interest,
                                                               mds_due,
                                                               scheme_name,
                                                               no_of_inst_paid,
                                                               current_installment,
                                                               cust_id,
                                                               comm_addr_type,
                                                               chittal_street,
                                                               chittal_area,
                                                               chittal_state,
                                                               chittal_pincode,
                                                               MEMBER,
                                                               scheme_desc,
                                                               day_end_dt,
                                                               tel_no,
                                                               pending_inst,
                                                               div_no,
                                                               sub_no
                                                              )
AS
   SELECT chittal_no, member_no, fname, scheme_start_dt, scheme_end_dt,
          total_amount, paid_amount, last_paid_dt, branch_code, mds_interest,
          mds_due, scheme_name, no_of_inst_paid, current_installment, cust_id,
          comm_addr_type, chittal_street, chittal_area, chittal_state,
          chittal_pincode, MEMBER, scheme_desc, day_end_dt, tel_no,
          pending_inst, div_no, sub_no
     FROM (SELECT ma.chittal_no, ma.member_no, c.fname, msd.scheme_start_dt,
                  msd.scheme_end_dt,
                  msd.total_amount_division AS total_amount,
                  (SELECT SUM (((net_amt - penal_amt) + bonus_amt)
                              )
                     FROM mds_trans_details
                    WHERE mds_trans_details.chittal_no = ma.chittal_no)
                                                               AS paid_amount,
                  (SELECT MAX (draw_auction_date)
                     FROM mds_prized_money_details
                    WHERE scheme_name = msd.scheme_name
                      AND installment_no = (SELECT SUM (no_of_inst)
                                              FROM mds_trans_details
                                             WHERE chittal_no = ma.chittal_no))
                                                              AS last_paid_dt,
                  msd.branch_code,
                  get_mds_penal (ma.chittal_no, ma.sub_no) AS mds_interest,
                  get_mds_instdue (ma.scheme_name,
                                   ma.chittal_no,
                                   ma.division_no,
                                   (SELECT curr_appl_dt
                                      FROM day_end
                                     WHERE branch_code = msd.branch_code)
                                  ) mds_due,
                  msd.scheme_name,
                  get_mds_paidinstcount (ma.chittal_no,
                                         d.curr_appl_dt
                                        ) AS no_of_inst_paid,
                  (SELECT MAX (installment_no)
                     FROM mds_prized_money_details
                    WHERE scheme_name =
                                       msd.scheme_name)
                                                       AS current_installment,
                  ma.cust_id, c.comm_addr_type, c.care_of_name,
                  ca.street AS chittal_street, ca.area AS chittal_area,
                  ca.city chittal_city, ca.state AS chittal_state,
                  ca.pin_code chittal_pincode, c.membership_class AS MEMBER,
                  msd.scheme_desc, d.curr_appl_dt AS day_end_dt,
                  get_cust_phone (c.cust_id, c.comm_addr_type) AS tel_no,
                  (  (SELECT MAX (installment_no)
                        FROM mds_prized_money_details
                       WHERE scheme_name = msd.scheme_name)
                   - get_mds_paidinstcount (ma.chittal_no, d.curr_appl_dt)
                  ) AS pending_inst,
                  ma.division_no AS div_no, ma.sub_no
             FROM mds_application ma,
                  mds_scheme_details msd,
                  mds_master_maintenance mm,
                  customer c,
                  cust_addr ca,
                  day_end d
            WHERE ma.scheme_name = msd.scheme_name
              AND ma.cust_id = c.cust_id
              AND c.cust_id = ca.cust_id
              AND ca.addr_type = c.comm_addr_type
              AND msd.branch_code = d.branch_code
              AND ma.chittal_no = mm.chittal_no) mds
    WHERE mds.pending_inst > 0;

--End Version [Script Version - 0.0.135] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Babu

--Start Version [Script Version - 0.0.136] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Chithra

CREATE TABLE WEEKLY_INSTALLMENT_SLAB
(
  PROD_ID        VARCHAR2(28 BYTE),
  TYPE           VARCHAR2(50 BYTE),
  FROM_INSTALL   NUMBER,
  TO_INSTALL     NUMBER,
  INSTALLMENT_NO  NUMBER,
  PENAL          NUMBER(5) DEFAULT 0
)

insert into LOOKUP_MASTER values ('PERIOD','WEEKS','Weeks','CREATED','','Y');
insert into LOOKUP_MASTER values ('DEPOSITSPRODUCT.INT_CALC_METHOD','WEEKLY','Weekly','CREATED','','Y');
insert into LOOKUP_MASTER values ('LOANPRODUCT.LOANPERIODS','WEEKLY','Weekly','CREATED','','Y');

--End Version [Script Version - 0.0.136] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Chithra

--Start Version [Script Version - 0.0.137] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Shihad

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06138', '6138', 'Payment Voucher', 'APP01', 'DONE', 
    '41', 'com.see.truetransact.ui.payroll.voucherprocessing.PaymentVoucherUI', 54, 'CREATED', NULL, 
    NULL, 'Voucher Processing');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06138', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06138', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06138', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
COMMIT;

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06139', '6139', 'Head Consolidation', 'APP01', 'DONE', 
    '41', 'com.see.truetransact.ui.payroll.voucherprocessing.HeadConsolidationUI', 55, 'CREATED', NULL, 
    NULL, 'Head Consolidation');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06139', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06139', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06139', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
COMMIT;

ALTER TABLE PAYROLL_DEDUCTION_MAPPING ADD STATUS VARCHAR2(16 BYTE);

--End Version [Script Version - 0.0.137] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Shihad

--Start Version [Script Version - 0.0.138] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Rishad

CREATE OR REPLACE FORCE VIEW operative_suspense_prod (prod_id, prod_desc)
AS
   (SELECT oap.prod_id, oap.prod_desc
      FROM op_ac_product oap
     WHERE oap.authorized_status = 'AUTHORIZED'
       AND oap.status != 'DELETED'
       AND oap.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT sam.prod_id, sam.prod_desc
      FROM suspense_product sam
     WHERE sam.authorized_status = 'AUTHORIZED'
       AND sam.status != 'DELETED'
       AND sam.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                      FROM mds_application ma
                                     WHERE ma.prod_id IS NOT NULL)
    UNION ALL
    SELECT dp.prod_id, dp.prod_desc
      FROM deposits_product dp
     WHERE dp.authorize_status = 'AUTHORIZED'
       AND dp.status != 'DELETED'
       AND dp.prod_id IN (SELECT DISTINCT (ma.prod_id)
                                     FROM mds_application ma
                                    WHERE ma.prod_id IS NOT NULL)
    UNION ALL 
       SELECT  A.PROD_ID,A.PROD_DESC FROM ADVANCES_PRODUCT  A
                                   WHERE A.AUTHORIZE_STATUS='AUTHORIZED'
                                   AND A.STATUS !='DELETED'
                                   AND A.PROD_ID IN ( SELECT DISTINCT(MA.PROD_ID) FROM MDS_APPLICATION MA
                                   WHERE MA.PROD_ID IS NOT NULL)                             
                                    );

--End Version [Script Version - 0.0.138] [ReleaseVersion - 9.2.2.0]--[16-02-2015] -- by Rishad

--Start Version [Script Version - 0.0.139] [ReleaseVersion - 9.2.2.0]--[24-02-2015] -- by Shihad

ALTER TABLE SHARE_ACCT ADD CLOSE_DT DATE;

--End Version [Script Version - 0.0.139] [ReleaseVersion - 9.2.2.0]--[24-02-2015] -- by Shihad

--Start Version [Script Version - 0.0.140] [ReleaseVersion - 9.2.2.0]--[04-03-2015] -- by Chithra

 ALTER TABLE DEPOSITS_PROD_RD ADD (WEEKLY_SPEC VARCHAR2(5 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.140] [ReleaseVersion - 9.2.2.0]--[04-03-2015] -- by Chithra

--Start Version [Script Version - 0.0.141] [ReleaseVersion - 9.2.2.0]--[06-03-2015] -- by Jeffin John

alter table SUSPENSE_ACCOUNT_MASTER add SUSPENSE_LAST_INT_CALC_DT DATE 

CREATE OR REPLACE FUNCTION get_advamt_emi (
   actnum                VARCHAR2,
   asondate              DATE,
   emiinsimpleinterest   VARCHAR2,
   installmenttype       VARCHAR2
)
   RETURN NUMBER
IS
--DECLARE
--actNum varchar2(13):= '0001304001253';
--asonDate date := '28FEB2015';
   loandate   DATE;
   recble     NUMBER (16, 2);
   balance    NUMBER (16, 2);
   recvd      NUMBER (16, 2);
--EMIINSIMPLEINTEREST VARCHAR2(2) := 'Y';
--INSTALLMENTTYPE VARCHAR2(25) := 'UNIFORM_PRINCIPLE_EMI';
BEGIN
   SELECT lsd.from_dt
     INTO loandate
     FROM loans_facility_details lfd JOIN loans_sanction_details lsd
          ON lsd.borrow_no = lfd.borrow_no
    WHERE lfd.acct_num = actnum;
--DBMS_OUTPUT.PUT_LINE('loandate jeff   ' || loandate);
   SELECT NVL (SUM (li.total_amt), 0)
     INTO recble
     FROM loans_installment li
    WHERE li.installment_dt <= asondate AND li.acct_num = actnum;

   SELECT NVL (SUM (ltd.principle + ltd.interest), 0)
     INTO recvd
     FROM loan_trans_details ltd
    WHERE ltd.trans_dt <= asondate
      AND ltd.act_num = actnum
      AND ltd.trans_type = 'CREDIT';

   balance := recble - recvd;

   IF balance <= 0
   THEN
      balance := 0;
   END IF;

--DBMS_OUTPUT.PUT_LINE('balance jeff   ' || BALANCE);
   RETURN balance;
END;
/

CREATE OR REPLACE FUNCTION GETSUSPENSEDUE2(ACTNUM VARCHAR,ASONDT DATE) 
RETURN NUMBER IS
INST_AMT NUMBER(16,2):=0;
PAID_AMT NUMBER(16,2):=0;
return_AMT NUMBER(16,2):=0;
RECD_AMT NUMBER(16,2):=0;
BALANCE NUMBER(16,2):=0;
OPENING NUMBER(16,2);
BEGIN
BEGIN
    SELECT nvl(SUM (sui.paid_amount),0) INTO return_AMT  
      FROM suspense_installment sui
     WHERE sui.acct_num = ACTNUM
       AND paid_date <= ASONDT
       AND sui.bill_id IS NOT NULL;
    EXCEPTION WHEN OTHERS THEN return_AMT:=0;
END;
BEGIN
    SELECT nvl(SUM (sui.INSTALLMENT_AMOUNT),0) INTO OPENING  
      FROM suspense_installment sui
     WHERE sui.acct_num = ACTNUM
       AND SUI.INSTALLMENT_DATE <= ASONDT
       AND sui.bill_id IS NULL;
    EXCEPTION WHEN OTHERS THEN OPENING:=0;
END;
BEGIN
    SELECT NVL(SUM (SI.INSTALLMENT_AMOUNT),0) INTO INST_AMT
      FROM SUSPENSE_INSTALLMENT SI
    WHERE SI.ACCT_NUM = ACTNUM 
     AND SI.INSTALLMENT_DATE <= ASONDT and si.bill_id is not null;   
    EXCEPTION WHEN OTHERS THEN INST_AMT:=0;
END;
BEGIN
    SELECT NVL (SUM (S.PAID_AMOUNT), 0) INTO PAID_AMT
      FROM SUSPENSE_INSTALLMENT S,DAY_END DE
     WHERE S.ACCT_NUM = ACTNUM AND S.PAID_DATE <= DE.CURR_APPL_DT and S.TRANS_ALL_ID is not null;
    EXCEPTION WHEN OTHERS THEN PAID_AMT:=0;
END;
    INST_AMT := OPENING + INST_AMT;
    BALANCE:= INST_AMT - (PAID_AMT + return_AMT) ;
RETURN BALANCE; 
END;
/

alter table SALARY_RECOVERY_LIST_DETAIL add voucher_release_date date

alter table SALARY_RECOVERY_LIST_DETAIL add voucher_release_batch_id varchar2(16 byte)
						  						  
CREATE OR REPLACE FUNCTION GETSUSPENSEDUERECTRANS(ACTNUM VARCHAR,ASONDT
DATE)
RETURN NUMBER IS
INST_AMT NUMBER(16,2):=0;
PAID_AMT NUMBER(16,2):=0;
return_AMT NUMBER(16,2):=0;
RECD_AMT NUMBER(16,2):=0;
BALANCE NUMBER(16,2):=0;
OPENING NUMBER(16,2);
asondt2 date ;
BEGIN
select last_day(add_months(asondt,-1)) into asondt2 from dual;
BEGIN
    SELECT nvl(SUM (sui.paid_amount),0) INTO return_AMT
      FROM suspense_installment sui
     WHERE sui.acct_num = ACTNUM
       AND paid_date <= ASONDT
       AND sui.bill_id IS NOT NULL;
    EXCEPTION WHEN OTHERS THEN return_AMT:=0;
END;
BEGIN
    SELECT nvl(SUM (sui.INSTALLMENT_AMOUNT),0) INTO OPENING
      FROM suspense_installment sui
     WHERE sui.acct_num = ACTNUM
       AND SUI.INSTALLMENT_DATE <= ASONDT
       AND sui.bill_id IS NULL;
    EXCEPTION WHEN OTHERS THEN OPENING:=0;
END;
BEGIN
    SELECT NVL(SUM (SI.INSTALLMENT_AMOUNT),0) into INST_AMT
      FROM SUSPENSE_INSTALLMENT SI
    WHERE SI.ACCT_NUM = ACTNUM
     AND SI.INSTALLMENT_DATE < ASONDT2 and si.bill_id is not null;
    EXCEPTION WHEN OTHERS THEN INST_AMT:=0;
END;
BEGIN
    SELECT NVL (SUM (S.PAID_AMOUNT), 0) INTO PAID_AMT
      FROM SUSPENSE_INSTALLMENT S,DAY_END DE
     WHERE S.ACCT_NUM = ACTNUM AND S.PAID_DATE <= DE.CURR_APPL_DT and
S.TRANS_ALL_ID is not null;
    EXCEPTION WHEN OTHERS THEN PAID_AMT:=0;
END;
    INST_AMT := OPENING + INST_AMT;
    BALANCE:= INST_AMT - (PAID_AMT + return_AMT) ;
RETURN BALANCE;
END;
/

CREATE OR REPLACE FUNCTION GET_SUS_INTEREST(ACTNUM VARCHAR,ASONDT DATE)
RETURN NUMBER IS
--DECLARE
--ACTNUM VARCHAR2(16) := '0001603000966';
--ASONDT DATE := '19-dec-2014'; 
   STARTDATE            DATE;
   INT_DAYS             NUMBER(16,2);
   INST_PEND_AMT        NUMBER(16,2);
   INTEREST             NUMBER(16,2) :=0;
   ROI                  NUMBER(16,2) := 0;
   GRACE_PERIOD         NUMBER(16,2);
   PAIDAMT              NUMBER(16,2):=0; 
   PAIDINT              NUMBER(16,2);
   INSTALLMENT_AMOUNT   NUMBER(16,2);
   LASTPAIDDATE         DATE;
   PENDINGAMT           NUMBER(16,2);
   INSTSTARTDATE        DATE;
   FLAG                 NUMBER(1) :=0;
   NEXTINSTDUEDT        DATE;
   DUEDT                DATE;    
BEGIN
    SELECT S.INTEREST_RATE, S.GRACE_PERIOD_DAYS
    INTO ROI, GRACE_PERIOD
    FROM SHOP_MASTER_TABLE S;
    SELECT NVL (SUM (SI.PAID_AMOUNT), 0), NVL (SUM (SI.INTEREST), 0)
     INTO PAIDAMT, PAIDINT
     FROM SUSPENSE_INSTALLMENT SI
    WHERE SI.PAID_DATE <= ASONDT AND SI.ACCT_NUM = ACTNUM;
    SELECT LAST_DAY(ADD_MONTHS(ASONDT,-2))+ 1 INTO DUEDT FROM DUAL;
    IF PAIDAMT > 0 THEN
        --DBMS_OUTPUT.PUT_LINE('inside loop PAIDAMT  ='||PAIDAMT);
        DECLARE CURSOR INSTDUE IS 
        SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
           NVL (SUM (INSTALLMENT_AMOUNT),0) AS INSTALLMENT_AMOUNT
           FROM SUSPENSE_INSTALLMENT   
           WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE < DUEDT and installment_amount > 0
        GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
        ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');
        BEGIN
            FOR I IN INSTDUE 
                LOOP
                PAIDAMT := PAIDAMT - I.INSTALLMENT_AMOUNT;
                if flag = 0 then
                    IF PAIDAMT <0 AND FLAG =0 THEN
                    LASTPAIDDATE := I.INSTALLMENT_DATE;
                    PENDINGAMT   := PAIDAMT * (-1);
                    SELECT LAST_DAY(LASTPAIDDATE) INTO NEXTINSTDUEDT FROM DUAL;
                    SELECT LAST_DAY(LASTPAIDDATE )+ GRACE_PERIOD INTO INSTSTARTDATE FROM DUAL;
                    INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(INSTSTARTDATE,'DD-MM-YYYY')) + 1;
                    INTEREST := INTEREST +  (PENDINGAMT * INT_DAYS * ROI / 36500);
                    FLAG := 1;
                    END IF;
                end if;
                END LOOP;
        END;
        IF FLAG = 1 THEN
                DECLARE CURSOR CURPENAL IS
                SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
                   NVL (SUM (INSTALLMENT_AMOUNT),0) AS INSTALLMENT_AMOUNT
                   FROM SUSPENSE_INSTALLMENT   
                   WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE >  NEXTINSTDUEDT AND INSTALLMENT_DATE < DUEDT
                GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
                ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');
                BEGIN
                    FOR J IN CURPENAL LOOP
                        INST_PEND_AMT := J.INSTALLMENT_AMOUNT;
                        STARTDATE := J.INSTALLMENT_DATE;
                        INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(STARTDATE,'DD-MM-YYYY')) + 1;
                        INTEREST := INTEREST +  (INST_PEND_AMT * INT_DAYS * ROI / 36500);
                    END LOOP;
                END;
        END IF;
    ELSE
    DECLARE CURSOR CURPENAL IS  
    SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
    NVL (SUM (INSTALLMENT_AMOUNT), 0) AS INSTALLMENT_AMOUNT
    FROM SUSPENSE_INSTALLMENT
    WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE < DUEDT
    GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
    ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');   
         BEGIN
            FOR PENAL IN CURPENAL
            LOOP
            INST_PEND_AMT := PENAL.INSTALLMENT_AMOUNT;
            STARTDATE := PENAL.INSTALLMENT_DATE;
            SELECT LAST_DAY(STARTDATE) + GRACE_PERIOD INTO STARTDATE FROM DUAL;
            INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(STARTDATE,'DD-MM-YYYY')) + 1;
            INTEREST := INTEREST +  (INST_PEND_AMT * INT_DAYS * ROI / 36500);
            END LOOP;
         END;
    INTEREST := ROUND(INTEREST);
    END IF;
    INTEREST := ROUND(INTEREST);
    INTEREST := INTEREST - nvl(PAIDINT,0);
    IF INTEREST < 0  THEN
    INTEREST := 0;
    END IF;
    RETURN INTEREST;
END;
/

CREATE OR REPLACE FUNCTION GET_SUS_INTEREST_TRANS_ALL(ACTNUM VARCHAR,ASONDT DATE)
RETURN NUMBER IS
--DECLARE
--ACTNUM VARCHAR2(16) := '0001603000966';
--ASONDT DATE := '19-dec-2014'; 
   STARTDATE            DATE;
   INT_DAYS             NUMBER(16,2);
   INST_PEND_AMT        NUMBER(16,2);
   INTEREST             NUMBER(16,2) :=0;
   ROI                  NUMBER(16,2) := 0;
   GRACE_PERIOD         NUMBER(16,2);
   PAIDAMT              NUMBER(16,2):=0; 
   PAIDINT              NUMBER(16,2);
   INSTALLMENT_AMOUNT   NUMBER(16,2);
   LASTPAIDDATE         DATE;
   PENDINGAMT           NUMBER(16,2);
   INSTSTARTDATE        DATE;
   FLAG                 NUMBER(1) :=0;
   NEXTINSTDUEDT        DATE;
   DUEDT                DATE;    
BEGIN
    SELECT S.INTEREST_RATE, S.GRACE_PERIOD_DAYS
    INTO ROI, GRACE_PERIOD
    FROM SHOP_MASTER_TABLE S;
    SELECT NVL (SUM (SI.PAID_AMOUNT), 0), NVL (SUM (SI.INTEREST), 0)
     INTO PAIDAMT, PAIDINT
     FROM SUSPENSE_INSTALLMENT SI
    WHERE SI.PAID_DATE <= ASONDT AND SI.ACCT_NUM = ACTNUM;
    SELECT LAST_DAY(ADD_MONTHS(ASONDT,-1))+ 1 INTO DUEDT FROM DUAL;
    IF PAIDAMT > 0 THEN
        --DBMS_OUTPUT.PUT_LINE('inside loop PAIDAMT  ='||PAIDAMT);
        DECLARE CURSOR INSTDUE IS 
        SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
           NVL (SUM (INSTALLMENT_AMOUNT),0) AS INSTALLMENT_AMOUNT
           FROM SUSPENSE_INSTALLMENT   
           WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE < DUEDT and installment_amount > 0
        GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
        ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');
        BEGIN
            FOR I IN INSTDUE 
                LOOP
                PAIDAMT := PAIDAMT - I.INSTALLMENT_AMOUNT;
                if flag = 0 then
                    IF PAIDAMT <0 AND FLAG =0 THEN
                    LASTPAIDDATE := I.INSTALLMENT_DATE;
                    PENDINGAMT   := PAIDAMT * (-1);
                    SELECT LAST_DAY(LASTPAIDDATE) INTO NEXTINSTDUEDT FROM DUAL;
                    SELECT LAST_DAY(LASTPAIDDATE )+ GRACE_PERIOD INTO INSTSTARTDATE FROM DUAL;
                    INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(INSTSTARTDATE,'DD-MM-YYYY')) + 1;
                    INTEREST := INTEREST +  (PENDINGAMT * INT_DAYS * ROI / 36500);
                    FLAG := 1;
                    END IF;
                end if;
                END LOOP;
        END;
        IF FLAG = 1 THEN
                DECLARE CURSOR CURPENAL IS
                SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
                   NVL (SUM (INSTALLMENT_AMOUNT),0) AS INSTALLMENT_AMOUNT
                   FROM SUSPENSE_INSTALLMENT   
                   WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE >  NEXTINSTDUEDT AND INSTALLMENT_DATE < DUEDT
                GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
                ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');
                BEGIN
                    FOR J IN CURPENAL LOOP
                        INST_PEND_AMT := J.INSTALLMENT_AMOUNT;
                        STARTDATE := J.INSTALLMENT_DATE;
                        INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(STARTDATE,'DD-MM-YYYY')) + 1;
                        INTEREST := INTEREST +  (INST_PEND_AMT * INT_DAYS * ROI / 36500);
                    END LOOP;
                END;
        END IF;
    ELSE
    DECLARE CURSOR CURPENAL IS  
    SELECT TO_DATE('01/' || EXTRACT (MONTH FROM INSTALLMENT_DATE) || '/' || EXTRACT (YEAR FROM INSTALLMENT_DATE),'DD-MM-YYYY') AS INSTALLMENT_DATE,
    NVL (SUM (INSTALLMENT_AMOUNT), 0) AS INSTALLMENT_AMOUNT
    FROM SUSPENSE_INSTALLMENT
    WHERE ACCT_NUM = ACTNUM AND INSTALLMENT_DATE < DUEDT
    GROUP BY EXTRACT (MONTH FROM INSTALLMENT_DATE),EXTRACT (YEAR FROM INSTALLMENT_DATE)
    ORDER BY TO_DATE(INSTALLMENT_DATE,'DD-MM-YYYY');   
         BEGIN
            FOR PENAL IN CURPENAL
            LOOP
            INST_PEND_AMT := PENAL.INSTALLMENT_AMOUNT;
            STARTDATE := PENAL.INSTALLMENT_DATE;
            SELECT LAST_DAY(STARTDATE) + GRACE_PERIOD INTO STARTDATE FROM DUAL;
            INT_DAYS := (TO_DATE(ASONDT,'DD-MM-YYYY')-TO_DATE(STARTDATE,'DD-MM-YYYY')) + 1;
            INTEREST := INTEREST +  (INST_PEND_AMT * INT_DAYS * ROI / 36500);
            END LOOP;
         END;
    INTEREST := ROUND(INTEREST);
    END IF;
    INTEREST := ROUND(INTEREST);
    INTEREST := INTEREST - nvl(PAIDINT,0);
    IF INTEREST < 0  THEN
    INTEREST := 0;
    END IF;
    RETURN INTEREST;
END;
/

DROP VIEW ALL_PRODUCT_ACCTS_RECOVERYDE;

CREATE OR REPLACE FORCE VIEW all_product_accts_recoveryde (act_num,
                                                                cust_id,
                                                                prod_type,
                                                                prod_id,
                                                                rep_act_num,
                                                                branch_id,
                                                                salary_recovery,
                                                                lock_status,
                                                                acct_status,
                                                                authorization_status,
                                                                emp_refno_new,
                                                                due_status,
                                                                customergroup,
                                                                fname
                                                               )
AS
   (SELECT da.deposit_no || '_1' AS act_num, da.cust_id, 'TD' AS prod_type,
           prod_id, da.deposit_no || '_1' AS rep_act_num, branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status, ds.acct_status,
           da.authorize_status, dem.emp_ref_no,
           DECODE (NVL (get_rd_install (da.deposit_no,
                                        de.curr_appl_dt,
                                        da.branch_id
                                       ),
                        0
                       ),
                   0, 'NOT_DUE',
                   'DUE'
                  ) AS due_status,
           c.customergroup, c.fname
      FROM deposit_acinfo da,
           deposit_sub_acinfo ds,
           day_end de,
           share_acct sa,
           deduction_exemption_mapping dem,
           customer c
     WHERE da.authorize_status = 'AUTHORIZED'
       AND da.status != 'DELETED'
       AND ds.acct_status != 'CLOSED'
       AND ds.deposit_no = da.deposit_no
       AND de.branch_code = da.branch_id
       AND da.cust_id = sa.cust_id(+)
       AND da.cust_id = c.cust_id
       AND sa.emp_refno_new = dem.emp_ref_no(+)
       AND EXISTS (
                   SELECT cust_id
                     FROM customer cm
                    WHERE cm.cust_id = c.cust_id
                          AND cm.cust_type_id = 'MEMBER')
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'TL' AS prod_type,
           lfd.prod_id, lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, dem.emp_ref_no,
           DECODE
              (CASE
                  WHEN lrs.emi_in_simpleintrest = 'Y'
                  AND lrs.install_type = 'UNIFORM_PRINCIPLE_EMI'
                     THEN get_tl_inst_od_emi (lfd.acct_num, de.curr_appl_dt)
                  WHEN lrs.install_type = 'UNIFORM_PRINCIPLE_EMI'
                  AND lrs.emi_in_simpleintrest IS NULL
                     THEN get_tl_inst_od (lfd.acct_num, de.curr_appl_dt)
               END,
               0, 'NOT_DUE',
               'DUE'
              ) AS due_status,
           c.customergroup, c.fname
      FROM loans_facility_details lfd,
           loans_borrower lb,
           day_end de,
           share_acct sa,
           loans_repay_schedule lrs,
           deduction_exemption_mapping dem,
           customer c
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.acct_status != 'CLOSED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (SELECT prod_id
                         FROM loans_product lp
                        WHERE lp.prod_id IN ('302', '308', '310'))
       AND NOT EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
       AND de.branch_code = lfd.branch_id
       AND lrs.acct_num = lfd.acct_num
       AND lb.cust_id = sa.cust_id(+)
       AND lb.cust_id = c.cust_id
       AND sa.emp_refno_new = dem.emp_ref_no(+)
       AND EXISTS (
                   SELECT cust_id
                     FROM customer cm
                    WHERE cm.cust_id = c.cust_id
                          AND cm.cust_type_id = 'MEMBER')
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, dem.emp_ref_no,
           CASE
              WHEN (SELECT lsd.to_dt
                      FROM loans_sanction_details lsd
                     WHERE lsd.borrow_no = lfd.borrow_no) >
                                                   de.curr_appl_dt
                 THEN 'NOT_DUE'
              ELSE 'DUE'
           END due_status,
           c.customergroup, c.fname
      FROM loans_facility_details lfd,
           loans_borrower lb,
           day_end de,
           share_acct sa,
           deduction_exemption_mapping dem,
           customer c
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.acct_status != 'CLOSED'
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (SELECT prod_id
                         FROM loans_product lp
                        WHERE lp.prod_id IN ('302', '308', '310'))
       AND EXISTS (
                   SELECT prod_id
                     FROM loans_product
                    WHERE behaves_like IN ('OD', 'CC')
                      AND prod_id = lfd.prod_id)
       AND de.branch_code = lfd.branch_id
       AND lb.cust_id = sa.cust_id(+)
       AND lb.cust_id = c.cust_id
       AND sa.emp_refno_new = dem.emp_ref_no(+)
       AND EXISTS (
                   SELECT cust_id
                     FROM customer cm
                    WHERE cm.cust_id = c.cust_id
                          AND cm.cust_type_id = 'MEMBER')
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'ATL' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, NULL AS emp_refno_new, NULL AS due_status,
           NULL AS customergroup, NULL AS fname
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND NOT EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id, 'AAD' AS prod_type, prod_id,
           lfd.acct_num || '_1' AS rep_act_num, branch_id,
           'N' AS salary_recovery, 'N' AS lock_status, lfd.acct_status,
           lfd.authorize_status_1, NULL AS emp_refno_new, NULL AS due_status,
           NULL AS customergroup, NULL AS fname
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.borrow_no = lb.borrow_no
       AND lfd.status != 'DELETED'
       AND EXISTS (
                 SELECT prod_id
                   FROM agriloans_product
                  WHERE behaves_like IN ('AOD', 'ACC')
                    AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num, am.suspense_customer_id,
           'SA' AS prod_type, am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           am.branch_code AS branch_id, 'N' AS salary_recovery,
           'N' AS lock_status, 'NEW' AS acct_status, am.authorize_status,
           NULL AS emp_refno_new, NULL AS due_status, c.customergroup,
           c.fname
      FROM suspense_account_master am, customer c
     WHERE c.cust_id = am.suspense_customer_id
       AND am.authorize_status = 'AUTHORIZED'
       AND am.status != 'DELETED'
       AND EXISTS (
              SELECT cust_id
                FROM customer cm
               WHERE cm.cust_id = c.cust_id
                 AND cm.cust_type_id IN ('MEMBER', 'CANTEEN'))
    UNION ALL
    SELECT am.chittal_no AS act_num, sa.cust_id, 'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status, am.authorize_status, dem.emp_ref_no,
           DECODE (get_mds_instdue (mm.scheme_name,
                                    am.chittal_no,
                                    am.division_no,
                                    de.curr_appl_dt
                                   ),
                   0, 'NOT_DUE',
                   'DUE'
                  ) AS due_status,
           c.customergroup, c.fname
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa,
           day_end de,
           deduction_exemption_mapping dem,
           customer c
     WHERE am.authorize_status = 'AUTHORIZED'
       AND am.member_no = sa.share_acct_no(+)
       AND am.status != 'DELETED'
       AND mm.scheme_name = msd.scheme_name
       AND am.chittal_no = mm.chittal_no
       AND am.sub_no = mm.sub_no
       AND am.member_no = sa.share_acct_no
       AND sa.cust_id = c.cust_id
       AND de.branch_code = am.branch_code
       AND sa.emp_refno_new = dem.emp_ref_no(+)
       AND sa.status != 'CLOSED'
       AND msd.status != 'CLOSED'
       AND EXISTS (
                   SELECT cust_id
                     FROM customer cm
                    WHERE cm.cust_id = c.cust_id
                          AND cm.cust_type_id = 'MEMBER'));

--End Version [Script Version - 0.0.141] [ReleaseVersion - 9.2.2.0]--[06-03-2015] -- by Jeffin John

--Start Version [Script Version - 0.0.142] [ReleaseVersion - 9.2.2.0]--[06-03-2015] -- by Anju Anand

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD CREATED_BY VARCHAR2 (50 Byte);

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD CREATED_DT DATE;

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD STATUS VARCHAR2 (10 Byte);

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD STATUS_BY VARCHAR2 (50 Byte);

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD STATUS_DT DATE;

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD AUTHORIZE_STATUS VARCHAR2 (10 Byte);

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD AUTHORIZE_BY VARCHAR2 (50 Byte);

ALTER TABLE WEEKLY_INSTALLMENT_SLAB ADD AUTHORIZE_DT DATE;

UPDATE LOOKUP_MASTER SET LOOKUP_REF_ID = '7' WHERE  LOOKUP_REF_ID = 'WEEKLY' AND LOOKUP_ID = 'DEPOSITSPRODUCT.INT_CALC_METHOD';

UPDATE LOOKUP_MASTER SET LOOKUP_REF_ID = '7' WHERE  LOOKUP_REF_ID = 'WEEKLY' AND LOOKUP_ID = 'LOANPRODUCT.LOANPERIODS';

ALTER TABLE IMBP_SETTINGS ADD SHARE_TYPE VARCHAR2 (16 Byte);

ALTER TABLE DEDUCTION_EXEMPTION_MAPPING ADD (EXEMPTION_MODE_TEMP VARCHAR2 (32 Byte), MAP_PROD_TYPE_TEMP VARCHAR2 (32 Byte), MAP_PROD_ID_TEMP VARCHAR2 (32 Byte), MAP_ACT_NUM_TEMP VARCHAR2 (32 Byte));

--End Version [Script Version - 0.0.142] [ReleaseVersion - 9.2.2.0]--[06-03-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.143] [ReleaseVersion - 9.2.2.0]--[10-03-2015] -- by Shihad

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR01064', '1064', 'Deposit Multiple Closing', 'APP01', 'DONE', 
    '6', 'com.see.truetransact.ui.deposit.multipleclosing.DepositMultiClosingUI', 3, 'CREATED', NULL, 
    NULL, 'Deposit Multiple Closing');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR01064', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR01064', 'CREATED', 'Y', 'Y', 
    'Y', 'N', 'N', 'Y', 'N');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR01064', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR01064', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
COMMIT;

CREATE TABLE DEPOSIT_MULTI_CLOSING_TEMP
(
  MULTI_DEP_CLOSE_ID  VARCHAR2(16 BYTE)         NOT NULL,
  DEPOSIT_NO          VARCHAR2(16 BYTE)         NOT NULL,
  DEPOSIT_SUB_NO      VARCHAR2(16 BYTE),
  CUST_ID             VARCHAR2(16 BYTE),
  PROD_ID             VARCHAR2(16 BYTE),
  DEPOSIT_DT          DATE,
  DEPOSIT_AMT         NUMBER(16,2),
  MATURITY_DT         DATE,
  RATE_OF_INT         NUMBER(4,2),
  PAID_INTEREST       NUMBER(16,2),
  DR_INTEREST         NUMBER(16,2),
  PAY_AMT             NUMBER(16,2),
  TOTAL_AMT           NUMBER(16,2),
  TOTAL_BALANCE       NUMBER(16,2),
  CUST_ID_UP          VARCHAR2(16 BYTE),
  FROM_ACC            VARCHAR2(16 BYTE),
  TO_ACC              VARCHAR2(16 BYTE),
  CLOSING_MODE        VARCHAR2(16 BYTE),
  PROD_TYPE           VARCHAR2(16 BYTE),
  PROD_ID_TRANS       VARCHAR2(16 BYTE),
  ACT_NUM             VARCHAR2(16 BYTE),
  STATUS              VARCHAR2(32 BYTE),
  CLOSE_DT            DATE,
  CLOSE_BY            VARCHAR2(64 BYTE),
  CREATE_BY           VARCHAR2(64 BYTE),
  AUTHORIZE_DT        DATE,
  AUTHORIZE_BY        VARCHAR2(64 BYTE),
  AUTHORIZE_STATUS    VARCHAR2(32 BYTE)
)

SET DEFINE OFF;
INSERT INTO ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 VALUES
   ('MULTI_DEP_CLOSE_ID', 0, 'MDC', NULL, 12, 
    '0001');
COMMIT;

--End Version [Script Version - 0.0.143] [ReleaseVersion - 9.2.2.0]--[10-03-2015] -- by Shihad

--Start Version [Script Version - 0.0.144] [ReleaseVersion - 9.2.2.0]--[10-03-2015] -- by Sathiya
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    SCREEN_DESC)
 Values
   ('SCR06105', '6105', 'Interest Reports', 'APP01', 'DONE', 
    '5', 'interestReport', 9, 'CREATED', 'REPORT', 
    'interestReport');

Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, AUTH_REJ_ALLOWED)
 Values
   ('GRP00001', 'SCR06105', 'CREATED', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, AUTH_REJ_ALLOWED)
 Values
   ('GRP00002', 'SCR06105', 'CREATED', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, AUTH_REJ_ALLOWED)
 Values
   ('GRP00003', 'SCR06105', 'CREATED', 'Y', 'Y');
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED)
 Values
   ('GRP01014', 'SCR06105', 'CREATED', 'Y', 'N', 
    'N', 'N', 'N', 'N');
        
create or replace function getRecoveryPenalUptodt (actno varchar2, asondt date) return number
is
    returnAmt number(16,2);    
begin 
      Select SUM (nvl(Interest,0)) into returnAmt 
	from (
	   SELECT   sum(nvl(PENAL,0)) Interest 
		FROM loan_trans_details
	       WHERE trans_dt <= asondt
		 AND act_num = actno
		 AND trn_code = 'C*'
		 AND AUTHORIZE_STATUS='AUTHORIZED'
	    GROUP BY act_num
	    union all                
	    SELECT   sum(nvl(PENAL,0)) Interest
		FROM adv_trans_details
	       WHERE trans_dt <= asondt
		 AND act_num = actno
		 AND trn_code = 'C*'
		 AND AUTHORIZE_STATUS='AUTHORIZED'
	    GROUP BY act_num
	    );                    
return NVL(returnAmt,0);
end getRecoveryPenalUptodt;
        
create or replace function getRecoveryIntUptodt (actno varchar2, asondt date) return number
is
    returnAmt number(16,2);    
begin 
      Select SUM (nvl(Interest,0)) into returnAmt 
	from (
	   SELECT   SUM (nvl(INTEREST,0))+sum(nvl(PENAL,0)) Interest 
		FROM loan_trans_details
	       WHERE trans_dt <= asondt
		 AND act_num = actno
		 AND trn_code = 'C*'
		 AND AUTHORIZE_STATUS='AUTHORIZED'
	    GROUP BY act_num
	    union all                
	    SELECT   SUM (nvl(INTEREST,0))+sum(nvl(PENAL,0)) Interest
		FROM adv_trans_details
	       WHERE trans_dt <= asondt
		 AND act_num = actno
		 AND trn_code = 'C*'
		 AND AUTHORIZE_STATUS='AUTHORIZED'
	    GROUP BY act_num
	    );                    
return NVL(returnAmt,0);
end getRecoveryIntUptodt;

MERGE INTO LOANS_FACILITY_DETAILS LFD 
USING (
  SELECT * 
  FROM LOANS_PRODUCT
) LP ON (LP.PROD_ID = LFD.PROD_ID AND BEHAVES_LIKE = 'OD')
WHEN MATCHED THEN UPDATE SET LFD.INTEREST = 'COMPOUND' WHERE LFD.INTEREST = 'SIMPLE'  

--End Version [Script Version - 0.0.144] [ReleaseVersion - 9.2.2.0]--[10-03-2015] -- by Sathiya

--Start Version [Script Version - 0.0.145] [ReleaseVersion - 9.2.2.0]--[11-03-2015] -- by Rishad

ALTER TABLE CUSTOMER ADD (SUB_CASTE VARCHAR2(16));

ALTER TABLE CUSTOMER ADD (MINORITY VARCHAR2(2));

CREATE TABLE CUSTOMER_PROOF
(
  CUST_ID     VARCHAR2(15 BYTE),
  PROOF_TYPE  VARCHAR2(15 BYTE),
  UNIQUE_ID   VARCHAR2(20 BYTE),
  STATUS      VARCHAR2(10 BYTE)
);

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.SUBCASTE', 'OBC', 'OBC', 'CREATED', 'Y', 
    'Y');

CREATE OR REPLACE FUNCTION GET_TD_INTEREST_UPTO_ASONDT(DEPOSITNO VARCHAR,DEPOSITDT DATE,
                                                   DEPOSITAMT NUMBER,ROI NUMBER,CLOSEDDATE DATE,ASONDT DATE,PERIOD NUMBER)
RETURN NUMBER IS
    INTPAYABLE NUMBER(16,2) := 0;
    INTPAID NUMBER(16,2) := 0;
    INTUPTODATE DATE := ASONDT;
BEGIN
    IF NVL(CLOSEDDATE,ADD_MONTHS(ASONDT,1)) <= ASONDT THEN
        RETURN INTPAID;
    END IF;    
    BEGIN
        SELECT NVL(SUM(I.INT_AMT),0) INTO INTPAID
        FROM DEPOSIT_INTEREST I
        WHERE I.ACT_NUM = DEPOSITNO || '_1' AND
              I.INT_PAID_DATE <= ASONDT AND
              I.PAID_INT = 'CREDIT';
    EXCEPTION
    WHEN OTHERS THEN
        INTPAID := 0;
    END;
    IF period> 0 THEN
        INTPAYABLE := DEPOSITAMT * ROI * (INTUPTODATE - DEPOSITDT)/36500;
    ELSE
        INTPAYABLE := DEPOSITAMT * ROI * MONTHS_BETWEEN(INTUPTODATE,DEPOSITDT)/1200;
    END IF;
    INTPAYABLE := INTPAYABLE;
    IF INTPAYABLE < 0 THEN
        INTPAYABLE := 0;
    END IF;
    INTPAYABLE := ROUND(INTPAYABLE,0);
    RETURN INTPAYABLE;
END;
/

CREATE OR REPLACE FUNCTION GET_TD_INTEREST_VALIDATION(DEPOSITNO VARCHAR,APPINTEREST NUMBER)
RETURN VARCHAR IS
FLAG  VARCHAR2(10) :='FALSE';
TOTAL_INT_CREDIT1 NUMBER(16,2):= 0;
TOTAL_INT_DRAWN1  NUMBER(16,2):=0;
PERIODIC_INT_AMT1 NUMBER(16,2):=0;
INTEREST   NUMBER(16,2):=0;
     BEGIN
     SELECT D.TOTAL_INT_CREDIT,D.TOTAL_INT_DRAWN,D.PERIODIC_INT_AMT,GET_TD_INTEREST_UPTO_ASONDT (D.DEPOSIT_NO, D.DEPOSIT_DT,D.DEPOSIT_AMT, D.RATE_OF_INT, D.CLOSE_DT, D.LAST_INT_APPL_DT,D.DEPOSIT_PERIOD_DD)
     INTO  TOTAL_INT_CREDIT1,TOTAL_INT_DRAWN1,PERIODIC_INT_AMT1,INTEREST
     FROM DEPOSIT_SUB_ACINFO D where D.DEPOSIT_NO=DEPOSITNO;
    IF TOTAL_INT_CREDIT1 <> TOTAL_INT_DRAWN1 THEN
    FLAG :='TRUE'; 
    ELSIF INTEREST <> TOTAL_INT_CREDIT1 THEN
    FLAG := 'TRUE';
    ELSIF PERIODIC_INT_AMT1 <> APPINTEREST THEN
    FLAG :='TRUE';
    ELSE
    FLAG :='FALSE';
    END IF;
  RETURN FLAG;
END;
/

--End Version [Script Version - 0.0.145] [ReleaseVersion - 9.2.2.0]--[11-03-2015] -- by Rishad

--Start Version [Script Version - 0.0.146] [ReleaseVersion - 9.2.2.0]--[12-03-2015] -- by Babu

ALTER TABLE AGENT_MASTER MODIFY  AGENT_MACHINE_ID VARCHAR2(40);

DROP VIEW ALL_PRODUCTS;

/* Formatted on 2015/03/06 15:22 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_products (prod_type,
                                                prod_id,
                                                prod_desc,
                                                behaves_like,
                                                ac_hd_id
                                               )
AS
   (SELECT 'OA' AS prod_type, prod_id, prod_desc, behavior AS behaves_like,
           ac_hd_id
      FROM op_ac_product
    UNION
    SELECT 'TD' AS prod_type, prod_id, prod_desc, behaves_like,
           acct_head AS ac_hd_id
      FROM deposits_product
    UNION
    SELECT 'TL' AS prod_type, prod_id, prod_desc, behaves_like,
           acct_head AS ac_hd_id
      FROM loans_product
    UNION
    SELECT 'ATL' AS prod_type, prod_id, prod_desc, behaves_like,
           acct_head AS ac_hd_id
      FROM agriloans_product
    UNION
    SELECT 'SA' AS prod_type, prod_id, prod_desc, '' AS behaves_like,
           ac_hd_id
      FROM suspense_product
    UNION
    SELECT 'MDS' AS prod_type, s.scheme_name AS prod_id,
           s.scheme_desc AS prod_desc, 'MDS' AS behaves_like,
           ma.receipt_head AS ac_hd_id
      FROM mds_scheme_details s JOIN mds_acct_head ma
           ON s.scheme_name = ma.scheme_name
    UNION
    SELECT 'INV' AS prod_type, investment_prod_id AS prod_id,
           iinvestment_prod_desc AS prod_desc,
           investment_type AS behaves_like, iinvestment_ac_hd AS ac_hd_id
      FROM investment_conf_details
    UNION
    SELECT 'AB' AS prod_type, prod_id AS prod_id, prod_desc AS prod_desc,
           account_type AS behaves_like, principal_ac_hd AS ac_hd_id
      FROM other_bank_account_products);

--End Version [Script Version - 0.0.146] [ReleaseVersion - 9.2.2.0]--[12-03-2015] -- by Babu

--Start Version [Script Version - 0.0.147] [ReleaseVersion - 9.2.2.0]--[12-03-2015] -- by Sreekrishnan

 ALTER TABLE DEPOSITS_PROD_RD ADD (INCLUDE_FULL_MONTH VARCHAR2(2 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.147] [ReleaseVersion - 9.2.2.0]--[12-03-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.148] [ReleaseVersion - 9.2.2.0]--[12-03-2015] -- by Anju Anand

ALTER TABLE OTHER_BANK_PASSBOOK MODIFY BANK_CODE VARCHAR2(100 BYTE);

CREATE OR REPLACE PROCEDURE other_bank_bal_update (
   bankcode     VARCHAR2,
   branchcode   VARCHAR2,
   accttype     VARCHAR2
)
AS
--DECLARE
   --BANKCODE VARCHAR2(100) := 'D L B Athani-DLBA112';
   --BRANCHCODE VARCHAR2(32) := '0001';
   --accttype VARCHAR2(32) := 'OTHER_BANK_OD';
   opening      NUMBER (16, 2) := 0;
   newbalance   NUMBER (16, 2) := 0;
   transtype    VARCHAR2 (16)  := NULL;
   checknum     NUMBER (16)    := 1;
BEGIN
   IF accttype = 'OTHER_BANK_OD'
   THEN
      transtype := 'CREDIT';
      checknum := -1;
   ELSE
      transtype := 'DEBIT';
   END IF;

   SELECT NVL (obp.balance, 0)
     INTO opening
     FROM other_bank_passbook obp
    WHERE obp.srl_no = 1 AND bank_code = bankcode AND branch_code = branchcode;

   DECLARE
      CURSOR b
      IS
         SELECT   DECODE (trans_type,
                          transtype, obp.amount * checknum,
                          obp.amount
                         ) AS amount,
                  obp.balance, obp.srl_no, obp.trans_type
             FROM other_bank_passbook obp
            WHERE obp.srl_no > 1
              AND obp.bank_code = bankcode
              AND obp.branch_code = branchcode
         ORDER BY obp.srl_no;
   BEGIN
      newbalance := opening;
      FOR i IN b
      LOOP
         newbalance := newbalance + i.amount;
         --DBMS_OUTPUT.put_line (i.srl_no || '  ' || newbalance || ' ' || i.amount
         UPDATE other_bank_passbook obp
            SET obp.balance = newbalance
          WHERE obp.srl_no = i.srl_no
            AND obp.bank_code = bankcode
            AND obp.branch_code = branchcode;
         COMMIT;
      END LOOP;
   END;
END;
/

--End Version [Script Version - 0.0.148] [ReleaseVersion - 9.2.2.0]--[12-03-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.149] [ReleaseVersion - 9.2.2.0]--[13-03-2015] -- by Chithra

ALTER TABLE TRANSFER_TRANS ADD (SCREEN_NAME VARCHAR2(100 BYTE));
ALTER TABLE LOANS_ACCT_CHARGE_DETAILS ADD (SCREEN_NAME VARCHAR2(100 BYTE));
--End Version [Script Version - 0.0.149] [ReleaseVersion - 9.2.2.0]--[13-03-2015] -- by Chithra

--Start Version [Script Version - 0.0.150] [ReleaseVersion - 9.2.2.0]--[16-03-2015] -- by Chithra
 ALTER TABLE DEPOSITS_PROD_SCHEME ADD (DOUBLING_COUNT NUMBER DEFAULT 2);
--End Version [Script Version - 0.0.150] [ReleaseVersion - 9.2.2.0]--[16-03-2015] -- by Chithra

--Start Version [Script Version - 0.0.151] [ReleaseVersion - 9.2.2.0]--[19-03-2015] -- by rishad

CREATE OR REPLACE FUNCTION CALCULATE_DD_SI_COMMFUNCT(ACTNUM IN VARCHAR,FDATE IN DATE,TDATE IN DATE) RETURN NUMBER
AS
    CNT INTEGER := 0;
    COMM Number(16,2) :=0;
    AMT NUMBER(16,2);
BEGIN
    SELECT SUM(T.AMOUNT) INTO AMT
    FROM DAILY_DEPOSIT_TRANS T
    WHERE T.ACC_NUM = ACTNUM  AND T.TRN_DT BETWEEN FDATE AND TDATE AND T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS != 'DELETED';
      COMM :=AMT*1/100;
      RETURN COMM;
END;
/
CREATE OR REPLACE FUNCTION GET_TD_INTEREST_VALIDATION(DEPOSITNO VARCHAR,APPINTEREST NUMBER)
RETURN VARCHAR IS
FLAG  VARCHAR2(10) :='FALSE';
TOTAL_INT_CREDIT1 NUMBER(16,2):= 0;
TOTAL_INT_DRAWN1  NUMBER(16,2):=0;
PERIODIC_INT_AMT1 NUMBER(16,2):=0;
INTEREST   NUMBER(16,2):=0;
     BEGIN
     SELECT D.TOTAL_INT_CREDIT,D.TOTAL_INT_DRAWN,D.PERIODIC_INT_AMT,GET_TD_INTEREST_UPTO_ASONDT (D.DEPOSIT_NO, D.DEPOSIT_DT,D.DEPOSIT_AMT, D.RATE_OF_INT, D.CLOSE_DT, D.LAST_INT_APPL_DT,D.DEPOSIT_PERIOD_DD)
     INTO  TOTAL_INT_CREDIT1,TOTAL_INT_DRAWN1,PERIODIC_INT_AMT1,INTEREST
     FROM DEPOSIT_SUB_ACINFO D where D.DEPOSIT_NO=DEPOSITNO;
    IF TOTAL_INT_CREDIT1 <> TOTAL_INT_DRAWN1 THEN
    FLAG :='TRUE'; 
    ELSIF INTEREST <> TOTAL_INT_CREDIT1 THEN
    FLAG := 'TRUE';
    ELSE
    FLAG :='FALSE';
    END IF;
  RETURN FLAG;
END;
/


--End Version [Script Version - 0.0.151] [ReleaseVersion - 9.2.2.0]--[19-03-2015] -- by rishad

--Start Version [Script Version - 0.0.152] [ReleaseVersion - 9.2.2.0]--[21-03-2015] -- by Babu

alter table LOANS_PROD_ACPARAM add (INTEREST_PAID_FREQ_DAYS NUMBER(16,2) DEFAULT 0);

CREATE OR REPLACE FUNCTION GET_TL_INIT_INTEREST(LOAN_NO VARCHAR2) RETURN NUMBER IS
 --DECLARE
    -- LOAN_NO LOANS_FACILITY_DETAILS.ACCT_NUM%TYPE := '0001276000084';
    LOAN_AMOUNT LOANS_SANCTION_DETAILS.LIMIT%TYPE := 0;
    FDATE LOANS_SANCTION_DETAILS.FROM_DT%TYPE;
    TDATE LOANS_SANCTION_DETAILS.TO_DT%TYPE;
    ROI LOANS_INT_MAINTENANCE.INTEREST%TYPE;
    INT_AMOUNT LOAN_TRANS_DETAILS.INTEREST%TYPE := 0;
BEGIN
    BEGIN
    SELECT SD.LIMIT,SD.FROM_DT,
               CASE 
                    WHEN P.IS_INTEREST_PAID_FIRST='Y' AND P.INTEREST_PAID_FREQ_DAYS>0
                          THEN    SD.FROM_DT+P.INTEREST_PAID_FREQ_DAYS
                          ELSE SD.TO_DT
               END AS TO_DT,           
               CASE WHEN F.INT_GET_FROM = 'ACT' THEN
                        (SELECT LI.INTEREST FROM LOANS_INT_MAINTENANCE LI WHERE LI.ACCT_NUM = F.ACCT_NUM AND LI.STATUS != 'DELETED')
                    WHEN F.INT_GET_FROM = 'PROD' THEN 
                         GET_TL_ROI(F.PROD_ID,SD.FROM_DT,SD.LIMIT)
                    ELSE 0
               END INTO LOAN_AMOUNT,FDATE,TDATE,ROI
        FROM LOANS_SANCTION_DETAILS SD
        JOIN LOANS_FACILITY_DETAILS F ON F.BORROW_NO = SD.BORROW_NO
        LEFT JOIN LOANS_PROD_ACPARAM P ON P.PROD_ID=F.PROD_ID
        WHERE F.ACCT_NUM = LOAN_NO AND F.AUTHORIZE_STATUS_1 IS NULL;
               -- DBMS_OUTPUT.PUT_LINE('TO_DATE '||TDATE||'FROM_DT '||FDATE);
        INT_AMOUNT := (LOAN_AMOUNT * (TDATE - FDATE) * ROI) / 36500;
    EXCEPTION
        WHEN OTHERS THEN
             INT_AMOUNT := 0;
                   --  DBMS_OUTPUT.PUT_LINE('TO_DATE '||TDATE||'FROM_DT '||FDATE);
    END;
   RETURN round(INT_AMOUNT);
     --DBMS_OUTPUT.PUT_LINE(' INT_AMOUNT ' || TO_CHAR(INT_AMOUNT) || ' LOAN_AMOUNT ' || LOAN_AMOUNT ||
                         --' NOD ' || (TDATE - FDATE) || ' ROI ' || ROI );
END;
--End Version [Script Version - 0.0.152] [ReleaseVersion - 9.2.2.0]--[21-03-2015] -- by Babu

--Start Version [Script Version - 0.0.153] [ReleaseVersion - 9.2.2.0]--[21-03-2015] -- by shihad

ALTER TABLE LOCKER_SURRENDER ADD NOTRANS VARCHAR2(64 BYTE);

--End Version [Script Version - 0.0.153] [ReleaseVersion - 9.2.2.0]--[21-03-2015] -- by shihad

--Start Version [Script Version - 0.0.154] [ReleaseVersion - 9.2.2.0]--[25-03-2015] -- by rishad

CREATE OR REPLACE FUNCTION CALC_FREQUENCY(LASTINTCALCDATE DATE, FREQUENCY INT ) RETURN DATE IS
FREQUENCY_DATE DATE;
BEGIN
    IF(FREQUENCY=90) THEN
            SELECT  LAST_DAY( ADD_MONTHS( LASTINTCALCDATE, MOD(3-MOD( TO_CHAR(TO_DATE(LASTINTCALCDATE),'mm'),3),3) ) ) INTO FREQUENCY_DATE FROM (
          SELECT DISTINCT
          TO_CHAR(DT,'Q') QUARTER
          FROM (SELECT ADD_MONTHS(TO_DATE(LASTINTCALCDATE),LEVEL-1) DT
          FROM DUAL
          CONNECT BY LEVEL <= 12)
          )
          WHERE TO_CHAR(TO_DATE(LASTINTCALCDATE),'Q')=QUARTER;
    ELSIF(FREQUENCY=180) THEN
            select case when TO_CHAR(LASTINTCALCDATE,'mm') between 4 and 9 then 
            (SELECT TO_DATE('30-sep-'||(TO_CHAR(LASTINTCALCDATE,'yyyy'))) from dual)
            else (SELECT TO_DATE('31-MAR-'||(TO_CHAR(LASTINTCALCDATE,'yyyy')+ 
            case when TO_CHAR(LASTINTCALCDATE,'mm') between 1 and 3 then 0 else 1 end ))  from dual) end INTO FREQUENCY_DATE from dual;
    ELSIF(FREQUENCY=30) THEN
            SELECT LAST_DAY (LASTINTCALCDATE) INTO  FREQUENCY_DATE FROM DUAL;
    ELSIF(FREQUENCY=360) THEN
        SELECT TO_DATE('31-MAR-'||(TO_CHAR(TO_DATE(LASTINTCALCDATE),'yyyy')+
        (CASE WHEN TO_CHAR(TO_DATE(LASTINTCALCDATE),'mm')>3 
        THEN 1 
        ELSE 0 
        END))) INTO FREQUENCY_DATE   FROM DUAL;                    
  END IF;
  RETURN FREQUENCY_DATE;
END;
/

CREATE OR REPLACE function deleteDepositinterestTrail (
       DEPOSIT_NO        IN   VARCHAR
    )
      RETURN VARCHAR2
    IS
       curval   VARCHAR2 (16);
       PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN

        DELETE FROM DEPOSIT_INT_TRIAL WHERE  ACT_NUM=DEPOSIT_NO; 
       COMMIT;
          RETURN curval;
    END;
/
--End Version [Script Version - 0.0.154] [ReleaseVersion - 9.2.2.0]--[25-03-2015] -- by rishad

--Start Version [Script Version - 0.0.155] [ReleaseVersion - 9.2.2.0]--[26-03-2015] -- by sreekrishnan
ALTER TABLE GROUP_LOAN__TRANS_DETAILS ADD BRANCH_ID VARCHAR2(16);

ALTER TABLE GROUP_LOAN_DETAILS ADD BRANCH_ID VARCHAR2(16);
--End Version [Script Version - 0.0.155] [ReleaseVersion - 9.2.2.0]--[26-03-2015] -- by sreekrishnan

--Start Version [Script Version - 0.0.156] [ReleaseVersion - 9.2.2.0]--[26-03-2015] -- by Sathiya

ALTER TABLE PARAMETERS ADD AMC_FROM_DT DATE;
ALTER TABLE PARAMETERS ADD AMC_TO_DT DATE;
ALTER TABLE parameters ADD AMC_ALERT_TIME NUMBER(3) DEFAULT(0);

--End Version [Script Version - 0.0.156] [ReleaseVersion - 9.2.2.0]--[26-03-2015] -- by Sathiya

--Start Version [Script Version - 0.0.157] [ReleaseVersion - 9.2.2.0]--[26-03-2015] -- by Jeffin John

CREATE OR REPLACE FUNCTION get_rd_install_recovery (
   actnum       VARCHAR,
   asondate     DATE,
   branchcode   VARCHAR
)
   RETURN NUMBER
IS
   pending_install   NUMBER (10);
BEGIN
   SELECT FLOOR (MONTHS_BETWEEN (TO_DATE (asondate) - 1,
                                   ADD_MONTHS (r.due_date, -1)
                                 + get_no_of_holidays (asondate, branchcode)
                                )
                ) AS pending
     INTO pending_install
     FROM deposit_recurring r JOIN deposit_sub_acinfo d
          ON r.deposit_no_sub = d.deposit_no || '_' || d.deposit_sub_no
        AND d.total_install_paid = r.sl_no
    WHERE d.deposit_no = actnum;

   IF pending_install > 0
   THEN
      pending_install := pending_install;
   ELSE
      pending_install := 0;
   END IF;

   RETURN pending_install;
END;
/

CREATE TABLE SALARY_RECOVERY_RD_DETAILS
(
  INT_CALC_UPTO_DT  DATE,
  DEPOSIT_NO        VARCHAR2(16 BYTE),
  SUB_NO            NUMBER(1),
  INSTALLMENT_NO    NUMBER(16),
  PENAL_AMT         NUMBER(18,2),
  INST_AMT          NUMBER(18,2)
)

CREATE TABLE DED_EXEMPTION_RD_DETAILS
(
  INT_CALC_UPTO_DT  DATE,
  DEPOSIT_NO        VARCHAR2(16 BYTE),
  SUB_NO            NUMBER(1),
  INSTALLMENT_NO    NUMBER(16),
  PENAL_AMT         NUMBER(18,2),
  INST_AMT          NUMBER(18,2)
)

--End Version [Script Version - 0.0.157] [ReleaseVersion - 9.2.2.0]--[26-03-2015] -- by Jeffin John

--Start Version [Script Version - 0.0.158] [ReleaseVersion - 9.2.2.0]--[30-03-2015] -- by Chithra

CREATE OR REPLACE FUNCTION GET_TL_ROI_DRINT(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN
    SELECT drgtr.roi INTO RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = CATG
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(TRUNC(TO_DATE(LOANDUEDT,'DD-MM-YYYY')- TO_DATE(LOANDATE,'DD-MM-YYYY')),0)
          BETWEEN from_period
              AND to_period and DRGTR.INT_TYPE = 'D';              
    RETURN RATEOFINT;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_ROI_CRINT(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN
    SELECT drgtr.roi INTO RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = CATG
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(TRUNC(TO_DATE(LOANDUEDT,'DD-MM-YYYY')- TO_DATE(LOANDATE,'DD-MM-YYYY')),0)
          BETWEEN from_period
              AND to_period and DRGTR.INT_TYPE = 'C';              
    RETURN RATEOFINT;
END;
/

CREATE OR REPLACE FUNCTION GET_ADV_CRDR_INTEREST(ACTNUM VARCHAR, FROMDT DATE,TODT DATE) RETURN VARCHAR IS
    --DECLARE
    --ACTNUM VARCHAR2(13) := '0001307000622';
    --FROMDT DATE := '01-JAN-2015';
    --TODT DATE := '31-JAN-2015';
    RATEOFINT NUMBER(16,2);
    INTGET VARCHAR2(10);
    CATG VARCHAR2(30);
    STARTDAT DATE;
    ENDDT DATE;
    LIMT NUMBER(16);
    PRODID NUMBER(10);
    DRINTRATE NUMBER(16,2);
    CRINTRATE NUMBER(16,2);
    BEGIN
         SELECT LFD.PROD_ID, LFD.INT_GET_FROM,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT INTO PRODID,INTGET,CATG,STARTDAT,ENDDT,LIMT FROM LOANS_FACILITY_DETAILS LFD
         JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
         JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
         WHERE LFD.ACCT_NUM = ACTNUM;
         IF INTGET = 'ACT' THEN
         SELECT NVL(LIM.INTEREST,0) INTO RATEOFINT FROM LOANS_INT_MAINTENANCE LIM WHERE LIM.ACCT_NUM = ACTNUM;
         ELSE
         SELECT GET_TL_ROI_DRINT(PRODID,CATG,STARTDAT,ENDDT,LIMT)  INTO DRINTRATE FROM DUAL;
         SELECT GET_TL_ROI_CRINT(PRODID,CATG,STARTDAT,ENDDT,LIMT)  INTO CRINTRATE FROM DUAL;
         END IF;
    BEGIN
    DECLARE CURSOR A IS
    SELECT prod_id, act_num, TO_DATE (FROMDT) AS day_end_dt,
      case when  (SELECT MIN (k.day_end_dt)
          FROM advances_dayend_balance k
         WHERE k.act_num = a.act_num
           AND k.day_end_dt > FROMDT
           AND k.day_end_dt <= TODT) is null then TO_DATE ( TODT) else (SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = a.act_num
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT) end AS next_dt,
        (SELECT NVL (amt, 0)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt IN (
        SELECT MAX (c.day_end_dt)
        FROM advances_dayend_balance c
        WHERE c.act_num = k.act_num
        AND c.day_end_dt <= FROMDT)) AS amt,
        case when (SELECT NVL (amt, 0)
        FROM advances_dayend_balance g
        WHERE g.act_num = ACTNUM
        AND g.day_end_dt IN (
        SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT)) is null then amt else (SELECT NVL (amt, 0)
        FROM advances_dayend_balance g
        WHERE g.act_num = ACTNUM
        AND g.day_end_dt IN (
        SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT)) end  AS next_amt   
        FROM advances_dayend_balance a
        WHERE a.act_num = ACTNUM
        AND a.day_end_dt IN (SELECT MAX (c.day_end_dt)
        FROM advances_dayend_balance c
        WHERE c.act_num = a.act_num AND c.day_end_dt <= FROMDT)
        UNION 
        SELECT a.prod_id, a.act_num, a.day_end_dt, a.next_dt, a.amt,
        b.amt AS next_amt
        FROM (SELECT prod_id, act_num, day_end_dt,
        NVL ((SELECT MIN (day_end_dt)
        FROM advances_dayend_balance b
        WHERE b.day_end_dt > a.day_end_dt AND act_num =ACTNUM),
        day_end_dt
        ) AS next_dt,
        amt
        FROM advances_dayend_balance a
        WHERE act_num = ACTNUM AND day_end_dt BETWEEN FROMDT AND TODT) a,
        (SELECT *
        FROM advances_dayend_balance) b
        WHERE a.prod_id = b.prod_id
        AND a.act_num = b.act_num
        AND b.day_end_dt = a.next_dt
        union
        SELECT a.prod_id, a.act_num, (select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)  day_end_dt, 
        to_date(TODT) next_dt, (SELECT amt FROM advances_dayend_balance where act_num =ACTNUM and 
        day_end_dt=(select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)) amt,
        0 next_amt
        FROM advances_dayend_balance a where A.ACT_NUM =ACTNUM AND day_end_dt BETWEEN FROMDT AND TODT        
        ORDER BY  day_end_dt  ;
    DATEDIFF NUMBER(10);
    FIRSTDATE DATE;
    NEXTDATE DATE;
    FLAG INTEGER := 0;
    CREDITINTEREST NUMBER(16,2) := 0;
    DEBITINTEREST NUMBER(16,2) := 0;
    INTEREST VARCHAR2(50);
    BEGIN
         FOR I IN A LOOP
         SELECT NVL(TRUNC(TO_DATE(I.NEXT_DT,'DD-MM-YYYY')- TO_DATE(I.DAY_END_DT,'DD-MM-YYYY')),0) INTO DATEDIFF FROM DUAL;
         FIRSTDATE := I.DAY_END_DT; 
         --DBMS_OUTPUT.PUT_LINE('DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT);
         IF I.AMT > 0 THEN
         IF INTGET = 'ACT' THEN 
         CREDITINTEREST := CREDITINTEREST + (I.AMT *  DATEDIFF * RATEOFINT) /36500;
         ELSE
         CREDITINTEREST := CREDITINTEREST + (I.AMT *  DATEDIFF * CRINTRATE ) /36500;
         END IF;
         --DBMS_OUTPUT.PUT_LINE('RATEOFINT  ='||RATEOFINT|| 'DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT||'CREDITINTEREST = '||CREDITINTEREST  );
         ELSE
         IF INTGET = 'ACT' THEN
         DEBITINTEREST := DEBITINTEREST + (I.AMT * DATEDIFF * RATEOFINT) /36500;
         ELSE
         DEBITINTEREST := DEBITINTEREST + (I.AMT * DATEDIFF * DRINTRATE) /36500;
         END IF;
         --DBMS_OUTPUT.PUT_LINE('RATEOFINT  ='||RATEOFINT||'DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT||'DEBITINTEREST = '||DEBITINTEREST  );  
         END IF;
         INTEREST := 'DEBITINTEREST = '||DEBITINTEREST||':'||'CREDITINTEREST =  '||CREDITINTEREST;
         END LOOP;
         --DBMS_OUTPUT.PUT_LINE('DEBITINTEREST = '||DEBITINTEREST||' : '||'CREDITINTEREST =  '||CREDITINTEREST);
         RETURN INTEREST;
         END;
    END;
    END;
/

ALTER TABLE LOANS_SECURITY_MEMBER MODIFY(MEMBER_NAME VARCHAR2(300 BYTE));

--End Version [Script Version - 0.0.158] [ReleaseVersion - 9.2.2.0]--[30-03-2015] -- by Chithra

--Start Version [Script Version - 0.0.159] [ReleaseVersion - 9.2.2.0]--[31-03-2015] -- by Anju Anand

ALTER TABLE CUSTOMER ADD DIVISION VARCHAR2 (40 Byte);

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'CANTEEN', 'CANTEEN', 'CREATED', NULL, 
    'Y');

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'FACTORY EMPLOYEE', 'FACTORY EMPLOYEE', 'CREATED', NULL, 
    'Y');
   
 Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'OFFICERS', 'OFFICERS', 'CREATED', NULL, 
    'Y');
    
  Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'OFFICE STAFF', 'OFFICE STAFF', 'CREATED', NULL, 
    'Y');


ALTER TABLE LOANS_PROD_ACPARAM ADD SALARY_RECOVERY VARCHAR2 (1 Byte)  DEFAULT 'N';

--End Version [Script Version - 0.0.159] [ReleaseVersion - 9.2.2.0]--[31-03-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.160] [ReleaseVersion - 9.2.2.0]--[31-03-2015] -- by Anju Anand

ALTER TABLE INVESTMENT_CONF_DETAILS ADD TDS_AC_HD VARCHAR2 (16 Byte);

--End Version [Script Version - 0.0.160] [ReleaseVersion - 9.2.2.0]--[31-03-2015] -- by Anju Anand

--Start Version [Script Version - 0.0.161] [ReleaseVersion - 9.2.2.0]--[02-04-2015] -- by Rishad

CREATE OR REPLACE FUNCTION GET_FEBDATE(PARADATE IN DATE) RETURN DATE IS
        ACTUALDATE DATE;
        MONTH1 NUMBER :=0;
        year1 number:=0;
        BEGIN
        select NVL(extract(month from to_date(PARADATE)),0) ,NVL(extract(year from to_date(PARADATE)),0) INTO MONTH1,YEAR1
        from DUAL;
        IF MONTH1 <>2 THEN 
        ACTUALDATE := PARADATE;
        ELSE
        IF(MOD(YEAR1,400)<>0)
        THEN
        ACTUALDATE :=PARADATE-3;
        ELSE
        ACTUALDATE :=PARADATE-2;
        END IF;
        END IF ;
        RETURN ACTUALDATE;
        END;
/

CREATE TABLE DEPOSIT_INT_TRIAL
(
  ACT_NUM                      VARCHAR2(16 BYTE),
  INT_DT                       DATE,
  INT_TYPE                     VARCHAR2(16 BYTE),
  AC_HD_ID                     VARCHAR2(16 BYTE),
  APPL_DT                      DATE,
  INT_AMT                      NUMBER(16,8),
  INT_RATE                     NUMBER(11,8),
  PRINCIPLE_AMT                NUMBER(22,8),
  PRODUCT_ID                   VARCHAR2(16 BYTE),
  PRODUCT_TYPE                 VARCHAR2(8 BYTE),
  TRANS_LOG_ID                 VARCHAR2(16 BYTE),
  CUST_ID                      VARCHAR2(16 BYTE),
  IS_TDS_APPLIED               VARCHAR2(16 BYTE),
  TDS_AMT                      NUMBER(16,2),
  PAID_INT                     VARCHAR2(16 BYTE),
  INT_PAID_DATE                DATE,
  TOTAL_INT_BALANCE            VARCHAR2(18 BYTE),
  TOTAL_TDS_DEDUCTED_FROM_ALL  NUMBER(16),
  TOTAL_TDS_AMOUNT             NUMBER(16,2),
  LAST_TDS_DEDUCTED_DT         DATE,
  LAST_TDS_RECIVED_FROM        VARCHAR2(16 BYTE),
  USER_ID                      VARCHAR2(32 BYTE),
  BRANCH_CODE                  VARCHAR2(32 BYTE)
)

--End Version [Script Version - 0.0.161] [ReleaseVersion - 9.2.2.0]--[02-04-2015] -- by Rishad

--Start Version [Script Version - 0.0.162] [ReleaseVersion - 9.2.2.1]--[17-04-2015] -- by Sreekrishnan
    DROP VIEW ALL_TRANS;

    /* Formatted on 2015/04/13 14:20 (Formatter Plus v4.8.8) */
    CREATE OR REPLACE FORCE VIEW all_trans (trans_id,
    batch_id,
    ac_hd_id,
    act_num,
    amount,
    trans_dt,
    trans_type,
    inst_type,
    inst_dt,
    token_no,
    init_trans_id,
    init_chann_type,
    particulars,
    status,
    instrument_no1,
    instrument_no2,
    prod_id,
    prod_type,
    authorize_status,
    authorize_by,
    authorize_dt,
    authorize_remarks,
    status_by,
    branch_id,
    status_dt,
    trans_mode,
    initiated_branch,
    authorize_status_2,
    link_batch_id,
    payment_status,
    gl_trans_act_num,
    narration,
    single_trans_id,
    trans_mod_type,
    screen_name
    )
    AS
    (SELECT "TRANS_ID", '' AS "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
    "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT", "TOKEN_NO",
    "INIT_TRANS_ID", "INIT_CHANN_TYPE", "PARTICULARS", "STATUS",
    "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID", "PROD_TYPE",
    "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
    "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID", "STATUS_DT",
    'CASH' AS "TRANS_MODE", "INITIATED_BRANCH", "AUTHORIZE_STATUS_2",
    "LINK_BATCH_ID" AS "LINK_BATCH_ID", "PAYMENT_STATUS",
    gl_trans_act_num AS "GL_TRANS_ACT_NUM", narration AS "NARRATION",
    single_trans_id AS "SINGLE_TRANS_ID",
    trans_mod_type AS "TRANS_MOD_TYPE", screen_name AS "SCREEN_NAME"
    FROM "CASH_TRANS"
    UNION ALL
    SELECT "TRANS_ID", "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
    "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT",
    NULL AS "TOKEN_NO", "INIT_TRANS_ID", "INIT_CHANN_TYPE",
    "PARTICULARS", "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2",
    "PROD_ID", "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY",
    "AUTHORIZE_DT", "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID",
    "STATUS_DT", "TRANS_MODE", "INITIATED_BRANCH",
    "AUTHORIZE_STATUS_2", "LINK_BATCH_ID" AS "LINK_BATCH_ID",
    '' AS "PAYMENT_STATUS", gl_trans_act_num AS "GL_TRANS_ACT_NUM",
    narration AS "NARRATION", single_trans_id AS "SINGLE_TRANS_ID",
    trans_mod_type AS "TRANS_MOD_TYPE", screen_name AS "SCREEN_NAME"
    FROM transfer_trans
    UNION ALL
    SELECT "INWARD_ID" AS "TRANS_ID", NULL AS "BATCH_ID", "AC_HD_ID",
    "ACCT_NO" AS "ACT_NUM", "AMOUNT", "CLEARING_DT" AS "TRANS_DT",
    'DEBIT' AS "TRANS_TYPE", "INSTRUMENT_TYPE" AS "INST_TYPE",
    "INSTRUMENT_DT" AS "INST_DT", NULL AS "TOKEN_NO",
    "SUSER_ID" AS "INIT_TRANS_ID",
    "INITIATED_BRANCH" AS "INIT_CHANN_TYPE", '' AS "PARTICULARS",
    "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID",
    "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
    "AUTHORIZE_REMARKS", "CREATED_BY" AS "STATUS_BY", "BRANCH_ID",
    "S_DATE" AS "STATUS_DT", 'CLEARING' AS "TRANS_MODE",
    "INITIATED_BRANCH", '' AS "AUTHORIZE_STATUS_2",
    '' AS "LINK_BATCH_ID", '' AS "PAYMENT_STATUS",
    '' AS "GL_TRANS_ACT_NUM", '' AS "NARRATION",
    '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
    '' AS "SCREEN_NAME"
    FROM inward_clearing
    WHERE authorize_status != 'REJECTED'
    AND inward_id NOT IN (SELECT inward_id
    FROM inward_bouncing)
    UNION ALL
    SELECT ib.bouncing_id AS trans_id, NULL AS batch_id, ic.ac_hd_id,
    ic.acct_no AS act_num, ib.amount, ib.clearing_date AS trans_dt,
    'CREDIT' AS trans_type, ic.instrument_type AS "INST_TYPE",
    ic.instrument_dt AS "INST_DT", NULL AS "TOKEN_NO",
    ib.status_by AS "INIT_TRANS_ID",
    ic.initiated_branch AS init_chann_type,
    'INWARD RETURN : ' || ib.bouncing_reason AS particulars, ib.status,
    ic.instrument_no1, ic.instrument_no2, ic.prod_id, ic.prod_type,
    ib.authorize_status, ib.authorize_by, ib.authorize_dt,
    ic.authorize_remarks, ib.status_by, ib.branch_id, ib.status_dt,
    'CLEARING' AS "TRANS_MODE", ib.branch_id AS initiated_branch,
    '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
    '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
    '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
    '' AS "SCREEN_NAME"
    FROM inward_bouncing ib, inward_clearing ic
    WHERE ic.authorize_status = 'REJECTED' AND ib.inward_id = ic.inward_id
    UNION ALL
    SELECT oc.batch_id AS "TRANS_ID", oc.schedule_no AS "BATCH_ID",
    pis.ac_hd_id AS "AC_HD_ID", pis.acct_no AS "ACT_NUM",
    DECODE (t.table_name,
    'OUTWARD_CLEARING', oc.amount,
    pis.amount
    ) AS amount,
    oc.outward_dt AS "TRANS_DT", 'CREDIT' AS "TRANS_TYPE",
    '' AS "INST_TYPE", NULL AS "INST_DT", NULL AS "TOKEN_NO",
    oc.status_by AS "INIT_TRANS_ID", oc.branch_id AS "INIT_CHANN_TYPE",
    'By oclg' AS "PARTICULARS", oc.status, '' AS "instrument_no1",
    '' AS "instrument_no2", '' AS "PROD_ID", '' AS "PROD_TYPE",
    'AUTHORIZED' AS authorize_status, oc.authorize_by, oc.authorize_dt,
    oc.authorize_remarks, oc.status_by, oc.branch_id, oc.status_dt,
    'CLEARING' AS "TRANS_MODE", oc.branch_id AS initiated_branch,
    '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
    '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
    '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
    '' AS "SCREEN_NAME"
    FROM outward_clearing oc,
    pay_in_slip pis,
    outward_tally ot,
    (SELECT batch_id,
    DECODE (COUNT (*),
    1, 'PAY_IN_SLIP',
    'OUTWARD_CLEARING'
    ) AS table_name
    FROM outward_clearing
    GROUP BY batch_id) t
    WHERE oc.batch_id = t.batch_id
    AND pis.batch_id = t.batch_id
    AND ot.schedule_no = oc.schedule_no
    AND ot.tally_status = 'CLOSED'
    UNION ALL
    SELECT trans_id AS "TRANS_ID", NULL AS "BATCH_ID", ac_hd_id,
    NULL AS "ACT_NUM", amount, trans_dt, trans_type, inst_type,
    inst_dt, NULL AS "TOKEN_NO", init_trans_id, init_chann_type,
    particulars, status, instrument_no1, instrument_no2, prod_id,
    prod_type, 'AUTHORIZED' AS authorize_status, NULL AS authorize_by,
    NULL AS authorize_dt, NULL AS authorize_remarks, NULL AS status_by,
    branch_id, status_dt, trans_mode, branch_id AS initiated_branch,
    '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
    '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
    '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
    '' AS "SCREEN_NAME"
    FROM trans_ref_gl
    WHERE trans_mode = 'CLEARING'
    UNION ALL
    SELECT otr.return_id AS "TRANS_ID", otr.batch_id AS "BATCH_ID",
    '' AS "AC_HD_ID", otr.acct_no AS actnum, otr.amount,
    otr.clearing_date AS "TRANS_DT", 'DEBIT' AS trans_type,
    otc.instrument_type AS inst_type, otc.instrument_dt AS "INST_DT",
    NULL AS "TOKEN_NO", otr.status_by AS "INIT_TRANS_ID",
    otr.branch_id AS "INIT_CHANN_TYPE",
    'OUTWARD RETURN : ' || otc.authorize_remarks AS patriculars,
    otr.status, otr.instrument_no1, otr.instrument_no2,
    '' AS "PROD_ID", '' AS "PROD_TYPE", otr.authorize_status,
    otr.authorize_by, otr.authorize_dt, otr.authorize_remarks,
    otr.status_by, otr.branch_id, otr.status_dt,
    'CLEARING' AS "TRANS_MODE", otr.initiated_branch,
    '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
    '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
    '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
    '' AS "SCREEN_NAME"
    FROM outward_return otr, outward_clearing otc
    WHERE otc.authorize_status = 'REJECTED' AND otr.batch_id = otc.batch_id);

--End Version [Script Version - 0.0.162] [ReleaseVersion - 9.2.2.1]--[17-04-2015] -- by Sreekrishnan


--Start Version [Script Version - 0.0.163] [ReleaseVersion - 9.2.2.1]--[17-04-2015] -- by Rishad

alter table  LOANS_PROD_SUBSIDY_REBATE add (ARC_WAIVER  varchar2(1)  DEFAULT 'N')


alter table LOANS_PROD_ACHD add (DEBIT_ARC_HEAD varchar2(20))
 
alter table  LOANS_PROD_SUBSIDY_REBATE add (ARBITRARY_WAIVER  varchar2(1)  DEFAULT 'N')

alter table LOANS_PROD_ACHD add (DEBIT_ARBITRARY_HEAD varchar2(20))

alter table  LOANS_PROD_SUBSIDY_REBATE add (DECREE_WAIVER  varchar2(1)  DEFAULT 'N')

alter table LOANS_PROD_ACHD add (DEBIT_DECREE_HEAD varchar2(20))

alter table  LOANS_PROD_SUBSIDY_REBATE add (EP_COST_WAIVER  varchar2(1)  DEFAULT 'N',POSTAGE_WAIVER  varchar2(1)  DEFAULT 'N',
ADVERTISE_WAIVER  varchar2(1)  DEFAULT 'N',LEGAL_WAIVER  varchar2(1)  DEFAULT 'N',
INSURANCE_WAIVER  varchar2(1)  DEFAULT 'N',MISCELLANEOUS_WAIVER  varchar2(1)  DEFAULT 'N')

alter table LOANS_PROD_ACHD add (DEBIT_EP_COST_HEAD varchar2(20),DEBIT_POSTAGE_HEAD varchar2(20),DEBIT_ADVERTISE_HEAD varchar2(20),
DEBIT_LEGAL_HEAD varchar2(20),
DEBIT_INSURANCE_HEAD varchar2(20),DEBIT_MISCELLANEOUS_HEAD varchar2(20))



--End Version [Script Version - 0.0.163] [ReleaseVersion - 9.2.2.1]--[17-04-2015] -- by Rishad

--Start Version [Script Version - 0.0.164] [ReleaseVersion - 9.2.2.1]--[18-04-2015] -- by Sreekrishnan

ALTER TABLE ARREAR_CALCULATION_MASTER ADD TRANS_DT DATE;

--End Version [Script Version - 0.0.164] [ReleaseVersion - 9.2.2.1]--[18-04-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.165] [ReleaseVersion - 9.2.2.1]--[25-04-2015] -- by Sreekrishnan

    call INSERT_REPORT_GROUP('SCR09991')

    SET DEFINE OFF;
    Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
    Values
   ('SCR09991', '133', 'Daily Account Transactions', 'APP01', 'DONE', 
    '8', 'com.see.truetransact.ui.transaction.dailyDepositTrans.DailyDepositTransUI', 3, 'CREATED', NULL, 
    NULL, 'Daily Deposit');
    COMMIT;

    ALTER TABLE  AGENT_MASTER ADD COLSEP  VARCHAR2(250) DEFAULT(';') ;

    ALTER TABLE  AGENT_MASTER ADD TXT_QUALIFIER  VARCHAR2(250)  ;

    ALTER TABLE  AGENT_MASTER ADD EXP_QUERY  VARCHAR2(250) DEFAULT('DAILY_COL_MSTER_DATA') ;

    ALTER TABLE  AGENT_MASTER ADD IMP_QUERY  VARCHAR2(250) DEFAULT('DAILY_COL_DATA') ;

    ALTER TABLE  AGENT_MASTER ADD SKIP_FIRST_LINE  VARCHAR2(250) DEFAULT('Y') ;

    CREATE TABLE COLLECTION_DET
    (
      COL1              VARCHAR2(150 BYTE),
      COL2              VARCHAR2(150 BYTE),
      COL3              VARCHAR2(150 BYTE),
      COL4              VARCHAR2(150 BYTE),
      COL5              VARCHAR2(150 BYTE),
      COL6              VARCHAR2(150 BYTE),
      COL7              VARCHAR2(150 BYTE),
      COL8              VARCHAR2(150 BYTE),
      COL9              VARCHAR2(150 BYTE),
      COL10             VARCHAR2(150 BYTE),
      COL11             VARCHAR2(150 BYTE),
      COL12             VARCHAR2(150 BYTE),
      COL13             VARCHAR2(150 BYTE),
      COL14             VARCHAR2(150 BYTE),
      COL15             VARCHAR2(150 BYTE),
      AGENT_ID          VARCHAR2(15 BYTE),
      INITIATED_BRANCH  VARCHAR2(4 BYTE),
      COL_DATE          DATE
    )

    CREATE OR REPLACE FUNCTION is_number (p_string IN VARCHAR2)
       RETURN INT
    IS
       v_new_num NUMBER;
    BEGIN
       v_new_num := TO_NUMBER(p_string);
       RETURN 1;
    EXCEPTION
    WHEN VALUE_ERROR THEN
       RETURN 0;
    END is_number;
    /    
--End Version [Script Version - 0.0.165] [ReleaseVersion - 9.2.2.1]--[25-04-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.166] [ReleaseVersion - 9.2.2.1]--[27-04-2015] -- by Chithra
CREATE OR REPLACE function get_mds_prizedstatus(chittalno varchar2) return varchar is
   --declare 
   --chittalno varchar2(13) := '0001497000001';
   msg varchar2(20);
   licount integer;
   begin 
   begin
   Select count(*) into licount from MDS_PRIZED_MONEY_DETAILS mpd
   join MDS_APPLICATION ma on MA.CHITTAL_NO = mpd.chittal_no
   where MPD.CHITTAL_NO = chittalno;
   exception when others then
   licount := 0;
   end;
   if licount =  0 then
   msg := 'Nonprized';
   else
   msg := 'Prized';
   end if;
   return msg;
   end;
/


CREATE TABLE CUST_REGIONAL
(
  CUST_ID      VARCHAR2(10 BYTE)                NOT NULL,
  FNAME        VARCHAR2(384 BYTE),
  HOUSE        VARCHAR2(256 BYTE),
  GUARDIAN     VARCHAR2(128 BYTE),
  PLACE        VARCHAR2(50 BYTE),
  VILLAGE      VARCHAR2(128 BYTE),
  TALUK        VARCHAR2(128 BYTE),
  CITY         VARCHAR2(50 BYTE),
  STATE        VARCHAR2(50 BYTE),
  AMSAM        VARCHAR2(50 BYTE),
  DESAM        VARCHAR2(50 BYTE),
  COUNTRY      VARCHAR2(40 BYTE),
  STATUS       VARCHAR2(30 BYTE),
  BRANCH_CODE  VARCHAR2(30 BYTE),
  STATUS_BY    VARCHAR2(50 BYTE),
  STATUS_DT    DATE
);


CREATE TABLE CUST_REG_DICT
(
  M  VARCHAR2(50 BYTE),
  E  VARCHAR2(50 BYTE)
);

ALTER TABLE CUSTOMER ADD (RETIREMENT_DT DATE,RETIREMENT_AGE NUMBER(3));

--End Version [Script Version - 0.0.166] [ReleaseVersion - 9.2.2.1]--[27-04-2015] -- by Chithra

--Start Version [Script Version - 0.0.167] [ReleaseVersion - 9.2.2.1]--[12-05-2015] -- by Sreekrishnan

CREATE OR REPLACE FUNCTION GET_TL_LAST_INTERESTDATE(ACTNUM VARCHAR,ASONDT DATE,TRANSAMT NUMBER )
RETURN DATE IS
/* DECLARE

  ---COLINTAMT NUMBER,
 ACTNUM VARCHAR2(15) := '00012640000H4';
 COLINTAMT NUMBER:= 4402;
 ASONDT DATE :='27-FEB-2015';
 */
   
  STARTDATE DATE;
  LSTINTRCALCDATE DATE;
  BALAMT NUMBER;   
  PAYBLEAMT NUMBER;
  ROI NUMBER;
  UNAUTH INT; 
  INTRAMT NUMBER;    
  BEGIN
    SELECT  MAX(T.TRANS_DT)  INTO STARTDATE   FROM LOAN_TRANS_DETAILS T   WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND PRINCIPLE>0;
    SELECT   PBAL   INTO BALAMT   FROM LOAN_TRANS_DETAILS    WHERE ACT_NUM = ACTNUM AND  TRANS_DT <= ASONDT
    AND TRANS_SLNO =(SELECT MAX(TRANS_SLNO) FROM LOAN_TRANS_DETAILS    WHERE ACT_NUM = ACTNUM AND  TRANS_DT <= ASONDT);    

    SELECT GET_TL_INTEREST(ACTNUM,STARTDATE-1,ASONDT) INTO PAYBLEAMT FROM DUAL;
      
    --DBMS_OUTPUT.PUT_LINE('STARTDATE : ' ||STARTDATE);
       SELECT CASE WHEN LFD.INT_GET_FROM = 'ACT' THEN
                    (SELECT MAX(LIM.INTEREST) FROM LOANS_INT_MAINTENANCE LIM WHERE  
                     LIM.ACCT_NUM = LFD.ACCT_NUM AND LIM.STATUS != 'DELETED'
                     AND FROM_DT =(SELECT MAX(FROM_DT) FROM LOANS_INT_MAINTENANCE LIM WHERE  
                     LIM.ACCT_NUM = LFD.ACCT_NUM AND LIM.STATUS != 'DELETED') )
                WHEN LFD.INT_GET_FROM = 'PROD' THEN
                     GET_TL_ROI(LFD.PROD_ID,LSD.FROM_DT,LSD.LIMIT)
                ELSE 0 END INTO ROI
    FROM LOANS_FACILITY_DETAILS LFD
    JOIN LOANS_SANCTION_DETAILS LSD ON LFD.BORROW_NO = LSD.BORROW_NO   WHERE ACCT_NUM = ACTNUM;
 
  --DBMS_OUTPUT.PUT_LINE ( ' INTEREST : ' || ROI);
  
   IF NVL(BALAMT,0)>0 THEN
      SELECT NVL(SUM(AMOUNT),0) INTO INTRAMT    FROM ALL_TRANS AT 
      JOIN LOANS_PROD_ACHD LPA  ON LPA.PROD_ID = SUBSTR(ACTNUM,5,3)   AND AT.AC_HD_ID = AC_DEBIT_INT  
      WHERE TRANS_DT =ASONDT AND  LINK_BATCH_ID = ACTNUM AND  NVL(AT.AUTHORIZE_STATUS,' ')!='AUTHORIZED' AND NVL(STATUS,' ')!='DELETED';   

    SELECT   ASONDT - (  CEIL(( ((PAYBLEAMT - (INTRAMT+TRANSAMT)) * 36500) / (BALAMT *  ROI)))) INTO LSTINTRCALCDATE   FROM DUAL;
   ELSE
      SELECT   ASONDT   INTO LSTINTRCALCDATE   FROM DUAL;
   END IF ;
     RETURN LSTINTRCALCDATE;
   -- DBMS_OUTPUT.PUT_LINE( ' LSTINTRCALCDATE : ' || LSTINTRCALCDATE);
  
  END;
/


CREATE OR REPLACE FUNCTION CALCULATE_DD_SI_COMMFUNCT(ACTNUM IN VARCHAR,TDATE IN DATE,PRODID IN VARCHAR) RETURN NUMBER
AS
    CNT INTEGER := 0;
    COMM Number(16,2) :=0;
    AMT NUMBER(16,2);
    CMPER NUMBER(16,2);
BEGIN

    SELECT COMM_PER_AC_HOLDR INTO CMPER FROM AGENT_PROD_MAPPING WHERE PROD_ID = PRODID;
    SELECT SUM(T.AMOUNT) INTO AMT
    FROM DAILY_DEPOSIT_TRANS T
    WHERE T.ACC_NUM = ACTNUM  AND T.TRN_DT BETWEEN (SELECT LAST_COL_DT FROM AGENT_COLLECTION_PROD WHERE PROD_ID = PRODID AND AGENT_ID = T.AGENT_NO )  AND TDATE AND T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS != 'DELETED';
      COMM :=AMT*CMPER/100;
      RETURN COMM;
END;
/

CREATE TABLE AGENT_COLLECTION_PROD
(
  PROD_TYPE    VARCHAR2(40 BYTE),
  PROD_ID      VARCHAR2(40 BYTE),
  AGENT_ID     VARCHAR2(16 BYTE),
  LAST_COL_DT  DATE
)

--End Version [Script Version - 0.0.167] [ReleaseVersion - 9.2.2.1]--[12-05-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.168] [ReleaseVersion - 9.2.2.1]--[12-05-2015] -- by Chithra
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, AUTHORIZED)
 Values
   ('CUSTOMER.CUST_STATUS', 'RETIRED', 'Retired', 'CREATED', NULL, 'Y');     
COMMIT;

ALTER TABLE RENT_REGISTER MODIFY(RENT_DATE VARCHAR2(5 BYTE));

ALTER TABLE CUST_REGIONAL ADD (SHARE_ACCT_NO VARCHAR2(30 BYTE));

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR01066', '1066', 'Member Malayalam Conversion', 'APP01', 'DONE', 
    '2', '', 3, 'CREATED', NULL, 
    NULL, 'Member Malayalam Conversion');    
COMMIT;

Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00004', 'SCR01066', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
    
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR01066', 'CREATED', 'Y', 'Y', 
    'Y', 'N', 'N', 'Y', 'N');
    
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR01066', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
    
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR01066', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
    
COMMIT;
--End Version [Script Version - 0.0.168] [ReleaseVersion - 9.2.2.1]--[14-05-2015] -- by Chithra

--Start Version [Script Version - 0.0.169] [ReleaseVersion - 9.2.2.1]--[22-05-2015] -- by Nidhin

    CREATE OR REPLACE FUNCTION get_FromDate_mdsletter(SCHEMENAME VARCHAR2) RETURN date IS
    --DECLARE
    --SCHEMENAME VARCHAR2(10) := '505';
    FROMDT DATE;
    FROMDATE DATE;
    BEGIN
    BEGIN
    SELECT ADD_MONTHS (MAX (mpd.draw_auction_date), 1) INTO FROMDT
    FROM mds_prized_money_details mpd
    WHERE mpd.scheme_name = SCHEMENAME;
    EXCEPTION WHEN OTHERS THEN 
    DBMS_OUTPUT.PUT_LINE('NO DATA');
    END;
    BEGIN
    SELECT TO_DATE(MSD.RESOLUTION_DT,'DD/MM/YYYY' ) INTO FROMDATE FROM MDS_SCHEME_DETAILS MSD
    WHERE MSD.SCHEME_NAME = SCHEMENAME;
    EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('NODATA');
    END;
    IF FROMDT IS NULL THEN
    FROMDT := FROMDATE;
    END IF;
    RETURN FROMDT;
    END;

--End Version [Script Version - 0.0.169] [ReleaseVersion - 9.2.2.1]--[22-05-2015] -- by Nidhin

--Start Version [Script Version - 0.0.170] [ReleaseVersion - 9.2.2.1]--[26-05-2015] -- by Sreekrishnan
    ALTER TABLE BALANCESHEET_BALANCEFINAL ADD ENTRY_MODE VARCHAR2(16);
--End Version [Script Version - 0.0.170] [ReleaseVersion - 9.2.2.1]--[26-05-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.171] [ReleaseVersion - 9.2.2.1]--[03-06-2015] -- by Sathiya
CREATE OR REPLACE function get_mds_installment(chittalno varchar) return number is
   prodid varchar2(10);
   schemename varchar2(10);
   inst number;
   advance varchar2(1);
   schemeinst number;
   li_count number;
   countr number;
   begin
   Select ma.scheme_name,ma.PROD_ID into schemename,prodid from  MDS_APPLICATION ma where MA.CHITTAL_NO = chittalno;
   Select nvl(MPGD.ADVANCE_COLLECTION,'N') into advance  from MDS_PRODUCT_GENERAL_DETAILS mpgd where prod_id = prodid;
   Select  nvl(MSD.NO_OF_INSTALLMENTS,0)into schemeinst from MDS_SCHEME_DETAILS msd where  MSD.SCHEME_NAME = schemename;
   Select count(*) into countr from MDS_PRIZED_MONEY_DETAILS mpd where MPD.SCHEME_NAME = schemename;
   begin
   select sum(mtd.NO_OF_INST) into li_count from MDS_TRANS_DETAILS mtd where MTD.CHITTAL_NO = chittalno;
   exception when others then
   li_count := 0;
   end;
   if li_count is null then
   li_count := 0 ;
   end if;
   if li_count = 0 and advance = 'Y'  and  countr = 1 then
   li_count  := 1;
   end if;
   return li_count;
   end;
--End Version [Script Version - 0.0.171] [ReleaseVersion - 9.2.2.1]--[03-06-2015] -- by Sathiya

--Start Version [Script Version - 0.0.172] [ReleaseVersion - 9.2.2.1]--[19-06-2015] -- by Chithra
insert into ID_GENERATION values('COMMISSION_ID',0,'DCI','12 jan 2015',8,'0001'); 

insert into ID_GENERATION values('DAILY_ROI_ID',0,'DRI','12 jan 2015',8,'0001');
 
ALTER TABLE DAILY_DEP_COMM_SLAB ADD (periodIn VARCHAR2(30 BYTE));

ALTER TABLE DAILY_DEP_COMM_SLAB_DET ADD (COMM_PENAL NUMBER(4,2));
ALTER TABLE DAILY_DEP_ROI_SLAB ADD (periodIn VARCHAR2(30 BYTE));

ALTER TABLE DAILY_DEP_ROI_SLAB_DET ADD (COMM_PENAL NUMBER(4,2));
ALTER TABLE DAILY_DEP_ROI_SLAB ADD (BRANCH_CODE VARCHAR2(30 BYTE));

ALTER TABLE DAILY_DEP_COMM_SLAB ADD (BRANCH_CODE VARCHAR2(30 BYTE));


CREATE TABLE DAILY_DEP_COMM_SLAB_DET1
(
  FK_COMM_ID      INTEGER,
  FROM_PERIOD_MM  INTEGER,
  TO_PERIOD_MM    INTEGER,
  COMM_PERC       NUMBER(4,2),
  COMM_PENAL      NUMBER(4,2)
)

INSERT INTO DAILY_DEP_COMM_SLAB_DET1 (FK_COMM_ID,FROM_PERIOD_MM,TO_PERIOD_MM,COMM_PERC,COMM_PENAL) 
select FK_COMM_ID,FROM_PERIOD_MM,TO_PERIOD_MM,COMM_PERC,COMM_PENAL from DAILY_DEP_COMM_SLAB_DET;
 
 delete from DAILY_DEP_COMM_SLAB_DET 
 
ALTER TABLE DAILY_DEP_COMM_SLAB_DET DROP CONSTRAINT FK_DD_COMM_ID;

ALTER TABLE DAILY_DEP_COMM_SLAB_DET MODIFY(FK_COMM_ID VARCHAR2(30));


ALTER TABLE DAILY_DEP_COMM_SLAB_DET MODIFY(FROM_PERIOD_MM NUMBER(4,2));


ALTER TABLE DAILY_DEP_COMM_SLAB_DET MODIFY(TO_PERIOD_MM NUMBER(4,2));

INSERT INTO DAILY_DEP_COMM_SLAB_DET (FK_COMM_ID,FROM_PERIOD_MM,TO_PERIOD_MM,COMM_PERC,COMM_PENAL) 
select FK_COMM_ID,FROM_PERIOD_MM,TO_PERIOD_MM,COMM_PERC,COMM_PENAL from DAILY_DEP_COMM_SLAB_DET1;



CREATE TABLE DAILY_DEP_COMM_SLAB1
(
  COMM_ID      INTEGER,
  EFFECT_FROM  DATE,
  STATUS       VARCHAR2(30 BYTE),
  STATUS_BY    VARCHAR2(100 BYTE),
  PROD_ID      VARCHAR2(3 BYTE),
  PERIODIN     VARCHAR2(30 BYTE),
  BRANCH_CODE  VARCHAR2(30 BYTE)
)

INSERT INTO DAILY_DEP_COMM_SLAB1  
select *  from DAILY_DEP_COMM_SLAB;
 
 delete from DAILY_DEP_COMM_SLAB 
 
 ALTER TABLE DAILY_DEP_COMM_SLAB MODIFY(COMM_ID VARCHAR2(30));
 
 INSERT INTO DAILY_DEP_COMM_SLAB  
select *  from DAILY_DEP_COMM_SLAB1;

CREATE TABLE DAILY_DEP_ROI_SLAB_DET1
(
  FK_ROI_ID       VARCHAR(30),
  FROM_PERIOD_MM  NUMBER(4,2),
  TO_PERIOD_MM    NUMBER(4,2),
  ROI             NUMBER(4,2),
  COMM_PENAL      NUMBER(4,2)
);

INSERT INTO DAILY_DEP_ROI_SLAB_DET1  
select * from DAILY_DEP_ROI_SLAB_DET;
 
 delete from DAILY_DEP_ROI_SLAB_DET;
 
ALTER TABLE DAILY_DEP_ROI_SLAB_DET DROP CONSTRAINT FK_ROI_ID;

ALTER TABLE DAILY_DEP_ROI_SLAB_DET MODIFY(FK_ROI_ID VARCHAR2(30));

ALTER TABLE DAILY_DEP_ROI_SLAB_DET MODIFY(FROM_PERIOD_MM NUMBER(16,8));

ALTER TABLE DAILY_DEP_ROI_SLAB_DET MODIFY(TO_PERIOD_MM NUMBER(4,2));

INSERT INTO DAILY_DEP_ROI_SLAB_DET (FK_ROI_ID,FROM_PERIOD_MM,TO_PERIOD_MM,ROI,COMM_PENAL)
select FK_ROI_ID,FROM_PERIOD_MM,TO_PERIOD_MM,ROI,COMM_PENAL from DAILY_DEP_ROI_SLAB_DET1;

CREATE TABLE DAILY_DEP_ROI_SLAB1
(
  ROI_ID       INTEGER,
  EFFECT_FROM  DATE,
  STATUS       VARCHAR2(20 BYTE),
  STATUS_BY    VARCHAR2(100 BYTE),
  PROD_ID      VARCHAR2(3 BYTE),
  PERIODIN     VARCHAR2(30 BYTE),
  BRANCH_CODE  VARCHAR2(30 BYTE)
);

INSERT INTO DAILY_DEP_ROI_SLAB1  
select *  from DAILY_DEP_ROI_SLAB;
 
 delete from DAILY_DEP_ROI_SLAB ;
 
 ALTER TABLE DAILY_DEP_ROI_SLAB MODIFY(ROI_ID VARCHAR2(30));
 
 INSERT INTO DAILY_DEP_ROI_SLAB  
select *  from DAILY_DEP_ROI_SLAB1;

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12231', '12231', 'Daily Commission', 'APP01', 'DONE', 
    '3', '', 17, 'CREATED', NULL, 
    NULL, 'Daily Commission'); 
       
COMMIT;

Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR12231', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
    
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR12231', 'CREATED', 'Y', 'Y', 
    'Y', 'N', 'N', 'Y', 'N');
    
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR12231', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
    
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR12231', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', 'N');
    
COMMIT;

--End Version [Script Version - 0.0.172] [ReleaseVersion - 9.2.2.1]--[19-06-2015] -- by Chithra

--Start Version [Script Version - 0.0.173] [ReleaseVersion - 9.2.2.1]--[23-06-2015] -- by Sreekrishnan
CREATE OR REPLACE FUNCTION get_tl_total(ACTNUM VARCHAR, ASONDT DATE)
RETURN NUMBER IS
Balance NUMBER(16,2) := 0;
BEGIN
SELECT  sum(a.balance) into balance 
    FROM (
    WITH cte_a AS
               (5                           
                SELECT   t.act_num, 'INSURANCE CHARGES' AS charge_type,
                         SUM (NVL (t.insurance_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL                
                SELECT   t.act_num, 'ARBITRARY CHARGES' AS charge_type,
                         SUM (NVL (t.arbitary_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'LEGAL CHARGES' AS charge_type,
                         SUM (NVL (t.legal_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'MISCELLANEOUS CHARGES' AS charge_type,
                         SUM (NVL (t.misc_charges, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'EXECUTION DECREE CHARGES' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'POSTAGE CHARGES' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num
                UNION ALL
                SELECT   t.act_num, 'OTHERS' AS charge_type,
                         SUM (NVL (t.advertise_charge, 0)) AS amount
                    FROM loan_trans_details t
                   WHERE t.act_num = ACTNUM
                     AND t.trans_dt <=  ASONDT
                     AND t.trans_type = 'CREDIT'
                     AND t.authorize_status = 'AUTHORIZED'
                GROUP BY t.act_num                
                UNION 
                   SELECT   t.act_num, t.charge_type  AS charge_type,sum(nvl(t.PAID_AMT,0)) AS amount
                    FROM loans_acct_charge_details t
                   WHERE t.act_num = ACTNUM
                     AND t.charge_date <= ASONDT
                     --and t.charge_type='EP_COST' 
                     AND t.authorize_status = 'AUTHORIZED'
                     AND t.status != 'DELETED'
                    GROUP BY t.act_num,t.charge_type),
               cte_b AS
               (SELECT   a.act_num, a.charge_type, SUM (a.amount) AS amount
                    FROM loans_acct_charge_details a
                   WHERE a.act_num = ACTNUM
                     AND a.charge_date <=  ASONDT
                     AND a.authorize_status = 'AUTHORIZED'
                     AND a.status != 'DELETED'
                GROUP BY a.act_num, a.charge_type)
          SELECT b.act_num, a.charge_type, b.amount - a.amount AS balance,
                 NULL AS s_order, 'A' AS mod_type
            FROM cte_b b LEFT JOIN cte_a a
                 ON a.act_num = b.act_num
               AND a.charge_type = NVL (b.charge_type, 'OTHERS')
          UNION ALL
          SELECT f.acct_num AS act_num, 'PRINCIPAL' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_balance (f.acct_num,  ASONDT)
                    ELSE get_adv_balance (f.acct_num,  ASONDT)
                 END AS balance,
                 1 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num = ACTNUM
          UNION ALL
          SELECT f.acct_num AS act_num, 'INTEREST' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_interest (f.acct_num,
                                             sd.from_dt,
                                              ASONDT
                                            )
                    ELSE get_adv_interest_application (f.acct_num,  ASONDT)
                 END AS balance,
                 2 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num =  ACTNUM
          UNION ALL
          SELECT f.acct_num AS act_num, 'PENAL INTEREST' AS charge_type,
                 CASE
                    WHEN p.behaves_like != 'OD'
                       THEN get_tl_od_interest(f.acct_num,ASONDT)
                    ELSE get_adv_pen_int_application (f.acct_num,
                                                       ASONDT
                                                     )
                 END AS balance,
                 3 AS s_order, 'A' AS mod_type
            FROM loans_facility_details f JOIN loans_product p
                 ON p.prod_id = f.prod_id
                 JOIN loans_sanction_details sd ON sd.borrow_no = f.borrow_no
           WHERE f.acct_num =  ACTNUM
           ) a;
RETURN balance;
End;
/
--End Version [Script Version - 0.0.173] [ReleaseVersion - 9.2.2.1]--[23-06-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.174] [ReleaseVersion - 9.2.2.1]--[24-06-2015] -- by Rishad

alter table DEPOSIT_SUB_ACINFO_SAMENO  add(POSTAGE_AMT NUMBER(16,2));

--End Version [Script Version - 0.0.174] [ReleaseVersion - 9.2.2.1]--[24-06-2015] -- by Rishad

--Start Version [Script Version - 0.0.175] [ReleaseVersion - 9.2.2.1]--[25-06-2015] -- by Sreekrishnan

alter table DAILY_LOAN_COLLECTION_DETAILS  add(COMMISSION NUMBER(16,2));

--End Version [Script Version - 0.0.175] [ReleaseVersion - 9.2.2.1]--[25-06-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.176] [ReleaseVersion - 9.2.2.1]--[26-06-2015] -- by Nidhin

 ALTER TABLE MDS_MASTER_MAINTENANCE ADD (CHIT_CLOSE_DT DATE);

--End Version [Script Version - 0.0.176] [ReleaseVersion - 9.2.2.1]--[26-06-2015] -- by Nidhin

--Start Version [Script Version - 0.0.177] [ReleaseVersion - 9.2.2.2]--[08-07-2015] -- by Sathiya

ALTER TABLE DEDUCTION_EXCEPTION_LIST ADD (ACTUAL_DEMAND NUMBER(16,2));

CREATE OR REPLACE FUNCTION GET_TL_PENINTEREST(ACTNUM VARCHAR,LOANDATE DATE,ASONDT DATE,PENROI NUMBER)
RETURN NUMBER IS
--DECLARE
--ACTNUM VARCHAR2(13) := '0001310000211';
--LOANDATE DATE := '03-JAN-2014';
--ASONDT DATE := '31-MAR-2015';
---PENROI NUMBER(12,2) := 3.0;
    PENINTRECEIVABLE NUMBER(16,2) := 0;
    PENINTRECEIVED NUMBER(16,2) := 0;
    INSTAMTRECEIVALBE NUMBER(16,2) := 0;
    PRNCOLLECTED NUMBER(16,2) := 0;
    LASTINTCALCDATE DATE;
    STARTDATE DATE;
    CALCPRN NUMBER(16,2) := 0;
    WITHACTUALINST NUMBER(16,2) := 0;
    INSTCOUNT NUMBER(16,2) := 0;
    Graceperiod number(10);
BEGIN
    --Select nvl(R.GRACE_PERIOD,0)  into Graceperiod From RECOVERY_PARAMETERS R ;
    IF GET_TL_BALANCE(ACTNUM,ASONDT) != 0 THEN
        SELECT F.LAST_INT_CALC_DT INTO LASTINTCALCDATE 
        FROM LOANS_FACILITY_DETAILS F
        WHERE F.ACCT_NUM = ACTNUM;
        IF LASTINTCALCDATE < ASONDT THEN
            STARTDATE := LASTINTCALCDATE + 1;
        ELSE
--            SELECT NVL(MAX(T.TRANS_DT),LOANDATE) INTO STARTDATE 
--            FROM LOAN_TRANS_DETAILS T
--            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND UPTO_DT_INT = 'Y';
SELECT NVL(MAX(T.TRANS_DT),LOANDATE) INTO STARTDATE 
        FROM LOAN_TRANS_DETAILS T
        WHERE T.ACT_NUM =ACTNUM AND T.TRANS_DT < ASONDT and T.PRINCIPLE > 0 AND
        T.TRANS_DT in (select max(LTD.TRANS_DT) from 
        loan_trans_details ltd where LTD.ACT_NUM = T.ACT_NUM
        and LTD.TRANS_TYPE = 'CREDIT' AND LTD.PRINCIPLE > 0 AND LTD.TRANS_DT < ASONDT);       --AND UPTO_DT_INT = 'Y';
        END IF;
        SELECT GET_TL_INST_OD(F.ACCT_NUM,ASONDT) INTO INSTAMTRECEIVALBE
        FROM LOANS_FACILITY_DETAILS F 
        WHERE F.ACCT_NUM = ACTNUM;
    --    Select nvl(R.GRACE_PERIOD,0)  into Graceperiod From RECOVERY_PARAMETERS R ;
--        DBMS_OUTPUT.PUT_LINE('STARTDATE = '||STARTDATE);
        IF INSTAMTRECEIVALBE > 0 THEN
            SELECT NVL(SUM(T.PENAL),0) INTO PENINTRECEIVED
            FROM LOAN_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.TRANS_DT > STARTDATE;
            DECLARE CURSOR CURINST IS 
            SELECT I.PRINCIPAL_AMT,I.INSTALLMENT_DT AS INSTALLMENT_DT--I.INSTALLMENT_DT + Graceperiod AS INSTALLMENT_DT
            FROM LOANS_INSTALLMENT I
            WHERE I.ACCT_NUM = ACTNUM AND I.INSTALLMENT_DT <= ASONDT AND I.INSTALLMENT_DT >= STARTDATE --I.INSTALLMENT_DT + Graceperiod <= ASONDT AND I.INSTALLMENT_DT >= STARTDATE
            AND I.PRINCIPAL_AMT > 0
            UNION ALL
            SELECT 0 AS PRINCIPAL_AMT,ASONDT AS INSTALLMENT_DT
            FROM DUAL
            ORDER BY INSTALLMENT_DT;
            FLG NUMBER := 0;
            BEGIN
                FOR INST IN CURINST
                LOOP
                    --DBMS_OUTPUT.PUT_LINE(inst.INSTALLMENT_DT);
                    IF FLG  = 0 THEN
                    STARTDATE := INST.INSTALLMENT_DT;
                    FLG := 1;
                    END IF;
                    PENINTRECEIVABLE := NVL(PENINTRECEIVABLE,0) + (GET_TL_INST_OD(ACTNUM,STARTDATE) * (INST.INSTALLMENT_DT-STARTDATE) * PENROI)/36500;
                    --DBMS_OUTPUT.PUT_LINE('PENINTRECEIVABLE =   '||'GET_TL_INST_OD(ACTNUM,STARTDATE)=   '||GET_TL_INST_OD(ACTNUM,STARTDATE)||  PENINTRECEIVABLE||'STARTDATE=  '||STARTDATE||'INST.INSTALLMENT_DT=  '||INST.INSTALLMENT_DT||' PENROI=  '||PENROI);
                    STARTDATE := INST.INSTALLMENT_DT;
                END LOOP;
            END;
            PENINTRECEIVABLE := NVL(PENINTRECEIVABLE,0) - NVL(PENINTRECEIVED,0);
            PENINTRECEIVABLE := ROUND(PENINTRECEIVABLE,0);
        END IF;
        IF PENINTRECEIVABLE < 0 THEN
            PENINTRECEIVABLE := 0;
        END IF;
    ELSE        PENINTRECEIVABLE := 0;
    END IF;
       RETURN PENINTRECEIVABLE;
       --DBMS_OUTPUT.PUT_LINE('PENINTRECEIVABLE =   '||PENINTRECEIVABLE );
END;
/

CREATE OR REPLACE FUNCTION GET_TL_LASTRECOVERY_TYPE(ACTNUM VARCHAR,ASONDT DATE) RETURN VARCHAR IS
LASTTRANSDT DATE; 
TRANSMODE VARCHAR2(100);
TRANSMETHOD VARCHAR2(100);
BEGIN
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
        SELECT TRIM(NVL(MAX(SUBSTR(ATA.TRANS_ALL_ID,1,2)),MAX(REC_MODE))) INTO TRANSMODE   FROM  ALL_TRANS ATA
         WHERE ATA.TRANS_DT = LASTTRANSDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
           --dbms_output.put_line('LASTTRANSDT   ='||LASTTRANSDT);
        IF TRANSMODE = 'RP' THEN 
                TRANSMETHOD := 'Salary Recovery';
            ELSE
                IF TRANSMODE = 'SI' OR TRANSMODE = 'TE' THEN 
                    TRANSMETHOD := 'Deduction SI';        
                ELSE
                    IF TRANSMODE = 'TA' THEN 
                        TRANSMETHOD := 'By Recovery Cash/Transfer';
                    ELSE
                        IF TRANSMODE IS NULL THEN
                            TRANSMETHOD := 'By Direct Cash/Transfer';
                        END IF; 
                END IF;
            END IF;
        END IF;
RETURN TRANSMETHOD ;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_RECBLE_RECOVERY(ACTNUM VARCHAR,ASONDT DATE) RETURN NUMBER IS
--declare
--actnum varchar2(13) := '0001309000080';
--asondt date := '07-juL-2015';
RECEIVABLE NUMBER(12,2);
RECD NUMBER(12,2);
LOAN_STATUS VARCHAR2(100);
INST_TYPE VARCHAR2(100);
EMITYPE VARCHAR2(1);
REPAYDT DATE;
INSTAMT NUMBER(12,2);
PRINCBAL NUMBER(12,2);
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        where LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        
         BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO REPAYDATE FOR LUMPSUM');
            END;
            
IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'Y' THEN
            BEGIN
            SELECT NVL (SUM (LIM.TOTAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE_EMI RECBLE');
            END;
            --DBMS_OUTPUT.PUT_LINE('RECEIVABLE   ='||RECEIVABLE);
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0) + NVL(LTD.INTEREST,0) )  INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT AND TRANS_TYPE = 'CREDIT';
            EXCEPTION WHEN OTHERS THEN 
             DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE_EMI RECD');
            END;
            DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'  '||RECD);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            IF RECEIVABLE IS NULL THEN 
            RECEIVABLE := 0;
            END IF;             
            INSTAMT := GET_TL_INSTAMT(ACTNUM);
            IF  RECEIVABLE < INSTAMT THEN
                RECEIVABLE := INSTAMT;
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE);
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'EMIADVANCE';
                ELSE
                LOAN_STATUS := 'EMIDUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE
    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'N' THEN
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE RECBLE');
            END;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT
            AND LTD.TRANS_TYPE ='CREDIT'  ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE RECD');
            END;
            --RECEIVABLE := RECEIVABLE -  RECD;
            DBMS_OUTPUT.PUT_LINE(' RECEIVABLE uniform ='||RECEIVABLE||'   '||'RECD ='||RECD);
            
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            IF RECEIVABLE IS NULL THEN 
            RECEIVABLE := 0;
            END IF;
            INSTAMT := GET_TL_INSTAMT(ACTNUM);
            PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
            
            
            IF REPAYDT < asondt then
                IF  RECEIVABLE < INSTAMT THEN
                   
                    IF PRINCBAL < RECEIVABLE THEN
                    RECEIVABLE := NVL(PRINCBAL,0);
                    ELSE 
                    RECEIVABLE := INSTAMT;
                    END IF;
                END IF;
            End if;
            
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'UNIFORM ADVANCE';
                ELSE
                LOAN_STATUS := 'UNIFORM DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('UNIFORM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE 
   IF INST_TYPE = 'LUMP_SUM' OR INST_TYPE = 'EYI' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO REPAYDATE FOR LUMPSUM');
            END;
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA LUMPSUM RECEIVABLE');
            END;
             BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT
            AND LTD.TRANS_TYPE ='CREDIT'  ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE RECD');
            END;
            INSTAMT := GET_TL_INSTAMT(ACTNUM);
            PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT
            AND LTD.TRANS_TYPE = 'CREIDT'  ;
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            DBMS_OUTPUT.PUT_LINE(RECEIVABLE || '   '||RECD  );
            RECEIVABLE := RECEIVABLE -  RECD; 
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            IF RECEIVABLE IS NULL THEN 
            RECEIVABLE := 0;
            END IF;
            
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'LUMPSUM ADVANCE';
                ELSE
                LOAN_STATUS := 'LUMPSUM DUE';
            END IF; 
            --DBMS_OUTPUT.PUT_LINE('LUMPSUM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
    END IF;
   END IF;
END IF;
--DBMS_OUTPUT.PUT_LINE('LOAN_STATUS  ='||LOAN_STATUS||'   '||RECEIVABLE);
RETURN RECEIVABLE;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_STATUS_RECOVERY(ACTNUM VARCHAR,ASONDT DATE) RETURN VARCHAR IS
--DECLARE
--ACTNUM VARCHAR2(13) := '0001305000909';
--ASONDT DATE := '30-JUN-2015';
RECEIVABLE NUMBER(12,2);
RECD NUMBER(12,2);
LOAN_STATUS VARCHAR2(100);
INST_TYPE VARCHAR2(100);
EMITYPE VARCHAR2(1);
REPAYDT DATE;
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED';
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'Y' THEN
            BEGIN
            SELECT NVL (SUM (LIM.TOTAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECBLE');
            END ;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0) + NVL(LTD.INTEREST,0) )  INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE  LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECD ');
            END;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'  '||RECD);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE);
            IF RECEIVABLE <= 0  THEN
                LOAN_STATUS := 'EMIADVANCE';
                ELSE
                LOAN_STATUS := 'EMIDUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE
    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'N' THEN
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECBLE UNIFORM PRINCIPLE');
            END;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE   LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECD UNIFORM PRINCIPLE');
            END;
            RECEIVABLE := RECEIVABLE -  RECD;
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'UNIFORM ADVANCE';
                ELSE
                LOAN_STATUS := 'UNIFORM DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('UNIFORM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE 
   IF INST_TYPE = 'LUMP_SUM' OR INST_TYPE = 'EYI' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA');
            END;
            --DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM 
            AND LTD.TRANS_TYPE = 'CREDIT' AND  LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            RECEIVABLE := RECEIVABLE -  RECD; 
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'LUMPSUM ADVANCE';
                ELSE
                LOAN_STATUS := 'LUMPSUM DUE';
            END IF; 
            --DBMS_OUTPUT.PUT_LINE('LUMPSUM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
    END IF;
   END IF;
END IF;
RETURN LOAN_STATUS;
END;

CREATE OR REPLACE FUNCTION GET_TL_INTERESTRECBLE_recovery(ACTNUM VARCHAR,ASONDT DATE,Recoverytype varchar)
RETURN NUMBER IS
--declare 
--actnum varchar2(13) := '0001304001168';
--asondt date := '07-jul-2015';
--Recoverytype varchar2(50) :='Direct' ;
--loandate date :='30-mar-2015';
    INTRECEIVABLE NUMBER(16,2) := 0;
    INTRECEIVED NUMBER(16,2) := 0;
    ROI NUMBER(16,2) := 0;
    TRNDATE DATE; 
    PRNBAL NUMBER(16,2) := 0;
    LASTINTCALCDATE DATE;
    STARTDATE DATE;
    CATG varchar2(32);
    LOANDATE DATE;
    SDATE DATE;
    CNT NUMBER;
    LAST_RECDATE DATE;
    FLG NUMBER := 0;
    status VARCHAR2(10);
    lastintdate date;
BEGIN
    SELECT LSD.FROM_DT INTO LOANDATE  FROM LOANS_SANCTION_DETAILS LSD,LOANS_FACILITY_DETAILS LFD WHERE LSD.BORROW_NO = LFD.BORROW_NO
    AND LFD.ACCT_NUM = ACTNUM; 
    SELECT F.LAST_INT_CALC_DT INTO LASTINTCALCDATE
    FROM LOANS_FACILITY_DETAILS F 
    WHERE F.ACCT_NUM = ACTNUM;
    BEGIN
    select SR.INT_CALC_UPTO_DT into lastintdate  from SALARY_RECOVERY_LIST_DETAIL sr where SR.INT_CALC_UPTO_DT = LASTINTCALCDATE
    and SR.ACT_NUM = actnum;
    EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('NO INTEREST DATE');
    --lastintdate := LASTINTCALCDATE; 
    END;
      
    --DBMS_OUTPUT.PUT_LINE('lastintdate   ='||lastintdate);
    SELECT NVL(MAX(T.TRANS_DT),LOANDATE) INTO STARTDATE 
                FROM LOAN_TRANS_DETAILS T
                WHERE T.ACT_NUM =ACTNUM AND T.TRANS_DT < ASONDT and T.PRINCIPLE > 0 AND
                T.TRANS_DT in (select max(LTD.TRANS_DT) from 
                loan_trans_details ltd where LTD.ACT_NUM = T.ACT_NUM
                and LTD.TRANS_TYPE = 'CREDIT' AND LTD.PRINCIPLE > 0 AND LTD.TRANS_DT < ASONDT);       --AND UPTO_DT_INT = 'Y';
                dbms_output.put_line('startdate  pras='||STARTDATE);
     If lastintdate is null then            
     SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM LOAN_TRANS_DETAILS LT
     WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > STARTDATE AND LT.TRANS_DT <= ASONDT;
     Else     
     SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM LOAN_TRANS_DETAILS LT
     WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > STARTDATE AND LT.TRANS_DT <= ASONDT;
     End if;
     
     --dbms_output.put_line('STARTDATE   ='||STARTDATE);
    IF LASTINTCALCDATE < ASONDT THEN
         if lastintdate = LASTINTCALCDATE  then
            if Recoverytype = 'Recovery' then 
                STARTDATE := LASTINTCALCDATE;
                DBMS_OUTPUT.PUT_LINE('STARTDATE IST  ='||STARTDATE);
            end if;
         else
          STARTDATE := LASTINTCALCDATE + 1;
         End if;
         --dbms_output.put_line('STARTDATE     ='||STARTDATE);
    ELSE
        SDATE := STARTDATE;
        DBMS_OUTPUT.PUT_LINE('SDATE   ='||SDATE);
    END IF;
    --DBMS_OUTPUT.PUT_LINE('LAST_RECDATE   ='||LAST_RECDATE);
    --DBMS_OUTPUT.PUT_LINE(STARTDATE||'NEAR LOOP' );
    --SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM LOAN_TRANS_DETAILS LT
    --WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > STARTDATE AND LT.TRANS_DT <= ASONDT;
    SELECT CASE WHEN LFD.INT_GET_FROM = 'ACT' THEN
                    (SELECT LIM.INTEREST FROM LOANS_INT_MAINTENANCE LIM WHERE LIM.ACCT_NUM = LFD.ACCT_NUM)
                WHEN LFD.INT_GET_FROM = 'PROD' THEN
                   GET_TL_ROI(LFD.PROD_ID,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT)
                ELSE 0 END INTO ROI
    FROM LOANS_FACILITY_DETAILS LFD
    JOIN LOANS_SANCTION_DETAILS LSD ON LFD.BORROW_NO = LSD.BORROW_NO
    JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
    WHERE LFD.ACCT_NUM = ACTNUM;
DECLARE CURSOR LOANTRANS IS 
    SELECT T.TRANS_DT,T.PRINCIPLE,T.TRN_CODE
    FROM LOAN_TRANS_DETAILS T
    WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.TRANS_DT >= STARTDATE AND T.PRINCIPLE > 0 
    UNION
    SELECT ASONDT AS TRANS_DT,0 AS PRINCIPLE,'DP' AS TRN_CODE
    FROM DUAL
    ORDER BY TRANS_DT ASC;
    TRANSDT LOAN_TRANS_DETAILS.TRANS_DT%TYPE;
    I NUMBER(16,2) := 0;
    DATEDIFF NUMBER;
    FLAG NUMBER := 0  ;
    BEGIN
        FOR TRN IN LOANTRANS LOOP
            SELECT NVL(SUM(CASE WHEN T.TRN_CODE = 'DP' THEN 1 ELSE -1 END * T.PRINCIPLE),0) INTO PRNBAL  
            FROM LOAN_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT < TRN.TRANS_DT;
            --dbms_output.put_line('FLAG  ='||FLAG);
            if Recoverytype = 'Direct' then  
                IF FLAG = 0 THEN 
                TRNDATE := TRN.TRANS_DT ;
                DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                FLAG := 1;
                ELSE
                    IF FLG = 1 THEN 
                        TRNDATE := TRN.TRANS_DT ;
                        DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    ELSE
                    TRNDATE := TRN.TRANS_DT ;
                    DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    DATEDIFF := DATEDIFF + 1;
                    END IF;
                END IF;
            Else
               IF FLAG = 0 THEN 
                TRNDATE := TRN.TRANS_DT ;
                DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                --dbms_output.put_line('DATEDIFF   =inside loop else flag 0'||DATEDIFF);
                FLAG := 1;
               ELSE
                    IF FLG = 1 THEN 
                        TRNDATE := TRN.TRANS_DT ;
                        DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    ELSE
                    TRNDATE := TRN.TRANS_DT ;
                    DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    DATEDIFF := DATEDIFF + 1;
                    END IF;
               END IF;
            End if;
            --dbms_output.put_line(DATEDIFF);
            INTRECEIVABLE := INTRECEIVABLE +  (PRNBAL * DATEDIFF * ROI/ 36500);
           --dbms_output.put_line('flag  ='||flag||'    '||INTRECEIVED||' ' ||PRNBAL||' '||TRN.TRANS_DT||'ROI= '||ROI||' '||STARTDATE||''||'DATE DIFF ='||DATEDIFF ||' '||INTRECEIVABLE); 
            STARTDATE := TRN.TRANS_DT;
        END LOOP;
    END;
    --DBMS_OUTPUT.PUT_LINE('INTRECEIVED   ='||INTRECEIVED);
    INTRECEIVABLE := INTRECEIVABLE - NVL(INTRECEIVED,0);
    IF INTRECEIVABLE < 0 THEN
       INTRECEIVABLE := 0;
    END IF;
    INTRECEIVABLE := ROUND(INTRECEIVABLE);
        BEGIN
            SELECT NVL(lfd.acct_status,'NEW')
            INTO status
            FROM loans_facility_details lfd 
            WHERE lfd.acct_num = actnum 
            AND (LFD.acct_close_dt IS NULL
                  OR LFD.acct_close_dt > GET_LAST_FINENDDATE(asondt) AND LFD.acct_close_dt <= ASONDT
                 );
        EXCEPTION WHEN OTHERS THEN
        STATUS := 'NEW';
        END;
  IF STATUS = NULL THEN 
  STATUS := 'NEW';
  END IF;
    IF STATUS = 'CLOSED' THEN
    RETURN 0;
    --dbms_output.put_line(INTRECEIVABLE);
    END IF;
   RETURN INTRECEIVABLE;
    --dbms_output.put_line(INTRECEIVABLE);
END;
/

CREATE OR REPLACE FUNCTION GET_TL_PRINCRECBLE(ACTNUM VARCHAR, ASONDT DATE,RECOVERYTYPE VARCHAR) RETURN NUMBER IS
--DECLARE 
--ACTNUM VARCHAR2(13) := '0001303001450';
--ASONDT DATE := '23-JUN-2015';
--RECOVERYTYPE VARCHAR2(100) := 'Direct';
LASTINTDATE DATE;
PENDINGPRINCIPLE NUMBER(12,2);
PENDINGINTEREST NUMBER(12,2);
PENDNGPENAL NUMBER(12,2);
LASTRECOVERYDATE DATE;
PRINCPAYABLE NUMBER(12,2);
INST_TYPE VARCHAR2(50);
EMITYPE VARCHAR2(100);
RECEIVABLE NUMBER(12,2);
TRANSMETHOD VARCHAR2(100);
INTRECBLE NUMBER(12,2);
INSTCOUNT NUMBER(10);
INSTAMT NUMBER(12,2);
NOOFINST NUMBER(12,2);
PRINCBAL NUMBER(12,2);
REPAYDT DATE;
LASTTRANSDT DATE;
RECOVERYFLAG VARCHAR2(100);
INSTAMTRECD NUMBER(12,2);
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL(LRS.EMI_IN_SIMPLEINTREST,'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        TRANSMETHOD := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        RECEIVABLE   := GET_TL_RECBLE_RECOVERY(ACTNUM,ASONDT);
        INTRECBLE := GET_TL_INTERESTRECBLE_RECOVERY(ACTNUM,ASONDT,RECOVERYTYPE);
        PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
        INSTAMT :=  GET_TL_INSTAMT(ACTNUM);
        DBMS_OUTPUT.PUT_LINE(INST_TYPE||'   '||EMITYPE||'RECEIVABLE  ='||RECEIVABLE||'   PRINCBAL='||PRINCBAL||'   INSTAMT='||INSTAMT);        
        BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
        EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN LSD');
        END;
        --DBMS_OUTPUT.PUT_LINE('INST_TYPE  ='||INST_TYPE||'EMITYPE    '||EMITYPE||'REPAYDT   '||REPAYDT||'  '||'RECEIVABLE ='||RECEIVABLE);
        
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';           
        SELECT ADD_MONTHS(LAST_DAY(ASONDT),-1) INTO LASTRECOVERYDATE FROM DUAL;           
        BEGIN
        SELECT MAX(SRLD.INT_CALC_UPTO_DT) INTO LASTINTDATE  FROM SALARY_RECOVERY_LIST_DETAIL SRLD,DAY_END DE 
        WHERE SRLD.STATUS = 'CREATED' AND SRLD.ACT_NUM = ACTNUM AND SRLD.INT_CALC_UPTO_DT <= ASONDT;
        EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('NO DATA IN SRLD');
        END;
        BEGIN                               
        SELECT NVL(PRINCIPAL,0) - NVL(REC_PRINCIPAL,0),NVL(INTEREST,0)-NVL(REC_INTEREST,0) ,NVL(PENAL,0)-NVL(REC_PENAL,0) INTO
        PENDINGPRINCIPLE ,PENDINGINTEREST,PENDNGPENAL FROM SALARY_RECOVERY_LIST_DETAIL SRLD
        WHERE SRLD.ACT_NUM = ACTNUM
        AND SRLD.INT_CALC_UPTO_DT = LASTINTDATE;
        EXCEPTION WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('NO DATA IN SRLD PENDING');
        END ;
        
            IF RECEIVABLE <= 0 THEN
               if REPAYDT < ASONDT THEN
                   IF PRINCBAL < INSTAMT THEN
                         RECEIVABLE := PRINCBAL;
                   ELSE
                        
                         RECEIVABLE := INSTAMT;
                        
                   END IF;
               END IF;
            END IF; 
            
            DBMS_OUTPUT.PUT_LINE('LASTRECOVERYDATE   '||LASTRECOVERYDATE||'   '||'RECEIVABLE actual    ='||RECEIVABLE);
            
          /* FORMATTED ON 2015/07/02 14:26 (FORMATTER PLUS V4.8.8) */
            IF RECOVERYTYPE = 'Direct' then
            BEGIN
            SELECT  CASE WHEN LRS.INSTALL_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  LRS.EMI_IN_SIMPLEINTREST = 'Y' THEN
            SUM(LTD.PRINCIPLE  + LTD.INTEREST)
            ELSE
            SUM(NVL(LTD.PRINCIPLE,0)) END INTO INSTAMTRECD            
            FROM LOAN_TRANS_DETAILS LTD,LOANS_REPAY_SCHEDULE LRS WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT > LASTRECOVERYDATE
            AND LTD.TRANS_DT <= ASONDT AND LTD.TRANS_TYPE = 'CREDIT'
            AND LRS.ACCT_NUM = LTD.ACT_NUM
            GROUP BY LRS.INSTALL_TYPE,LRS.EMI_IN_SIMPLEINTREST;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN ALL_TRANS DURING THIS MONTH');
            END;
            RECEIVABLE := nvl(RECEIVABLE,0) - nvl(INSTAMTRECD,0);                  
            END IF;
            DBMS_OUTPUT.PUT_LINE('PRINCRECD  ='||INSTAMTRECD||'  '||'RECEIVABLE    ='||RECEIVABLE);
        
         /* CONDITION 1*/
                                       
        /*RECOVERY A/CS THEN*/       
           IF PENDNGPENAL = 0 AND PENDINGINTEREST = 0 AND PENDINGPRINCIPLE = 0 THEN
            RECOVERYFLAG := 'RecoveryCompleted';
           ELSE
            RECOVERYFLAG := 'RecoveryPartial';
           END IF;           
        /*CHECK LAST TRANSACTION OF A/C  */   
           IF LASTTRANSDT > LASTRECOVERYDATE THEN
                IF RECEIVABLE <= 0 THEN 
                    RECOVERYFLAG := 'RecoveryCompleted';
                    RECEIVABLE := 0;
                ELSE
                    RECOVERYFLAG := 'RecoveryPartial';
                END IF;
           END IF;           
    /*  HERE CONSIDER THE RECEIVABLE */
    
    
    
    DBMS_OUTPUT.PUT_LINE('RECOVERYFLAG   ='||RECOVERYFLAG);
    
    /* CONDITION 2*/
           IF RECOVERYTYPE = 'Recovery' THEN
              IF RECEIVABLE < 0  THEN
                 IF PRINCBAL < INSTAMT THEN
                     RECEIVABLE := PRINCBAL;
                 ELSE
                     RECEIVABLE := INSTAMT;
                 END IF;
              END IF;
           ELSE
               IF RECEIVABLE < 0   THEN
                  IF RECOVERYFLAG = 'RecoveryCompleted' THEN
                     RECEIVABLE := 0;
                      DBMS_OUTPUT.PUT_LINE(' condition 2 Direct Completed   ='||PRINCBAL);
                  ELSE
                      IF LASTTRANSDT >LASTRECOVERYDATE THEN
                         IF PRINCBAL < INSTAMT THEN
                             RECEIVABLE := PRINCBAL;
                         ELSE
                             RECEIVABLE := INSTAMT;
                         END IF;
                      END IF;
                      DBMS_OUTPUT.PUT_LINE(' condition 2 Direct Partial   ='||PRINCBAL);
                  END IF;
               END IF;
           END IF;
           /*  CONDITION 3  */
--           IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' THEN  
--               IF RECEIVABLE < INSTAMT THEN
--                 IF PRINCBAL < INSTAMT THEN
--                     RECEIVABLE := PRINCBAL;
--                 ELSE
--                     RECEIVABLE := INSTAMT;
--                 END IF;
--               END IF;
--               DBMS_OUTPUT.PUT_LINE(' CONDITION 3 EMI   ='||RECEIVABLE);
--           ELSE
--               IF REPAYDT < ASONDT THEN
--               PRINCBAL := 0 ;
--               END IF;
--               DBMS_OUTPUT.PUT_LINE(' CONDITION 3 LUMPSUM   ='||RECEIVABLE);
--           END IF;
    /*  END OF CONSIDER THE RECEIVABLE */ 
               /*  HERE CONSIDERING THE PRINCIPLE PAYABLE  */
            --DBMS_OUTPUT.PUT_LINE('RECEIVABLE     ='||RECEIVABLE||'RECOVERYFLAG   ='||RECOVERYFLAG||' '||PENDNGPENAL||'  '|| PENDINGINTEREST||'  '||PENDINGPRINCIPLE||'   '||LASTINTDATE||'  '||LASTTRANSDT ) ;        
    IF RECOVERYTYPE = 'Recovery' THEN
           IF RECEIVABLE > 0 THEN
                    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                        PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                    ELSE
                        PRINCPAYABLE := RECEIVABLE;
                    END IF;
           ELSE
                    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                       IF RECOVERYFLAG = 'RecoveryPartial' THEN                         
                            IF INTRECBLE > INSTAMT THEN
                                NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                            ELSE
                                IF PRINCBAL < INSTAMT  THEN
                                    PRINCPAYABLE := PRINCBAL;
                                ELSE
                                    PRINCPAYABLE := INSTAMT;
                                END IF;
                            END IF;
                            WHILE INSTCOUNT <= NOOFINST
                            LOOP
                              INSTCOUNT := INSTCOUNT + 1;
                              IF PRINCPAYABLE >=PRINCBAL THEN
                               PRINCPAYABLE := PRINCBAL;
                              ELSE
                              PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                              END IF; 
                              --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                            END LOOP;
                       END IF;
                    ELSE
                       IF RECOVERYFLAG = 'RecoveryPartial' THEN
                         IF REPAYDT < ASONDT THEN
                         DBMS_OUTPUT.PUT_LINE('I AM HERE');
                               IF INTRECBLE > INSTAMT THEN
                                  NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                               ELSE
                                    IF PRINCBAL < INSTAMT  THEN
                                        PRINCPAYABLE := PRINCBAL;
                                    ELSE
                                        PRINCPAYABLE := INSTAMT;
                                    END IF;
                               END IF;
                                WHILE INSTCOUNT <= NOOFINST
                                LOOP
                                  INSTCOUNT := INSTCOUNT + 1;
                                  IF PRINCPAYABLE >=PRINCBAL THEN
                                   PRINCPAYABLE := PRINCBAL;
                                  ELSE
                                  PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                  END IF; 
                                  --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                END LOOP;
                              IF INTRECBLE < INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                              ELSE
                                        IF PRINCBAL < INSTAMT  THEN
                                            PRINCPAYABLE := PRINCBAL;
                                        ELSE
                                            PRINCPAYABLE := INSTAMT;
                                        END IF;
                                            
                                    WHILE INSTCOUNT <= NOOFINST
                                    LOOP
                                      INSTCOUNT := INSTCOUNT + 1;
                                      IF PRINCPAYABLE >=PRINCBAL THEN
                                       PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                      PRINCPAYABLE := INSTAMT ;
                                      END IF; 
                                      --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                    END LOOP;
                                      IF PRINCPAYABLE >= PRINCBAL THEN
                                        PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                        PRINCPAYABLE := INSTAMT;
                                      END IF;
                              END IF;
                         ELSE
                         PRINCPAYABLE := 0;
                         END IF;
                       ELSE
                       PRINCPAYABLE := 0;
                       END IF;
                    END IF;
           END IF;
   -- DBMS_OUTPUT.PUT_LINE('PRINCPAYABLE   ='||PRINCPAYABLE||'INTRECBLE  ='||INTRECBLE||'   INSTAMT ='||INSTAMT);
    ELSE
         --IF TRANSMETHOD = 'BY RECOVERY CASH/TRANSFER' OR TRANSMETHOD = 'DEDUCTION SI' OR TRANSMETHOD = 'BY DIRECT CASH/TRANSFER' THEN
          --DBMS_OUTPUT.PUT_LINE('I AM OUTSIDE');
             IF RECEIVABLE > 0 THEN
                            IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                                PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                            ELSE
                                PRINCPAYABLE := RECEIVABLE;
                            END IF;
             ELSE
                            IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                               IF RECOVERYFLAG = 'RecoveryPartial' THEN                         
                                    IF INTRECBLE > INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                    ELSE
                                        IF PRINCBAL < INSTAMT  THEN
                                            PRINCPAYABLE := PRINCBAL;
                                        ELSE
                                            PRINCPAYABLE := INSTAMT;
                                        END IF;
                                    END IF;
                                    WHILE INSTCOUNT <= NOOFINST
                                    LOOP
                                      INSTCOUNT := INSTCOUNT + 1;
                                      IF PRINCPAYABLE >=PRINCBAL THEN
                                       PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                      PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                      END IF; 
                                      --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                    END LOOP;
                               END IF;
                            ELSE
                               IF RECOVERYFLAG = 'RecoveryPartial' THEN
                                 IF REPAYDT < ASONDT THEN
                                 DBMS_OUTPUT.PUT_LINE('I AM HERE');
                                       IF INTRECBLE > INSTAMT THEN
                                          NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                       ELSE
                                            IF PRINCBAL < INSTAMT  THEN
                                                PRINCPAYABLE := PRINCBAL;
                                            ELSE
                                                PRINCPAYABLE := INSTAMT;
                                            END IF;
                                       END IF;
                                        WHILE INSTCOUNT <= NOOFINST
                                        LOOP
                                          INSTCOUNT := INSTCOUNT + 1;
                                          IF PRINCPAYABLE >=PRINCBAL THEN
                                           PRINCPAYABLE := PRINCBAL;
                                          ELSE
                                          PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                          END IF; 
                                          --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                        END LOOP;
                                      IF INTRECBLE < INSTAMT THEN
                                                NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                      ELSE
                                                IF PRINCBAL < INSTAMT  THEN
                                                    PRINCPAYABLE := PRINCBAL;
                                                ELSE
                                                    PRINCPAYABLE := INSTAMT;
                                                END IF;
                                                    
                                            WHILE INSTCOUNT <= NOOFINST
                                            LOOP
                                              INSTCOUNT := INSTCOUNT + 1;
                                              IF PRINCPAYABLE >=PRINCBAL THEN
                                               PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                              PRINCPAYABLE := INSTAMT ;
                                              END IF; 
                                              --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                            END LOOP;
                                              IF PRINCPAYABLE >= PRINCBAL THEN
                                                PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                                PRINCPAYABLE := INSTAMT;
                                              END IF;
                                      END IF;
                                 ELSE
                                 PRINCPAYABLE := 0;
                                 END IF;
                               ELSE
                               PRINCPAYABLE := 0;
                               END IF;
                            END IF;
             END IF;     -- END IF;
    END IF;
    IF PRINCPAYABLE IS NULL THEN 
    PRINCPAYABLE := 0 ;
    END IF;
RETURN PRINCPAYABLE;
DBMS_OUTPUT.PUT_LINE('PRINCPAYABLE   ='||PRINCPAYABLE||'  '||'INTRECBLE  ='||INTRECBLE||INST_TYPE||'   '||EMITYPE||'RECEIVABLE  ='||RECEIVABLE||'   PRINCBAL='||PRINCBAL||'   INSTAMT='||INSTAMT);
--DBMS_OUTPUT.PUT_LINE('REPAYDT   ='||REPAYDT||'     TRANSMETHOD  ='||TRANSMETHOD||'   '||PRINCPAYABLE);
END;
/

CREATE OR REPLACE function GET_RecoveryTL(ACTNUM varchar2,ASONDT date,Recoverytype varchar) Return varchar is
--DECLARE 
--ACTNUM VARCHAR2(13) := '0001303001147';
--ASONDT DATE := '30-JUN-2015';
--Recoverytype varchar2(100) := 'Recovery';
RecoveryDetails varchar2(500);
INST_TYPE VARCHAR2(50);
EMITYPE VARCHAR2(1);
RECEIVABLE NUMBER(16,2);
FROMDT DATE;
TODT DATE;
CATG VARCHAR2(50);
LIMITR NUMBER(16,2);
PRODID VARCHAR2(10);
INTRECBLE NUMBER(16,2);
LASTTRANSDT DATE;
PRINCBAL NUMBER(16,2);
PRINCPAYABLE NUMBER(16,2);
INSTAMT NUMBER(16,2);
TransMethod Varchar2(100);
INTGETFROM VARCHAR2(10);
LOAN_STATUS VARCHAR2(100);
PENALINTRATE NUMBER(12,2);
PENALRECBLE NUMBER(12,2);
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        where LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
        SELECT LSD.FROM_DT,LSD.TO_DT,LB.CATEGORY,LSD.LIMIT,LFD.PROD_ID,LFD.INT_GET_FROM INTO FROMDT,TODT,CATG,LIMITR,PRODID,INTGETFROM 
        FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
        WHERE LFD.BORROW_NO = LSD.BORROW_NO
        AND LSD.BORROW_NO = LB.BORROW_NO
        AND LFD.ACCT_NUM = ACTNUM; 
        TRANSMETHOD  := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        RECEIVABLE   := GET_TL_RECBLE_RECOVERY(ACTNUM,ASONDT);
        LOAN_STATUS  := GET_TL_STATUS_RECOVERY(ACTNUM,ASONDT);
        PENALINTRATE := GET_TL_PENROI(PRODID,CATG,ACTNUM,FROMDT,TODT,LIMITR,INTGETFROM);
        PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
        INSTAMT :=  GET_TL_INSTAMT(ACTNUM);
        INTRECBLE := GET_TL_INTERESTRECBLE_recovery(ACTNUM,ASONDT,Recoverytype);
        Penalrecble := GET_TL_PENINTEREST(ACTNUM,FROMDT,ASONDT,PENALINTRATE);
        PRINCPAYABLE   := GET_TL_PRINCRECBLE(ACTNUM,ASONDT,Recoverytype);
RecoveryDetails := 'ACTNUM='||actnum||':'||'LOAN_STATUS='||LOAN_STATUS||':'||'Transmethod='||Transmethod||':'||'INSTAMT ='||INSTAMT||':'||'PRINCPAYABLE='||PRINCPAYABLE||':'||'intrecble='||intrecble||':'||'Penalrecble='||Penalrecble||':';
--dbms_output.put_line(RecoveryDetails) ;
Return RecoveryDetails;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_INSTAMT(ACTNUM VARCHAR2) RETURN NUMBER IS
--DECLARE
--actnum varchar2(13) := '0001303001110'; 
    INST_AMT NUMBER(16,2) := 0;
    INSTTYPE VARCHAR2(50);
    EMI VARCHAR2(10);
    COUNTR NUMBER;
BEGIN
SELECT lrs.install_type, NVL (lrs.emi_in_simpleintrest, 'N')
  INTO insttype, emi
  FROM loans_repay_schedule lrs
 WHERE lrs.acct_num = actnum;
IF INSTTYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMI = 'Y' THEN

--SELECT MAX(I.TOTAL_AMT) INTO INST_AMT
--FROM LOANS_INSTALLMENT I
--WHERE I.ACCT_NUM = ACTNUM AND I.STATUS != 'DELETED' AND NVL(I.ACTIVE_STATUS,'Y') = 'Y' AND
--I.INSTALLMENT_SLNO = (SELECT MIN(LI.INSTALLMENT_SLNO)
--                FROM LOANS_INSTALLMENT LI 
--                WHERE LI.ACCT_NUM = ACTNUM AND LI.STATUS != 'DELETED' AND NVL(LI.ACTIVE_STATUS,'Y') = 'Y' );
SELECT COUNT(*),I.TOTAL_AMT INTO COUNTR,INST_AMT
FROM LOANS_INSTALLMENT I 
WHERE I.ACCT_NUM = ACTNUM AND I.STATUS != 'DELETED' AND NVL(I.ACTIVE_STATUS,'Y') = 'Y'
GROUP BY I.TOTAL_AMT  HAVING COUNT(I.TOTAL_AMT) > 1;
RETURN INST_AMT;
ELSE
    SELECT MAX(I.PRINCIPAL_AMT) INTO INST_AMT
    FROM LOANS_INSTALLMENT I
    WHERE I.ACCT_NUM = ACTNUM AND I.STATUS != 'DELETED' AND NVL(I.ACTIVE_STATUS,'Y') = 'Y' AND
          I.INSTALLMENT_SLNO = (SELECT max(LI.INSTALLMENT_SLNO)
                                FROM LOANS_INSTALLMENT LI 
                                WHERE LI.ACCT_NUM = ACTNUM AND LI.STATUS != 'DELETED' AND NVL(LI.ACTIVE_STATUS,'Y') = 'Y' ); 
RETURN INST_AMT;
End if;
END;
/

--End Version [Script Version - 0.0.177] [ReleaseVersion - 9.2.2.2]--[08-07-2015] -- by Sathiya

--Start Version [Script Version - 0.0.178] [ReleaseVersion - 9.2.2.2]--[10-07-2015] -- by Chithra

Insert into SCREEN_MASTER   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,     MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,     RECORD_KEY_COL, SCREEN_DESC)
 Values   ('SCR12232', '12232', 'PF interest Application', 'APP01', 'DONE',     '41', '', 17, 'CREATED', NULL,     NULL, 'PF interest Application'); 
 
Insert into GROUP_SCREENS    (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP01014', 'SCR12232', 'CREATED', 'Y', 'Y',     'Y', 'Y', 'Y', 'Y', NULL);
    
Insert into GROUP_SCREENS   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP00001', 'SCR12232', 'CREATED', 'Y', 'Y',     'Y', 'N', 'N', 'Y', 'N');
    
Insert into GROUP_SCREENS   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP00002', 'SCR12232', 'CREATED', 'Y', 'Y',     'Y', 'Y', 'Y', 'Y', 'N');
    
Insert into GROUP_SCREENS   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP00003', 'SCR12232', 'CREATED', 'Y', 'Y',     'Y', 'Y', 'Y', 'Y', 'N');
    
COMMIT;

ALTER TABLE PAY_PF_MASTER ADD (LAST_INT_CALC_DT DATE);

CREATE OR REPLACE function get_pfinterest(Fromdate Date,toDate Date,EmpId varchar,payCode varchar,roi number) return number is
--Declare
--Fromdate Date := '01-apr-2014';
--ToDate Date  := '31-mar-2015';
--EmpId varchar2(10) := 'E08';
--paydesc varchar2(100) := 'PROVIDENT FUND';
--ROI NUMBER(12,2) := 8.0;
Begin
Declare cursor A is
SELECT SUM(DECODE(TRANS_TYPE,'CREDIT',1,-1)* AMOUNT) AS AMOUNT,TO_DATE(Fromdate) AS MONTH_YEAR  FROM PAYROLL P
 WHERE P.EMPLOYEEID = EmpId AND P.PAY_CODE = payCode 
 AND P.MONTH_YEAR
  <=(sELECT MAX(P1.MONTH_YEAR) FROM PAYROLL P1 WHERE P1.MONTH_YEAR <=Fromdate AND
   P1.EMPLOYEEID = EmpId AND P1.PAY_CODE = payCode)   
 UNION 
 SELECT  SUM(DECODE(TRANS_TYPE,'CREDIT',1,-1)*
 AMOUNT) AS AMOUNT,P2.MONTH_YEAR AS MONTH_YEAR FROM PAYROLL P2
 WHERE P2.PAY_CODE = payCode AND P2.EMPLOYEEID = EmpId AND P2.MONTH_YEAR BETWEEN
 TO_DATE(Fromdate)+1 AND ToDate
 GROUP BY MONTH_YEAR
 UNION 
 SELECT 0 AS AMOUNT,TO_DATE(ToDate)+1 AS MONTH_YEAR FROM DUAL
  ORDER BY MONTH_YEAR;
INTEREST NUMBER(12,2) :=0;
DATEDIFF NUMBER(12) := 0;
fDate Date := Fromdate;
TEMP_AMT  NUMBER(12,2) := 0;
BEGIN 
FOR I IN A LOOP
DATEDIFF := i.month_year - fdate;
INTEREST := interest + ((TEMP_AMT * DATEDIFF * ROI)/36500);
TEMP_AMT :=TEMP_AMT+i.amount;
fDate := i.month_year;   
--dbms_output.put_line('DATEDIFF    ='||DATEDIFF||' '||'amount ='||i.amount||'  '||'interest =   '||
--interest ||'TEMP_AMT ' || TEMP_AMT );
END LOOP;
return INTEREST;
END;
End;
/

CREATE OR REPLACE FUNCTION  GET_FUTURE_SERVICE(CUSTID VARCHAR) RETURN VARCHAR IS
DT_OFBIRTH DATE;
DT_OFJOIN DATE;
RETIREAGE NUMBER(3);
RETIREDATE DATE;
FUTURE_SERVICE VARCHAR2(30);
YRS NUMBER(10);
MNTHS NUMBER(10);
DYS NUMBER(10);
CURRDATE DATE ;
BEGIN
SELECT C.DOB,C.JOINING_DATE INTO DT_OFBIRTH,DT_OFJOIN  FROM CUSTOMER  C WHERE  C.CUST_ID = CUSTID;

SELECT DE.CURR_APPL_DT INTO CURRDATE FROM DAY_END DE WHERE DE.BRANCH_CODE = '0001'; 

SELECT P.RETIREMENT_AGE INTO RETIREAGE  FROM PARAMETERS P;

SELECT GET_RETIRE_DATE(CUSTID) INTO RETIREDATE FROM DUAL;

SELECT TRUNC(MONTHS_BETWEEN(RETIREDATE, CURRDATE) / 12),
TRUNC(MOD(MONTHS_BETWEEN(RETIREDATE, CURRDATE), 12)),
TRUNC(RETIREDATE - ADD_MONTHS(CURRDATE, TRUNC(MONTHS_BETWEEN(RETIREDATE, CURRDATE)))) INTO YRS,MNTHS,DYS FROM dual;

 IF YRS IS NULL THEN
  YRS := 0;
 END IF;
 IF MNTHS IS NULL THEN
 MNTHS := 0;
 END IF;
 IF DYS IS NULL  THEN 
 DYS := 0;
 END IF;
 FUTURE_SERVICE := TO_CHAR(YRS)||'Years'||'  '||TO_CHAR(MNTHS)||'Months'||'  '||TO_CHAR(DYS)||'Days';
 RETURN FUTURE_SERVICE;  
END;
/
--End Version [Script Version - 0.0.178] [ReleaseVersion - 9.2.2.2]--[10-07-2015] -- by Chithra

--Start Version [Script Version - 0.0.179] [ReleaseVersion - 9.2.2.2]--[15-07-2015] -- by Sreekrishnan
alter table LOANS_PROD_SUBSIDY_REBATE  add(REBATE_CALC_PERIOD NUMBER(16,2));
--End Version [Script Version - 0.0.179] [ReleaseVersion - 9.2.2.2]--[15-07-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.180] [ReleaseVersion - 9.2.2.2]--[16-07-2015] -- by Chithra
ALTER TABLE DIRECTOR_BOARD ADD (SELECTION_DT DATE);
ALTER TABLE DIRECTOR_BOARD ADD (ACCT_HD VARCHAR2(30 BYTE));
--End Version [Script Version - 0.0.180] [ReleaseVersion - 9.2.2.2]--[16-07-2015] -- by Chithra

--Start Version [Script Version - 0.0.181] [ReleaseVersion - 9.2.2.2]--[06-08-2015] -- by Rishad
--created by rajesh,modified by rishad
CREATE OR REPLACE function addmonths(deposit_dt date, pass_dt date, noofmonths number) return date is
    temp_dt date;
begin
        temp_dt:=add_months(pass_dt,noofmonths);
        if  to_number(to_char(deposit_dt,'dd'))>to_number(to_char(last_day(temp_dt),'dd')) then
            temp_dt:=last_day(temp_dt);
        else
            temp_dt:=to_date(to_char(deposit_dt,'dd')||'-'||to_char(temp_dt,'mm')||to_char(temp_dt,'yyyy'), 'dd-mm-yyyy');
        end if;
--        dbms_output.put_line('inside else:'||deposit_dt||' / temp_dt'||temp_dt);
    return temp_dt;
end;
/
--End Version [Script Version - 0.0.181] [ReleaseVersion - 9.2.2.2]--[06-08-2015] -- by rishad

--Start Version [Script Version - 0.0.182] [ReleaseVersion - 9.2.2.2]--[07-08-2015] -- by Sreekrishan

    SET DEFINE OFF;
    Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
    Values
   ('SCR08999', '6139', 'Pension Scheme', 'APP01', 'DONE', 
    '15', NULL, 55, 'CREATED', NULL, 
    NULL, 'Head Consolidation');
    COMMIT;

    CALL INSERT_REPORT_GROUP('SCR08999');


    CREATE TABLE SHARE_PENSON_TRANS
    (
      SHARE_ACCT_NO      VARCHAR2(16 BYTE),
      TRANS_AMOUNT       NUMBER(16,2),
      SHARE_RUN_PERIOD   NUMBER(16,2),
      CUST_AGE           NUMBER(16,2),
      TRANS_DT           DATE,
      TRANS_ID           VARCHAR2(16 BYTE),
      TRANS_TYPE         VARCHAR2(16 BYTE),
      STATUS             VARCHAR2(16 BYTE),
      STATUS_BY          VARCHAR2(16 BYTE),
      STATUS_DT          DATE,
      AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
      AUTHORIZED_BY      VARCHAR2(16 BYTE),
      AUTHORIZED_DT      DATE,
      BRANCH_CODE        VARCHAR2(16 BYTE)
    )

    ALTER TABLE SHARE_CONF_DETAILS ADD PENSION_SCHEME_AGE NUMBER (16,2);
    ALTER TABLE SHARE_CONF_DETAILS ADD PENSION_SCHEME_DURATION  NUMBER (16,2);
    ALTER TABLE SHARE_CONF_DETAILS ADD MIN_PENSION NUMBER (16,2);
    ALTER TABLE SHARE_CONF_DETAILS ADD PENSION_AC_HD VARCHAR2 (13 Byte);
    ALTER TABLE SHARE_CONF_DETAILS ADD PENSION_PROD_TYPE VARCHAR2 (3 Byte);
    ALTER TABLE SHARE_CONF_DETAILS ADD PENSION_PROD_ID VARCHAR2 (3 Byte); 
    ALTER TABLE SHARE_CONF_DETAILS ADD PENSION_START_DT DATE; 


    ALTER TABLE GROUP_LOAN_PRODUCT ADD DAILY_COLLECTION VARCHAR2 (3 Byte);

    CREATE OR REPLACE FUNCTION GET_CUST_NAME_FROM_SHARE(SHARENO IN VARCHAR2) RETURN VARCHAR2 IS
        CUSTNAME VARCHAR2(100);
        BEGIN
        SELECT 
        CASE WHEN  CUST_TYPE='INDIVIDUAL' THEN 
        FNAME||' '||MNAME||' '||LNAME
        ELSE
            COMP_NAME 
        END INTO CUSTNAME
        FROM CUSTOMER
        WHERE MEMBERSHIP_NO = SHARENO AND STATUS !='DELETED';
        RETURN CUSTNAME;
        END;
    /
--End Version [Script Version - 0.0.182] [ReleaseVersion - 9.2.2.2]--[07-08-2015] -- by Sreekrishan

--Start Version [Script Version - 0.0.183] [ReleaseVersion - 9.2.2.2]--[7-08-2015] -- by Chithra
Insert into SCREEN_MASTER   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,     MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,     RECORD_KEY_COL, SCREEN_DESC)
 Values   ('SCR12233', '12233', 'Leave Surrender', 'APP01', 'DONE',     '41', '', 17, 'CREATED', NULL,     NULL, 'Leave Surrender'); 
 
Insert into GROUP_SCREENS    (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP01014', 'SCR12233', 'CREATED', 'Y', 'Y',     'Y', 'Y', 'Y', 'Y', NULL);
    
Insert into GROUP_SCREENS   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP00001', 'SCR12233', 'CREATED', 'Y', 'Y',     'Y', 'N', 'N', 'Y', 'N');
    
Insert into GROUP_SCREENS   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP00002', 'SCR12233', 'CREATED', 'Y', 'Y',     'Y', 'Y', 'Y', 'Y', 'N');
    
Insert into GROUP_SCREENS   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED,     DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values   ('GRP00003', 'SCR12233', 'CREATED', 'Y', 'Y',     'Y', 'Y', 'Y', 'Y', 'N');
    
COMMIT;

INSERT INTO ID_GENERATION VALUES('LEAVE_SURRENDER_ID','1','LSI','28 JUL 2015','8','0001');

INSERT INTO ID_GENERATION VALUES('Directory_ID','1','DR','28 JUL 2015','8','0001');

INSERT INTO ID_GENERATION VALUES('BOARD_MT_ID','1','DI','28 JUL 2015','8','0001');

ALTER TABLE  IMBP_SETTINGS ADD (status VARCHAR2(30 BYTE));


CREATE TABLE LEAVE_SURRENDER_DETAILS
(
  LEAVE_SURRENDER_ID  VARCHAR2(30)               NOT NULL,
  EMP_ID           VARCHAR2(30)    NOT NULL,
  LEAVE_NO        NUMBER(10,8)               NOT NULL,
  AMOUNT     NUMBER(10,8)               NOT NULL,
  BRANCH_ID          VARCHAR2(30),
  CREATED_DT         DATE,
  CREATED_BY         VARCHAR2(50),
  STATUS             VARCHAR2(30),
  STATUS_BY          VARCHAR2(50),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(30),
  AUTHORIZED_BY      VARCHAR2(50),
  AUTHORIZED_DATE    DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
NOMONITORING;
--End Version [Script Version - 0.0.183] [ReleaseVersion - 9.2.2.2]--[7-08-2015] -- by Chithra

--Start Version [Script Version - 0.0.184] [ReleaseVersion - 9.2.2.3]--[18-08-2015] -- by Chithra
CREATE OR REPLACE function get_pfinterest(Fromdate Date,toDate Date,EmpId varchar,payCode varchar,roi number) return number is
--Declare
--Fromdate Date := '01-apr-2014';
--ToDate Date  := '31-mar-2015';
--EmpId varchar2(10) := 'E08';
--paydesc varchar2(100) := 'PROVIDENT FUND';
--ROI NUMBER(12,2) := 8.0;
--payCode  varchar2(10) := 'PF';
Begin
Declare cursor A is
SELECT SUM(DECODE(TRANS_TYPE,'CREDIT',1,-1)* AMOUNT) AS AMOUNT,TO_DATE(Fromdate) AS TRAN_DT 
 FROM PAY_PF_TRANS P,PAY_PF_MASTER PM
 WHERE  PM.EMP_ID =EmpId AND PM.PF_ACT_NO = P.PF_NO
 AND P.TRAN_DT
  <=(SELECT MAX(P1.TRAN_DT) FROM PAY_PF_TRANS P1,PAY_PF_MASTER PM1 WHERE P1.TRAN_DT <=Fromdate AND
   P1.PF_NO = PM1.PF_ACT_NO AND PM1.EMP_ID =EmpId  )   
 UNION 
 SELECT  SUM(DECODE(TRANS_TYPE,'CREDIT',1,-1)*
 AMOUNT) AS AMOUNT,P2.TRAN_DT AS TRAN_DT FROM PAY_PF_TRANS P2,PAY_PF_MASTER PM2
 WHERE PM2.PF_ACT_NO = P2.PF_NO AND  PM2.EMP_ID =EmpId AND P2.TRAN_DT BETWEEN
 TO_DATE(Fromdate)+1 AND ToDate
 GROUP BY TRAN_DT
 UNION 
 SELECT 0 AS AMOUNT,TO_DATE(ToDate)+1 AS TRAN_DT FROM DUAL
  ORDER BY TRAN_DT;
INTEREST NUMBER(12,2) :=0;
DATEDIFF NUMBER(12) := 0;
fDate Date := Fromdate;
TEMP_AMT  NUMBER(12,2) := 0;
BEGIN 
FOR I IN A LOOP
DATEDIFF := i.TRAN_DT - fdate;
INTEREST := interest + ((TEMP_AMT * DATEDIFF * ROI)/36500);
TEMP_AMT :=TEMP_AMT+i.amount;
fDate := i.TRAN_DT;   
dbms_output.put_line('DATEDIFF    ='||DATEDIFF||' '||'amount ='||i.amount||'  '||'interest =   '|| INTEREST ||'TEMP_AMT ' || TEMP_AMT );
END LOOP;
return INTEREST;
END;
End;
/


ALTER TABLE LOCKER_SURRENDER ADD (RENEW_BF_EXPDT VARCHAR2(5 BYTE) DEFAULT 'N');

ALTER TABLE DEPOSITS_PROD_RD ADD (IRREGULAR_SB_PRODUCT VARCHAR2(30 BYTE));

update LOOKUP_MASTER set LOOKUP_DESC='Quarterly' where  LOOKUP_DESC='Quaterly' and LOOKUP_ID ='DEPOSITSPRODUCT.DEPOSITPERIOD';

ALTER TABLE CUST_ADDR ADD (POSTOFFICE VARCHAR2(150 BYTE));

update SCREEN_MASTER set SCREEN_NAME='Active Member List' where SCREEN_NAME='Active_MemberList';

ALTER TABLE Active_MemberList RENAME TO Active_Member_List;

CREATE OR REPLACE FUNCTION GET_ADV_CRDR_INTEREST(ACTNUM VARCHAR, FROMDT DATE,TODT DATE) RETURN VARCHAR IS
/* For modifications in this function check notes and compare with GET_ADV_CRDR_INTEREST_ORIGINAL */
    --DECLARE
    --ACTNUM VARCHAR2(13) := '0001307000622';
    --FROMDT DATE := '01-JAN-2015';
    --TODT DATE := '31-JAN-2015';
    RATEOFINT NUMBER(16,2);
    INTGET VARCHAR2(10);
    CATG VARCHAR2(30);
    STARTDAT DATE;
    ENDDT DATE;
    LIMT NUMBER(16);
    PRODID NUMBER(10);
    DRINTRATE NUMBER(16,2);
    CRINTRATE NUMBER(16,2);
    BEGIN
         SELECT LFD.PROD_ID, LFD.INT_GET_FROM,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT INTO PRODID,INTGET,CATG,STARTDAT,ENDDT,LIMT FROM LOANS_FACILITY_DETAILS LFD
         JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
         JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
         WHERE LFD.ACCT_NUM = ACTNUM;
         IF INTGET = 'ACT' THEN
         SELECT NVL(LIM.INTEREST,0) INTO RATEOFINT FROM LOANS_INT_MAINTENANCE LIM WHERE LIM.ACCT_NUM = ACTNUM;
         ELSE
         SELECT GET_TL_ROI_DRINT(PRODID,CATG,STARTDAT,ENDDT,LIMT)  INTO DRINTRATE FROM DUAL;
         SELECT GET_TL_ROI_CRINT(PRODID,CATG,STARTDAT,ENDDT,LIMT)  INTO CRINTRATE FROM DUAL;
         END IF;
    BEGIN
    DECLARE CURSOR A IS
    SELECT prod_id, act_num, TO_DATE (FROMDT) AS day_end_dt,
      case when  (SELECT MIN (k.day_end_dt)
          FROM advances_dayend_balance k
         WHERE k.act_num = a.act_num
           AND k.day_end_dt > FROMDT
           AND k.day_end_dt <= TODT) is null then TO_DATE ( TODT) else (SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = a.act_num
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT) end AS next_dt,
        (SELECT NVL (amt, 0)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt IN (
        SELECT MAX (c.day_end_dt)
        FROM advances_dayend_balance c
        WHERE c.act_num = k.act_num
        AND c.day_end_dt <= FROMDT)) AS amt,
        case when (SELECT NVL (amt, 0)
        FROM advances_dayend_balance g
        WHERE g.act_num = ACTNUM
        AND g.day_end_dt IN (
        SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT)) is null then amt else (SELECT NVL (amt, 0)
        FROM advances_dayend_balance g
        WHERE g.act_num = ACTNUM
        AND g.day_end_dt IN (
        SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT)) end  AS next_amt   
        FROM advances_dayend_balance a
        WHERE a.act_num = ACTNUM
        AND a.day_end_dt IN (SELECT MAX (c.day_end_dt)
        FROM advances_dayend_balance c
        WHERE c.act_num = a.act_num AND c.day_end_dt <= FROMDT)
        UNION 
        SELECT a.prod_id, a.act_num, a.day_end_dt, a.next_dt, a.amt,
        b.amt AS next_amt
        FROM (SELECT prod_id, act_num, day_end_dt,
        NVL ((SELECT MIN (day_end_dt)
        FROM advances_dayend_balance b
        WHERE b.day_end_dt > a.day_end_dt AND act_num =ACTNUM),
        TODT  /* Changed day_end_dt to parameter "TODT" so that union will remove that record. */
        ) AS next_dt,
        amt
        FROM advances_dayend_balance a
        WHERE act_num = ACTNUM AND day_end_dt BETWEEN FROMDT AND TODT) a,
        (SELECT *
        FROM advances_dayend_balance) b
        WHERE a.prod_id = b.prod_id
        AND a.act_num = b.act_num
        AND b.day_end_dt = a.next_dt
        union
        SELECT a.prod_id, a.act_num, (select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)  day_end_dt, 
        to_date(TODT) next_dt, (SELECT amt FROM advances_dayend_balance where act_num =ACTNUM and 
        day_end_dt=(select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)) amt,
        (SELECT amt FROM advances_dayend_balance where act_num =ACTNUM and 
        day_end_dt=(select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)) next_amt /* Changed next_amt to last balance instead of zero */
        FROM advances_dayend_balance a where A.ACT_NUM =ACTNUM AND day_end_dt BETWEEN FROMDT AND TODT        
        ORDER BY  day_end_dt  ;
    DATEDIFF NUMBER(10);
    FIRSTDATE DATE;
    NEXTDATE DATE;
    FLAG INTEGER := 0;
    CREDITINTEREST NUMBER(16,2) := 0;
    DEBITINTEREST NUMBER(16,2) := 0;
    INTEREST VARCHAR2(50);
    BEGIN
         FOR I IN A LOOP
         SELECT NVL(TRUNC(TO_DATE(I.NEXT_DT,'DD-MM-YYYY')- TO_DATE(I.DAY_END_DT,'DD-MM-YYYY')),0) INTO DATEDIFF FROM DUAL;
         FIRSTDATE := I.DAY_END_DT; 
         --DBMS_OUTPUT.PUT_LINE('DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT);
         IF I.AMT > 0 THEN
         IF INTGET = 'ACT' THEN 
         CREDITINTEREST := CREDITINTEREST + (I.AMT *  DATEDIFF * RATEOFINT) /36500;
         ELSE
         CREDITINTEREST := CREDITINTEREST + (I.AMT *  DATEDIFF * CRINTRATE ) /36500;
         END IF;
         --DBMS_OUTPUT.PUT_LINE('RATEOFINT  ='||RATEOFINT|| 'DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT||'CREDITINTEREST = '||CREDITINTEREST  );
         ELSE
         IF INTGET = 'ACT' THEN
         DEBITINTEREST := DEBITINTEREST + (I.AMT * DATEDIFF * RATEOFINT) /36500;
         ELSE
         DEBITINTEREST := DEBITINTEREST + (I.AMT * DATEDIFF * DRINTRATE) /36500;
         END IF;
         --DBMS_OUTPUT.PUT_LINE('RATEOFINT  ='||RATEOFINT||'DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT||'DEBITINTEREST = '||DEBITINTEREST  );  
         END IF;
         INTEREST := 'DEBITINTEREST = '||DEBITINTEREST||':'||'CREDITINTEREST =  '||CREDITINTEREST;
         END LOOP;
         --DBMS_OUTPUT.PUT_LINE('DEBITINTEREST = '||DEBITINTEREST||' : '||'CREDITINTEREST =  '||CREDITINTEREST);
         RETURN INTEREST;
         END;
    END;
    END;
/

Insert into LOOKUP_MASTER (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED) Values  ('POSTOFFICE', '680022', 'Patturaikkal', 'CREATED', 'Y',  'Y');
--End Version [Script Version - 0.0.184] [ReleaseVersion - 9.2.2.3]--[18-08-2015] -- by Chithra

--Start Version [Script Version - 0.0.185] [ReleaseVersion - 9.2.2.3]--[04-09-2015] -- by Rishad
alter table DEPOSIT_SUB_ACINFO add INT_DIFFERENCE number(20) default 0
--End Version [Script Version - 0.0.185] [ReleaseVersion - 9.2.2.3]--[04-09-2015] -- by Rishad

--Start Version [Script Version - 0.0.186] [ReleaseVersion - 9.2.2.3]--[07-09-2015] -- by Chithra

DROP TABLE ACTIVE_MEMBERLIST CASCADE CONSTRAINTS;

CREATE TABLE ACTIVE_MEMBERLIST
(
  SHARE_ACC_NUM  VARCHAR2(60 BYTE),
  NAME           VARCHAR2(60 BYTE),
  AVAL_BALANCE   NUMBER(16,2),
  STATUS         VARCHAR2(60 BYTE),
  STATUS_BY      VARCHAR2(60 BYTE),
  CREATED_DATE   DATE,
  CREATED_BY     VARCHAR2(60 BYTE)
)
TABLESPACE CBMSDATA
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING
NOCOMPRESS
NOCACHE
NOPARALLEL
MONITORING;
--End Version [Script Version - 0.0.186] [ReleaseVersion - 9.2.2.3]--[07-09-2015] -- by Chithra

--Start Version [Script Version - 0.0.187] [ReleaseVersion - 9.2.2.3]--[08-09-2015] -- by Sreekrishnan
ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD (AUCTION_TRANS VARCHAR2(1 BYTE) DEFAULT 'N');
--End Version [Script Version - 0.0.187] [ReleaseVersion - 9.2.2.3]--[08-09-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.188] [ReleaseVersion - 9.2.2.3]--[09-09-2015] -- by Chithra (FOR TELK)
CREATE OR REPLACE FUNCTION GET_TL_STATUS(ACTNUM VARCHAR,ASONDT DATE) RETURN VARCHAR IS
--DECLARE
--ACTNUM VARCHAR2(13) := '0001305000909';
--ASONDT DATE := '30-JUN-2015';
RECEIVABLE NUMBER(12,2);
RECD NUMBER(12,2);
LOAN_STATUS VARCHAR2(100);
INST_TYPE VARCHAR2(100);
EMITYPE VARCHAR2(1);
REPAYDT DATE;
BEHAVES VARCHAR2(20);
BEGIN
       SELECT  LP.BEHAVES_LIKE INTO BEHAVES  FROM  LOANS_PRODUCT LP WHERE LP.PROD_ID = SUBSTR(ACTNUM,5,3) ;
       
      IF BEHAVES = 'OD' THEN
      INST_TYPE := 'LUMP_SUM';
      ELSE
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED';
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
      END IF;
IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'Y' THEN
            BEGIN
            SELECT NVL (SUM (LIM.TOTAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECBLE');
            END ;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0) + NVL(LTD.INTEREST,0) )  INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE  LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECD ');
            END;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'  '||RECD);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE);
            IF RECEIVABLE <= 0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE
    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'N' THEN
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECBLE UNIFORM PRINCIPLE');
            END;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE   LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECD UNIFORM PRINCIPLE');
            END;
            RECEIVABLE := RECEIVABLE -  RECD;
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('UNIFORM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE 
   IF INST_TYPE = 'LUMP_SUM' OR INST_TYPE = 'EYI' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA');
            END;
            --DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM 
            AND LTD.TRANS_TYPE = 'CREDIT' AND  LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            RECEIVABLE := RECEIVABLE -  RECD; 
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF; 
            --DBMS_OUTPUT.PUT_LINE('LUMPSUM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
    ELSE
     IF INST_TYPE = 'LUMP_SUM' AND BEHAVES = 'OD' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA');
            END;
            /*BEGIN
            /*SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ; 
            END; */ 
            DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            
            IF REPAYDT < ASONDT THEN
            RECEIVABLE := GET_ADV_BALANCE(ACTNUM,ASONDT);
            ELSE 
            RECEIVABLE := 0;
            END IF; 
            
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            
            SELECT SUM (NVL (LTD.PRINCIPLE , 0)) INTO RECD
            FROM ADV_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM
            AND LTD.TRANS_TYPE = 'CREDIT' AND  LTD.TRANS_DT <= ASONDT;
            
            
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            RECEIVABLE := RECEIVABLE -  RECD; 
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF; 
     
     
     
     END IF; 
    
    END IF;
    
    
   END IF;
END IF;
RETURN LOAN_STATUS;
END;
/

CREATE OR REPLACE function GET_RecoveryTL(ACTNUM varchar2,ASONDT date,Recoverytype varchar) Return varchar is
--DECLARE 
--ACTNUM VARCHAR2(13) := '0001305001125';
--ASONDT DATE := '08-SEP-2015';
--Recoverytype varchar2(100) := 'Direct';
RecoveryDetails varchar2(500);
INST_TYPE VARCHAR2(50);
EMITYPE VARCHAR2(1);
RECEIVABLE NUMBER(16,2);
FROMDT DATE;
TODT DATE;
CATG VARCHAR2(50);
LIMITR NUMBER(16,2);
PRODID VARCHAR2(10);
INTRECBLE NUMBER(16,2);
LASTTRANSDT DATE;
PRINCBAL NUMBER(16,2);
PRINCPAYABLE NUMBER(16,2);
INSTAMT NUMBER(16,2);
TransMethod Varchar2(100);
INTGETFROM VARCHAR2(10);
LOAN_STATUS VARCHAR2(100);
PENALINTRATE NUMBER(12,2);
PENALRECBLE NUMBER(12,2);
monthopdate date;
LOANSTATUS VARCHAR2(15);
LI_COUNT NUMBER;
REMITTEDSTATUS VARCHAR2(50);
FULLRECOVERED NUMBER;
RECOVERYDATE DATE;
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        where LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
        SELECT LSD.FROM_DT,LSD.TO_DT,LB.CATEGORY,LSD.LIMIT,LFD.PROD_ID,LFD.INT_GET_FROM INTO FROMDT,TODT,CATG,LIMITR,PRODID,INTGETFROM 
        FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
        WHERE LFD.BORROW_NO = LSD.BORROW_NO
        AND LSD.BORROW_NO = LB.BORROW_NO
        AND LFD.ACCT_NUM = ACTNUM;
        TRANSMETHOD  := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        
        DBMS_OUTPUT.PUT_LINE(TRANSMETHOD);
        SELECT LAST_DAY(ADD_MONTHS(ASONDT,-1)) + 1 INTO MONTHOPDATE FROM DUAL;
        
        SELECT  COUNT(*) INTO LI_COUNT FROM ALL_TRANS ATA WHERE ATA.TRANS_DT >= MONTHOPDATE
        AND  ATA.TRANS_DT <= ASONDT AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED' AND ATA.LINK_BATCH_ID = ACTNUM ;
        LOANSTATUS := GET_TL_STATUS(ACTNUM,ASONDT);
        IF LOANSTATUS = 'ADVANCE'  AND LI_COUNT > 0 THEN
        REMITTEDSTATUS := 'PAID';
        ELSE
        IF TRANSMETHOD = 'Salary Recovery' THEN
        SELECT LAST_DAY(ADD_MONTHS(ASONDT,-1)) INTO RECOVERYDATE FROM DUAL;
        SELECT COUNT(*) INTO FULLRECOVERED FROM SALARY_RECOVERY_LIST_DETAIL SR WHERE SR.INT_CALC_UPTO_DT = RECOVERYDATE AND
        SR.TOTAL_DEMAND != NVL(SR.REC_PRINCIPAL,0) + NVL(SR.REC_PENAL,0) + NVL(SR.REC_INTEREST,0) + NVL(SR.REC_CHARGES,0)
        AND SR.ACT_NUM = ACTNUM;
        
        DBMS_OUTPUT.PUT_LINE(FULLRECOVERED);
        
            IF FULLRECOVERED > 0 THEN
            REMITTEDSTATUS := 'NOT PAID';
            ELSE
            REMITTEDSTATUS := 'PAID';
            END IF;
        ELSE
        REMITTEDSTATUS := 'NOT PAID';
        END IF;
        END IF;
        TRANSMETHOD  := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        RECEIVABLE   := GET_TL_RECBLE_RECOVERY(ACTNUM,ASONDT);
        LOAN_STATUS  := GET_TL_STATUS_RECOVERY(ACTNUM,ASONDT);
        PENALINTRATE := GET_TL_PENROI(PRODID,CATG,ACTNUM,FROMDT,TODT,LIMITR,INTGETFROM);
        PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
        INSTAMT :=  GET_TL_INSTAMT(ACTNUM);
        INTRECBLE := GET_TL_INTERESTRECBLE_recovery(ACTNUM,ASONDT,Recoverytype);
        Penalrecble := GET_TL_PENINTEREST(ACTNUM,FROMDT,ASONDT,PENALINTRATE);
        PRINCPAYABLE   := GET_TL_PRINCRECBLE(ACTNUM,ASONDT,Recoverytype);
RecoveryDetails := 'ACTNUM='||actnum||':'||'LOAN_STATUS='||LOAN_STATUS||':'||'Transmethod='||Transmethod||':'||'INSTAMT ='||INSTAMT||':'||'PRINCPAYABLE='||PRINCPAYABLE||':'||'intrecble='||intrecble||':'||'Penalrecble='||Penalrecble||':'||'REMITTEDSTATUS='||REMITTEDSTATUS||':';
--dbms_output.put_line(RecoveryDetails) ;
Return RecoveryDetails;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_PRINCRECBLE(ACTNUM VARCHAR, ASONDT DATE,RECOVERYTYPE VARCHAR) RETURN NUMBER IS
--DECLARE 
--ACTNUM VARCHAR2(13) := '0001304001395';
--ASONDT DATE := '08-sep-2015';
--RECOVERYTYPE VARCHAR2(100) := 'Direct';
LASTINTDATE DATE;
PENDINGPRINCIPLE NUMBER(12,2);
PENDINGINTEREST NUMBER(12,2);
PENDNGPENAL NUMBER(12,2);
LASTRECOVERYDATE DATE;
PRINCPAYABLE NUMBER(12,2);
INST_TYPE VARCHAR2(50);
EMITYPE VARCHAR2(100);
RECEIVABLE NUMBER(12,2);
TRANSMETHOD VARCHAR2(100);
INTRECBLE NUMBER(12,2);
INSTCOUNT NUMBER(10);
INSTAMT NUMBER(12,2);
NOOFINST NUMBER(12,2);
PRINCBAL NUMBER(12,2);
REPAYDT DATE;
LASTTRANSDT DATE;
RECOVERYFLAG VARCHAR2(100);
INSTAMTRECD NUMBER(12,2);
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL(LRS.EMI_IN_SIMPLEINTREST,'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        TRANSMETHOD := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        RECEIVABLE   := GET_TL_RECBLE_RECOVERY(ACTNUM,ASONDT);
        INTRECBLE := GET_TL_INTERESTRECBLE_RECOVERY(ACTNUM,ASONDT,RECOVERYTYPE);
        PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
        INSTAMT :=  GET_TL_INSTAMT(ACTNUM);
        DBMS_OUTPUT.PUT_LINE(INST_TYPE||'   '||EMITYPE||'   RECEIVABLE  ='||RECEIVABLE||'   PRINCBAL='||PRINCBAL||'   INSTAMT='||INSTAMT);        
        BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
        EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN LSD');
        END;
        --DBMS_OUTPUT.PUT_LINE('INST_TYPE  ='||INST_TYPE||'EMITYPE    '||EMITYPE||'REPAYDT   '||REPAYDT||'  '||'RECEIVABLE ='||RECEIVABLE);
        
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';           
        SELECT ADD_MONTHS(LAST_DAY(ASONDT),-1) INTO LASTRECOVERYDATE FROM DUAL;           
        BEGIN
        SELECT MAX(SRLD.INT_CALC_UPTO_DT) INTO LASTINTDATE  FROM SALARY_RECOVERY_LIST_DETAIL SRLD,DAY_END DE 
        WHERE SRLD.STATUS = 'CREATED' AND SRLD.ACT_NUM = ACTNUM AND SRLD.INT_CALC_UPTO_DT <= ASONDT;
        EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('NO DATA IN SRLD');
        END;
        BEGIN                               
        SELECT NVL(PRINCIPAL,0) - NVL(REC_PRINCIPAL,0),NVL(INTEREST,0)-NVL(REC_INTEREST,0) ,NVL(PENAL,0)-NVL(REC_PENAL,0) INTO
        PENDINGPRINCIPLE ,PENDINGINTEREST,PENDNGPENAL FROM SALARY_RECOVERY_LIST_DETAIL SRLD
        WHERE SRLD.ACT_NUM = ACTNUM
        AND SRLD.INT_CALC_UPTO_DT = LASTINTDATE;
        EXCEPTION WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('NO DATA IN SRLD PENDING');
        END ;
        
            IF RECEIVABLE <= 0 THEN
               if REPAYDT < ASONDT THEN
                   IF PRINCBAL < INSTAMT THEN
                         RECEIVABLE := PRINCBAL;
                   ELSE
                         RECEIVABLE := INSTAMT;
                   END IF;
               END IF;
            END IF; 
            
            DBMS_OUTPUT.PUT_LINE('LASTRECOVERYDATE   '||LASTRECOVERYDATE||'   '||'RECEIVABLE actual    ='||RECEIVABLE);
            
          /* FORMATTED ON 2015/07/02 14:26 (FORMATTER PLUS V4.8.8) */
            IF RECOVERYTYPE = 'Direct' then
            BEGIN
            SELECT  CASE WHEN LRS.INSTALL_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  LRS.EMI_IN_SIMPLEINTREST = 'Y' THEN
            SUM(LTD.PRINCIPLE  + LTD.INTEREST)
            ELSE
            SUM(NVL(LTD.PRINCIPLE,0)) END INTO INSTAMTRECD            
            FROM LOAN_TRANS_DETAILS LTD,LOANS_REPAY_SCHEDULE LRS WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT > LASTRECOVERYDATE
            AND LTD.TRANS_DT <= ASONDT AND LTD.TRANS_TYPE = 'CREDIT'
            AND LRS.ACCT_NUM = LTD.ACT_NUM
            GROUP BY LRS.INSTALL_TYPE,LRS.EMI_IN_SIMPLEINTREST;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN ALL_TRANS DURING THIS MONTH');
            END;
            RECEIVABLE := nvl(RECEIVABLE,0) - nvl(INSTAMTRECD,0);                  
            END IF;
            DBMS_OUTPUT.PUT_LINE('PRINCRECD  ='||INSTAMTRECD||'  '||'RECEIVABLE    ='||RECEIVABLE);
        
         /* CONDITION 1*/
                                       
        /*RECOVERY A/CS THEN*/       
           IF PENDNGPENAL = 0 AND PENDINGINTEREST = 0 AND PENDINGPRINCIPLE = 0 THEN
            RECOVERYFLAG := 'RecoveryCompleted';
           ELSE
            RECOVERYFLAG := 'RecoveryPartial';
           END IF;           
        /*CHECK LAST TRANSACTION OF A/C  */   
           IF LASTTRANSDT > LASTRECOVERYDATE THEN
                IF RECEIVABLE <= 0 THEN 
                    RECOVERYFLAG := 'RecoveryCompleted';
                    RECEIVABLE := 0;
                ELSE
                    RECOVERYFLAG := 'RecoveryPartial';
                END IF;
           END IF;           
    /*  HERE CONSIDER THE RECEIVABLE */
    
    
    
    DBMS_OUTPUT.PUT_LINE('RECOVERYFLAG   ='||RECOVERYFLAG);
    
    /* CONDITION 2*/
           IF RECOVERYTYPE = 'Recovery' THEN
              IF RECEIVABLE < 0  THEN
                 IF PRINCBAL < INSTAMT THEN
                     RECEIVABLE := PRINCBAL;
                 ELSE
                     RECEIVABLE := INSTAMT;
                 END IF;
              END IF;
           ELSE
               IF RECEIVABLE < 0   THEN
                  IF RECOVERYFLAG = 'RecoveryCompleted' THEN
                     RECEIVABLE := 0;
                      DBMS_OUTPUT.PUT_LINE(' condition 2 Direct Completed   ='||PRINCBAL);
                  ELSE
                      IF LASTTRANSDT >LASTRECOVERYDATE THEN
                         IF PRINCBAL < INSTAMT THEN
                             RECEIVABLE := PRINCBAL;
                         ELSE
                             RECEIVABLE := INSTAMT;
                         END IF;
                      END IF;
                      DBMS_OUTPUT.PUT_LINE(' condition 2 Direct Partial   ='||PRINCBAL);
                  END IF;
               END IF;
           END IF;
           /*  CONDITION 3  */
--           IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' THEN  
--               IF RECEIVABLE < INSTAMT THEN
--                 IF PRINCBAL < INSTAMT THEN
--                     RECEIVABLE := PRINCBAL;
--                 ELSE
--                     RECEIVABLE := INSTAMT;
--                 END IF;
--               END IF;
--               DBMS_OUTPUT.PUT_LINE(' CONDITION 3 EMI   ='||RECEIVABLE);
--           ELSE
--               IF REPAYDT < ASONDT THEN
--               PRINCBAL := 0 ;
--               END IF;
--               DBMS_OUTPUT.PUT_LINE(' CONDITION 3 LUMPSUM   ='||RECEIVABLE);
--           END IF;
    /*  END OF CONSIDER THE RECEIVABLE */ 
               /*  HERE CONSIDERING THE PRINCIPLE PAYABLE  */
            DBMS_OUTPUT.PUT_LINE('RECEIVABLE     ='||RECEIVABLE);        
    IF RECOVERYTYPE = 'Recovery' THEN
           IF RECEIVABLE > 0 THEN
                    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                        IF PRINCBAL < INSTAMT  THEN
                                 PRINCPAYABLE := PRINCBAL;
                        ELSE
                                 PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                        END IF;                     
                    ELSE
                        If INST_TYPE = 'LUMP_SUM' Then 
                            if REPAYDT < ASONDT THEN
                                PRINCPAYABLE := RECEIVABLE;
                            Else
                                PRINCPAYABLE := 0;
                            End if;
                        Else
                          PRINCPAYABLE := RECEIVABLE;  
                        End if;
                    END IF;
           ELSE
                    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                       IF RECOVERYFLAG = 'RecoveryPartial' THEN                         
                            IF INTRECBLE > INSTAMT THEN
                                NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                            ELSE
                                IF PRINCBAL < INSTAMT  THEN
                                    PRINCPAYABLE := PRINCBAL;
                                ELSE
                                    PRINCPAYABLE := INSTAMT;
                                END IF;
                            END IF;
                            WHILE INSTCOUNT <= NOOFINST
                            LOOP
                              INSTCOUNT := INSTCOUNT + 1;
                              IF PRINCPAYABLE >=PRINCBAL THEN
                               PRINCPAYABLE := PRINCBAL;
                              ELSE
                              PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                              END IF; 
                              --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                            END LOOP;
                       END IF;
                    ELSE
                       DBMS_OUTPUT.PUT_LINE('I AM HERE IN LUMPSUM');
                       IF RECOVERYFLAG = 'RecoveryPartial' THEN
                         IF REPAYDT < ASONDT THEN
                         DBMS_OUTPUT.PUT_LINE('I AM HERE');
                               IF INTRECBLE > INSTAMT THEN
                                  NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                               ELSE
                                    IF PRINCBAL < INSTAMT  THEN
                                        PRINCPAYABLE := PRINCBAL;
                                    ELSE
                                        PRINCPAYABLE := INSTAMT;
                                    END IF;
                               END IF;
                                WHILE INSTCOUNT <= NOOFINST
                                LOOP
                                  INSTCOUNT := INSTCOUNT + 1;
                                  IF PRINCPAYABLE >=PRINCBAL THEN
                                   PRINCPAYABLE := PRINCBAL;
                                  ELSE
                                  PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                  END IF; 
                                  --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                END LOOP;
                              IF INTRECBLE < INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                              ELSE
                                        IF PRINCBAL < INSTAMT  THEN
                                            PRINCPAYABLE := PRINCBAL;
                                        ELSE
                                            PRINCPAYABLE := INSTAMT;
                                        END IF;
                                            
                                    WHILE INSTCOUNT <= NOOFINST
                                    LOOP
                                      INSTCOUNT := INSTCOUNT + 1;
                                      IF PRINCPAYABLE >=PRINCBAL THEN
                                       PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                      PRINCPAYABLE := INSTAMT ;
                                      END IF; 
                                      --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                    END LOOP;
                                      IF PRINCPAYABLE >= PRINCBAL THEN
                                        PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                        PRINCPAYABLE := INSTAMT;
                                      END IF;
                              END IF;
                         ELSE
                         PRINCPAYABLE := 0;
                         END IF;
                       ELSE
                       PRINCPAYABLE := 0;
                       END IF;
                    END IF;
           END IF;
   -- DBMS_OUTPUT.PUT_LINE('PRINCPAYABLE   ='||PRINCPAYABLE||'INTRECBLE  ='||INTRECBLE||'   INSTAMT ='||INSTAMT);
    ELSE
         --IF TRANSMETHOD = 'BY RECOVERY CASH/TRANSFER' OR TRANSMETHOD = 'DEDUCTION SI' OR TRANSMETHOD = 'BY DIRECT CASH/TRANSFER' THEN
          --DBMS_OUTPUT.PUT_LINE('I AM OUTSIDE');
             IF RECEIVABLE > 0 THEN
                            IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                               IF RECEIVABLE < INSTAMT THEN
                               PRINCPAYABLE := RECEIVABLE;
                               ELSE
                               dbms_output.put_line('hey i am here');
                                    IF INTRECBLE > INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);
                                        if NOOFINST = 1 then
                                        NOOFINST := NOOFINST + 1;
                                        end if;
                                        dbms_output.put_line('NOOFINST = '||NOOFINST);
                                        PRINCPAYABLE := RECEIVABLE; 
                                        dbms_output.put_line('PRINCPAYABLE =   '||PRINCPAYABLE||'  '||'PRINCBAL  '||PRINCBAL );
                                        FOR INSTCOUNT IN 1..NOOFINST -1
                                        LOOP
                                             IF PRINCPAYABLE >=PRINCBAL THEN
                                               PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                              PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                             END IF; 
                                        dbms_output.put_line('PRINCPAYABLE =   '||PRINCPAYABLE||'  '||'PRINCBAL  '||PRINCBAL );    
                                        END LOOP;
                                       PRINCPAYABLE := PRINCPAYABLE - INTRECBLE;
                                    else
                                    PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                                    END IF;
                               dbms_output.put_line('hey i am here  II');
                               --PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                               END IF;
                            ELSE
                                PRINCPAYABLE := RECEIVABLE;
                            END IF;
             ELSE
                            IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                               IF RECOVERYFLAG = 'RecoveryPartial' THEN                         
                                    IF INTRECBLE > INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                    ELSE
                                        IF PRINCBAL < INSTAMT  THEN
                                            PRINCPAYABLE := PRINCBAL;
                                        ELSE
                                            PRINCPAYABLE := INSTAMT;
                                        END IF;
                                    END IF;
                                    WHILE INSTCOUNT <= NOOFINST
                                    LOOP
                                      INSTCOUNT := INSTCOUNT + 1;
                                      IF PRINCPAYABLE >=PRINCBAL THEN
                                       PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                      PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                      END IF; 
                                      --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                    END LOOP;
                               END IF;
                            ELSE
                               IF RECOVERYFLAG = 'RecoveryPartial' THEN
                                 IF REPAYDT < ASONDT THEN
                                 DBMS_OUTPUT.PUT_LINE('I AM HERE');
                                       IF INTRECBLE > INSTAMT THEN
                                          NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                       ELSE
                                            IF PRINCBAL < INSTAMT  THEN
                                                PRINCPAYABLE := PRINCBAL;
                                            ELSE
                                                PRINCPAYABLE := INSTAMT;
                                            END IF;
                                       END IF;
                                        WHILE INSTCOUNT <= NOOFINST
                                        LOOP
                                          INSTCOUNT := INSTCOUNT + 1;
                                          IF PRINCPAYABLE >=PRINCBAL THEN
                                           PRINCPAYABLE := PRINCBAL;
                                          ELSE
                                          PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                          END IF; 
                                          --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                        END LOOP;
                                      IF INTRECBLE < INSTAMT THEN
                                                NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                      ELSE
                                                IF PRINCBAL < INSTAMT  THEN
                                                    PRINCPAYABLE := PRINCBAL;
                                                ELSE
                                                    PRINCPAYABLE := INSTAMT;
                                                END IF;
                                                    
                                            WHILE INSTCOUNT <= NOOFINST
                                            LOOP
                                              INSTCOUNT := INSTCOUNT + 1;
                                              IF PRINCPAYABLE >=PRINCBAL THEN
                                               PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                              PRINCPAYABLE := INSTAMT ;
                                              END IF; 
                                              --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                            END LOOP;
                                              IF PRINCPAYABLE >= PRINCBAL THEN
                                                PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                                PRINCPAYABLE := INSTAMT;
                                              END IF;
                                      END IF;
                                 ELSE
                                 PRINCPAYABLE := 0;
                                 END IF;
                               ELSE
                               PRINCPAYABLE := 0;
                               END IF;
                            END IF;
             END IF;     -- END IF;
    END IF;
    IF PRINCPAYABLE IS NULL THEN 
    PRINCPAYABLE := 0 ;
    END IF;
RETURN PRINCPAYABLE;
--DBMS_OUTPUT.PUT_LINE('PRINCPAYABLE   ='||PRINCPAYABLE||'  '||'INTRECBLE  ='||INTRECBLE||INST_TYPE||'   '||EMITYPE||'RECEIVABLE  ='||RECEIVABLE||'   PRINCBAL='||PRINCBAL||'   INSTAMT='||INSTAMT);
--DBMS_OUTPUT.PUT_LINE('REPAYDT   ='||REPAYDT||'     TRANSMETHOD  ='||TRANSMETHOD||'   '||PRINCPAYABLE);
END;
/
--End Version [Script Version - 0.0.188] [ReleaseVersion - 9.2.2.3]--[09-09-2015] -- by Chithra

--Start Version [Script Version - 0.0.189] [ReleaseVersion - 9.2.2.3]--[25-09-2015] -- by Chithra

Insert into LOOKUP_MASTER   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,AUTHORIZED)  Values  ('TERM_LOAN.INT_REBATE_CAL', 'Monthly calculation', 'Monthly calculation', 'CREATED', 'Y',     'Y');

ALTER TABLE LOANS_PROD_SUBSIDY_REBATE ADD (INT_RATE_REBATE VARCHAR2(10 BYTE));

ALTER TABLE DEPOSITS_PROD_RD ADD (RD_NATURE VARCHAR2(10 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.189] [ReleaseVersion - 9.2.2.3]--[25-09-2015] -- by Chithra

--Start Version [Script Version - 0.0.190] [ReleaseVersion - 9.2.2.3]--[07-10-2015] -- by Chithra
CREATE OR REPLACE function deleteAccountIntTrailAll (TODATE IN DATE,BRANCH_ID VARCHAR ,PRODID VARCHAR)
        RETURN VARCHAR2
      IS
         curval   VARCHAR2 (16);
         PRAGMA AUTONOMOUS_TRANSACTION;
      BEGIN    
          DELETE FROM ACT_INTEREST_TRIAL WHERE  
          APPL_DT=TODATE AND BRANCH_CODE=BRANCH_ID AND PRODUCT_ID=PRODID;        
         COMMIT;   
            RETURN curval;
      END;
/

ALTER TABLE ACT_INTEREST_TRIAL ADD (PARTICULARS VARCHAR2(50 BYTE));

ALTER TABLE ACT_INTEREST_TRIAL ADD (OD_CR_TOT_AMT NUMBER(16,2));


CREATE OR REPLACE FUNCTION GET_ADV_CRDR_INTEREST(ACTNUM VARCHAR, FROMDT DATE,TODT DATE) RETURN VARCHAR IS
/* For modifications in this function check notes and compare with GET_ADV_CRDR_INTEREST_ORIGINAL */
    --DECLARE
   -- ACTNUM VARCHAR2(13) := '0001214000085';
   -- FROMDT DATE := '1 may 2015';
   -- TODT DATE := '22 aug 2015';
    RATEOFINT NUMBER(16,2);
    INTGET VARCHAR2(10);
    CATG VARCHAR2(30);
    STARTDAT DATE;
    ENDDT DATE;
    LIMT NUMBER(16);
    PRODID NUMBER(10);
    DRINTRATE NUMBER(16,2);
    CRINTRATE NUMBER(16,2);
    BEGIN
         SELECT LFD.PROD_ID, LFD.INT_GET_FROM,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT INTO PRODID,INTGET,CATG,STARTDAT,ENDDT,LIMT FROM LOANS_FACILITY_DETAILS LFD
         JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
         JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
         WHERE LFD.ACCT_NUM = ACTNUM;
         IF INTGET = 'ACT' THEN
         SELECT NVL(LIM.INTEREST,0) INTO RATEOFINT FROM LOANS_INT_MAINTENANCE LIM WHERE LIM.ACCT_NUM = ACTNUM;
         ELSE
         SELECT GET_TL_ROI_DRINT(PRODID,CATG,STARTDAT,ENDDT,LIMT)  INTO DRINTRATE FROM DUAL;
         SELECT GET_TL_ROI_CRINT(PRODID,CATG,STARTDAT,ENDDT,LIMT)  INTO CRINTRATE FROM DUAL;
         END IF;
    BEGIN
    DECLARE CURSOR A IS
    SELECT prod_id, act_num, TO_DATE (FROMDT) AS day_end_dt,
      case when  (SELECT MIN (k.day_end_dt)
          FROM advances_dayend_balance k
         WHERE k.act_num = a.act_num
           AND k.day_end_dt > FROMDT
           AND k.day_end_dt <= TODT) is null then TO_DATE ( TODT) else (SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = a.act_num
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT) end AS next_dt,
        (SELECT NVL (amt, 0)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt IN (
        SELECT MAX (c.day_end_dt)
        FROM advances_dayend_balance c
        WHERE c.act_num = k.act_num
        AND c.day_end_dt <= FROMDT)) AS amt,
        case when (SELECT NVL (amt, 0)
        FROM advances_dayend_balance g
        WHERE g.act_num = ACTNUM
        AND g.day_end_dt IN (
        SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT)) is null then amt else (SELECT NVL (amt, 0)
        FROM advances_dayend_balance g
        WHERE g.act_num = ACTNUM
        AND g.day_end_dt IN (
        SELECT MIN (k.day_end_dt)
        FROM advances_dayend_balance k
        WHERE k.act_num = ACTNUM
        AND k.day_end_dt > FROMDT
        AND k.day_end_dt <= TODT)) end  AS next_amt   
        FROM advances_dayend_balance a
        WHERE a.act_num = ACTNUM
        AND a.day_end_dt IN (SELECT MAX (c.day_end_dt)
        FROM advances_dayend_balance c
        WHERE c.act_num = a.act_num AND c.day_end_dt <= FROMDT)
        UNION 
        SELECT a.prod_id, a.act_num, a.day_end_dt, a.next_dt, a.amt,
        b.amt AS next_amt
        FROM (SELECT prod_id, act_num, day_end_dt,
        NVL ((SELECT MIN (day_end_dt)
        FROM advances_dayend_balance b
        WHERE b.day_end_dt > a.day_end_dt AND act_num =ACTNUM),
        TODT  /* Changed day_end_dt to parameter "TODT" so that union will remove that record. */
        ) AS next_dt,
        amt
        FROM advances_dayend_balance a
        WHERE act_num = ACTNUM AND day_end_dt BETWEEN FROMDT AND TODT) a,
        (SELECT *
        FROM advances_dayend_balance) b
        WHERE a.prod_id = b.prod_id
        AND a.act_num = b.act_num
        AND b.day_end_dt = a.next_dt
        union
        SELECT a.prod_id, a.act_num, (select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)  day_end_dt, 
        to_date(TODT) next_dt, (SELECT amt FROM advances_dayend_balance where act_num =ACTNUM and 
        day_end_dt=(select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)) amt,
        (SELECT amt FROM advances_dayend_balance where act_num =ACTNUM and 
        day_end_dt=(select max(day_end_dt) from advances_dayend_balance
        where act_num =ACTNUM AND day_end_dt<=TODT)) next_amt /* Changed next_amt to last balance instead of zero */
        FROM advances_dayend_balance a where A.ACT_NUM =ACTNUM AND day_end_dt BETWEEN FROMDT AND TODT        
        ORDER BY  day_end_dt  ;
    DATEDIFF NUMBER(10);
    FIRSTDATE DATE;
    NEXTDATE DATE;
    FLAG INTEGER := 0;
    CREDITINTEREST NUMBER(16,2) := 0;
    DEBITINTEREST NUMBER(16,2) := 0;
    INTEREST VARCHAR2(150);
    CRTOTAMT NUMBER(16,2) :=0;
    DRTOTAMT NUMBER(16,2) :=0;
    CRTOTDAYS NUMBER(12,2) :=0;
    DRTOTDAYS NUMBER(12,2) :=0;
    CRROIRATE NUMBER(12,2) :=0;
    DRROIRATE NUMBER(12,2) :=0;
    prodamt number(15,2) := 0;
    DATEDIFFTEMP NUMBER(10);
    BEGIN
         FOR I IN A LOOP
         SELECT NVL(TRUNC(TO_DATE(I.NEXT_DT,'DD-MM-YYYY')- TO_DATE(I.DAY_END_DT,'DD-MM-YYYY')),0) INTO DATEDIFF FROM DUAL;
         SELECT NVL(TRUNC(TO_DATE(TODT,'DD-MM-YYYY')- TO_DATE(I.DAY_END_DT,'DD-MM-YYYY')),0) INTO DATEDIFFTEMP FROM DUAL;
         FIRSTDATE := I.DAY_END_DT; 
         --DBMS_OUTPUT.PUT_LINE('DATEDIFF=  '||DATEDIFF||'   DATEDIFFTEMP ='||DATEDIFFTEMP||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT || 'TODT= '||TODT ||' I.NEXT_DT ='||I.NEXT_DT);
         IF I.AMT > 0 THEN
         IF INTGET = 'ACT' THEN 
         CREDITINTEREST := CREDITINTEREST + (I.AMT *  DATEDIFF * RATEOFINT) /36500;
         IF DATEDIFFTEMP > 0 THEN
         CRTOTAMT := CRTOTAMT + I.AMT;
         END IF;
         CRTOTDAYS := CRTOTDAYS + DATEDIFF;
         CRROIRATE := RATEOFINT;
         ELSE
         CREDITINTEREST := CREDITINTEREST + (I.AMT *  DATEDIFF * CRINTRATE ) /36500;
         IF DATEDIFFTEMP > 0 THEN
         CRTOTAMT := CRTOTAMT + I.AMT;
         END IF;
         CRTOTDAYS := CRTOTDAYS + DATEDIFF;
         CRROIRATE := CRINTRATE;
         END IF;
         --DBMS_OUTPUT.PUT_LINE('RATEOFINT  ='||RATEOFINT|| 'DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT||'CREDITINTEREST = '||CREDITINTEREST  );
         ELSE
         IF INTGET = 'ACT' THEN
         DEBITINTEREST := DEBITINTEREST + (I.AMT * DATEDIFF * RATEOFINT) /36500;
         IF DATEDIFFTEMP > 0 THEN
         DRTOTAMT := DRTOTAMT + I.AMT;
         END IF;
         DRTOTDAYS := DRTOTDAYS + DATEDIFF;
         DRROIRATE := RATEOFINT;
         ELSE
         DEBITINTEREST := DEBITINTEREST + (I.AMT * DATEDIFF * DRINTRATE) /36500;
         IF DATEDIFFTEMP > 0 THEN
         DRTOTAMT := DRTOTAMT + I.AMT;
         END IF;
         DRTOTDAYS := DRTOTDAYS + DATEDIFF;
         DRROIRATE := DRINTRATE;
         END IF;
         --DBMS_OUTPUT.PUT_LINE('RATEOFINT  ='||RATEOFINT||'DATEDIFF=  '||DATEDIFF||'   FIRSTDATE ='||FIRSTDATE||'  NEXT DATE=   '||I.DAY_END_DT||'AMT =     '||I.AMT||'DEBITINTEREST = '||DEBITINTEREST  );  
         END IF;
         INTEREST := 'DEBITINTEREST = '||DEBITINTEREST||':CREDITINTEREST =  '||CREDITINTEREST || ':CRTOTAMT =' || CRTOTAMT ||':DRTOTAMT =' ||
          DRTOTAMT ||':CRROIRATE ='|| CRROIRATE ||':DRROIRATE =' || DRROIRATE || ':DRTOTDAYS = ' || DRTOTDAYS || ':CRTOTDAYS =' || CRTOTDAYS ;
           -- DBMS_OUTPUT.PUT_LINE('INTEREST = '||INTEREST);
         END LOOP;
         --DBMS_OUTPUT.PUT_LINE('DEBITINTEREST = '||DEBITINTEREST||' : '||'CREDITINTEREST =  '||CREDITINTEREST);
        RETURN INTEREST;
         END;
    END;
    END;
/

--End Version [Script Version - 0.0.190] [ReleaseVersion - 9.2.2.3]--[07-10-2015] -- by Chithra

--Start Version [Script Version - 0.0.191] [ReleaseVersion - 9.2.2.3]--[08-10-2015] -- by Sreekrishnan

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('MDSPRODUCT.CHARGETYPE', 'ABSOLUTE', 'Absolute', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('MDSPRODUCT.CHARGETYPE', 'PENDING_INST_WOUT_BONUS', 'Pending Inst Without Bonus', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('MDSPRODUCT.CHARGETYPE', 'PERCENT', 'Percent', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('MDSPRODUCT.CHARGETYPE', 'PENDING_INST', 'Pending Installment', 'CREATED', NULL, 
    'Y');
COMMIT;

--End Version [Script Version - 0.0.191] [ReleaseVersion - 9.2.2.3]--[08-10-2015] -- by Sreekrishnan

--Start Version [Script Version - 0.0.190] [ReleaseVersion - 9.2.2.3]--[08-10-2015] -- by Chithra

ALTER TABLE SUSPENSE_PRODUCT ADD (NEG_AMT_YN VARCHAR2(5 BYTE));

--End Version [Script Version - 0.0.190] [ReleaseVersion - 9.2.2.3]--[08-10-2015] -- by Chithra

--Start Version [Script Version - 0.0.191] [ReleaseVersion - 9.2.2.3]--[16-10-2015] -- by Sreekrishnan
CREATE OR REPLACE FUNCTION CALCULATE_DD_SI_COMMFUNCT(ACTNUM IN VARCHAR,TDATE IN DATE,PRODID IN VARCHAR,SIID IN VARCHAR) RETURN NUMBER
AS
    CNT INTEGER := 0;
    COMM Number(16,2) :=0;
    AMT NUMBER(16,2);
    CMPERBNK NUMBER(16,2);
    CMPERACH NUMBER(16,2);
BEGIN
SELECT COMM_PER_AC_HOLDR,COMM_PER_BANK INTO CMPERACH,CMPERBNK FROM AGENT_PROD_MAPPING WHERE PROD_ID = PRODID;
    SELECT SUM(T.AMOUNT) INTO AMT
    FROM DAILY_DEPOSIT_TRANS T
    WHERE T.ACC_NUM = ACTNUM  AND T.TRN_DT BETWEEN (SELECT nvl(LAST_RUN_DT,SI_START_DT) FROM standing_instruction WHERE SI_ID = SIID )  AND TDATE AND T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS != 'DELETED';
            DBMS_OUTPUT.PUT_LINE ( ' AMT ' || AMT );
      DBMS_OUTPUT.PUT_LINE ( ' CMPERACH ' || CMPERACH );
      DBMS_OUTPUT.PUT_LINE ( ' CMPERBNK ' || CMPERBNK );
            COMM :=(AMT*(CMPERACH+CMPERBNK))/100;
            DBMS_OUTPUT.PUT_LINE ( ' COMM ' || COMM );
    RETURN COMM;
end;
/

ALTER TABLE LOAN_CHARGE_DEFINITION ADD (DAY_WISE_CALC VARCHAR2(1 BYTE) DEFAULT 'N');

--End Version [Script Version - 0.0.191] [ReleaseVersion - 9.2.2.3]--[16-10-2015] -- by Sreekrishnan

--start Version [Script Version - 0.0.192] [ReleaseVersion - 9.2.2.3]--[28-10-2015] -- by Chithra
DROP VIEW ALL_CUSTOMER_BALANCE;

/* Formatted on 2015/10/28 10:42 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW ALL_CUSTOMER_BALANCE (act_num,
                                                         cust_id,
                                                         customer_name,
                                                         available_balance,
                                                         branch_code,shadow_debit
                                                        )
AS
   (SELECT act_num, cust_id, acct_name AS customer_name,
           NVL (available_balance, 0) AS available_balance, branch_code, NVL (shadow_debit, 0) AS shadow_debit
      FROM act_master
     WHERE act_status_id != 'CLOSED'
       AND status != 'DELETED'
       AND authorization_status = 'AUTHORIZED'
    UNION ALL
    SELECT suspense_acct_num AS act_num, suspense_customer_id AS cust_id,
           suspense_name AS customer_name,
           NVL (clear_balance, 0) AS available_balance, branch_code, NVL (unclear_balance, 0) AS shadow_debit
      FROM suspense_account_master
     WHERE status != 'DELETED' AND authorize_status = 'AUTHORIZED'
    UNION ALL
    SELECT dsa.deposit_no || '_' || dsa.deposit_sub_no AS act_num, da.cust_id,
           DECODE (cu.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           dsa.available_balance, da.branch_id AS branch_code, NVL (shadow_debit, 0) AS shadow_debit
      FROM deposit_sub_acinfo dsa, deposit_acinfo da, customer cu
     WHERE da.cust_id = cu.cust_id
       AND da.deposit_no = dsa.deposit_no
       AND da.deposit_status != 'CLOSED'
       AND da.authorize_status = 'AUTHORIZED'
       AND dsa.available_balance > 0
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           NVL (available_balance, 0) AS available_balance,
           branch_id AS branch_code, NVL (shadow_debit, 0) AS shadow_debit
      FROM loans_borrower lb, customer cu, loans_facility_details lfd
     WHERE lb.cust_id = cu.cust_id
       AND lb.borrow_no = lfd.borrow_no
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.prod_id IN (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like = 'OD'
                 AND status != 'DELETED'
                 AND authorize_status = 'AUTHORIZED')
    UNION ALL
    SELECT b.ac_hd_id AS act_num, '' AS cust_id,
           b.ac_hd_desc AS customer_name,
           NVL (cur_bal, 0) AS available_balance, branch_code, NVL (shadow_debit, 0) AS shadow_debit
      FROM gl a, ac_hd b
     WHERE a.authorize_status = 'AUTHORIZED' AND a.ac_hd_id = b.ac_hd_id
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id,
           agency_name AS customer_name, available_balance, branch_id, NVL (shadow_debit, 0) AS shadow_debit
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');
--End Version [Script Version - 0.0.192] [ReleaseVersion - 9.2.2.3]--[28-10-2015] -- by Chithra

--Strart Version [Script Version - 0.0.193] [ReleaseVersion - 9.2.2.3]--[28-10-2015] -- by Sreekrishnan
--check the screen master id befor insert script
SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12238', '12238', 'Agent Commision Product Wise', 'APP01', 'DONE', 
    '8', NULL, 4, 'CREATED', NULL, 
    NULL, 'Agent Commision Product Wise');
COMMIT;
CALL INSERT_REPORT_GROUP('SCR12238');
--End Version [Script Version - 0.0.193] [ReleaseVersion - 9.2.2.3]--[28-10-2015] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.194] [ReleaseVersion - 9.2.2.3]--[29-10-2015] -- by Sreekrishnan
ALTER TABLE LOANS_PROD_SUBSIDY_REBATE ADD (REBATE_CALC varchar2(1) DEFAULT 'N');
--End Version [Script Version - 0.0.194] [ReleaseVersion - 9.2.2.3]--[29-10-2015] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.195] [ReleaseVersion - 9.2.2.3]--[30-10-2015] -- by Rishad
   alter table loans_prod_intrec  add(PENAL_APP_EMI varchar2(1 byte))
--End Version [Script Version - 0.0.195] [ReleaseVersion - 9.2.2.3]--[30-10-2015] -- by Rishad

--Strart Version [Script Version - 0.0.196] [ReleaseVersion - 9.2.2.3]--[11-11-2015] -- by Chithra
ALTER TABLE STANDING_INSTRUCTION ADD (Instalment_YN VARCHAR2(5 BYTE) DEFAULT 'N');
ALTER TABLE STANDING_INSTRUCTION ADD (Instalment_No NUMBER(5));
ALTER TABLE STANDING_INSTRUCTION ADD (Pending_Inst_YN VARCHAR2(5 BYTE) DEFAULT 'N');
--End Version [Script Version - 0.0.196] [ReleaseVersion - 9.2.2.3]--[11-11-2015] -- by Chithra

--Strart Version [Script Version - 0.0.197] [ReleaseVersion - 9.2.2.3]--[16-11-2015] -- by Rishad
--written by ajith
CREATE OR REPLACE FUNCTION ACT_INT_CALC_START_DT(ACTNO VARCHAR,STARTDT NUMBER)
RETURN DATE
IS
INT_STARTDT DATE;
OPEN_DT DATE;
BEGIN
SELECT CREATE_DT INTO OPEN_DT FROM ACT_MASTER WHERE ACT_NUM=ACTNO;
IF TO_CHAR (OPEN_DT, 'DD')>STARTDT THEN
SELECT LAST_DAY(OPEN_DT)+1 INTO INT_STARTDT FROM DUAL;
ELSE
INT_STARTDT:=OPEN_DT;
END IF;
RETURN INT_STARTDT;
END;
/

--End Version [Script Version - 0.0.197] [ReleaseVersion - 9.2.2.3]--[16-11-2015] -- by Rishad

--Strart Version [Script Version - 0.0.198] [ReleaseVersion - 9.2.2.3]--[18-11-2015] -- by Rishad
--following function are written by prasanth kg
CREATE OR REPLACE FUNCTION GET_DUEDETAILS_EMI(ACTNUM VARCHAR) RETURN VARCHAR IS
--DECLARE 
--ACTNUM VARCHAR2(13) :='0001203000934';
PAIDINST NUMBER(10);
TODAY DATE;
LASTPAIDUPTODATE DATE;
PAYABLEINST NUMBER(10);
PENDINGINST NUMBER(10);
INSTAMT NUMBER(10);
PENAL NUMBER(12,2);  
TOTAL_DUE NUMBER(10);
TOTALDEMAND NUMBER(12,2);
NARRATION VARCHAR2(1000);
BEGIN
Select max(to_number(LI.INSTALLMENT_SLNO)) INTO PAIDINST from loans_installment li where LI.ACCT_NUM = actnum
AND LI.INSTALLMENT_PAID = 'Y' AND LI.IS_BALANCE = 0;
SELECT DE.CURR_APPL_DT INTO TODAY FROM DAY_END DE;
sELECT LI.INSTALLMENT_DT INTO LASTPAIDUPTODATE FROM LOANS_INSTALLMENT LI WHERE LI.INSTALLMENT_SLNO = PAIDINST
AND LI.ACCT_NUM = ACTNUM;
SELECT MAX(LI.INSTALLMENT_SLNO) INTO PAYABLEINST   FROM LOANS_INSTALLMENT LI WHERE LI.ACCT_NUM = ACTNUM
AND LI.INSTALLMENT_DT < TODAY;
SELECT GET_TL_INSTAMT(ACTNUM) INTO INSTAMT FROM DUAL;
PENDINGINST := PAYABLEINST - PAIDINST;
IF PENDINGINST <0 THEN 
PENDINGINST := 0;
END IF;
IF TODAY < LASTPAIDUPTODATE  THEN 
NARRATION := 'ADVANCE LOAN'||'  '||'INST AMT RS '||TO_CHAR(INSTAMT)||'/-';
ELSE
  SELECT  GET_EMIPENAL(ACTNUM) INTO PENAL FROM DUAL;
  TOTAL_DUE := PENDINGINST * INSTAMT;
  TOTALDEMAND := TOTAL_DUE + PENAL; 
  NARRATION := 'INST AMT  RS '||TO_CHAR(INSTAMT)||'/- '||'PENDING INST  '||TO_CHAR(PENDINGINST)||'   '||'TOTAL DUE  RS: '||TO_CHAR(TOTAL_DUE)||'/-  '||'PENAL   RS:'||TO_CHAR(PENAL)||'/-  '||'TOTAL DEMAND   RS: '||TOTALDEMAND||'/-';
END IF;
--DBMS_OUTPUT.PUT_LINE(NARRATION);
RETURN NARRATION;
END;
/
========================================================================================
CREATE OR REPLACE FUNCTION GET_EMIPENAL(ACTNUM VARCHAR) RETURN NUMBER IS 
--DECLARE
--ACTNUM VARCHAR2(13) := '0001203001910' ;
PAIDINST NUMBER(10);
PAYABLEINST NUMBER(10);
PROID VARCHAR2(3);
CATG VARCHAR2(50);
FDATE DATE;
TDATE DATE;
LAMT NUMBER(12,2);
PENDINGINST NUMBER(10);
INTFROM VARCHAR2(20);
INSTAMT NUMBER(12,2);
PENALRATE NUMBER(12,2);
PENAL NUMBER(12,2);
PRODUCT NUMBER;
today date;
BEGIN
SELECT MAX(TO_NUMBER(LI.INSTALLMENT_SLNO)) INTO PAIDINST FROM LOANS_INSTALLMENT LI WHERE LI.ACCT_NUM = ACTNUM
AND LI.INSTALLMENT_PAID = 'Y' AND LI.IS_BALANCE = 0;
select DE.CURR_APPL_DT into today  from day_end de ;
SELECT MAX(LI.INSTALLMENT_SLNO) INTO PAYABLEINST   FROM LOANS_INSTALLMENT LI WHERE LI.ACCT_NUM = ACTNUM
AND LI.INSTALLMENT_DT < today;
SELECT LFD.PROD_ID,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT,LFD.INT_GET_FROM INTO PROID,CATG,FDATE,TDATE,LAMT,INTFROM  FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
WHERE LFD.BORROW_NO = LB.BORROW_NO
AND LB.BORROW_NO = LSD.BORROW_NO
AND LFD.ACCT_NUM = ACTNUM;
SELECT GET_TL_INSTAMT(ACTNUM) INTO INSTAMT FROM DUAL;
    IF INTFROM = 'ACT' THEN
    SELECT LIM.PENAL_INTEREST INTO PENALRATE FROM LOANS_INT_MAINTENANCE LIM WHERE
    LIM.ACCT_NUM = ACTNUM AND LIM.SLNO =( SELECT MAX(LS.SLNO) FROM LOANS_INT_MAINTENANCE LS WHERE LS.ACCT_NUM = LIM.ACCT_NUM);  
    ELSE
    SELECT GET_TL_ROI_EMI(ACTNUM,CATG,FDATE,TDATE,LAMT) INTO PENALRATE FROM DUAL;
    END IF;
PENDINGINST := PAYABLEINST - PAIDINST;
        IF PENDINGINST <0 THEN 
        PENAL := 0;
        ELSE
        PRODUCT := PENDINGINST * ((PENDINGINST +1)/2) ;
        PENAL := INSTAMT *  PRODUCT * (PENALRATE/1200);
        PENAL := ROUND(PENAL,0);
        END IF;
--DBMS_OUTPUT.PUT_LINE(PENAL);
RETURN PENAL;
END;
/
===========================================================================================
CREATE OR REPLACE FUNCTION GET_TL_ROI_EMI(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN

    SELECT drgtr.roi INTO RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = CATG
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(TRUNC(TO_DATE(LOANDUEDT,'DD-MM-YYYY')- TO_DATE(LOANDATE,'DD-MM-YYYY')),0)
          BETWEEN from_period
              AND to_period ;              
    RETURN RATEOFINT;
END;
/

--End Version [Script Version - 0.0.198] [ReleaseVersion - 9.2.2.3]--[18-11-2015] -- by Rishad

--Strart Version [Script Version - 0.0.199] [ReleaseVersion - 9.2.2.3]--[24-11-2015] -- by Sreekrishnan
ALTER TABLE SHARE_CONF_DETAILS ADD (SHARE_CERTIFICATE_PRINT VARCHAR2(1 BYTE) DEFAULT 'N');

ALTER TABLE MDS_SCHEME_DETAILS ADD (BONUS_PRINT VARCHAR2(1 BYTE) DEFAULT 'Y');
--End Version [Script Version - 0.0.199] [ReleaseVersion - 9.2.2.3]--[24-11-2015] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.200] [ReleaseVersion - 9.2.2.3]--[8-12-2015] -- by Sreekrishnan
ALTER TABLE OTHER_BANKS_ACT_MASTER ADD CLOSED_DT DATE;
--End Version [Script Version - 0.0.200] [ReleaseVersion - 9.2.2.3]--[8-12-2015] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.201] [ReleaseVersion - 9.2.2.3]--[11-12-2015] -- by Rishad
alter table SHARE_ACCT_DETAILS add (FROMSL_NO NUMBER(10)default 0,TOSL_NO NUMBER(10) default 0)
--End Version [Script Version - 0.0.201] [ReleaseVersion - 9.2.2.3]--[11-12-2015] -- by Rishad

--Strart Version [Script Version - 0.0.202] [ReleaseVersion - 9.2.2.3]--[21-12-2015] -- by Rishad
alter table ADV_TRANS_DETAILS add (TRANS_MODE varchar2(10))
--End Version [Script Version - 0.0.202] [ReleaseVersion - 9.2.2.3]--[21-12-2015] -- by Rishad

--Strart Version [Script Version - 0.0.203] [ReleaseVersion - 9.2.2.3]--[21-12-2015] -- by Sreekrishnan
alter table ACT_MASTER add (INTRODUCER varchar2(16));
alter table DEPOSIT_ACINFO add (INTRODUCER varchar2(16));
--End Version [Script Version - 0.0.203] [ReleaseVersion - 9.2.2.3]--[21-12-2015] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.204] [ReleaseVersion - 9.2.2.3]--[18-Dec-2015] -- by  Suresh R
CREATE TABLE CARD_ACCT_STATUS
(
  CARD_ACCT_NUM      VARCHAR2(36 BYTE),
  SL_NO              NUMBER(5),
  ACTION             VARCHAR2(6 BYTE),
  ACTION_DT          DATE,
  REMARKS            VARCHAR2(250 BYTE),
  STATUS             VARCHAR2(16 BYTE),
  STATUS_BY          VARCHAR2(32 BYTE),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(32 BYTE),
  AUTHORIZED_BY      VARCHAR2(64 BYTE),
  AUTHORIZED_DT      DATE
);
ALTER TABLE ACT_MASTER ADD CARD_ACCT_NUM VARCHAR2(36 BYTE);
UPDATE OP_AC_SPCLITEM_PARAM SET ATM_CARD_ISSUED='N';
--End Version [Script Version - 0.0.204] [ReleaseVersion - 9.2.2.3]--[18-Dec-2015] -- by  Suresh R

--Start Version [Script Version - 0.0.205] [ReleaseVersion - 9.2.2.3]--[4-01-2016] -- by Sreekrishnan
 ALTER TABLE DEPOSITS_PROD_RD ADD (GRACE_PERIOD NUMBER(10)default 0);
 ALTER TABLE DEPOSIT_ACINFO ADD PASSBOOK_LINENO NUMBER(10);
--End Version [Script Version - 0.0.205] [ReleaseVersion - 9.2.2.3]--[4-01-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.206] [ReleaseVersion - 9.2.2.3]--[24-11-2014] -- by Jeffin John

insert into LOOKUP_MASTER (lookup_id,lookup_ref_id,lookup_desc,status,authorized) values ('DEPOSITSPRODUCT.OPERATESLIKE','THRIFT','Thrift','CREATED','Y');

insert into LOOKUP_MASTER (lookup_id,lookup_ref_id,lookup_desc,status,authorized) values ('DEPOSITSPRODUCT.OPERATESLIKE','BENEVOLENT','Benevolent','CREATED','Y');

ALTER TABLE DEPOSIT_SUB_ACINFO ADD ADT_AMT NUMBER(16,2);

ALTER TABLE DEPOSIT_RECURRING ADD ADT_AMT NUMBER(16,2);

Insert into SCREEN_MASTER
        (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
        MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
        RECORD_KEY_COL, SCREEN_DESC)
    Values
        ('SCR06137', '3', 'Interest Processing', 'APP01', 'DONE', 
        '6', 'com.see.truetransact.ui.deposit.interestprocessing.InterestProcessingUI', 7, 'CREATED', NULL, 
        NULL, 'Interest Processing');
    
call INSERT_REPORT_GROUP('SCR06137');

ALTER TABLE deposit_interest ADD reserve_fund_percent  NUMBER(11,8);

ALTER TABLE deposit_interest ADD reserve_fund_amt NUMBER(22,8);

--End Version [Script Version - 0.0.206] [ReleaseVersion - 9.2.2.3]--[24-11-2014] -- by Jeffin John

--Start Version [Script Version - 0.0.207] [ReleaseVersion - 9.2.2.3]--[24-11-2014] -- by Chithra

ALTER TABLE SHARE_CONF_DETAILS ADD (FULLCLOSURE_REQUIRED VARCHAR2(2 BYTE) DEFAULT 'N');

ALTER TABLE CUSTOMER ADD (DIVISION VARCHAR2(40 BYTE));

ALTER TABLE SALARY_RECOVERY_LIST_DETAIL ADD (UNRECOVERY VARCHAR2(5 BYTE) DEFAULT 'N');

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'TRIVANDRAM', 'TRIVANDRAM', 'CREATED', '', 
    'Y');
    
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'CHENNAI', 'CHENNAI', 'CREATED', '', 
    'Y');
    
    Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('CUSTOMER.DIVISION', 'COCHINE', 'COCHINE', 'CREATED', '', 
    'Y');

ALTER TABLE SALARY_RECOVERY_LIST_DETAIL ADD (DEP_INST_NO NUMBER(10));

--End Version [Script Version - 0.0.207] [ReleaseVersion - 9.2.2.3][24-11-2014] -- by Chithra

--Start Version [Script Version - 0.0.208] [ReleaseVersion - 9.2.2.4]--[22-01-2016] -- by Rishad

alter table PARAMETERS add LOGOUT_TIME number(6) default 45;

--End Version [Script Version - 0.0.208] [ReleaseVersion - 9.2.2.4][22-01-2016] -- by Rishad

--Start Version [Script Version - 0.0.209] [ReleaseVersion - 9.2.2.4]--[3-02-2016] -- by Sreekrishnan
CREATE OR REPLACE FUNCTION get_curr_bills_id (
prodId VARCHAR2,branchid VARCHAR2
)
RETURN VARCHAR2
IS
Pragma Autonomous_Transaction;
id_prefix BRANCH_ACNO_MAINTENANCE.PREFIX%TYPE;
id_currvalue BRANCH_ACNO_MAINTENANCE.LAST_AC_NO%TYPE;
new_id VARCHAR2(20);
BEGIN
UPDATE BRANCH_ACNO_MAINTENANCE SET LAST_AC_NO=NEXT_AC_NO,NEXT_AC_NO=NEXT_AC_NO+1 WHERE PROD_ID=prodId AND BRANCH_ID = branchid;
commit;
SELECT LAST_AC_NO,PREFIX INTO id_currvalue,id_prefix  FROM BRANCH_ACNO_MAINTENANCE WHERE PROD_ID=prodId AND BRANCH_ID=branchid;
new_id:=UPPER(id_prefix)||id_currvalue;
commit;
return new_id;
END;
/

CREATE TABLE AGENT_COMMISION_SLAB
(
  PROD_ID            VARCHAR2(40 BYTE),
  FROM_DT            DATE,
  TO_DT              DATE,
  FROM_AMOUNT        NUMBER,
  TO_AMOUNT          NUMBER,
  STATUS_DT          DATE,
  STATUS             VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS   VARCHAR2(16 BYTE),
  COMMISSION_AMOUNT  NUMBER(10)
)
--End Version [Script Version - 0.0.209] [ReleaseVersion - 9.2.2.4][3-02-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.210] [ReleaseVersion - 9.2.2.4]--[09-02-2016] -- by Sathiya

CREATE OR REPLACE FUNCTION GetcustName(Acno VARCHAR2) 
RETURN VARCHAR2 IS
    CustName VARCHAR2(500);
BEGIN
   
SELECT CNAME INTO custname 
FROM ( 
SELECT DECODE (a.cust_type, 'INDIVIDUAL', fname, comp_name) CNAME
  FROM customer a join act_master b
  on a.cust_id=b.cust_id 
 WHERE a.cust_id=b.cust_id  and b.ACT_NUM=Acno
 UNION ALL
 SELECT DECODE (a.cust_type, 'INDIVIDUAL', fname, comp_name) CNAME
  --INTO custname
 FROM customer a JOIN LOANS_BORROWER B ON A.CUST_ID=B.CUST_ID
 JOIN  LOANS_FACILITY_DETAILS C
ON B.BORROW_NO=C.BORROW_NO AND C.ACCT_NUM= Acno
 UNION ALL
 SELECT DECODE (a.cust_type, 'INDIVIDUAL', a.fname, a.comp_name) CNAME
  FROM customer a 
  JOIN deposit_acinfo b 
    ON a.cust_id = b.CUST_ID
 WHERE b.DEPOSIT_NO = Acno); 
 
 -- SELECT DECODE (cust_type,'INDIVIDUAL', fname, comp_name) into CustName
from customer where CUST_ID=Custid;
    
    RETURN CustName;
END GetcustName;
/

Insert into MODULE_MASTER
   (MODULE_ID, MODULE_NAME, CREATED_DT, SL_NO, STATUS)
 Values
   ('42', 'Edit Migrated Data', TO_DATE('09/11/2014 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 42, 'CREATED');

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR08887', '8887', 'Edit Migrated Data', 'APP01', 'DONE', 
    '34', 'Edit Migrated Data', 4, 'CREATED', NULL, 
    NULL, NULL);

call INSERT_REPORT_GROUP('SCR08887');

ALTER TABLE PARAMETERS ADD PENDING_TXN_ALLOWED_DAYS NUMERIC(3) default 0;

--End Version [Script Version - 0.0.210] [ReleaseVersion - 9.2.2.4][09-02-2016] -- by Sathiya

--Start Version [Script Version - 0.0.211] [ReleaseVersion - 9.2.2.4]--[12-02-2016] -- by Nithya

ALTER TABLE LOANS_PRODUCT ADD REPAYMENT_TYPE VARCHAR2(30);

ALTER TABLE LOANS_PRODUCT ADD REPAYMENT_FREQ NUMERIC(6,2);

ALTER TABLE CUST_ADDR ADD WARD_NAME VARCHAR2(30);

INSERT INTO LOOKUP_MASTER(LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC,STATUS,AUTHORIZED)
 VALUES('CUSTOMER.WARD','OLLUKKARA','OLLUKKARA','CREATED','Y');

INSERT INTO LOOKUP_MASTER_DESC (LOOKUP_ID,LOOKUP_ID_DESC,EDITABLE,AUTHORIZE_STATUS,AUTHORIZE_BY,STATUS_BY) VALUES 
('CUSTOMER.WARD','OLLUKKARA','Y','Y','admin','sysadmin')

--End Version [Script Version - 0.0.211] [ReleaseVersion - 9.2.2.4]--[12-02-2016] -- by Nithya

--Start Version [Script Version - 0.0.212] [ReleaseVersion - 9.2.2.4]--[19-02-2016] -- by Sreekrishnan
ALTER TABLE SUSPENSE_ACCOUNT_MASTER ADD CLOSED_DT DATE;
ALTER TABLE SUSPENSE_ACCOUNT_MASTER ADD ACCT_STATUS VARCHAR2(10);

DROP VIEW ALL_CUSTOMER_BALANCE;

/* Formatted on 2016/02/19 14:25 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_customer_balance (act_num,
                                                           cust_id,
                                                           customer_name,
                                                           available_balance,
                                                           min_balance,
                                                           branch_code
                                                          )
AS
   (SELECT ac.act_num, cust_id, acct_name AS customer_name,
           NVL (available_balance, 0) AS available_balance,
           NVL (CASE
                   WHEN ap.chk_book = 'Y'
                      THEN op.min_bal_w_chk
                   ELSE op.min_bal_wt_chk
                END,
                0
               ) AS min_balance,
           branch_code
      FROM act_master ac, act_param_detail ap, op_ac_account_param op
     WHERE act_status_id != 'CLOSED'
       AND op.prod_id = ac.prod_id
       AND ap.act_num = ac.act_num
       AND ac.status != 'DELETED'
       AND ac.authorization_status = 'AUTHORIZED'
    UNION ALL
    SELECT suspense_acct_num AS act_num, suspense_customer_id AS cust_id,
           suspense_name AS customer_name,
           NVL (clear_balance, 0) AS available_balance, 0 AS min_balance,
           branch_code
      FROM suspense_account_master
     WHERE status != 'DELETED' AND authorize_status = 'AUTHORIZED'
    UNION ALL
    SELECT dsa.deposit_no || '_' || dsa.deposit_sub_no AS act_num, da.cust_id,
           DECODE (cu.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           dsa.available_balance, 0 AS min_balance,
           da.branch_id AS branch_code
      FROM deposit_sub_acinfo dsa, deposit_acinfo da, customer cu
     WHERE da.cust_id = cu.cust_id
       AND da.deposit_no = dsa.deposit_no
       AND da.deposit_status != 'CLOSED'
       AND da.authorize_status = 'AUTHORIZED'
       AND dsa.available_balance > 0
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           NVL (available_balance, 0) AS available_balance, 0 AS min_balance,
           branch_id AS branch_code
      FROM loans_borrower lb, customer cu, loans_facility_details lfd
     WHERE lb.cust_id = cu.cust_id
       AND lb.borrow_no = lfd.borrow_no
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.prod_id IN (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like = 'OD'
                 AND status != 'DELETED'
                 AND authorize_status = 'AUTHORIZED')
    UNION ALL
    SELECT b.ac_hd_id AS act_num, '' AS cust_id,
           b.ac_hd_desc AS customer_name,
           NVL (cur_bal, 0) AS available_balance, 0 AS min_balance,
           branch_code
      FROM gl a, ac_hd b
     WHERE a.authorize_status = 'AUTHORIZED' AND a.ac_hd_id = b.ac_hd_id
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id,
           agency_name AS customer_name, available_balance, 0 AS min_balance,
           branch_id
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

--End Version [Script Version - 0.0.212] [ReleaseVersion - 9.2.2.4]--[19-02-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.213] [ReleaseVersion - 9.2.2.4]--[9-03-2016] -- by Sreekrishnan

CREATE OR REPLACE PROCEDURE ACCOUNT_HEAD_CREATION(DESCR VARCHAR2,MODLE VARCHAR2 ) AS
 BEGIN 
   -- EXECUTE ACCOUNT_HEAD_CREATION ('MDSH 2/2015' ,'M');
  Insert into      AC_HD
   (MJR_AC_HD_ID, SUB_AC_HD_ID, AC_HD_CODE, AC_HD_ID, AC_HD_DESC, 
    STATUS, CREATED_DT, DELETED_DT, AUTHORIZE_STATUS, AUTHORIZE_BY, 
    AUTHORIZE_DT, STATUS_BY, STATUS_DT, REC_DETAILED_IN_DAYBOOK, PAY_DETAILED_IN_DAYBOOK, 
    AC_HD_ORDER)          
  SELECT  MJR_AC_HD_ID,SUB_AC_HD_ID,NACHD,NACHD,DESCR,
    'CREATED', NULL, NULL, 'AUTHORIZED', 'sysadmin', 
     NULL, 'admin', NULL, 'Y', 'Y', 
     NACHD FROM (SELECT MJR_AC_HD_ID,SUB_AC_HD_ID,MAX(AC_HD_ID)+1 AS NACHD FROM AC_HD AH WHERE is_number(AC_HD_ID)=1 and 
     EXISTS (SELECT * FROM NEW_ACC_HEAD WHERE MODULE =MODLE AND MJRHD = AH.MJR_AC_HD_ID )
     GROUP BY MJR_AC_HD_ID,SUB_AC_HD_ID 
     ); 
   COMMIT;
   UPDATE AC_HD AH SET AC_HD_DESC=(SELECT MJR_AC_HD_DESC||' - '||AH.AC_HD_DESC FROM MJR_AC_HD WHERE MJR_AC_HD_ID =AH.MJR_AC_HD_ID ) 
    WHERE AC_HD_DESC =DESCR AND EXISTS (SELECT * FROM NEW_ACC_HEAD WHERE MODULE = MODLE AND MJRHD = AH.MJR_AC_HD_ID) ; 
   COMMIT;   
  INSERT INTO  AC_HD_PARAM
   (AC_HD_ID, FLOAT_ACT, CONTRA_ACT, CR_CLR, CR_TRANS, 
    CR_CASH, DR_CLR, DR_TRANS, DR_CASH, RECONS, 
    F_TRANS_DT, L_TRANS_DT, TRANSPOST, POSTMODE, BALANCETYPE, 
    GLBALANCE, AC_OPEN_DT, AC_CLOSE_DT, STATUS, AUTHORIZE_STATUS, 
    AUTHORIZE_BY, AUTHORIZE_DT, STATUS_BY, STATUS_DT, NEGATIVE_ALLOWED, 
    RECONS_AC_HD_ID, HO_ACCT, DAY_END_ZERO_CHECK)    
   SELECT AC_HD_ID AS AC_HD_ID,'Y' AS FLOAT_ACT, NULL AS CONTRA_ACT, 'Y' AS CR_CLR,
    'Y' AS CR_TRANS, 'Y' AS CR_CASH, 'Y' AS DR_CLR, 'Y' AS DR_TRANS,'Y' AS DR_CASH, 
    'N' AS RECONS,NULL AS F_TRANS_DT, NULL AS L_TRANS_DT, 'BOTH' AS TRANSPOST, 
    'INDIVIDUAL' AS POSTMODE, DECODE(SUBSTR(MJR_AC_HD_ID,1,1),'1','DEBIT',
    '2','CREDIT','4','CREDIT','5','DEBIT') AS BALANCETYPE,0 AS GLBALANCE, NULL AS 
    AC_OPEN_DT, NULL AS AC_CLOSE_DT, 'CREATED' AS STATUS, 'AUTHORIZED' AS 
    AUTHORIZE_STATUS, 'sysadmin' AS AUTHORIZE_BY, NULL AS AUTHORIZE_DT, 'admin' AS 
    STATUS_BY, NULL AS STATUS_DT, 'N' AS NEGATIVE_ALLOWED, NULL AS RECONS_AC_HD_ID, 
    'N' AS HO_ACCT, 'N' AS DAY_END_ZERO_CHECK FROM AC_HD WHERE 
    AC_HD_ID NOT IN(SELECT AC_HD_ID FROM AC_HD_PARAM);
  COMMIT;
   INSERT INTO  BRANCH_GL     (AC_HD_ID, STATUS, GROUP_ID)
    SELECT AC_HD_ID,'CREATED','BG000001' FROM  AC_HD WHERE 
    AC_HD_ID NOT IN(SELECT AC_HD_ID FROM BRANCH_GL)  ;    
 COMMIT; 
 END;
/


CREATE TABLE NEW_ACC_HEAD
(
  MODULE  VARCHAR2(1 BYTE),
  MJRHD   VARCHAR2(10 BYTE)
)

--End Version [Script Version - 0.0.213] [ReleaseVersion - 9.2.2.4]--[9-03-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.214] [ReleaseVersion - 9.2.2.4]--[10-03-2016] -- by Nithya

Insert into SCREEN_MASTER
        (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
        MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
        RECORD_KEY_COL, SCREEN_DESC)
    Values
        ('SCR09993', '3100', 'Deposit Account Search', 'APP01', 'DONE',
        '6', 'com.see.truetransact.ui.deposit.CheckCustomerDepositsUI', 7, 'CREATED', NULL,
        NULL, 'Deposit Search');
       
       
call INSERT_REPORT_GROUP('SCR09993');

--End Version [Script Version - 0.0.214] [ReleaseVersion - 9.2.2.4]--[10-03-2016] -- by Nithya

--Start Version [Script Version - 0.0.215] [ReleaseVersion - 9.2.2.4]--[10-03-2016] -- by Rishad
CREATE OR REPLACE PACKAGE PkgReports AS 
  function get_achd_desc (achd varchar) return varchar;
  
  FUNCTION fngetrelationtype(custid VARCHAR) return varchar2;
  
  FUNCTION GetcustFullName(Custid VARCHAR2,reptype number ) RETURN VARCHAR2;
  
  FUNCTION Getcustidbyaccountno(Acctno VARCHAR2) RETURN VARCHAR2;
  
 function get_otherBank_Name (acNo varchar) return varchar;
 
END PkgReports;
/

CREATE OR REPLACE PACKAGE BODY PkgReports
AS
function get_achd_desc (achd varchar) return varchar
is

hdtype varchar(100);

begin

    SELECT AC_HD_DESC
      INTO hdtype
      FROM ac_hd  join mjr_ac_hd  on AC_HD.MJR_AC_HD_ID = MJR_AC_HD.MJR_AC_HD_ID
     WHERE ac_hd_id=achd
  ORDER BY 1;
 
  return hdtype;

end get_achd_desc;

FUNCTION fngetrelationtype(custid VARCHAR)
       RETURN varchar2
    IS
       cust_id   varchar2(15);
    BEGIN
   
SELECT nvl(case when upper(care_of) ='HUSBAND' then 'W/o'
            when upper(GENDER)='MALE' and upper(care_of) ='MOTHER' then ' S/o'
            when upper(GENDER)='FEMALE' and upper(care_of) ='MOTHER' then ' D/o'
            when upper(GENDER)='MALE' and upper(care_of) ='MOTHER' then ' S/o'
            when upper(GENDER)='FEMALE' and upper(care_of) ='MOTHER' then ' D/o'else '  ' end,'  ')
             relation into cust_id
  FROM customer
 WHERE cust_id = custid ;
    
       RETURN cust_id;
    END fngetrelationtype;
    
FUNCTION GetcustFullName(Custid VARCHAR2,reptype number )
RETURN VARCHAR2 IS
    CustName VARCHAR2(500);
BEGIN
   
     SELECT case when 1=Reptype then DECODE (cust_type,'INDIVIDUAL', fname, comp_name) ||' ' ||MNAME||' ' ||LNAME  -- full name
                 when 2=Reptype then DECODE (cust_type,'INDIVIDUAL', fname, comp_name) -- first name
                 when 3=Reptype then MNAME -- middle name
                 when 4=Reptype then LNAME -- last name   
                 when 5=Reptype then DECODE (cust_type,'INDIVIDUAL', fname, comp_name) ||' ' ||MNAME||' ' ||LNAME ||' '||pkgreports.fngetrelationtype(CUST_ID)||' '||CARE_OF_NAME --- with care of name
             end as CustName into CustName
        from customer where CUST_ID=Custid;
       
    RETURN CustName;
END GetcustFullName;

FUNCTION Getcustidbyaccountno(Acctno VARCHAR2)
RETURN VARCHAR2 IS
    Custid VARCHAR2(100);
BEGIN
select custid INTO Custid
from (
SELECT b.CUST_ID custid
  FROM customer a
  JOIN act_master b
    ON a.cust_id = b.cust_id
 WHERE b.act_num = Acctno
 union all
  SELECT b.CUST_ID custid
  FROM customer a
  JOIN LOANS_BORROWER b  
    ON a.cust_id = b.CUST_ID
  join loans_facility_details c
  on b.BORROW_NO=c.BORROW_NO
 WHERE c.ACCT_NUM = Acctno
  UNION ALL
SELECT b.CUST_ID custid
  FROM customer a
  JOIN deposit_acinfo b
    ON a.cust_id = b.CUST_ID
 WHERE b.DEPOSIT_NO = Acctno
 union all
    SELECT b.SUSPENSE_CUSTOMER_ID custid
  FROM customer a
  JOIN SUSPENSE_ACCOUNT_MASTER b
    ON a.cust_id = b.SUSPENSE_CUSTOMER_ID
 WHERE b.SUSPENSE_ACCT_NUM =Acctno
 );
 
    RETURN custid;
END Getcustidbyaccountno;

 function get_otherBank_Name (acNo varchar) return varchar
is
hdtype varchar(100);
begin
    SELECT AGENCY_NAME
      INTO hdtype
      FROM OTHER_BANKS_ACT_MASTER 
     WHERE ACT_MASTER_ID=acNo
  ORDER BY 1;
  return hdtype;
end get_otherBank_Name ;

END pkgreports;
/

--End Version [Script Version - 0.0.215] [ReleaseVersion - 9.2.2.4]--[10-03-2016] -- by Rishad

--Strart Version [Script Version - 0.0.216] [ReleaseVersion - 9.2.2.4]--[18-03-2016] -- by Sreekrishnan
    ALTER TABLE OP_AC_PRODUCT ADD WITHDRAWAL_CHARGE VARCHAR2 (1 Byte)

    ALTER TABLE OP_AC_PRODUCT ADD WITHDRAWAL_CHARGE_PERIOD NUMBER

    ALTER TABLE OP_AC_CHARGES_PARAM ADD DEBIT_CHARGE_RATE_TYPE VARCHAR2 (16 Byte) 

    ALTER TABLE OP_AC_CHARGES_PARAM ADD DEBIT_CHARGE_RATE NUMBER 

    ALTER TABLE OP_AC_ACHEAD_PARAM ADD DEBIT_CHARGE_HD VARCHAR2 (16 Byte)

    ALTER TABLE GOLD_CONFIGURATION ADD DEFAULT_ITEM VARCHAR2 (1 Byte) 
--End Version [Script Version - 0.0.216] [ReleaseVersion - 9.2.2.4]--[18-03-2016] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.217] [ReleaseVersion - 9.2.2.4]--[18-03-2016] -- by Nithya

CREATE TABLE DEPO_THRIFTBENEVOLENT_INSTALL(
PROD_ID VARCHAR2(16),
EFFECTIVE_DATE DATE,
INSTALLMENT_AMT NUMBER(16,2),
OPERATES_LIKE VARCHAR2(30),
CONSTRAINT PK_ID PRIMARY KEY(PROD_ID,EFFECTIVE_DATE)
);


CREATE TABLE DEPO_ACCT_THRIFTBENEVOLENT(
  PROD_ID VARCHAR2(16),
  DEPOSIT_NO VARCHAR2(16),
  EFFECTIVE_DATE DATE,
  ADDITIONAL_AMT NUMBER(12,2),
  CONSTRAINT PK_ACCT_ID PRIMARY KEY(PROD_ID,DEPOSIT_NO,EFFECTIVE_DATE) 
);

ALTER TABLE LOAN_ARBITRATION ADD ARC_CUST_REP_TDT DATE;

ALTER TABLE LOAN_ARBITRATION ADD ARC_STATUS VARCHAR2(2);

ALTER TABLE LOAN_ARBITRATION ADD PROD_ID VARCHAR2(16);

ALTER TABLE LOAN_ARBITRATION ADD BRANCH_ID VARCHAR2(16);

COMMIT;

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('OPERATIVE_ACCT.CHARGETYPE', 'FIXED', 'Fixed', 'CREATED', NULL, 
    'Y');
    

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('OPERATIVE_ACCT.CHARGETYPE', 'PERCENT', 'Percent', 'CREATED', NULL, 
    'Y');  
    
commit;   

--End Version [Script Version - 0.0.217] [ReleaseVersion - 9.2.2.4]--[18-03-2016] -- by Nithya

--Strart Version [Script Version - 0.0.218] [ReleaseVersion - 9.2.2.4]--[21-03-2016] -- by Rishad

CREATE OR REPLACE FUNCTION GET_STANDING_AMT(prodid VARCHAR2,PRODTYPE varchar2,ACTNUM VARCHAR2,InstNo NUMBER,DEBITAMT NUMBER) 
RETURN NUMBER IS
   DEBITAMT1 NUMBER(16,2) := 0;
   REPAYMENTTYPE varchar2(20);
BEGIN 
   IF PRODTYPE= 'TL' THEN
    SELECT P.REPAYMENT_TYPE INTO REPAYMENTTYPE  FROM LOANS_PRODUCT p WHERE P.prod_id=prodid;
    IF REPAYMENTTYPE='EMI'
    THEN SELECT GET_TL_INST(ACTNUM)*InstNo INTO DEBITAMT1  FROM DUAL;
    ELSE DEBITAMT1:=DEBITAMT;
    END IF;
   ELSE DEBITAMT1:=DEBITAMT;
    END IF;
    RETURN DEBITAMT1;
END;
/

--End Version [Script Version - 0.0.218] [ReleaseVersion - 9.2.2.4]--[21-03-2016] -- by Rishad

--Strart Version [Script Version - 0.0.219] [ReleaseVersion - 9.2.2.4]--[31-03-2016] -- by Rishad

CREATE TABLE THRIFTBEN_INT_CALC_MASTER
(
  PROD_ID              VARCHAR2(64 BYTE),
  DEBIT_GL             VARCHAR2(128 BYTE),
  PAYABLE_GL           VARCHAR2(128 BYTE),
  FROM_PERIOD          DATE,
  TO_PERIOD            DATE,
  INT_PERCENT          NUMBER(16,2),
  RESERVEFUND_PERCENT  NUMBER(16,2),
  RESOLUTION_NO        VARCHAR2(32 BYTE),
  RESOLUTION_DATE      DATE,
  REMARKS              VARCHAR2(128 BYTE),
  TOTAL_INT_AMOUNT     NUMBER(16,2),
  STATUS               VARCHAR2(128 BYTE),
  STATUS_DATE          DATE,
  STATUS_BY            VARCHAR2(16 BYTE),
  CREATED_DT           DATE,
  CREATED_BY           VARCHAR2(16 BYTE),
  BRANCH_CODE          VARCHAR2(16 BYTE),
  AUTHORIZE_BY         VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS     VARCHAR2(16 BYTE),
  AUTHORIZE_DATE       DATE
);

alter table SHARE_CONF_DETAILS  add (SAL_SECURITY_LIMIT number(10));


CREATE TABLE LOANS_SECURITY_VEHICLE
(
  ACCT_NUM           VARCHAR2(16 BYTE),
  MEMBER_NO          VARCHAR2(16 BYTE),
  MEMBER_NAME        VARCHAR2(45 BYTE),
  MEMBER_TYPE        VARCHAR2(16 BYTE),
  CONTACT_NO         NUMBER(12),
  VEHICLE_NO  VARCHAR2(16 BYTE),
  VEHICLE_TYPE  VARCHAR2(16 BYTE),
  RC_BOOK_NO VARCHAR2(16 BYTE),VEHICLE_DATE DATE,
  VEHICLE_DETAILS VARCHAR2(200 BYTE),
  BRANCH_CODE        VARCHAR2(16 BYTE),
  STATUS             VARCHAR2(16 BYTE),
  STATUS_DT          DATE,
  STATUS_BY          VARCHAR2(16 BYTE),
  AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
  AUTHORIZED_DT      DATE,
  AUTHORIZED_BY      VARCHAR2(16 BYTE)
);
--written by prsanthkg
CREATE OR REPLACE Function Get_TDBD_Interest(DepositNo varchar,Behaveslike varchar,FrmDt Date,ToDate Date,ROI Number) Return Number is
--Declare 
--DepositNo varchar2(15) := '0001203001096';
--Behaveslike varchar2(25) := 'BENEVOLENT';
--FrmDt Date := '01-apr-2015';
--ToDate date := '31-mar-2016';
--ROI Number(12,2) := 12;
COUNTR number;
IntrestAmt number(12,2) := 0;
DaysDiff number(12);
Begin
if Behaveslike = 'THRIFT' THEN   
SELECT COUNT(*) INTO COUNTR FROM DEPOSIT_RECURRING DR WHERE DR.DEPOSIT_NO_SUB = DepositNo||'_1'
and  DR.TRANS_DT >= FrmDt AND DR.TRANS_DT <= ToDate;
if Countr >= 1 then
Declare 
Cursor A is 
Select d.trans_dt, sum(nvl(D.AMOUNT,0) + nvl(D.ADT_AMT,0)) as Amt  From deposit_recurring D WHERE D.DEPOSIT_NO_SUB = DepositNo||'_1'
and  D.TRANS_DT >= FrmDt AND D.TRANS_DT <= ToDate
group by d.trans_dt
order by d.trans_dt;
Begin
        For I In a Loop
        Select to_date(ToDate) - to_date(i.trans_dt) into DaysDiff From dual;
   --   dbms_output.put_line ('DaysDiff ='||DaysDiff);
        IntrestAmt := nvl(IntrestAmt,0) + (i.amt  * Roi * DaysDiff)/36500;
   --     dbms_output.put_line ('IntrestAmt ='||IntrestAmt);
        End loop;
End;
Else
IntrestAmt := 0 ;
End if;
Else 
if Behaveslike = 'BENEVOLENT' THEN
SELECT COUNT(*) INTO COUNTR FROM DEPOSIT_RECURRING DR WHERE DR.DEPOSIT_NO_SUB = DepositNo||'_1'
and  DR.TRANS_DT >= FrmDt AND DR.TRANS_DT <= ToDate;
if Countr >= 1 then
Declare 
Cursor A is 
Select d.trans_dt, sum(nvl(D.AMOUNT,0) + nvl(D.ADT_AMT,0)) as Amt  From deposit_recurring D WHERE D.DEPOSIT_NO_SUB = DepositNo||'_1'
and  D.TRANS_DT >= FrmDt AND D.TRANS_DT <= ToDate
group by d.trans_dt
order by d.trans_dt;
Begin
        For I In a Loop
        Select to_date(ToDate) - to_date(i.trans_dt) into DaysDiff From dual;
      dbms_output.put_line ('DaysDiff ='||DaysDiff);
        IntrestAmt := nvl(IntrestAmt,0) + (i.amt  * Roi * DaysDiff)/36500;
        dbms_output.put_line ('IntrestAmt ='||IntrestAmt);
        End loop;
End;
Else
IntrestAmt := 0 ;
End If;
End If;
End If;
--dbms_output.put_line('IntrestAmt= '||IntrestAmt);
Return IntrestAmt;
End;
/
CREATE OR REPLACE Function Get_Thrift_IntPyble_Premat(actnumber varchar,asondt Date) return Number is 
-- DECLARE 
--    ACTNUMBER VARCHAR2(13) := '0001208000456';
--    ASONDT DATE := '05-feb-2016';
    COUNTR NUMBER(10);
    FINDATE DATE ;
    DaysDiff number;
    IntrestAmt number(12,2);
    roundoff varchar2(20);
 BEGIN
        SELECT GET_LAST_FINENDDATE(ASONDT) + 1 INTO FINDATE FROM DUAL;
        SELECT COUNT(*) INTO COUNTR FROM DEPOSIT_RECURRING DR WHERE DR.DEPOSIT_NO_SUB = ACTNUMBER||'_1'
        and  DR.TRANS_DT >= FINDATE AND DR.TRANS_DT <= ASONDT;
    IF COUNTR > 0 THEN
        Declare cursor a is 
        Select d.trans_dt, sum(nvl(D.AMOUNT,0) + nvl(D.ADT_AMT,0)) as Amt  From deposit_recurring D WHERE D.DEPOSIT_NO_SUB = ACTNUMBER||'_1'
        and  D.TRANS_DT >= FINDATE AND D.TRANS_DT <= ASONDT
        group by d.trans_dt
        order by d.trans_dt;
        ROI number(12,2);
        begin
        For I In a Loop
        select get_Thrift_ROI(actnumber,i.trans_dt)  into ROI from dual;
      dbms_output.put_line ('ROI ='||ROI);
        Select to_date(asondt) - to_date(i.trans_dt) into DaysDiff From dual;
      dbms_output.put_line ('DaysDiff ='||DaysDiff);
        IntrestAmt := nvl(IntrestAmt,0) + (i.amt  * Roi * DaysDiff)/36500;
        dbms_output.put_line ('IntrestAmt ='||IntrestAmt);
        End loop;
        End;
    --ELSE
    END IF;
    select nvl(ROUNDOFF_CRITERIA,'NEAREST_VALUE') into roundoff from DEPOSITS_PROD_SCHEME dps where DPS.PROD_ID = substr(actnumber,5,3);
    if roundoff = 'NEAREST_VALUE' then
    IntrestAmt := round(IntrestAmt,0);
    End if;
    Return IntrestAmt; 
 END;
/
CREATE OR REPLACE Function Get_recovery_TDBD(DepositNo Varchar,Behaveslike Varchar,AsonDT Date) return Number is
--Declare 
--DepositNo Varchar2(15) := '0001203001096';
--Behaveslike Varchar2(50) := 'BENEVOLENT';
--ASONDT Date :='31-mar-2015';
INSTAMT number(12,2);
addamt number(12,2);
TotalDemad number(12,2);
Begin
SELECT nvl(D.INSTALLMENT_AMT,0)
  INTO INSTAMT
  FROM DEPO_THRIFTBENEVOLENT_INSTALL D
 WHERE d.OPERATES_LIKE = Behaveslike and D.EFFECTIVE_DATE = (SELECT MAX (S.EFFECTIVE_DATE)
                             FROM DEPO_THRIFTBENEVOLENT_INSTALL S
                            WHERE S.PROD_ID = D.PROD_ID) ;
if Behaveslike = 'THRIFT' then
Select nvl(ADDITIONAL_AMT,0) into addamt from DEPO_ACCT_THRIFTBENEVOLENT dat
where dat.DEPOSIT_NO  = DepositNo and dat.EFFECTIVE_DATE = 
(select max(r.EFFECTIVE_DATE) from DEPO_ACCT_THRIFTBENEVOLENT r where r.deposit_no = dat.deposit_no);
End iF;
If Behaveslike = 'THRIFT' then 
TotalDemad :=INSTAMT + addamt;
Else
TotalDemad :=INSTAMT;
End if;
--Dbms_output.put_line('TotalDemad  ='||TotalDemad);
Return TotalDemad ;
End;
/

--End Version [Script Version - 0.0.219] [ReleaseVersion - 9.2.2.4]--[31-03-2016] -- by Rishad

--Strart Version [Script Version - 0.0.220] [ReleaseVersion - 9.2.2.4]--[5-04-2016] -- by Sreekrishnan

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12240', '12240', 'Share Dividend Payment Transfer', 'APP01', 'DONE', 
    '15', NULL, 4, 'CREATED', NULL, 
    NULL, 'Share Dividend Payment Transfer');
COMMIT;

call INSERT_REPORT_GROUP('SCR12240');

--End Version [Script Version - 0.0.220] [ReleaseVersion - 9.2.2.4]--[5-04-2016] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.221] [ReleaseVersion - 9.2.2.4]--[08-04-2016] -- by Rishad

CREATE OR REPLACE FUNCTION GET_TL_INST(ACTNUM VARCHAR2) 
RETURN NUMBER IS
    INST_AMT NUMBER(16,2) := 0;
BEGIN
    SELECT MAX(I.TOTAL_AMT) INTO INST_AMT
    FROM LOANS_INSTALLMENT I
    WHERE I.ACCT_NUM = ACTNUM AND I.STATUS != 'DELETED' AND NVL(I.ACTIVE_STATUS,'Y') = 'Y' AND
          I.INSTALLMENT_SLNO = (SELECT MIN(LI.INSTALLMENT_SLNO)
                                FROM LOANS_INSTALLMENT LI 
                                WHERE LI.ACCT_NUM = ACTNUM AND LI.STATUS != 'DELETED' AND NVL(LI.ACTIVE_STATUS,'Y') = 'Y' ); 
    RETURN INST_AMT;
END;
/
--End Version [Script Version - 0.0.221] [ReleaseVersion - 9.2.2.4]--[08-04-2016] -- by Rishad

--Strart Version [Script Version - 0.0.222] [ReleaseVersion - 9.2.2.4]--[11-04-2016] -- by Sreekrishnan
CREATE OR REPLACE PROCEDURE UPDATED_DEPOSIT_MULTIPLEID(DEPONO varchar2)
AS
BEGIN
     UPDATE DEPOSIT_ACINFO DA set DA.MULTIPLE_DEPOSIT_ID ='' where DA.DEPOSIT_NO = substr(DEPONO,0,13) and DA.MULTIPLE_DEPOSIT_ID is not null;
     UPDATE DEPOSIT_SUB_ACINFO DSA set DSA.MULTIPLE_DEPOSIT_ID = '' where DSA.DEPOSIT_NO = substr(DEPONO,0,13) and DsA.MULTIPLE_DEPOSIT_ID is not null;
     COMMIT; 
END;
/

--Add Which ever products want for deposit standing instruction selection on screen
SET DEFINE OFF;
Insert into PERILAT.LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INTEREST_TRANS_PRODUCTTYPE', 'TL', 'Term Loans', 'CREATED', 'N', 
    'Y');
COMMIT;

--End Version [Script Version - 0.0.222] [ReleaseVersion - 9.2.2.4]--[11-04-2016] -- by Sreekrishnan

--Strart Version [Script Version - 0.0.223] [ReleaseVersion - 9.2.2.4]--[06-05-2016] -- by Rishad
alter table PAY_SETTINGS modify(srl_no number);
alter table PAYMASTER modify(srl_no number);
alter table LOANS_PROD_ACPARAM add (IS_INTEREST_LOAN_DUE VARCHAR2(10))

--End Version [Script Version - 0.0.222] [ReleaseVersion - 9.2.2.4]--[06-05-2016] -- by Rishad

--Strart Version [Script Version - 0.0.224] [ReleaseVersion - 9.2.2.5]--[08-04-2016] -- by Nithya

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('EMPLOYEE.DEPARTMENT', 'Appr', 'Appr', 'CREATED', 'N', 
    'Y');

INSERT INTO DESIG_MASTER 
 (DESIG_ID, DESIG_DESCIP, STATUS)
 Values
   ('Appr', 'Appraiser', 'CREATED')

--End Version [Script Version - 0.0.224] [ReleaseVersion - 9.2.2.5]--[08-04-Y2016] -- by Nithya

--Start Version [Script Version - 0.0.225] [ReleaseVersion - 9.2.2.5]--[06-05-2016] -- by Sreekrishnan

CREATE OR REPLACE FUNCTION GET_SHARE_PENSION(SHARENO VARCHAR,ASON DATE,PENSIONSTARTDT DATE)
RETURN NUMBER IS
    PENSION NUMBER(16,2) := 0;
BEGIN
                                SELECT FLOOR ((MONTHS_BETWEEN (LAST_DAY(ASON), LAST_DAY (NVL ((SELECT MAX (trans_dt)
                                                    FROM share_penson_trans
                                                   WHERE share_acct_no =
                                                              SHARENO
                                                     AND status != 'DELETED'
                                                     AND authorized_status =
                                                                  'AUTHORIZED'),
                                                 PENSIONSTARTDT
                                                )
                                           )))) INTO PENSION FROM DUAL;
    RETURN PENSION;
END;
/

CREATE OR REPLACE FUNCTION GET_DAILY_LOAN_COLLECTION(ACTNUM VARCHAR,UPTO DATE)
RETURN NUMBER IS
    COLLECTION NUMBER(16,2) := 0;
BEGIN
    SELECT SUM(LT.PRINCIPLE) INTO COLLECTION FROM LOAN_TRANS_DETAILS LT WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT>UPTO;
    RETURN COLLECTION;
END;
/

ALTER TABLE SECURITY_DETAILS ADD RELEASE_DT date;
--End Version [Script Version - 0.0.225] [ReleaseVersion - 9.2.2.5]--[06-05-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.226] [ReleaseVersion - 9.2.2.5]--[09-05-2016] -- by Sathiya

ALTER TABLE CUSTOMER ADD AGENT_CUST_ID VARCHAR2(16);

ALTER TABLE AGENT_MASTER ADD (REGION VARCHAR2(16),TXN_TYPE VARCHAR2(16));

ALTER TABLE LOANS_PRODUCT ADD INTEREST_TYPE VARCHAR2(32) DEFAULT 'N';

ALTER TABLE PARAMETERS ADD APP_SUSPENSE_ACHD VARCHAR2(16);

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCRA6109', '6109', 'App Agent Collection Details', 'APP01', 'DONE', 
    '8', 'App Agent Collection Details', 5, 'CREATED', 'App Agent Collection Details');
COMMIT;

call INSERT_REPORT_GROUP('SCRA6109');

INSERT INTO LOOKUP_MASTER (LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC,STATUS,EDITABLE,AUTHORIZED)VALUES(
'AGENT_APP_TRANSACTION_TYPE','DEBIT','Debit','CREATED','','Y');

INSERT INTO LOOKUP_MASTER (LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC,STATUS,EDITABLE,AUTHORIZED)VALUES(
'AGENT_APP_TRANSACTION_TYPE','CREDIT','Credit','CREATED','','Y');

INSERT INTO LOOKUP_MASTER (LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC,STATUS,EDITABLE,AUTHORIZED)VALUES(
'AGENT_APP_TRANSACTION_TYPE','BOTH','Both','CREATED','','Y');

INSERT INTO LOOKUP_MASTER (LOOKUP_ID,LOOKUP_REF_ID,LOOKUP_DESC,STATUS,EDITABLE,AUTHORIZED)VALUES(
'AGENT_APP_REGION','OLLUKKARA','Ollukkara','CREATED','','Y');

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('AGENT_LEAVE_ID', 1, 'AL', TO_DATE('05/05/2004 16:17:44', 'MM/DD/YYYY HH24:MI:SS'), 10, 
    '0001');
COMMIT;

CREATE OR REPLACE function GETCUSTAGENTSTATUS(CUSTID VARCHAR2) RETURN VARCHAR2 IS
    ISAGENT VARCHAR2(128);
BEGIN
    SELECT NVL((IS_AGENT),'N') INTO ISAGENT FROM CUSTOMER WHERE CUST_ID=CUSTID;
    RETURN ISAGENT;
    EXCEPTION WHEN OTHERS THEN RETURN NULL;
END;
/

CREATE TABLE APP_TRANS_DETAILS
(
  CUST_ID           VARCHAR2(16 BYTE),
  PROD_TYPE         VARCHAR2(16 BYTE),
  AGENT_CUST_ID     VARCHAR2(16 BYTE),
  ACT_NUM           VARCHAR2(16 BYTE),
  AMOUNT            NUMBER,
  TXN_TYPE          VARCHAR2(16 BYTE),
  CREATED_DT        DATE,
  STATUS_DT         DATE,
  STATUS_BY         VARCHAR2(16 BYTE),
  STATUS            VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS  VARCHAR2(16 BYTE),
  AUTHORIZE_BY      VARCHAR2(16 BYTE),
  AUTHORIZE_DT      DATE,
  IS_TXN            VARCHAR2(3 BYTE),
  CASH_ID           VARCHAR2(16 BYTE),
  BATCH_ID          VARCHAR2(16 BYTE),
  APP_ID            VARCHAR2(16 BYTE),
  TRANS_DT          DATE,
  BRANCH_ID         VARCHAR2(16 BYTE),
  VALUE_DT          DATE
)

CREATE TABLE AGENT_LEAVE_DETAILS
(
  L_AGENT_ID        VARCHAR2(16 BYTE),
  L_AGENT_NAME      VARCHAR2(64 BYTE),
  L_REGION          VARCHAR2(16 BYTE),
  C_AGENT_ID        VARCHAR2(16 BYTE),
  C_AGENT_NAME      VARCHAR2(64 BYTE),
  C_REGION          VARCHAR2(16 BYTE),
  TXN_TYPE          VARCHAR2(16 BYTE),
  FROM_DATE         DATE,
  TO_DATE           DATE,
  STATUS_DT         DATE,
  STATUS_BY         VARCHAR2(16 BYTE),
  STATUS            VARCHAR2(16 BYTE),
  AUTHORIZE_DT      DATE,
  AUTHORIZE_BY      VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS  VARCHAR2(16 BYTE),
  SL_NO             NUMBER(6),
  AGENT_LEAVE_ID    VARCHAR2(16 BYTE)
)

CREATE TABLE APP_USER_LOGIN_HISTORY
(
  USER_ID       VARCHAR2(32 BYTE),
  BRANCH_CODE   VARCHAR2(32 BYTE),
  DATE_TIME     DATE,
  LOGIN_STATUS  VARCHAR2(8 BYTE)
)

CREATE TABLE APP_USER_LOGIN_HISTORY
(
  USER_ID       VARCHAR2(32 BYTE),
  BRANCH_CODE   VARCHAR2(32 BYTE),
  DATE_TIME     DATE,
  LOGIN_STATUS  VARCHAR2(8 BYTE)
)

CREATE OR REPLACE FORCE VIEW ALL_AGENTS_ACCOUNTS
(
   CUST_ID,
   NAME,
   ACT_NUM,
   PROD_TYPE,
   PROD_ID,
   PROD_DESC,
   BASE_CURRENCY,
   BRANCH_NAME,
   LAST_TRANS_DT,
   CUST_USERID,
   BRANCH_ID,
   ACCT_STATUS,
   AVAILABLE_BALANCE,
   AGENT_CUST_ID,
   UNIQUE_ID,
   PAN_NUMBER
)
AS
   (SELECT AM.cust_id,
           get_joint_cust (am.act_num) AS NAME,
           am.act_num AS act_num,
           'OA' AS prod_type,
           am.prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (AM.BRANCH_CODE) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (AM.CUST_ID) CUST_USERID,
           AM.branch_code AS branch_id,
           am.act_status_id AS acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM act_master am, CUSTOMER C, all_products ap
     WHERE     C.CUST_ID = AM.CUST_ID
           AND am.authorization_status = 'AUTHORIZED'
           AND am.prod_id = ap.prod_id
           AND ACT_STATUS_ID = 'NEW'
           AND am.status IN ('CREATED', 'MODIFIED')
    UNION ALL
    SELECT DA.cust_id,
           get_joint_cust (da.deposit_no) AS NAME,
           da.deposit_no AS act_num,
           'TD' AS prod_type,
           da.prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (branch_id) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (DA.CUST_ID) CUST_USERID,
           branch_id,
           ds.acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM deposit_acinfo da,
           deposit_sub_acinfo ds,
           CUSTOMER C,
           DEPOSITS_PRODUCT DP,
           all_products ap
     WHERE     C.CUST_ID = DA.CUST_ID
           AND DP.PROD_ID = DA.PROD_ID
           AND da.authorize_status = 'AUTHORIZED'
           AND ds.deposit_no = da.deposit_no
           AND da.prod_id = ap.prod_id
           AND DP.BEHAVES_LIKE = 'RECURRING'
           AND ACCT_STATUS = 'NEW'
           AND da.status IN ('CREATED', 'MODIFIED', 'LIEN')
    UNION ALL
    SELECT LB.cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'TL' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (branch_id) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (LB.CUST_ID) CUST_USERID,
           branch_id,
           lfd.acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM loans_facility_details lfd,
           loans_borrower lb,
           CUSTOMER C,
           all_products ap
     WHERE     C.CUST_ID = LB.CUST_ID
           AND lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND behaves_like NOT IN ('OD', 'CC')
           AND ACCT_STATUS = 'NEW'
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
    UNION ALL
    SELECT LB.cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'AD' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (branch_id) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (LB.CUST_ID) CUST_USERID,
           branch_id,
           lfd.acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM loans_facility_details lfd,
           loans_borrower lb,
           CUSTOMER C,
           all_products ap
     WHERE     C.CUST_ID = LB.CUST_ID
           AND lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND ACCT_STATUS = 'NEW'
           AND behaves_like IN ('OD', 'CC')
    UNION ALL
    SELECT LB.cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'ATL' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (branch_id) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (LB.CUST_ID) CUST_USERID,
           branch_id,
           lfd.acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM agri_loans_facility_details lfd,
           loans_borrower lb,
           CUSTOMER C,
           all_products ap
     WHERE     C.CUST_ID = LB.CUST_ID
           AND lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND ACCT_STATUS = 'NEW'
           AND behaves_like NOT IN ('AOD', 'ACC')
    UNION ALL
    SELECT LB.cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'AAD' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (branch_id) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (LB.CUST_ID) CUST_USERID,
           branch_id,
           lfd.acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM agri_loans_facility_details lfd,
           loans_borrower lb,
           CUSTOMER C,
           all_products ap
     WHERE     C.CUST_ID = LB.CUST_ID
           AND lfd.authorize_status_1 = 'AUTHORIZED'
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND ACCT_STATUS = 'NEW'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND behaves_like IN ('AOD', 'ACC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (am.suspense_acct_num) AS NAME,
           am.suspense_acct_num AS act_num,
           'SA' AS prod_type,
           am.suspense_prod_id AS prod_id,
           ap.prod_desc,
           'INR' BASE_CURRENCY,
           GETBRANCHNAME (am.branch_code) BRANCH_NAME,
           LAST_TRANS_DT,
           GETCUSTUSERID (CUST_ID) CUST_USERID,
           am.branch_code AS branch_id,
           'NEW' AS acct_status,
           clear_balance AS AVAILABLE_BALANCE,
           C.AGENT_CUST_ID AGENT_CUST_ID,
           C.UNIQUE_ID UNIQUE_ID,
           C.PAN_NUMBER PAN_NUMBER
      FROM suspense_account_master am, customer c, all_products ap
     WHERE     am.suspense_customer_id = c.cust_id
           AND am.authorize_status = 'AUTHORIZED'
           AND am.suspense_prod_id = ap.prod_id
           AND am.status IN ('CREATED', 'MODIFIED'));

CREATE OR REPLACE PACKAGE PKGGENREPORTS AS  
/*
AUTHOR: Sathiya
Version 01-04-2016_1

*/
  
  FUNCTION GetProdIDbyaccountno(Acctno VARCHAR2) RETURN VARCHAR2;
  
  FUNCTION getheadtype (prodid VARCHAR2) RETURN varchar2;  
  
END PKGGENREPORTS;
/

CREATE OR REPLACE PACKAGE BODY PKGGENREPORTS 
AS
FUNCTION GetProdIDbyaccountno(Acctno VARCHAR2)
RETURN VARCHAR2 IS
    prodid VARCHAR2(100);
BEGIN
      
select prodid INTO prodid
from (
    SELECT PROD_ID prodid
      FROM act_master  
     WHERE act_num = Acctno
     union all 
    SELECT substr(BORROW_NO,5,3) prodid
      FROM LOANS_BORROWER  
     WHERE BORROW_NO = Acctno
 );
    RETURN prodid;
END GetProdIDbyaccountno;

FUNCTION getheadtype (prodid VARCHAR2)
   RETURN varchar2
IS
   headtype   varchar2(16);
BEGIN
   
   SELECT acct_head
     INTO headtype
     FROM (SELECT ac_hd_id acct_head
             FROM all_products
            WHERE prod_id = prodid AND ROWNUM = 1);

   RETURN headtype;
END getheadtype;                                            
                                                        
END PKGGENREPORTS;
/

--End Version [Script Version - 0.0.226] [ReleaseVersion - 9.2.2.5]--[09-05-2016] -- by Sathiya

--Start Version [Script Version - 0.0.227] [ReleaseVersion - 9.2.2.5]--[10-05-2016] -- by Sreekrishnan
DROP VIEW ALL_CUSTOMER_BALANCE;

/* Formatted on 2016/05/10 13:25 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_customer_balance (act_num,
                                                           cust_id,
                                                           customer_name,
                                                           available_balance,
                                                           min_balance,
                                                           branch_code,
                                                           prod_id
                                                          )
AS
   (SELECT ac.act_num, cust_id, acct_name AS customer_name,
           NVL (available_balance, 0) AS available_balance,
           NVL (CASE
                   WHEN ap.chk_book = 'Y'
                      THEN op.min_bal_w_chk
                   ELSE op.min_bal_wt_chk
                END,
                0
               ) AS min_balance,
           branch_code, ac.prod_id
      FROM act_master ac, act_param_detail ap, op_ac_account_param op
     WHERE act_status_id != 'CLOSED'
       AND op.prod_id = ac.prod_id
       AND ap.act_num = ac.act_num
       AND ac.status != 'DELETED'
       AND ac.authorization_status = 'AUTHORIZED'
    UNION ALL
    SELECT suspense_acct_num AS act_num, suspense_customer_id AS cust_id,
           suspense_name AS customer_name,
           NVL (clear_balance, 0) AS available_balance, 0 AS min_balance,
           branch_code, suspense_prod_id AS prod_id
      FROM suspense_account_master
     WHERE status != 'DELETED' AND authorize_status = 'AUTHORIZED'
    UNION ALL
    SELECT dsa.deposit_no || '_' || dsa.deposit_sub_no AS act_num, da.cust_id,
           DECODE (cu.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           dsa.available_balance, 0 AS min_balance,
           da.branch_id AS branch_code, da.prod_id
      FROM deposit_sub_acinfo dsa, deposit_acinfo da, customer cu
     WHERE da.cust_id = cu.cust_id
       AND da.deposit_no = dsa.deposit_no
       AND da.deposit_status != 'CLOSED'
       AND da.authorize_status = 'AUTHORIZED'
       AND dsa.available_balance > 0
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           NVL (available_balance, 0) AS available_balance, 0 AS min_balance,
           branch_id AS branch_code, lfd.prod_id
      FROM loans_borrower lb, customer cu, loans_facility_details lfd
     WHERE lb.cust_id = cu.cust_id
       AND lb.borrow_no = lfd.borrow_no
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.prod_id IN (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like = 'OD'
                 AND status != 'DELETED'
                 AND authorize_status = 'AUTHORIZED')
    UNION ALL
    SELECT b.ac_hd_id AS act_num, '' AS cust_id,
           b.ac_hd_desc AS customer_name,
           NVL (cur_bal, 0) AS available_balance, 0 AS min_balance,
           branch_code, NULL AS rod_id
      FROM gl a, ac_hd b
     WHERE a.authorize_status = 'AUTHORIZED' AND a.ac_hd_id = b.ac_hd_id
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id,
           agency_name AS customer_name, available_balance, 0 AS min_balance,
           branch_id, am.prod_id
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');
--End Version [Script Version - 0.0.227] [ReleaseVersion - 9.2.2.5]--[10-05-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.228] [ReleaseVersion - 9.2.2.5]--[23-05-2016] -- by Sreekrishnan
DROP VIEW ALL_CUSTOMER_BALANCE;

/* Formatted on 2016/05/23 11:31 (Formatter Plus v4.8.8) */
CREATE OR REPLACE FORCE VIEW all_customer_balance (act_num,
                                                          cust_id,
                                                          customer_name,
                                                          available_balance,
                                                          min_balance,
                                                          branch_code,
                                                          shadow_debit,
                                                          prod_id
                                                         )
AS
   (SELECT ac.act_num, cust_id, acct_name AS customer_name,
           NVL (available_balance, 0) AS available_balance,
           NVL (CASE
                   WHEN ap.chk_book = 'Y'
                      THEN op.min_bal_w_chk
                   ELSE op.min_bal_wt_chk
                END,
                0
               ) AS min_balance,
           branch_code, NVL (shadow_debit, 0) AS shadow_debit, ac.prod_id
      FROM act_master ac, act_param_detail ap, op_ac_account_param op
     WHERE act_status_id != 'CLOSED'
       AND op.prod_id = ac.prod_id
       AND ap.act_num = ac.act_num
       AND ac.status != 'DELETED'
       AND ac.authorization_status = 'AUTHORIZED'
    UNION ALL
    SELECT suspense_acct_num AS act_num, suspense_customer_id AS cust_id,
           suspense_name AS customer_name,
           NVL (clear_balance, 0) AS available_balance, 0 AS min_balance,
           branch_code, NVL (unclear_balance, 0) AS shadow_debit,
           suspense_prod_id AS prod_id
      FROM suspense_account_master
     WHERE status != 'DELETED' AND authorize_status = 'AUTHORIZED'
    UNION ALL
    SELECT dsa.deposit_no || '_' || dsa.deposit_sub_no AS act_num, da.cust_id,
           DECODE (cu.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           dsa.available_balance, 0 AS min_balance,
           da.branch_id AS branch_code, NVL (shadow_debit, 0) AS shadow_debit,
           da.prod_id
      FROM deposit_sub_acinfo dsa, deposit_acinfo da, customer cu
     WHERE da.cust_id = cu.cust_id
       AND da.deposit_no = dsa.deposit_no
       AND da.deposit_status != 'CLOSED'
       AND da.authorize_status = 'AUTHORIZED'
       AND dsa.available_balance > 0
    UNION ALL
    SELECT lfd.acct_num AS act_num, lb.cust_id,
           DECODE (cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name
                  ) AS customer_name,
           NVL (available_balance, 0) AS available_balance, 0 AS min_balance,
           branch_id AS branch_code, NVL (shadow_debit, 0) AS shadow_debit,
           lfd.prod_id
      FROM loans_borrower lb, customer cu, loans_facility_details lfd
     WHERE lb.cust_id = cu.cust_id
       AND lb.borrow_no = lfd.borrow_no
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
       AND lfd.prod_id IN (
              SELECT prod_id
                FROM loans_product
               WHERE behaves_like = 'OD'
                 AND status != 'DELETED'
                 AND authorize_status = 'AUTHORIZED')
    UNION ALL
    SELECT b.ac_hd_id AS act_num, '' AS cust_id,
           b.ac_hd_desc AS customer_name,
           NVL (cur_bal, 0) AS available_balance, 0 AS min_balance,
           branch_code, NVL (shadow_debit, 0) AS shadow_debit, NULL AS rod_id
      FROM gl a, ac_hd b
     WHERE a.authorize_status = 'AUTHORIZED' AND a.ac_hd_id = b.ac_hd_id
    UNION ALL
    SELECT am.act_master_id AS act_num, '' AS cust_id,
           agency_name AS customer_name, available_balance, 0 AS min_balance,
           branch_id, NVL (shadow_debit, 0) AS shadow_debit, am.prod_id
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

--End Version [Script Version - 0.0.228] [ReleaseVersion - 9.2.2.5]--[23-05-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.229] [ReleaseVersion - 9.2.2.5]--[27-05-2016] -- by Sathiya
ALTER TABLE APP_TRANS_DETAILS ADD PERMANENT_AGENT_ID VARCHAR2(16); 
--End Version [Script Version - 0.0.229] [ReleaseVersion - 9.2.2.5]--[27-05-2016] -- by Sathiya

--Start Version [Script Version - 0.0.230] [ReleaseVersion - 9.2.2.5]--[3-06-2016] -- by Sreekrishnan
SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12246', '6139', 'Multiple Standing', 'APP01', 'DONE', 
    '8', NULL, 55, 'CREATED', NULL, 
    NULL, 'Multiple Standing');
COMMIT;


CALL INSERT_REPORT_GROUP('SCR12246');

alter table AGENT_PROD_MAPPING add CONSOLIDATE_TRANS varchar2(1);

CREATE OR REPLACE FUNCTION ROOM_RENT_DUE(BRANCH_ID VARCHAR,RM_ID VARCHAR,RM_NO VARCHAR) RETURN VARCHAR 
IS  
--    BRANCH_ID VARCHAR2(6):='0001';
--    RM_ID VARCHAR2(32):='RM000001';
--    RM_NO VARCHAR2(32):='123';
    BLDNG_NO VARCHAR2(32);
    CURR_DT DATE;
    RENT_DUE_FRM DATE;
    RENT_DUE_DT DATE;
    RENT_DUE_AMT NUMBER(16,2):=0;
    RENT_PENAL NUMBER(16,2):=0;
    RENTAMT NUMBER(16,2):=0;
    PENAL_ROI NUMBER(16,2):=0;
    FREQ VARCHAR2(64);
    CNT NUMBER(16);
    TOT_AMT VARCHAR2(80);
BEGIN
    SELECT CURR_APPL_DT INTO CURR_DT FROM DAY_END WHERE BRANCH_CODE=BRANCH_ID;
    SELECT BUILDING_NUM INTO BLDNG_NO  
    FROM RENT_PROFILE 
    WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
        AND RMNUMBER=RM_ID;
    SELECT COUNT(*) INTO CNT FROM RENT_TRANS 
    WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
        AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED'; 
        DBMS_OUTPUT.PUT_LINE( ' CNT ' || CNT);       
    IF CNT>0 THEN
        SELECT MAX(RENT_PERIOD_TO) INTO RENT_DUE_DT 
        FROM RENT_TRANS 
        WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
            AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED';
        CNT:=1;
        DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_DT ' || RENT_DUE_DT);
        FOR I IN (SELECT EFF_DATE,RENT_AMT,RENT_FRQ,PENEL_RATE 
            FROM RENT_DETAILS 
            WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                AND ROOM_STATUS='REGISTERED' AND RMNUMBER=RM_ID AND ROOMNUM=RM_NO 
                AND EFF_DATE>=(SELECT MAX(EFF_DATE) FROM RENT_DETAILS 
                    WHERE RMNUMBER=RM_ID AND ROOMNUM=RM_NO AND EFF_DATE<=RENT_DUE_DT 
                    AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                    AND ROOM_STATUS='REGISTERED') 
                AND EFF_DATE<=CURR_DT) LOOP
                DBMS_OUTPUT.PUT_LINE( ' CNT 2++' || CNT);       
            IF CNT=1 THEN
                RENT_DUE_FRM:=RENT_DUE_DT;
                RENTAMT:=I.RENT_AMT;
                PENAL_ROI:=I.PENEL_RATE;
                FREQ:=I.RENT_FRQ;
                CNT:=CNT+1;                 
            ELSE 
                SELECT RENT_DUE_AMT+(RENTAMT*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM))) INTO RENT_DUE_AMT FROM DUAL;
                SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
                RENT_DUE_FRM:=I.EFF_DATE;
                RENTAMT:=I.RENT_AMT;
                PENAL_ROI:=I.PENEL_RATE;
                FREQ:=I.RENT_FRQ;
                CNT:=CNT+1;
            END IF;
        END LOOP;
        SELECT RENT_DUE_AMT+(RENTAMT*FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))) INTO RENT_DUE_AMT FROM DUAL;
        DBMS_OUTPUT.PUT_LINE( ' RENTAMT 2++' || RENTAMT); 
        DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_FRM' || RENT_DUE_FRM);   
                DBMS_OUTPUT.PUT_LINE( ' CURR_DT 2++' || CURR_DT);
         DBMS_OUTPUT.PUT_LINE( ' FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))) 2++' || FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))); 
        DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_AMT 2++' || RENT_DUE_AMT);   
        SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
        TOT_AMT:=RENT_DUE_AMT+RENT_PENAL;
    END IF;
RETURN TOT_AMT;    
END;
/

CREATE OR REPLACE FUNCTION ROOM_RENT_PENAL(BRANCH_ID VARCHAR,RM_ID VARCHAR,RM_NO VARCHAR) RETURN VARCHAR 
IS  
--    BRANCH_ID VARCHAR2(6):='0001';
--    RM_ID VARCHAR2(32):='RM000001';
--    RM_NO VARCHAR2(32):='123';
    BLDNG_NO VARCHAR2(32);
    CURR_DT DATE;
    RENT_DUE_FRM DATE;
    RENT_DUE_DT DATE;
    RENT_DUE_AMT NUMBER(16,2):=0;
    RENT_PENAL NUMBER(16,2):=0;
    RENTAMT NUMBER(16,2):=0;
    PENAL_ROI NUMBER(16,2):=0;
    FREQ VARCHAR2(64);
    CNT NUMBER(16);
    TOT_AMT VARCHAR2(80);
BEGIN
    SELECT CURR_APPL_DT INTO CURR_DT FROM DAY_END WHERE BRANCH_CODE=BRANCH_ID;
    SELECT BUILDING_NUM INTO BLDNG_NO  
    FROM RENT_PROFILE 
    WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
        AND RMNUMBER=RM_ID;
    SELECT COUNT(*) INTO CNT FROM RENT_TRANS 
    WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
        AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED'; 
        DBMS_OUTPUT.PUT_LINE( ' CNT ' || CNT);       
    IF CNT>0 THEN
        SELECT MAX(RENT_PERIOD_TO) INTO RENT_DUE_DT 
        FROM RENT_TRANS 
        WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
            AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED';
        CNT:=1;
        DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_DT ' || RENT_DUE_DT);
        FOR I IN (SELECT EFF_DATE,RENT_AMT,RENT_FRQ,PENEL_RATE 
            FROM RENT_DETAILS 
            WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                AND ROOM_STATUS='REGISTERED' AND RMNUMBER=RM_ID AND ROOMNUM=RM_NO 
                AND EFF_DATE>=(SELECT MAX(EFF_DATE) FROM RENT_DETAILS 
                    WHERE RMNUMBER=RM_ID AND ROOMNUM=RM_NO AND EFF_DATE<=RENT_DUE_DT 
                    AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                    AND ROOM_STATUS='REGISTERED') 
                AND EFF_DATE<=CURR_DT) LOOP
                DBMS_OUTPUT.PUT_LINE( ' CNT 2++' || CNT);       
            IF CNT=1 THEN
                RENT_DUE_FRM:=RENT_DUE_DT;
                RENTAMT:=I.RENT_AMT;
                PENAL_ROI:=I.PENEL_RATE;
                FREQ:=I.RENT_FRQ;
                CNT:=CNT+1;                 
            ELSE 
                SELECT RENT_DUE_AMT+(RENTAMT*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM))) INTO RENT_DUE_AMT FROM DUAL;
                SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
                RENT_DUE_FRM:=I.EFF_DATE;
                RENTAMT:=I.RENT_AMT;
                PENAL_ROI:=I.PENEL_RATE;
                FREQ:=I.RENT_FRQ;
                CNT:=CNT+1;
            END IF;
        END LOOP;
        SELECT RENT_DUE_AMT+(RENTAMT*FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))) INTO RENT_DUE_AMT FROM DUAL;
        DBMS_OUTPUT.PUT_LINE( ' RENTAMT 2++' || RENTAMT); 
        DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_FRM' || RENT_DUE_FRM);   
                DBMS_OUTPUT.PUT_LINE( ' CURR_DT 2++' || CURR_DT);
         DBMS_OUTPUT.PUT_LINE( ' FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))) 2++' || FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))); 
        DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_AMT 2++' || RENT_DUE_AMT);   
        SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
        TOT_AMT:=RENT_DUE_AMT+RENT_PENAL;
    END IF;
RETURN TOT_AMT;    
END;
/

--End Version [Script Version - 0.0.230] [ReleaseVersion - 9.2.2.5]--[3-06-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.231] [ReleaseVersion - 9.2.2.5]--[22-06-2016] -- by Nithya

SET DEFINE OFF;

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR09996', '3101', 'Term Loan Repayment Schedule', 'APP01', 'DONE', 
    '5', 'com.see.truetransact.ui.termloan.repayment.RepaymentScheduleCreationUI', 42, 'CREATED', NULL, 
    NULL, 'Term Loan Repayment Schedule');
COMMIT;

CREATE TABLE OP_AC_SECURITY_MEMBER
(
  ACCT_NUM            VARCHAR2(16 BYTE),
  MEMBER_NO           VARCHAR2(16 BYTE),
  MEMBER_NAME         VARCHAR2(45 BYTE),
  MEMBER_TYPE         VARCHAR2(16 BYTE),
  CONTACT_NO          NUMBER(12),
  MEMBER_SALARY       NUMBER(18,2),
  MEMBER_NETWORTH     VARCHAR2(16 BYTE),
  BORROWER_SALARY     NUMBER(18,2),
  BORROWER_NETWORTH   VARCHAR2(16 BYTE),
  BRANCH_CODE         VARCHAR2(16 BYTE),
  STATUS              VARCHAR2(16 BYTE),
  STATUS_DT           DATE,
  STATUS_BY           VARCHAR2(16 BYTE),
  AUTHORIZED_STATUS   VARCHAR2(16 BYTE),
  AUTHORIZED_DT       DATE,
  AUTHORIZED_BY       VARCHAR2(16 BYTE),
  FROM_DT             DATE,
  TO_DT               DATE,
  ACT_STATUS          VARCHAR2(20 BYTE),
  BORROWER_MEMBER_NO  VARCHAR2(20 BYTE)
)

-- End Version [Script Version - 0.0.231] [ReleaseVersion - 9.2.2.5]--[22-06-2016] -- by Nithya 

--Start Version [Script Version - 0.0.231] [ReleaseVersion - 9.2.2.5]--[28-06-2016] -- by Sreekrishnan
ALTER TABLE LOAN_CHARGE_DEFINITION ADD PREMATURE_RATE NUMBER
--End Version [Script Version - 0.0.231] [ReleaseVersion - 9.2.2.5]--[28-06-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.232] [ReleaseVersion - 9.2.2.5]--[04-07-2016] -- by Sathiya

ALTER TABLE AGENT_MASTER ADD LAST_INTRO_PAID_DT DATE;

ALTER TABLE AGENT_COLLECTION_PROD ADD LAST_INTRO_PAID_DT DATE;

ALTER TABLE AGENTS_MONTHLY_SCHEDULE ADD TYPE_OF_COMMISION VARCHAR2(16);

ALTER TABLE AGENTS_MONTHLY_SCHEDULE ADD COMMISION_TO_NEW_AC NUMBER(14,2);

ALTER TABLE DAILY_DEPOSIT_TRANS ADD SCREEN_NAME VARCHAR2(32);

DROP VIEW AGENTMASTDET;

/* Formatted on 16/06/2016 11:12:36 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FORCE VIEW AGENTMASTDET
(
   ACT_NUM,
   FNAME,
   BAL,
   INSTNO,
   INSTAMT,
   PROD_ID,
   AGENT_ID,
   BRANCH_ID,
   AC_HD_ID
)
AS
   (SELECT act_num,
           cu.fname,
           ABS (NVL (clear_balance, 0)) AS bal,
           1 AS instno,
           1 AS instamt,
           SUBSTR (act_num, 5, 3) AS prod_id,
           agent_id,
           SUBSTR (act_num, 1, 4) AS branch_id,
           ac_hd_id
      FROM act_master am
           JOIN customer cu ON cu.cust_id = am.cust_id
           JOIN op_ac_product oa ON oa.prod_id = am.prod_id
     WHERE agent_id IS NOT NULL                      --is_number (act_num) = 1
    UNION ALL
    SELECT suspense_acct_num AS act_num,
           suspense_name AS fname,
           ABS (clear_balance) AS bal,
           1 AS instno,
           1 AS instamt,
           SUBSTR (suspense_acct_num, 5, 3) AS prod_id,
           agent_id,
           SUBSTR (suspense_acct_num, 1, 4) AS branch_id,
           ac_hd_id
      FROM suspense_account_master
           JOIN suspense_product sp
              ON sp.prod_id = SUBSTR (suspense_acct_num, 5, 3)
     WHERE agent_id IS NOT NULL      --WHERE is_number (suspense_acct_num) = 1
    UNION ALL
    SELECT dsa.deposit_no || '_' || dsa.deposit_sub_no AS act_num,
           cu.fname,
           ABS (NVL (clear_balance, 0)) AS bal,
           (  ABS (NVL (clear_balance, 0))
            / (CASE
                  WHEN (dsa.deposit_amt) = 0 THEN 1
                  ELSE (dsa.deposit_amt)
               END))
              AS instno,
           dsa.deposit_amt AS instamt,
           SUBSTR (dsa.deposit_no, 5, 3) AS prod_id,
           apm.agent_id,
           SUBSTR (dsa.deposit_no, 1, 4) AS branch_id,
           acct_head AS ac_hd_id
      FROM deposit_sub_acinfo dsa
           JOIN deposit_acinfo da ON da.deposit_no = dsa.deposit_no
           JOIN agent_prod_mapping apm
              ON apm.prod_id = SUBSTR (dsa.deposit_no, 5, 3)
           JOIN customer cu ON cu.cust_id = da.cust_id
           JOIN deposits_product dp
              ON dp.prod_id = SUBSTR (dsa.deposit_no, 5, 3)
     WHERE apm.agent_id IS NOT NULL          -- AND is_number (dsa.deposit_no) = 1
                               );

--NEED TO EXECUTE INSIDE THIS PACKAGE PKGGENREPORTS---

FUNCTION ACOPEN_FROM_AGENT_CUR_MONTH (SELECTED_AGENT_ID    VARCHAR2,FROM_DT DATE, TO_DT DATE) return number;

FUNCTION ACOPEN_FROM_AGENT_CUR_MONTH (SELECTED_AGENT_ID    VARCHAR2,FROM_DT DATE, TO_DT DATE)
   RETURN NUMBER
IS
   TOTAL_ACCOUNT   NUMBER (5);
BEGIN
   SELECT NOOFACCT
     INTO TOTAL_ACCOUNT
     FROM (SELECT COUNT (*) NOOFACCT
             FROM (SELECT CUST_ID OPERATIVE_ID, 'operative'
                     FROM ACT_MASTER
                    WHERE     AGENT_ID = SELECTED_AGENT_ID
                          AND CREATE_DT BETWEEN FROM_DT AND TO_DT
                   UNION
                   SELECT CUST_ID DEPOSIT_ID, 'deposit'
                     FROM DEPOSIT_ACINFO DA, DEPOSIT_SUB_ACINFO DSA
                    WHERE     DA.DEPOSIT_NO = DSA.DEPOSIT_NO
                          AND AGENT_ID = SELECTED_AGENT_ID
                          AND DSA.DEPOSIT_DT BETWEEN FROM_DT AND TO_DT
                   UNION
                   SELECT CUST_ID DEPOSIT_ID, 'deposit'
                     FROM DEPOSIT_ACINFO DA, DEPOSIT_SUB_ACINFO DSA
                    WHERE     DA.DEPOSIT_NO = DSA.DEPOSIT_NO
                          AND AGENT_ID = SELECTED_AGENT_ID
                          AND DSA.DEPOSIT_DT BETWEEN FROM_DT AND TO_DT));

   RETURN TOTAL_ACCOUNT;
END;      

Insert into MODULE_MASTER
   (MODULE_ID, MODULE_NAME, CREATED_DT, SL_NO, STATUS)
 Values
   ('42', 'Agent', TO_DATE('09/11/2014 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 41, 'CREATED');

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCRA6109', '6109', 'Agent Commision Slab Rate', 'APP01', 'DONE', 
    '42', 5, 'CREATED', 'Agent Commision Slab Rate');

call INSERT_REPORT_GROUP('SCRA6109');

ALTER TABLE AGENT_PROD_MAPPING ADD(
  ACCT_INTRO_COMMISION_HEAD      VARCHAR2(32 BYTE),
  ACCT_INTRO_COMMISION           NUMBER(5,2),
  FROM_DATE                      DATE,
  TO_DATE                        DATE,
  FROM_AMT                       NUMBER(14,2),
  TO_AMT                         NUMBER(14,2),
  STATUS                         VARCHAR2(16 BYTE),
  STATUS_DT                      DATE,
  STATUS_BY                      VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS               VARCHAR2(16 BYTE),
  AUTHORIZE_BY                   VARCHAR2(16 BYTE),
  AUTHORIZE_DT                   DATE,
  TDS                            NUMBER(14,2),
  SLAB_ID                        VARCHAR2(16 BYTE),
  SL_NO                          NUMBER(5));

  Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('AGENT_SLAB_ID', 0, 'ASI', TO_DATE('05/05/2004 16:17:44', 'MM/DD/YYYY HH24:MI:SS'), 10, 
    '0001');

--End Version [Script Version - 0.0.232] [ReleaseVersion - 9.2.2.5]--[04-07-2016] -- by Sathiya

--Start Version [Script Version - 0.0.233] [ReleaseVersion - 9.2.2.5]--[13-07-2016] -- by Sathiya

--NEED TO EXECUTE UNDER pkgreports PACKAGE

function FNGETBAL(actnum VARCHAR, asondt DATE) return number;

FUNCTION FNGETBAL (actnum VARCHAR, asondt DATE) return number
   IS
   outbal   NUMBER (16, 2) := 0;
   closedt date;
BEGIN

--select CLOSED_DT into closedt
--  from all_product_accts1 
-- where act_num=actnum;

   SELECT SUM (nvl(balance,0)) ---case when (closedt is null or closedt >asondt) then SUM (nvl(balance,0)) else 0   end 
     INTO outbal
     FROM (SELECT NVL (amt, 0) balance
             FROM act_dayend_balance
            WHERE act_num = actnum --and prod_id in ('106','105','107','104','103','101','102','119','118','108','109','110','111','112','113','114','115','116','117')
              AND day_end_dt =
                            (SELECT MAX (day_end_dt)
                               FROM act_dayend_balance
                              WHERE act_num = actnum --and prod_id in ('106','105','107','104','103','101','102','119','118','108','109','110','111','112','113','114','115','116','117')
                                AND day_end_dt <= asondt)
           UNION ALL
           SELECT NVL (amt, 0) balance
             FROM deposit_dayend_balance
            WHERE act_num = actnum --and prod_id in ('206','207','205','201','203','204','202','210','209','208')
              AND day_end_dt =
                            (SELECT MAX (day_end_dt)
                               FROM deposit_dayend_balance
                              WHERE act_num = actnum --and prod_id in ('206','207','205','201','203','204','202','210','209','208')
                                AND day_end_dt <= asondt)
            union all
           SELECT NVL (amt, 0) balance
             FROM ADVANCES_DAYEND_BALANCE
            WHERE act_num = actnum --AND PROD_ID IN ('306','310','311','323','324','325','332','333','334','335','336','337','338','328')
              AND day_end_dt =
                            (SELECT MAX (day_end_dt)
                               FROM ADVANCES_DAYEND_BALANCE
                              WHERE act_num = actnum --AND PROD_ID IN ('306','310','311','323','324','325','332','333','334','335','336','337','338','328')
                                AND day_end_dt<= asondt)
           UNION ALL
           SELECT NVL (amt, 0) balance
             FROM loans_dayend_balance
            WHERE act_num = actnum --and prod_id in ('302','303','304','305','307','308','331','312','322','326','327','329','330','309','318','319','320','317','316','315','314','301','321','313')
              AND day_end_dt =
                            (SELECT MAX (day_end_dt)
                               FROM loans_dayend_balance
                              WHERE act_num = actnum --AND prod_id in ('302','303','304','305','307','308','331','312','322','326','327','329','330','309','318','319','320','317','316','315','314','301','321','313')
                                AND day_end_dt<= asondt)
           UNION ALL
           
           SELECT NVL (amt, 0) balance
             FROM SUSPENSE_DAYEND_BALANCE
            WHERE act_num = actnum --and prod_id in ('206','207','205','201','203','204','202','210','209','208')
              AND day_end_dt =
                            (SELECT MAX (day_end_dt)
                               FROM SUSPENSE_DAYEND_BALANCE
                              WHERE act_num = actnum --and prod_id in ('206','207','205','201','203','204','202','210','209','208')
                                AND day_end_dt <= asondt)                                
--union all
--SELECT SUM (NVL (pkgreports.getkccreleasewisebal (a.release_no, asondt),0)) balance
--  FROM ncl_release_details a 
--  JOIN ncl_sanction_details b
--    ON a.ncl_sanction_no = b.ncl_sanction_no
-- WHERE RELEASE_DATE <=asondt 
--   AND a.ncl_sanction_no IN (SELECT ncl_sanction_no
--                               FROM ncl_sanction_details
--                              WHERE kcc_act_num = actnum
--                                AND SANCTION_DT<= asondt
--                                AND substr(kcc_act_num,5,3)='328')
       );


   RETURN outbal;
END FNGETBAL;

--NEED TO EXECUTE UNDER PKGGENREPORTS PACKAGE
  
  FUNCTION ACOPEN_FROM_AGENT_CUR_MONTH (SELECTED_AGENT_ID    VARCHAR2,FROM_DT DATE, TO_DT DATE) return number;
    
  FUNCTION Getcustidbyaccountno(Acctno VARCHAR2) RETURN VARCHAR2;
    
FUNCTION ACOPEN_FROM_AGENT_CUR_MONTH (SELECTED_AGENT_ID    VARCHAR2,FROM_DT DATE, TO_DT DATE)
   RETURN NUMBER
IS
   TOTAL_ACCOUNT   NUMBER (5);
BEGIN
   SELECT NOOFACCT
     INTO TOTAL_ACCOUNT
     FROM (SELECT SUM(TOT_COUNT) NOOFACCT
             FROM (SELECT COUNT(*) TOT_COUNT
                     FROM ACT_MASTER
                    WHERE     AGENT_ID = SELECTED_AGENT_ID
                          AND CREATE_DT BETWEEN FROM_DT AND TO_DT
                   UNION
                   SELECT COUNT(*) TOT_COUNT
                     FROM DEPOSIT_ACINFO DA, DEPOSIT_SUB_ACINFO DSA
                    WHERE     DA.DEPOSIT_NO = DSA.DEPOSIT_NO
                          AND AGENT_ID = SELECTED_AGENT_ID
                          AND DSA.DEPOSIT_DT BETWEEN FROM_DT AND TO_DT
                   UNION
                   SELECT COUNT(*) TOT_COUNT
                     FROM DEPOSIT_ACINFO DA, DEPOSIT_SUB_ACINFO DSA
                    WHERE     DA.DEPOSIT_NO = DSA.DEPOSIT_NO
                          AND AGENT_ID = SELECTED_AGENT_ID
                          AND DSA.DEPOSIT_DT BETWEEN FROM_DT AND TO_DT));

   RETURN TOTAL_ACCOUNT;
END;       

FUNCTION Getcustidbyaccountno(Acctno VARCHAR2)
RETURN VARCHAR2 IS
    Custid VARCHAR2(100);
BEGIN
select custid INTO Custid
from (
SELECT b.CUST_ID custid
  FROM customer a
  JOIN act_master b
    ON a.cust_id = b.cust_id
 WHERE b.act_num = Acctno
 union all
  SELECT b.CUST_ID custid
  FROM customer a
  JOIN LOANS_BORROWER b  
    ON a.cust_id = b.CUST_ID
  join loans_facility_details c
  on b.BORROW_NO=c.BORROW_NO
 WHERE c.ACCT_NUM = Acctno
  UNION ALL
SELECT b.CUST_ID custid
  FROM customer a
  JOIN deposit_acinfo b
    ON a.cust_id = b.CUST_ID
 WHERE b.DEPOSIT_NO = Acctno
 union all
    SELECT b.SUSPENSE_CUSTOMER_ID custid
  FROM customer a
  JOIN SUSPENSE_ACCOUNT_MASTER b
    ON a.cust_id = b.SUSPENSE_CUSTOMER_ID
 WHERE b.SUSPENSE_ACCT_NUM =Acctno
 );
 
    RETURN custid;
END Getcustidbyaccountno;

DROP VIEW ALL_PRODUCT_ACCTS1;

/* Formatted on 26/05/2016 AM 11:08:57 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FORCE VIEW ALL_PRODUCT_ACCTS1
(
   ACT_NUM,
   CUST_ID,
   PROD_TYPE,
   PROD_ID,
   REP_ACT_NUM,
   BRANCH_ID,
   SALARY_RECOVERY,
   LOCK_STATUS,
   ACCT_STATUS,
   AUTHORIZATION_STATUS,
   CLOSED_DT,
   CREATE_DT
)
AS
   (SELECT am.act_num AS act_num,
           am.cust_id,
           'OA' AS prod_type,
           prod_id,
           am.act_num || '_1' AS rep_act_num,
           branch_code AS branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           am.act_status_id AS acct_status,
           am.authorization_status,
           closed_dt,
           create_dt
      FROM act_master am
     WHERE am.authorization_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT da.deposit_no AS act_num,
           da.cust_id,
           'TD' AS prod_type,
           prod_id,
           da.deposit_no || '_1' AS rep_act_num,
           branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status,
           ds.acct_status,
           da.authorize_status,
           close_dt AS closed_dt,
           created_dt AS create_dt
      FROM deposit_acinfo da, deposit_sub_acinfo ds
     WHERE     da.authorize_status = 'AUTHORIZED'
           AND da.status != 'DELETED'
           AND ds.deposit_no = da.deposit_no
    UNION ALL
    SELECT lfd.acct_num AS act_num,
           lb.cust_id,
           'TL' AS prod_type,
           prod_id,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status,
           lfd.acct_status,
           lfd.authorize_status_1,
           acct_close_dt AS closed_dt,
           acct_open_dt AS create_dt
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.borrow_no = lb.borrow_no
           AND lfd.status != 'DELETED'
           AND NOT EXISTS
                      (SELECT prod_id
                         FROM loans_product
                        WHERE     behaves_like IN ('OD', 'CC')
                              AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num,
           lb.cust_id,
           'AD' AS prod_type,
           prod_id,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status,
           lfd.acct_status,
           lfd.authorize_status_1,
           acct_close_dt AS closed_dt,
           acct_open_dt AS create_dt
      FROM loans_facility_details lfd, loans_borrower lb
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.borrow_no = lb.borrow_no
           AND lfd.status != 'DELETED'
           AND EXISTS
                  (SELECT prod_id
                     FROM loans_product
                    WHERE     behaves_like IN ('OD', 'CC')
                          AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num,
           lb.cust_id,
           'ATL' AS prod_type,
           prod_id,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           lfd.acct_status,
           lfd.authorize_status_1,
           acct_close_dt AS closed_dt,
           acct_open_dt AS create_dt
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.borrow_no = lb.borrow_no
           AND lfd.status != 'DELETED'
           AND NOT EXISTS
                      (SELECT prod_id
                         FROM agriloans_product
                        WHERE     behaves_like IN ('AOD', 'ACC')
                              AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT lfd.acct_num AS act_num,
           lb.cust_id,
           'AAD' AS prod_type,
           prod_id,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           lfd.acct_status,
           lfd.authorize_status_1,
           acct_close_dt AS closed_dt,
           acct_open_dt AS create_dt
      FROM agri_loans_facility_details lfd, loans_borrower lb
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.borrow_no = lb.borrow_no
           AND lfd.status != 'DELETED'
           AND EXISTS
                  (SELECT prod_id
                     FROM agriloans_product
                    WHERE     behaves_like IN ('AOD', 'ACC')
                          AND prod_id = lfd.prod_id)
    UNION ALL
    SELECT am.suspense_acct_num AS act_num,
           am.suspense_customer_id,
           'SA' AS prod_type,
           am.suspense_prod_id AS prod_id,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           branch_code AS branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           'NEW' AS acct_status,
           am.authorize_status,
           NULL AS closed_dt,
           suspense_open__date AS create_dt
      FROM suspense_account_master am
     WHERE am.authorize_status = 'AUTHORIZED' AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num,
           sa.cust_id,
           'MDS' AS prod_type,
           am.scheme_name AS prod_id,
           am.chittal_no || '_' || am.sub_no AS rep_act_num,
           am.branch_code AS branch_id,
           NVL (mm.salary_recovery, 'N') AS salary_recovery,
           NVL (mm.lock_status, 'N') AS lock_status,
           msd.status AS acct_status,
           am.authorize_status,
           am.chit_end_dt AS closed_dt,
           am.chit_start_dt AS create_dt
      FROM mds_application am,
           mds_master_maintenance mm,
           mds_scheme_details msd,
           share_acct sa
     WHERE     am.authorize_status = 'AUTHORIZED'
           AND am.member_no = sa.share_acct_no(+)
           AND am.status != 'DELETED'
           AND mm.scheme_name = msd.scheme_name
           AND am.chittal_no = mm.chittal_no
           AND am.sub_no = mm.sub_no
    UNION ALL
    SELECT am.act_master_id AS act_num,
           '' AS cust_id,
           'AB' AS prod_type,
           prod_id,
           am.act_master_id || '_1' AS rep_act_num,
           branch_id AS branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           am.status AS acct_status,
           am.authorized_status,
           am.CLOSED_DT AS closed_dt,
           am.ACT_OPEN_DT AS create_dt
      FROM other_banks_act_master am
     WHERE am.authorized_status = 'AUTHORIZED' AND am.status != 'DELETED');

CREATE TABLE INTERBRANCH_TRANS
(
  TRANS_ID          VARCHAR2(16 BYTE),
  AC_HD_ID          VARCHAR2(16 BYTE),
  ACT_NUM           VARCHAR2(16 BYTE),
  TRANS_DT          DATE,
  AMOUNT            NUMBER(16,2),
  TRANS_TYPE        VARCHAR2(16 BYTE),
  PROD_ID           VARCHAR2(16 BYTE),
  PROD_TYPE         VARCHAR2(16 BYTE),
  BRANCH_ID         VARCHAR2(16 BYTE),
  INITIATED_BRANCH  VARCHAR2(16 BYTE),
  COMPLETED_STATUS  VARCHAR2(2 BYTE),
  OTHER_BRANCH_DT   DATE
);

CREATE OR REPLACE PROCEDURE EXECUTE_GL_ABSTRACT_BALANCE (
BRANCH_IDS VARCHAR2,  FIRST_DT DATE,  ST_DT DATE, END_DT DATE,RESULT OUT VARCHAR2 
)   IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
DECLARE
CURSOR C1 IS SELECT DT, AC_HD_ID, DECODE(BALANCE_TYPE,'DEBIT',-1*NVL(CLOSE_BAL,0),NVL(CLOSE_BAL,0)) CLOSE_BAL 
FROM GL_ABSTRACT WHERE AC_HD_ID IN (SELECT AC_HD_ID FROM INTERBRANCH_TRANS WHERE TRANS_DT BETWEEN ST_DT AND END_DT AND BRANCH_ID=BRANCH_IDS UNION
SELECT IBR_AC_HD FROM PARAMETERS) AND BRANCH_CODE=BRANCH_IDS AND DT=FIRST_DT;--FIRST_DT IS PREVIOUS DATE CLOSE BALANCE ;
START_DT DATE;
DEBIT NUMBER;
CREDIT NUMBER;
OP_BAL NUMBER;
CL_BAL NUMBER;
BEGIN  
SELECT 'GL'||LPAD(FLOOR(ABS(DBMS_RANDOM.NORMAL) * TO_CHAR(SYSDATE ,'j')),8,'0') INTO RESULT FROM DUAL;
FOR I IN C1 LOOP
    OP_BAL := I.CLOSE_BAL;
    START_DT:=ST_DT;
    WHILE START_DT<=END_DT LOOP
        SELECT NVL(SUM(DEBIT_CASH+DEBIT_TRANSFER+DEBIT_CLEARING),0) , 
        NVL(SUM(CREDIT_CASH+CREDIT_TRANSFER+CREDIT_CLEARING),0) INTO DEBIT, CREDIT FROM REP_DAY_BOOK_FINAL_IBR WHERE BRANCH_CODE=BRANCH_IDS AND
        AC_HD_ID=I.AC_HD_ID AND TRANS_DT=START_DT;
        UPDATE GL_ABSTRACT SET OPN_BAL=ABS(OP_BAL), BALANCE_TYPE=DECODE(OP_BAL,ABS(OP_BAL),'CREDIT','DEBIT') 
        WHERE AC_HD_ID=I.AC_HD_ID AND DT=START_DT AND BRANCH_CODE=BRANCH_IDS;
         --RESULT := RESULT ||CHR(13)|| chr(10)||'AC_HD_ID   :'||I.AC_HD_ID ||  '  START_DT   :'||START_DT ||  '  BRANCH_ID   :'||BRANCH_IDS || '  OP_BAL'  || ABS(OP_BAL) ||CHR(13)|| chr(10);
        CL_BAL:=OP_BAL-DEBIT+CREDIT;
        UPDATE GL_ABSTRACT SET CLOSE_BAL=ABS(CL_BAL),BALANCE_TYPE=DECODE(CL_BAL,ABS(CL_BAL),'CREDIT','DEBIT') 
        WHERE AC_HD_ID=I.AC_HD_ID AND DT=START_DT AND BRANCH_CODE=BRANCH_IDS;
        INSERT INTO GL_UPDATE_LOG VALUES (RESULT,I.AC_HD_ID,START_DT,BRANCH_IDS,OP_BAL,DEBIT,CREDIT,CL_BAL);
        START_DT:=START_DT+1;
        OP_BAL:=CL_BAL;
    END LOOP;
END LOOP;
 COMMIT;
END;
END;
/

CREATE OR REPLACE FUNCTION GL_ABSTRACT_BALANCE_FUNCTION (
BRANCH_ID VARCHAR2,  FIRST_DT DATE,  ST_DT DATE, END_DT DATE   
)RETURN VARCHAR2 IS 
RESULT VARCHAR2(12);
BEGIN
    -- In case FIRST_DT='24-feb-2016' ST_DT='25-feb-2016' and END_DT='24-feb-2016'
    IF ST_DT>END_DT THEN
        EXECUTE_GL_ABSTRACT_BALANCE( BRANCH_ID , END_DT-1 , END_DT , ST_DT,RESULT );
    ELSE
        EXECUTE_GL_ABSTRACT_BALANCE( BRANCH_ID , FIRST_DT , ST_DT , END_DT,RESULT );
    END IF;
  RETURN RESULT;
END;
/

CREATE OR REPLACE FUNCTION ALL_SCHE_UPDT_TSK_FUN (
BRANCH_ID VARCHAR2,   ST_DT DATE, END_DT DATE   
)RETURN CLOB IS 
RESULT CLOB;
BEGIN
  ALL_SCHEDULE_UPDATE_TASK( BRANCH_ID  , ST_DT , END_DT,RESULT );
  RETURN RESULT;
END;
/

CREATE OR REPLACE PROCEDURE ALL_SCHEDULE_UPDATE_TASK (BRANCH_IDS VARCHAR2,  ST_DT DATE, END_DT DATE,
RESULT  OUT CLOB )IS
PRAGMA AUTONOMOUS_TRANSACTION;
TMP_ST_DT DATE;
BEGIN
FOR A IN(
SELECT PROD_TYPE  FROM INTERBRANCH_TRANS WHERE TRANS_DT=ST_DT AND BRANCH_ID =BRANCH_IDS AND PROD_TYPE !='GL' GROUP BY PROD_TYPE)  LOOP
TMP_ST_DT := ST_DT;
IF A.PROD_TYPE='OA' THEN
WHILE TMP_ST_DT<=END_DT LOOP
FOR I IN (
SELECT PROD_ID, ACT_NUM, TMP_ST_DT, OPBAL-DR_AMT+CR_AMT AMT, OPBAL-DR_AMT+CR_AMT AVAIL_BAL, OPBAL-DR_AMT+CR_AMT CLEAR_BAL, 0 TOD_LIMIT FROM (
SELECT ALL_PRODUCT_ACCTS1.PROD_ID, TMP_ST_DT, ACT_NUM, 
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT-1),0) OPBAL,
SUM(DECODE(TRANS_TYPE,'DEBIT',NVL(AMOUNT,0),0)) DR_AMT,
SUM(DECODE(TRANS_TYPE,'CREDIT',NVL(AMOUNT,0),0)) CR_AMT,
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT),0) CLOSEBAL
FROM ALL_PRODUCT_ACCTS1, REP_SUB_DAY_BOOK_IBR WHERE 
(REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.ACT_NUM OR REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.REP_ACT_NUM)
AND TRANS_DT=TMP_ST_DT AND ALL_PRODUCT_ACCTS1.PROD_TYPE='OA' AND
ALL_PRODUCT_ACCTS1.PROD_ID!='201' AND
ALL_PRODUCT_ACCTS1.ACT_NUM IN (SELECT ACT_NUM FROM INTERBRANCH_TRANS WHERE TRANS_DT=TMP_ST_DT AND BRANCH_ID =BRANCH_IDS AND PROD_TYPE !='GL' AND PROD_TYPE ='OA') 
     AND ALL_PRODUCT_ACCTS1.BRANCH_ID = BRANCH_IDS
     AND (ALL_PRODUCT_ACCTS1.CLOSED_DT IS NULL OR ALL_PRODUCT_ACCTS1.CLOSED_DT > TMP_ST_DT)
     AND ALL_PRODUCT_ACCTS1.CREATE_DT <= TMP_ST_DT
     GROUP BY ALL_PRODUCT_ACCTS1.PROD_ID, ACT_NUM, TMP_ST_DT
)) LOOP
DBMS_OUTPUT.PUT_LINE('I.ACT_NUM'||I.ACT_NUM||'  I.TMP_ST_DT'||I.TMP_ST_DT||'  I.AMT ' || I.AMT  ||'  I.AVAIL_BAL '||I.AVAIL_BAL||'  I.CLEAR_BAL '||I.CLEAR_BAL);
RESULT :=RESULT ||  'I.ACT_NUM   :'||I.ACT_NUM ||  '  I.TMP_ST_DT   :'||TMP_ST_DT ||  '  I.AMT   :'||I.AMT || '  I.AVAIL_BAL'  || I.AVAIL_BAL ||'  I.CLEAR_BAL '||I.CLEAR_BAL ;
UPDATE ACT_DAYEND_BALANCE SET AMT=I.AMT, AVAILABLE_BALANCE=I.AVAIL_BAL,CLEAR_BALANCE=I.CLEAR_BAL,TOD_LIMIT=I.TOD_LIMIT ,PROD_ID=I.PROD_ID WHERE ACT_NUM=I.ACT_NUM AND DAY_END_DT=I.TMP_ST_DT;
END LOOP;
TMP_ST_DT:=TMP_ST_DT+1;
END LOOP;
ELSIF A.PROD_TYPE='TL'   THEN
WHILE TMP_ST_DT<=END_DT LOOP
FOR I IN (
SELECT PROD_ID, ACT_NUM, TMP_ST_DT, OPBAL-DR_AMT+CR_AMT CLEAR_BALANCE, -1*(OPBAL-DR_AMT+CR_AMT) PRINCIPAL, LIMIT FLAT_RATE_PRINCIPAL, SUBSIDY_AMT FROM (
SELECT ALL_PRODUCT_ACCTS1.PROD_ID, TMP_ST_DT, ACT_NUM, 
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT-1),0) OPBAL,
SUM(DECODE(TRANS_TYPE,'DEBIT',NVL(AMOUNT,0),0)) DR_AMT,
SUM(DECODE(TRANS_TYPE,'CREDIT',NVL(AMOUNT,0),0)) CR_AMT,
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT),0) CLOSEBAL, SUBSIDY_AMT, LIMIT
FROM ALL_PRODUCT_ACCTS1, REP_SUB_DAY_BOOK_IBR, LOANS_FACILITY_DETAILS LFD, LOANS_SANCTION_DETAILS LSD WHERE 
(REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.ACT_NUM OR REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.REP_ACT_NUM)
AND TRANS_DT=TMP_ST_DT AND ALL_PRODUCT_ACCTS1.ACT_NUM=LFD.ACCT_NUM AND LSD.BORROW_NO=LFD.BORROW_NO AND 
ALL_PRODUCT_ACCTS1.PROD_TYPE='TL' 
     AND ALL_PRODUCT_ACCTS1.BRANCH_ID = BRANCH_IDS AND
     ALL_PRODUCT_ACCTS1.ACT_NUM IN (SELECT ACT_NUM FROM INTERBRANCH_TRANS WHERE TRANS_DT=TMP_ST_DT AND BRANCH_ID =BRANCH_IDS AND PROD_TYPE !='GL' AND PROD_TYPE ='TL') 
     GROUP BY ALL_PRODUCT_ACCTS1.PROD_ID, ACT_NUM, TMP_ST_DT, LIMIT, SUBSIDY_AMT
)
WHERE OPBAL-DR_AMT+CR_AMT<>CLOSEBAL )LOOP
    RESULT :=RESULT ||CHR(13)|| CHR(10)|| 'I.ACT_NUM   :'||I.ACT_NUM ||  '  I.TMP_ST_DT   :'||TMP_ST_DT ||  '  I.AMT   :'||I.CLEAR_BALANCE || '  I.PRINCIPAL'  ||I.PRINCIPAL ||'  FLAT_RATE_PRINCIPAL '||I.FLAT_RATE_PRINCIPAL||CHR(13)|| CHR(10) ;

    UPDATE LOANS_DAYEND_BALANCE SET AMT=I.CLEAR_BALANCE,PRINCIPAL=I.PRINCIPAL,FLAT_RATE_PRINCIPAL=I.FLAT_RATE_PRINCIPAL ,AVAILABLE_SUBSIDY=I.SUBSIDY_AMT ,PROD_ID=I.PROD_ID 
    WHERE ACT_NUM=I.ACT_NUM AND DAY_END_DT=TMP_ST_DT;
END LOOP;
TMP_ST_DT:=TMP_ST_DT+1;
END LOOP;
ELSIF A.PROD_TYPE='AD'   THEN
WHILE TMP_ST_DT<=END_DT LOOP
FOR I IN (
SELECT PROD_ID, ACT_NUM, TMP_ST_DT, OPBAL-DR_AMT+CR_AMT AMT, -1*(OPBAL-DR_AMT+CR_AMT) PRINCIPAL, (OPBAL-DR_AMT+CR_AMT) + LIMIT AVAILABLE_BALANCE, 
OPBAL-DR_AMT+CR_AMT CLEAR_BALANCE, LIMIT DPLIMIT, 0 TOD_LIMIT, LIMIT OVERALL_LIMIT, 0 LIMIT FROM (
SELECT ALL_PRODUCT_ACCTS1.PROD_ID, TMP_ST_DT, ACT_NUM, 
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT-1),0) OPBAL,
SUM(DECODE(TRANS_TYPE,'DEBIT',NVL(AMOUNT,0),0)) DR_AMT,
SUM(DECODE(TRANS_TYPE,'CREDIT',NVL(AMOUNT,0),0)) CR_AMT,
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT),0) CLOSEBAL, SUBSIDY_AMT, LIMIT
FROM ALL_PRODUCT_ACCTS1, REP_SUB_DAY_BOOK_IBR, LOANS_FACILITY_DETAILS LFD, LOANS_SANCTION_DETAILS LSD
 WHERE 
(REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.ACT_NUM OR REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.REP_ACT_NUM)
AND TRANS_DT=TMP_ST_DT AND ALL_PRODUCT_ACCTS1.ACT_NUM=LFD.ACCT_NUM AND LSD.BORROW_NO=LFD.BORROW_NO AND 
ALL_PRODUCT_ACCTS1.PROD_TYPE='AD' 
     AND ALL_PRODUCT_ACCTS1.BRANCH_ID = BRANCH_IDS
     AND ALL_PRODUCT_ACCTS1.ACT_NUM IN (SELECT ACT_NUM FROM INTERBRANCH_TRANS WHERE TRANS_DT=TMP_ST_DT AND BRANCH_ID =BRANCH_IDS AND PROD_TYPE !='GL' AND PROD_TYPE ='AD') 

     GROUP BY ALL_PRODUCT_ACCTS1.PROD_ID, ACT_NUM, TMP_ST_DT, LIMIT, SUBSIDY_AMT
)
WHERE OPBAL-DR_AMT+CR_AMT<>CLOSEBAL )LOOP
 RESULT :=RESULT ||CHR(13)|| CHR(10)|| 'I.ACT_NUM   :'||I.ACT_NUM ||  '  I.TMP_ST_DT   :'||TMP_ST_DT ||  '  I.AMT   :'||I.AMT || '  I.PRINCIPAL'  ||I.PRINCIPAL ||'  ,AVAILABLE_BALANCE '||I.AVAILABLE_BALANCE||'CLEAR_BALANCE'||I.CLEAR_BALANCE ||CHR(13)|| CHR(10) ;

UPDATE ADVANCES_DAYEND_BALANCE SET PROD_ID=I.PROD_ID,AMT=I.AMT, PRINCIPAL=I.PRINCIPAL ,AVAILABLE_BALANCE=I.AVAILABLE_BALANCE,
CLEAR_BALANCE =I.CLEAR_BALANCE,DPLIMIT =I.DPLIMIT,TOD_LIMIT =I.TOD_LIMIT,OVERALL_LIMIT=I.OVERALL_LIMIT,LIMIT =I.LIMIT
WHERE ACT_NUM=I.ACT_NUM AND DAY_END_DT=TMP_ST_DT;
END LOOP;
TMP_ST_DT:=TMP_ST_DT+1;
END LOOP;
ELSIF A.PROD_TYPE='TD'   THEN
WHILE TMP_ST_DT<=END_DT LOOP
FOR I IN (
SELECT ACT_NUM, OPBAL, DR_AMT, CR_AMT, OPBAL-DR_AMT+CR_AMT ACT_BAL, CLOSEBAL, (OPBAL-DR_AMT+CR_AMT)-CLOSEBAL DIFF FROM (
SELECT ACT_NUM, 
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT-1),0) OPBAL,
SUM(DECODE(TRANS_TYPE,'DEBIT',NVL(AMOUNT,0),0)) DR_AMT,
SUM(DECODE(TRANS_TYPE,'CREDIT',NVL(AMOUNT,0),0)) CR_AMT,
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT),0) CLOSEBAL
FROM ALL_PRODUCT_ACCTS1, REP_SUB_DAY_BOOK_IBR WHERE 
(REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.ACT_NUM OR REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.REP_ACT_NUM)
AND TRANS_DT=TMP_ST_DT AND 
ALL_PRODUCT_ACCTS1.PROD_ID!='201'
     AND ALL_PRODUCT_ACCTS1.BRANCH_ID = BRANCH_IDS
     AND ALL_PRODUCT_ACCTS1.ACT_NUM IN (SELECT ACT_NUM FROM INTERBRANCH_TRANS WHERE TRANS_DT=TMP_ST_DT AND BRANCH_ID =BRANCH_IDS AND PROD_TYPE !='GL' AND PROD_TYPE ='TD')
     AND (ALL_PRODUCT_ACCTS1.CLOSED_DT IS NULL OR ALL_PRODUCT_ACCTS1.CLOSED_DT >= TMP_ST_DT)
     GROUP BY ACT_NUM
)
--where opbal-dr_amt+cr_amt<>closebal 
ORDER BY ACT_NUM ) LOOP
RESULT :=RESULT ||CHR(13)|| CHR(10)|| 'I.ACT_NUM   :'||I.ACT_NUM ||  '  I.TMP_ST_DT   :'||TMP_ST_DT ||  '  I.AMT   :'||I.ACT_BAL  ||CHR(13)|| CHR(10) ;

    UPDATE DEPOSIT_DAYEND_BALANCE SET AMT =I.ACT_BAL  ,PAYABLE_AMT=0 WHERE ACT_NUM=I.ACT_NUM AND DAY_END_DT=TMP_ST_DT;
END LOOP;
TMP_ST_DT:=TMP_ST_DT+1;
END LOOP;
WHILE TMP_ST_DT<=END_DT LOOP
-- to check opbal+transaction with close_bal (Only for daily deposits)
FOR I IN (
SELECT ACT_NUM, OPBAL, DR_AMT, CR_AMT, OPBAL-DR_AMT+CR_AMT ACT_BAL, CLOSEBAL, (OPBAL-DR_AMT+CR_AMT)-CLOSEBAL DIFF FROM (
SELECT ACT_NUM, 
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT-1),0) OPBAL,
SUM(DECODE(TRANS_TYPE,'DEBIT',NVL(AMOUNT,0),0)) DR_AMT,
SUM(DECODE(TRANS_TYPE,'CREDIT',NVL(AMOUNT,0),0)) CR_AMT,
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT),0) CLOSEBAL
FROM ALL_PRODUCT_ACCTS1, REP_SUB_DAY_BOOK_IBR WHERE 
(REP_SUB_DAY_BOOK_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.ACT_NUM OR REP_DAY_BOOK_FINAL_IBR.ACC_NO=ALL_PRODUCT_ACCTS1.REP_ACT_NUM)
AND TRANS_DT=TMP_ST_DT AND 
ALL_PRODUCT_ACCTS1.PROD_ID='201'
     AND ALL_PRODUCT_ACCTS1.BRANCH_ID = BRANCH_IDS
     AND ALL_PRODUCT_ACCTS1.ACT_NUM IN (SELECT ACT_NUM FROM INTERBRANCH_TRANS WHERE TRANS_DT=TMP_ST_DT AND BRANCH_ID =BRANCH_IDS AND PROD_TYPE !='GL' AND PROD_TYPE ='TD')
     GROUP BY ACT_NUM
UNION ALL
SELECT ACT_NUM, 
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT-1),0) OPBAL,
0 DR_AMT,
SUM(NVL(AMOUNT,0)) CR_AMT,
NVL(PKGREPORTS.FNGETBAL( ACT_NUM, TMP_ST_DT),0) CLOSEBAL
FROM ALL_PRODUCT_ACCTS1, DAILY_DEPOSIT_TRANS WHERE 
ALL_PRODUCT_ACCTS1.REP_ACT_NUM=DAILY_DEPOSIT_TRANS.ACC_NUM
     AND ALL_PRODUCT_ACCTS1.BRANCH_ID = BRANCH_IDS
     AND ALL_PRODUCT_ACCTS1.PROD_ID='201'
     AND TRN_DT=TMP_ST_DT
     GROUP BY ACT_NUM
)
WHERE OPBAL-DR_AMT+CR_AMT<>CLOSEBAL 
ORDER BY ACT_NUM ) LOOP
RESULT :=RESULT ||CHR(13)|| CHR(10)|| 'I.ACT_NUM   :'||I.ACT_NUM ||  '  I.TMP_ST_DT   :'||TMP_ST_DT ||  '  I.AMT   :'||I.ACT_BAL  ||CHR(13)|| CHR(10) ;

UPDATE DEPOSIT_DAYEND_BALANCE SET AMT =I.ACT_BAL  ,PAYABLE_AMT=0 WHERE ACT_NUM=I.ACT_NUM AND DAY_END_DT=TMP_ST_DT;
END LOOP;
TMP_ST_DT:=TMP_ST_DT+1;
END LOOP;
END IF;
END LOOP;
COMMIT;
END;
/

CREATE TABLE GL_UPDATE_LOG
(
  UPDATE_ID  VARCHAR2(12 BYTE),
  AC_HD_ID   VARCHAR2(16 BYTE),
  UPDATE_DT  DATE,
  BRANCH_ID  VARCHAR2(8 BYTE),
  OP_BAL     NUMBER(16,2),
  DEBIT      NUMBER(16,2),
  CREDIT     NUMBER(16,2),
  CLOSE_BAL  NUMBER(16,2)
)

CREATE OR REPLACE PROCEDURE EXE_DEL_GL_UPDATE_LOG_PRO  (
UPDATEIDS VARCHAR2
)   IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
     DELETE FROM GL_UPDATE_LOG WHERE UPDATE_ID =UPDATEIDS;
 COMMIT;
END;

CREATE OR REPLACE FUNCTION EXECUTE_DELETE_GL_UPDATE_LOG (
UPDATEIDS VARCHAR2   
)RETURN VARCHAR2 IS 
RESULT VARCHAR2(12);
BEGIN
  EXE_DEL_GL_UPDATE_LOG_PRO( UPDATEIDS );
  RETURN RESULT;
END;
/

--End Version [Script Version - 0.0.233] [ReleaseVersion - 9.2.2.5]--[13-07-2016] -- by Sathiya

--Start Version [Script Version - 0.0.234] [ReleaseVersion - 9.2.2.6]--[22-07-2016] -- by Nithya
call INSERT_REPORT_GROUP('SCR09996');

CREATE TABLE BILLS_MULTI_LODGEMENT_MASTER
(
  PROD_ID           VARCHAR2(16 BYTE),
  PROD_TYPE         VARCHAR2(4 BYTE),
  BORROW_ACCT_NUM   VARCHAR2(16 BYTE),
  BORROW_NAME       VARCHAR2(200 BYTE),
  INDIVIUAL_AMOUNT  NUMBER(16,2),
  LODGEMENT_ID      VARCHAR2(16 BYTE),
  STATUS            VARCHAR2(16 BYTE),
  INSTRUCTION       VARCHAR2(20 BYTE),
  INST_AMT          NUMBER(16,2),
  SERVICE_TAX       NUMBER(16,2)
)

alter table BILLS_LODGEMENT_MASTER ADD IS_MULTIPLE_LODGEMENT VARCHAR2(1)

UPDATE BILLS_LODGEMENT_MASTER BM SET BM.IS_MULTIPLE_LODGEMENT = 'N'

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR09997', '107', 'Multiple Account Lodgement', 'APP01', 'DONE', 
    '12', 'com.see.truetransact.ui.bills.lodgement.multipleaccountlodgement.MultipleAccountLodgementUI', 4, 'CREATED', NULL, 
    NULL, 'Multiple Account Lodgement');
COMMIT;

ALTER TABLE INWARD_REGISTER ADD BRANCH_ID VARCHAR2(16);

ALTER TABLE OUTWARD_REGISTER ADD BRANCH_ID VARCHAR2(16);

ALTER TABLE OUTWARD_REGISTER ADD ADDRESS VARCHAR2(250);

ALTER TABLE OUTWARD_REGISTER ADD MESSENGER VARCHAR2(16);

--End Version [Script Version - 0.0.234] [ReleaseVersion - 9.2.2.6]--[22-07-2016] -- by Nithya

--Start Version [Script Version - 0.0.235] [ReleaseVersion - 9.2.2.6]--[12-08-2016] -- by Sreekrishnan

ALTER TABLE LOANS_PRODUCT ADD EMI_FLAT_RATE VARCHAR2(1);

ALTER TABLE SMS_ACKNOWLEDGMENT ADD ACT_NUM VARCHAR2 (16 Byte)

ALTER TABLE SMS_ACKNOWLEDGMENT ADD SMS_MODULE VARCHAR2 (30 Byte)
  
--End Version [Script Version - 0.0.235] [ReleaseVersion - 9.2.2.6]--[12-08-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.236] [ReleaseVersion - 9.2.2.6]--[16-08-2016] -- by Nithya

ALTER TABLE IMBP_SETTINGS ADD MAX_NO_OF_LOANS  NUMBER(3);

UPDATE IMBP_SETTINGS IM SET IM.MAX_NO_OF_LOANS = 0 WHERE IM.MAX_NO_OF_LOANS IS NULL

-- FOR RBI
alter table SALARY_RECOVERY_LIST_DETAIL add OMIT_PRINCIPAL VARCHAR2(1)

alter table SALARY_RECOVERY_LIST_DETAIL add OMIT_INTEREST VARCHAR2(1)

--End Version [Script Version - 0.0.236] [ReleaseVersion - 9.2.2.6]--[16-08-2016] -- by Nithya

--Start Version [Script Version - 0.0.237] [ReleaseVersion - 9.2.2.6]--[16-08-2016] -- by Sreekrishnan
/* DAILY COLLECTION CALCULATION FUNCTION AND SCRIPTS */   
         
ALTER TABLE AGENT_PROD_MAPPING ADD COMM_BASED_LOAN INT DEFAULT (0);

AGENT_MASTER
     
CREATE OR REPLACE FUNCTION STANDING_LOAN_CRLOANACC(SIDEBITACCOUNT VARCHAR2) RETURN VARCHAR2 IS
-- SELECT  STANDING_LOAN_CRLOANACC ('0001595013059') FROM DUAL;
 CRACNT VARCHAR2(15);  
BEGIN
  BEGIN   
  SELECT SIC.ACCT_NO INTO CRACNT  FROM STANDING_INSTRUCTION_DEBIT SD 
  JOIN STANDING_INSTRUCTION SIT ON SIT.SI_ID = SD.SI_ID
  JOIN STANDING_INSTRUCTION_CREDIT SIC ON SIC.SI_ID = SD.SI_ID
   WHERE  SD.ACCT_NO =SIDEBITACCOUNT AND SIC.PROD_TYPE ='TL';  --- SD.SI_ID, 
   END ;
  RETURN CRACNT; 
END;
/



CREATE OR REPLACE FUNCTION GET_DAILY_LOAN_COLLECTION(ACTNUM VARCHAR,UPTO DATE)
RETURN NUMBER IS
    COLLECTION NUMBER(16,2) := 0;
BEGIN
    SELECT SUM(LT.PRINCIPLE) /*+ SUM(NVL(INTEREST,0))+ SUM(NVL(PENAL,0))+ SUM(NVL(PENAL,0))+
    SUM(NVL(POSTAGE_CHARGE,0))   + SUM(NVL(ARBITARY_CHARGE,0)) + SUM(NVL(LEGAL_CHARGE,0)) + SUM(NVL(INSURANCE_CHARGE,0)) +
     SUM(NVL(MISC_CHARGES,0)) + SUM(NVL(EXE_DEGREE,0)) +
     SUM(NVL(ADVERTISE_CHARGE,0)) + SUM(NVL(NOTICE_CHARGES,0)) */ 
      INTO COLLECTION FROM LOAN_TRANS_DETAILS LT 
    WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT>UPTO AND LT.TRANS_TYPE ='CREDIT';
    RETURN COLLECTION;
END;

CREATE OR REPLACE TYPE "TYPE_AGENT_COMM_DETAILS" AS OBJECT 
(
PROD_DESC                   VARCHAR2 (75 Byte) ,
PROD_ID                     VARCHAR2 (4 Byte) ,
LAST_COL_DT                 DATE ,
COLLECTION_AMOUNT           NUMBER(19,2) ,
COMMISION                   NUMBER(19,2) ,
VAT                          NUMBER(19,2) 
);

CREATE OR REPLACE TYPE "TAB_TYPE_AGENT_COMM_DETAILS" AS TABLE OF TYPE_AGENT_COMM_DETAILS; 
/

CREATE OR REPLACE   FUNCTION GET_AGENTCOMM(AGENTID VARCHAR2,DT DATE,VATRATE NUMBER)  RETURN TAB_TYPE_AGENT_COMM_DETAILS   AS       
   AGENTDET TAB_TYPE_AGENT_COMM_DETAILS;   
   -- SELECT * FROM TABLE(GET_AGENTCOMM ( 'C010026906','05AUG2016',0) );
   BEGIN
         SELECT TYPE_AGENT_COMM_DETAILS(PROD_DESC,PROD_ID,LAST_COL_DT,COLLECTION_AMOUNT,COMMISION,VAT) bulk collect into  AGENTDET FROM(         
         SELECT AP.PROD_DESC, AG.PROD_ID, AC.LAST_COL_DT,
         SUM (D.AMOUNT) AS COLLECTION_AMOUNT,
         ROUND((SUM (D.AMOUNT) * (NVL(AM.COMM_PER_BANK,0)+NVL(AM.COMM_PER_AC_HOLDR,0)) / 100),0) AS COMMISION,
          (SUM (D.AMOUNT) * (NVL(AM.COMM_PER_BANK,0)+NVL(AM.COMM_PER_AC_HOLDR,0) / 100) * VATRATE  / 100) AS VAT
         FROM DAILY_DEPOSIT_TRANS D,
         AGENTMASTDET AG,
         ALL_PRODUCTS AP,
         AGENT_COLLECTION_PROD AC,
         AGENT_PROD_MAPPING AM
         WHERE (D.ACC_NUM = AG.ACT_NUM ||'_1' OR D.ACC_NUM = AG.ACT_NUM) AND  AM.COMM_BASED_LOAN=0
         AND AG.AGENT_ID = D.AGENT_NO
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.PROD_ID = AP.PROD_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AM.PROD_ID = AG.PROD_ID
         AND D.AGENT_NO = AGENTID
         AND D.TRN_DT BETWEEN AC.LAST_COL_DT AND DT
         AND D.AUTHORIZE_STATUS = 'AUTHORIZED'
         GROUP BY D.AGENT_NO, AG.PROD_ID, AP.PROD_DESC, AC.LAST_COL_DT,
         AM.COMM_PER_BANK,AM.COMM_PER_AC_HOLDR
         UNION ALL
         SELECT PROD_DESC,  PROD_ID,  LAST_COL_DT,SUM(COLLECTION_AMOUNT) AS  COLLECTION_AMOUNT,ROUND((SUM(COLLECTION_AMOUNT*COMMRATE)/100),0) AS COMMISION,
         ((SUM(COLLECTION_AMOUNT*COMMRATE)/100) * VATRATE / 100) AS VAT
         FROM (SELECT D.AGENT_NO,AP.PROD_DESC, AG.PROD_ID, AC.LAST_COL_DT,
          NVL(GET_DAILY_LOAN_COLLECTION(STANDING_LOAN_CRLOANACC(D.ACC_NUM),AC.LAST_COL_DT),0)  AS COLLECTION_AMOUNT, 
           NVL(AM.COMM_PER_BANK,0)+NVL(AM.COMM_PER_AC_HOLDR,0) COMMRATE          
         FROM DAILY_DEPOSIT_TRANS D,
         AGENTMASTDET AG,
         ALL_PRODUCTS AP,
         AGENT_COLLECTION_PROD AC,
         AGENT_PROD_MAPPING AM
         WHERE (D.ACC_NUM = AG.ACT_NUM || '_1' OR D.ACC_NUM = AG.ACT_NUM) AND  AM.COMM_BASED_LOAN=1
         AND AG.AGENT_ID = D.AGENT_NO
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.PROD_ID = AP.PROD_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AM.PROD_ID = AG.PROD_ID
         AND D.AGENT_NO = AGENTID
         AND D.TRN_DT BETWEEN AC.LAST_COL_DT AND DT
         AND D.AUTHORIZE_STATUS = 'AUTHORIZED')         
         GROUP BY  AGENT_NO, PROD_ID,  PROD_DESC,  LAST_COL_DT 
         UNION ALL         
         SELECT al.PROD_DESC, lf.PROD_ID, AC.LAST_COL_DT,
         GET_DAILY_LOAN_COLLECTION(lf.ACCT_NUM,AC.LAST_COL_DT) AS COLLECTION_AMOUNT,
         (GET_DAILY_LOAN_COLLECTION(lf.ACCT_NUM,AC.LAST_COL_DT) * AP.COMM_PER_BANK / 100) AS COMMISION,
         ((GET_DAILY_LOAN_COLLECTION(lf.ACCT_NUM,AC.LAST_COL_DT) * AP.COMM_PER_BANK / 100) *  VATRATE / 100) AS VAT
         FROM DAILY_LOAN_SANCTION_DETAILS DL,AGENT_COLLECTION_PROD AC,
         AGENT_PROD_MAPPING AP,ALL_PRODUCTS AL,LOANS_FACILITY_DETAILS lf
         WHERE LF.ACCT_NUM = DL.ACCT_NUM AND  AP.COMM_BASED_LOAN=0
         AND dl.AGENT_ID  = AGENTID
         AND AC.PROD_ID = LF.PROD_ID
         AND AP.PROD_ID =  lf.PROD_ID
         and AC.AGENT_ID = DL.AGENT_ID
         and AL.PROD_ID = LF.PROD_ID
         AND DL.STATUS !='DELETED'
         AND DL.AGENT_ID  =AGENTID) WHERE COLLECTION_AMOUNT>0;
         RETURN AGENTDET;
         END;

--End Version [Script Version - 0.0.237] [ReleaseVersion - 9.2.2.6]--[16-08-2016] -- by Sreekrishnan

--Strat Version [Script Version - 0.0.238] [ReleaseVersion - 9.2.2.6]--[26-08-2016] -- by Sreekrishnan

CREATE OR REPLACE FUNCTION GET_RD_PENDING_PENAL (ACTNUM VARCHAR,ASONDATE DATE,BRANCHCODE VARCHAR,INSTPAY NUMBER) RETURN
NUMBER IS
PENDING_PENAL NUMBER(10);
PENAL_RATE NUMBER(10);
DEPAMT NUMBER(10);
PRODID VARCHAR2(10);
PENDING_INSTALL NUMBER(10);
DIFF NUMBER(10);
BEGIN
SELECT DA.PROD_ID,DS.DEPOSIT_AMT INTO PRODID,DEPAMT FROM DEPOSIT_ACINFO DA,DEPOSIT_SUB_ACINFO DS WHERE DA.DEPOSIT_NO = DS.DEPOSIT_NO
AND DS.DEPOSIT_NO = SUBSTR(ACTNUM,0,13);
SELECT PENAL_INT INTO PENAL_RATE FROM DEPOSIT_ROI_GROUP_TYPE_RATE WHERE ROI_GROUP_ID = PRODID
        AND DEPAMT BETWEEN FROM_AMOUNT AND TO_AMOUNT;
SELECT GET_RD_INSTALL(SUBSTR(ACTNUM,0,13),ASONDATE,BRANCHCODE) INTO PENDING_INSTALL FROM DUAL;
  IF  PENDING_INSTALL > 0 THEN 
      DIFF := PENDING_INSTALL-INSTPAY;
      PENDING_PENAL := (PENDING_INSTALL * (PENDING_INSTALL+1)/2 - DIFF * (DIFF+1)/2)*PENAL_RATE*DEPAMT/100;      
 ELSE
   PENDING_PENAL := 0;
   END IF;
RETURN PENDING_PENAL ;
END;
/
--End Version [Script Version - 0.0.238] [ReleaseVersion - 9.2.2.6]--[26-08-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.239] [ReleaseVersion - 9.2.2.6]--[09-09-2016] -- by Sreekrishnan
SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12242', '2242', 'Query Report', 'APP01', 'DONE', 
    '6', 'Query Report', 3, 'CREATED', NULL, 
    NULL, 'Query Report');
COMMIT;

call INSERT_REPORT_GROUP('SCR12242');

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12243', '2242', 'New Authorization List', 'APP01', 'DONE', 
    '6', 'New Authorization List', 3, 'CREATED', NULL, 
    NULL, 'New Authorization List');
COMMIT;

call INSERT_REPORT_GROUP('SCR12243');

--End Version [Script Version - 0.0.239] [ReleaseVersion - 9.2.2.6]--[09-09-2016] -- by Sreekrishnan

--Start Version [Script Version - 0.0.240] [ReleaseVersion - 9.2.2.6]--[20-09-2016] -- by Nithya

CREATE OR REPLACE FORCE VIEW all_transactions_view (trans_id,
                                                         batch_id,
                                                         ac_hd_id,
                                                         act_num,
                                                         amount,
                                                         trans_dt,
                                                         trans_type,
                                                         inst_type,
                                                         inst_dt,
                                                         particulars,
                                                         status,
                                                         instrument_no1,
                                                         instrument_no2,
                                                         prod_id,
                                                         prod_type,
                                                         authorize_status,
                                                         authorize_by,
                                                         status_by,
                                                         status_dt,
                                                         trans_mode,
                                                         branch_id,
                                                         initiated_branch,
                                                         authorize_status_2,
                                                         single_trans_id,
                                                         link_batch_id,
                                                         trans_mod_type,
                                                         narration
                                                        )
AS
   SELECT trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt, trans_type,
          inst_type, inst_dt, particulars, status, instrument_no1,
          instrument_no2, prod_id, prod_type, authorize_status, authorize_by,
          status_by, status_dt, trans_mode, branch_id, initiated_branch,
          authorize_status_2, single_trans_id, link_batch_id, trans_mod_type,
          narration
     FROM (SELECT   trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt,
                    trans_type, inst_type, inst_dt, particulars, status,
                    instrument_no1, instrument_no2, prod_id, prod_type,
                    authorize_status, authorize_by, status_by, status_dt,
                    trans_mode, branch_id, initiated_branch,
                    authorize_status_2, single_trans_id, link_batch_id,
                    trans_mod_type, narration
               FROM all_trans
/* Script added for updating dayend balance of Daily Deposit accounts */
           UNION ALL
           SELECT   TO_CHAR (trans_id), batch_id,
                    (SELECT acct_head
                       FROM deposits_product
                      WHERE prod_id = SUBSTR (acc_num, 5, 3)) AS ac_hd_id,
                    acc_num AS act_num, amount, trn_dt AS trans_dt,
                    trans_type, '' AS inst_type, NULL AS inst_dt, particulars,
                    status, '' AS instrument_no1, '' AS instrument_no2,
                    SUBSTR (acc_num, 5, 3) AS prod_id, prod_type,
                    authorize_status, authorize_by, '' AS status_by,
                    trn_dt AS status_dt, trans_mode,
                    SUBSTR (acc_num, 1, 4) AS branch_id, initiated_branch,
                    '' AS authorize_status_2, '' AS single_trans_id,
                    '' AS link_batch_id, '' AS trans_mod_type,
                    '' AS narration
               FROM daily_deposit_trans
           ORDER BY status_dt);


CREATE OR REPLACE function get_retire_date(custid varchar) return date is
      retireage number(3);
      retiredate date;
      begin
      select nvl(P.RETIREMENT_AGE,0) into retireage from parameters p;
      Select add_months(C.DOB,retireage * 12 ) into retiredate from customer c where C.CUST_ID = custid  ;
      return retiredate;
      end;
/

--End Version [Script Version - 0.0.240] [ReleaseVersion - 9.2.2.6]--[20-09-2016] -- by Nithya

--Start Version [Script Version - 0.0.241] [ReleaseVersion - 9.2.2.6]--[21-09-2016] -- by Sathiya
ALTER TABLE LOG MODIFY SCREEN VARCHAR2(128);
--End Version [Script Version - 0.0.241] [ReleaseVersion - 9.2.2.6]--[21-09-2016] -- by Sathiya

--Start Version [Script Version - 0.0.242] [ReleaseVersion - 9.2.2.6]--[21-09-2016] -- by Rishad
ALTER TABLE  LOAN_APPLICATION_REGISTER ADD (ELIGIBLE_AMT NUMBER(16,2));

ALTER TABLE LOAN_APPLICATION_REGISTER ADD (REPAYMENT_TYPE NUMBER(8));

ALTER TABLE LOANS_SECURITY_MEMBER  ADD (TOTAL_SALARY NUMBER (16,2));

ALTER TABLE LOANS_SECURITY_VEHICLE  ADD TOT_SALARY NUMBER(16,2);

ALTER TABLE LOAN_APPLICATION_REGISTER ADD COST_OF_VEHICHLE NUMBER(16,2);

ALTER TABLE LOANS_SECURITY_VEHICLE ADD NETWORTH NUMBER (16,2);

--End Version [Script Version - 0.0.242] [ReleaseVersion - 9.2.2.6]--[21-09-2016] -- by Rishad

--Start Version [Script Version - 0.0.243] [ReleaseVersion - 9.2.2.6]--[23-09-2016] -- by Sathiya

Alter table AGENT_MASTER add IMPORT_FILE_PATH VARCHAR2(250);

Alter table AGENT_MASTER add EXPORT_FILE_PATH VARCHAR2(250);

Alter table AGENT_MASTER add IMPORT_BAT_FILE VARCHAR2(250);

Alter table AGENT_MASTER add EXPORT_BAT_FILE VARCHAR2(250);

--End Version [Script Version - 0.0.243] [ReleaseVersion - 9.2.2.6]--[21-09-2016] -- by Sathiya

--Start Version [Script Version - 0.0.244] [ReleaseVersion - 9.2.2.6]--[26-09-2016] -- by Nithya

ALTER TABLE ACTIVE_MEMBER_LIST ADD FROM_DT DATE;

ALTER TABLE ACTIVE_MEMBER_LIST ADD MEETING_DT DATE;

--End Version [Script Version - 0.0.244] [ReleaseVersion - 9.2.2.6]--[26-09-2016] -- by Nithya

--Start Version [Script Version - 0.0.245] [ReleaseVersion - 9.2.2.6]--[10-11-2016] -- by Rishad

CREATE OR REPLACE FUNCTION get_ac_hd_name (
   achdid    VARCHAR
)
   RETURN VARCHAR2
IS
Pragma Autonomous_Transaction;
   achdname  AC_HD.AC_HD_DESC%TYPE;
BEGIN
select ac_hd_desc into achdname from ac_hd where ac_hd_id=achdid;
    return achdname;
END;
/


alter table LOANS_PROD_SUBSIDY_REBATE add REBATE_MODE varchar2(20);

--End Version [Script Version - 0.0.245] [ReleaseVersion - 9.2.2.6]--[10-11-2016] -- by Rishad

--Start Version [Script Version - 0.0.246] [ReleaseVersion - 9.2.2.6]--[10-11-2016] -- by Sathiya

CREATE TABLE DIFF_BRANCH_TRANS
(
  TRANS_ID          VARCHAR2(16 BYTE),
  AC_HD_ID          VARCHAR2(16 BYTE),
  ACT_NUM           VARCHAR2(16 BYTE),
  TRANS_DT          DATE,
  AMOUNT            NUMBER(16,2),
  TRANS_TYPE        VARCHAR2(16 BYTE),
  PROD_ID           VARCHAR2(16 BYTE),
  PROD_TYPE         VARCHAR2(16 BYTE),
  BRANCH_ID         VARCHAR2(16 BYTE),
  INITIATED_BRANCH  VARCHAR2(16 BYTE),
  COMPLETED_STATUS  VARCHAR2(2 BYTE),
  OTHER_BRANCH_DT   DATE
)

CREATE TABLE DIFF_BR_GL_UPDATE_LOG
(
  UPDATE_ID  VARCHAR2(12 BYTE),
  AC_HD_ID   VARCHAR2(16 BYTE),
  UPDATE_DT  DATE,
  BRANCH_ID  VARCHAR2(8 BYTE),
  OP_BAL     NUMBER(16,2),
  DEBIT      NUMBER(16,2),
  CREDIT     NUMBER(16,2),
  CLOSE_BAL  NUMBER(16,2)
)

CREATE OR REPLACE PROCEDURE DIFF_BR_EXE_DEL_GL_LOG_PRO  (
UPDATEIDS VARCHAR2
)   IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
     DELETE FROM DIFF_BR_GL_UPDATE_LOG WHERE UPDATE_ID =UPDATEIDS;
 COMMIT;
END;

CREATE OR REPLACE FUNCTION DIFF_BR_EXECUTE_DELETE_GL_LOG (
UPDATEIDS VARCHAR2   
)RETURN VARCHAR2 IS 
RESULT VARCHAR2(12);
BEGIN
  DIFF_BR_EXE_DEL_GL_LOG_PRO( UPDATEIDS );
  RETURN RESULT;
END;

CREATE OR REPLACE PROCEDURE DIFF_BR_EXE_GL_ABSTRACT_BAL (
BRANCH_IDS VARCHAR2,  FIRST_DT DATE,  ST_DT DATE, END_DT DATE,RESULT OUT VARCHAR2 
)   IS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
DECLARE
CURSOR C1 IS SELECT DT, AC_HD_ID, DECODE(BALANCE_TYPE,'DEBIT',-1*NVL(CLOSE_BAL,0),NVL(CLOSE_BAL,0)) CLOSE_BAL 
FROM GL_ABSTRACT WHERE AC_HD_ID in (SELECT AC_HD_ID FROM DIFF_BRANCH_TRANS WHERE TRANS_DT BETWEEN ST_DT AND END_DT AND BRANCH_ID=BRANCH_IDS union
select IBR_AC_HD from parameters) AND BRANCH_CODE=BRANCH_IDS AND DT=FIRST_DT;--FIRST_DT IS PREVIOUS DATE CLOSE BALANCE ;
START_DT DATE;
DEBIT NUMBER;
CREDIT NUMBER;
OP_BAL NUMBER;
CL_BAL NUMBER;
BEGIN  
SELECT 'GL'||LPAD(floor(ABS(dbms_random.normal) * to_char(sysdate ,'j')),8,'0') into RESULT FROM DUAL;
FOR I IN C1 LOOP
    OP_BAL := I.CLOSE_BAL;
    START_DT:=ST_DT;
    WHILE START_DT<=END_DT LOOP
        select NVL(sum(DEBIT_CASH+DEBIT_TRANSFER+DEBIT_CLEARING),0) , 
        NVL(sum(CREDIT_CASH+CREDIT_TRANSFER+CREDIT_CLEARING),0) INTO DEBIT, CREDIT FROM REP_DAY_BOOK_FINAL_IBR WHERE BRANCH_CODE=BRANCH_IDS AND
        AC_HD_ID=I.AC_HD_ID AND TRANS_DT=START_DT;
        UPDATE GL_ABSTRACT SET OPN_BAL=ABS(OP_BAL), BALANCE_TYPE=DECODE(OP_BAL,ABS(OP_BAL),'CREDIT','DEBIT') 
        WHERE AC_HD_ID=I.AC_HD_ID AND DT=START_DT AND BRANCH_CODE=BRANCH_IDS;
         --RESULT := RESULT ||CHR(13)|| chr(10)||'AC_HD_ID   :'||I.AC_HD_ID ||  '  START_DT   :'||START_DT ||  '  BRANCH_ID   :'||BRANCH_IDS || '  OP_BAL'  || ABS(OP_BAL) ||CHR(13)|| chr(10);
        CL_BAL:=OP_BAL-DEBIT+CREDIT;
        UPDATE GL_ABSTRACT SET CLOSE_BAL=ABS(CL_BAL),BALANCE_TYPE=DECODE(CL_BAL,ABS(CL_BAL),'CREDIT','DEBIT') 
        WHERE AC_HD_ID=I.AC_HD_ID AND DT=START_DT AND BRANCH_CODE=BRANCH_IDS;
        INSERT INTO DIFF_BR_GL_UPDATE_LOG VALUES (RESULT,I.AC_HD_ID,START_DT,BRANCH_IDS,OP_BAL,DEBIT,CREDIT,CL_BAL);
        START_DT:=START_DT+1;
        OP_BAL:=CL_BAL;
    END LOOP;
END LOOP;
 COMMIT;
END;
END;

CREATE OR REPLACE FUNCTION DIFF_BR_GL_ABSTRACT_BAL_FN (
BRANCH_ID VARCHAR2,  FIRST_DT DATE,  ST_DT DATE, END_DT DATE   
)RETURN VARCHAR2 IS 
RESULT VARCHAR2(12);
BEGIN
    -- In case FIRST_DT='24-feb-2016' ST_DT='25-feb-2016' and END_DT='24-feb-2016'
    IF ST_DT>END_DT THEN
        DIFF_BR_EXE_GL_ABSTRACT_BAL( BRANCH_ID , END_DT-1 , END_DT , ST_DT,RESULT );
    ELSE
        DIFF_BR_EXE_GL_ABSTRACT_BAL( BRANCH_ID , FIRST_DT , ST_DT , END_DT,RESULT );
    END IF;
  RETURN RESULT;
END;

--End Version [Script Version - 0.0.246] [ReleaseVersion - 9.2.2.6]--[10-11-2016] -- by Sathiya

-- Start Version [Script Version - 0.0.247] [ReleaseVersion - 9.2.2.6]--[23-11-2016] -- by Nithya

alter table OP_AC_SECURITY_MEMBER add TOD_SANCTIONED NUMBER(16,2)

alter table OP_AC_SECURITY_MEMBER add SURETY_ELIG_AMT NUMBER(16,2)

ALTER TABLE SMS_PARAMETER ADD REMINDER VARCHAR2(1 BYTE) DEFAULT 'N' 

-- End Version [Script Version - 0.0.247] [ReleaseVersion - 9.2.2.6]--[23-11-2016] -- by Nithya

-- Start Version [Script Version - 0.0.248] [ReleaseVersion - 9.2.2.6]--[23-11-2016] -- by Sathiya

ALTER TABLE SMS_ACKNOWLEDGMENT ADD CREATED_DT DATE;

---------------need to use under pkgreports package-----------------

FUNCTION getheadtype (prodid VARCHAR2) return varchar2;
 
FUNCTION getProdName (prodid VARCHAR2) return varchar2;

 FUNCTION getheadtype (prodid VARCHAR2)
   RETURN varchar2
IS
   headtype   varchar2(16);
BEGIN
   
   SELECT acct_head
     INTO headtype
     FROM (SELECT ac_hd_id acct_head
             FROM all_products
            WHERE prod_id = prodid AND ROWNUM = 1);

   RETURN headtype;
END getheadtype;

FUNCTION getProdName (prodid VARCHAR2)
   RETURN varchar2
IS
   ProdName   varchar2(60);
BEGIN
   SELECT ProdName
     INTO ProdName
     FROM (
      SELECT AC_HD_DESC ProdName
             FROM ac_hd
            WHERE AC_HD_ID=pkgreports.getheadtype(prodid));

   RETURN ProdName;
END getProdName;

UPDATE SMS_PARAMETER SET REMINDER = 'Y';

INSERT INTO SMS_SUBSCRIPTION (
SELECT  'TD' PROD_TYPE,DA.PROD_ID,DA.DEPOSIT_NO,CP.PHONE_NUMBER,DSA.DEPOSIT_DT,DSA.DEPOSIT_DT,DA.STATUS_BY,DA.STATUS,DA.STATUS_DT,DA.STATUS_BY,
DA.AUTHORIZE_STATUS,DA.AUTHORIZED_BY,DA.AUTHORIZED_DT FROM CUSTOMER C,CUST_PHONE CP,DEPOSIT_ACINFO DA,DEPOSIT_SUB_ACINFO DSA WHERE C.CUST_ID = DA.CUST_ID 
AND DA.DEPOSIT_NO = DSA.DEPOSIT_NO AND C.CUST_ID = CP.CUST_ID AND CP.PHONE_TYPE_ID = 'MOBILE' AND LENGTH(CP.PHONE_NUMBER) = 10
)

ALTER TABLE DIFF_BRANCH_TRANS ADD LOGGED_IN_BRANCH VARCHAR2(16);

-- End Version [Script Version - 0.0.248] [ReleaseVersion - 9.2.2.6]--[23-11-2016] -- by Sathiya

-- Start Version [Script Version - 0.0.249] [ReleaseVersion - 9.2.2.6]--[09-12-2016] -- by Nithya

CREATE TABLE QUERY_REPORT_MASTER
(
  REPORT_GROUP  VARCHAR2(75 BYTE),
  REPORT_NAME   VARCHAR2(75 BYTE),
  REPORT_QUERY  VARCHAR2(4000 BYTE),
  CREATE_DT     DATE
)

CREATE TABLE QUERY_REPORT_PARAMETERS
(
  REPORT_NAME      VARCHAR2(75 BYTE),
  PARAMETER_NAME   VARCHAR2(75 BYTE),
  FIELD_TYPE       VARCHAR2(75 BYTE),
  PARAMETER_VALUE  VARCHAR2(4000 BYTE)
)

-- End Version [Script Version - 0.0.249] [ReleaseVersion - 9.2.2.6]--[09-12-2016] -- by Nithya

-- Start Version [Script Version - 0.0.250] [ReleaseVersion - 9.2.2.6]--[22-12-2016] -- by Sathiya
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCRA6110', '1066', 'Generate QRCode', 'APP01', 'DONE', 
    '2', 3, 'CREATED', 'Generate QRCode');

call INSERT_REPORT_GROUP('SCRA6110');

CREATE TABLE QR_MASTER
(
  QR_ACT_NUM      VARCHAR2(16 BYTE),
  QR_BANK         VARCHAR2(16 BYTE),
  QR_DETAILS      VARCHAR2(256 BYTE),
  QR_FILE         BLOB,
  OTP_NUM         VARCHAR2(16 BYTE),
  STATUS          VARCHAR2(16 BYTE),
  STATUS_BY       VARCHAR2(16 BYTE),
  STATUS_DT       DATE,
  ONE_TIME_RESET  VARCHAR2(1 BYTE)
)

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('APP_CATEGORY', 'M', 'Merchant', 'CREATED', 'Y');

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('APP_CATEGORY', 'C', 'Customer', 'CREATED', 'Y');
   
ALTER TABLE QR_MASTER MODIFY OTP_NUM VARCHAR2(128);
ALTER TABLE QR_MASTER ADD CATEGORY VARCHAR2(16);

CREATE OR REPLACE function GETCUSTPWD(CUSTID VARCHAR2) RETURN VARCHAR2 IS
    UID VARCHAR2(128);
BEGIN
    SELECT CUST_PWD INTO UID FROM CUSTOMER WHERE CUST_ID=CUSTID;
    RETURN UID;
    EXCEPTION WHEN OTHERS THEN RETURN NULL;
END;

CREATE OR REPLACE FORCE VIEW ALL_CUSTOMER_ACCOUNTS
(
   CUST_ID,
   NAME,
   ACT_NUM,
   PROD_TYPE,
   PROD_ID,
   PROD_DESC,
   BASE_CURRENCY,
   BRANCH_NAME,
   LAST_TRANS_DT,
   CUST_USERID,
   CUST_PWD,
   BRANCH_ID,
   ACCT_STATUS,
   AVAILABLE_BALANCE,
   ACT_OPN_DT,
   PRODUCT_TYPE
)
AS
   (SELECT cust_id,
           get_joint_cust (am.act_num) AS NAME,
           am.act_num AS act_num,
           'OA' AS prod_type,
           am.prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (branch_code) branch_name,
           last_trans_dt,
           getcustuserid (am.cust_id) cust_userid,
           GETCUSTPWD (am.cust_id) cust_pwd,
           branch_code AS branch_id,
           am.act_status_id AS acct_status,
           clear_balance AS available_balance,
           am.create_dt AS act_opn_dt,
           'DEPOSIT' AS product_type
      FROM act_master am, all_products ap
     WHERE     am.authorization_status = 'AUTHORIZED'
           AND am.prod_id = ap.prod_id
           AND am.status IN ('CREATED', 'MODIFIED')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (da.deposit_no) AS NAME,
           da.deposit_no AS act_num,
           'TD' AS prod_type,
           da.prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (branch_id) branch_name,
           last_trans_dt,
           getcustuserid (cust_id) cust_userid,
           GETCUSTPWD (cust_id) cust_pwd,
           branch_id,
           ds.acct_status,
           clear_balance AS available_balance,
           da.created_dt AS act_opn_dt,
           'DEPOSIT' AS product_type
      FROM deposit_acinfo da, deposit_sub_acinfo ds, all_products ap
     WHERE     da.authorize_status = 'AUTHORIZED'
           AND ds.deposit_no = da.deposit_no
           AND da.prod_id = ap.prod_id
           AND da.status IN ('CREATED', 'MODIFIED', 'LIEN')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'TL' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (branch_id) branch_name,
           last_trans_dt,
           getcustuserid (cust_id) cust_userid,
           GETCUSTPWD (cust_id) cust_pwd,
           branch_id,
           lfd.acct_status,
           clear_balance AS available_balance,
           lfd.acct_open_dt AS act_opn_dt,
           'LOAN' AS product_type
      FROM loans_facility_details lfd, loans_borrower lb, all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND behaves_like NOT IN ('OD', 'CC')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'AD' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (branch_id) branch_name,
           last_trans_dt,
           getcustuserid (cust_id) cust_userid,
           GETCUSTPWD (cust_id) cust_pwd,
           branch_id,
           lfd.acct_status,
           clear_balance AS available_balance,
           lfd.acct_open_dt AS act_opn_dt,
           'LOAN' AS product_type
      FROM loans_facility_details lfd, loans_borrower lb, all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND behaves_like IN ('OD', 'CC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'ATL' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (branch_id) branch_name,
           last_trans_dt,
           getcustuserid (cust_id) cust_userid,
           GETCUSTPWD (cust_id) cust_pwd,
           branch_id,
           lfd.acct_status,
           clear_balance AS available_balance,
           lfd.acct_open_dt AS act_opn_dt,
           'LOAN' AS product_type
      FROM agri_loans_facility_details lfd,
           loans_borrower lb,
           all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND behaves_like NOT IN ('AOD', 'ACC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'AAD' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (branch_id) branch_name,
           last_trans_dt,
           getcustuserid (cust_id) cust_userid,
           GETCUSTPWD (cust_id) cust_pwd,
           branch_id,
           lfd.acct_status,
           clear_balance AS available_balance,
           lfd.acct_open_dt AS act_opn_dt,
           'LOAN' AS product_type
      FROM agri_loans_facility_details lfd,
           loans_borrower lb,
           all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND behaves_like IN ('AOD', 'ACC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (am.suspense_acct_num) AS NAME,
           am.suspense_acct_num AS act_num,
           'SA' AS prod_type,
           am.suspense_prod_id AS prod_id,
           ap.prod_desc,
           'INR' base_currency,
           getbranchname (am.branch_code) branch_name,
           last_trans_dt,
           getcustuserid (cust_id) cust_userid,
           GETCUSTPWD (cust_id) cust_pwd,
           am.branch_code AS branch_id,
           'NEW' AS acct_status,
           clear_balance AS available_balance,
           am.suspense_open__date AS act_opn_dt,
           'DEPOSIT' AS product_type
      FROM suspense_account_master am, customer c, all_products ap
     WHERE     am.suspense_customer_id = c.cust_id
           AND am.authorize_status = 'AUTHORIZED'
           AND am.suspense_prod_id = ap.prod_id
           AND am.status IN ('CREATED', 'MODIFIED'));

-- End Version [Script Version - 0.0.250] [ReleaseVersion - 9.2.2.6]--[22-12-2016] -- by Sathiya


-- Start Version [Script Version - 0.0.250] [ReleaseVersion - 9.2.2.6]--[10-1-2017] -- by Nithya

CREATE OR REPLACE FUNCTION ROOM_RENT_DUE(BRANCH_ID VARCHAR,RM_ID VARCHAR,RM_NO VARCHAR) RETURN VARCHAR 
  IS 
            --DECLARE
              --     BRANCH_ID VARCHAR2(6):='0001';
--                   RM_ID VARCHAR2(32):='RM000002';
  --                 RM_NO VARCHAR2(32):='1';
                BLDNG_NO VARCHAR2(32);
                CURR_DT DATE;
                RENT_DUE_FRM DATE;
                RENT_DUE_DT DATE;
                RENT_DUE_AMT NUMBER(16,2):=0;
                RENT_PENAL NUMBER(16,2):=0;
                RENTAMT NUMBER(16,2):=0;
                PENAL_ROI NUMBER(16,2):=0;
                FREQ VARCHAR2(64);
                CNT NUMBER(16);
                TOT_AMT VARCHAR2(80);
                OPDAY VARCHAR2(10);
                OPYEAR VARCHAR2(10);
                OPMONTH VARCHAR2(10);
                R_DATE VARCHAR2(5);
                ARRIVEDDATE VARCHAR2(10);
                MonthDiff number;
            BEGIN
                SELECT CURR_APPL_DT INTO CURR_DT FROM DAY_END WHERE BRANCH_CODE=BRANCH_ID;
                SELECT BUILDING_NUM INTO BLDNG_NO  
                FROM RENT_PROFILE 
                WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                    AND RMNUMBER=RM_ID;
                SELECT COUNT(*) INTO CNT FROM RENT_TRANS 
                WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
                    AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED'; 
                    DBMS_OUTPUT.PUT_LINE( ' CNT ' || CNT);       
                IF CNT>0 THEN
                    SELECT MAX(RENT_PERIOD_TO) INTO RENT_DUE_DT 
                    FROM RENT_TRANS 
                    WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
                    AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED';
                    SELECT NVL(RR.RENT_DATE,1) + NVL(PENAL_GR_PERIOD,0) INTO R_DATE FROM RENT_REGISTER RR WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO; 
                           
                   /* Formatted on 2017/01/06 12:47 (Formatter Plus v4.8.8)  for considering rent pay date*/
                SELECT TO_DATE (TO_CHAR (   TO_CHAR (R_DATE)
                                         || '/'
                                         || TO_CHAR (RENT_DUE_DT, 'MM')
                                         || '/'
                                         || TO_CHAR (RENT_DUE_DT, 'YYYY')
                                        ),
                                'DD/MM/YYYY'
                               )
                  INTO ARRIVEDDATE
                  FROM DUAL;
                    dbms_output.put_line('ARRIVEDDATE  -->'||ARRIVEDDATE);
                    RENT_DUE_DT := ARRIVEDDATE;--,'DD/MM/YYYY');     
                    CNT:=1;
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_DT ' || RENT_DUE_DT);
                    FOR I IN (SELECT EFF_DATE,RENT_AMT,RENT_FRQ,PENEL_RATE 
                        FROM RENT_DETAILS 
                        WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                            AND ROOM_STATUS='REGISTERED' AND RMNUMBER=RM_ID AND ROOMNUM=RM_NO 
                            AND EFF_DATE>=(SELECT MAX(EFF_DATE) FROM RENT_DETAILS 
                                WHERE RMNUMBER=RM_ID AND ROOMNUM=RM_NO AND EFF_DATE<=RENT_DUE_DT 
                                AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                                AND ROOM_STATUS='REGISTERED') 
                            AND EFF_DATE<=CURR_DT) LOOP
                            DBMS_OUTPUT.PUT_LINE( ' CNT 2++' || CNT);       
                        IF CNT=1 THEN
                            RENT_DUE_FRM:=RENT_DUE_DT;
                            RENTAMT:=I.RENT_AMT;
                            PENAL_ROI:=I.PENEL_RATE;
                            FREQ:=I.RENT_FRQ;
                            CNT:=CNT+1;                 
                        ELSE 
                            SELECT RENT_DUE_AMT+(RENTAMT*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM))) INTO RENT_DUE_AMT FROM DUAL;
                            SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
                            RENT_DUE_FRM:=I.EFF_DATE;
                            RENTAMT:=I.RENT_AMT;
                            PENAL_ROI:=I.PENEL_RATE;
                            FREQ:=I.RENT_FRQ;
                            CNT:=CNT+1;
                        END IF;
                    END LOOP;
                    if to_char(CURR_DT,'dd') <= R_DATE then
                    MonthDiff := CEIL(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM)) -1;
                    Else
                    MonthDiff :=FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM));
                    End if;    
                    SELECT RENT_DUE_AMT+(RENTAMT*MonthDiff) INTO RENT_DUE_AMT FROM DUAL;
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_AMT NITHYA' || RENT_DUE_AMT); 
                    DBMS_OUTPUT.PUT_LINE( ' RENTAMT 2++' || RENTAMT); 
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_FRM' || RENT_DUE_FRM);   
                            DBMS_OUTPUT.PUT_LINE( ' CURR_DT 2++' || CURR_DT);
                     DBMS_OUTPUT.PUT_LINE( ' FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))) 2++' || FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))); 
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_AMT 2++' || RENT_DUE_AMT); 
                    SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
                    TOT_AMT:=RENT_DUE_AMT;
                    --TOT_AMT:=RENT_PENAL;
                     DBMS_OUTPUT.PUT_LINE( ' PENAL RETURN ' || TOT_AMT);   
                END IF;
          RETURN TOT_AMT;    
            END;
/

CREATE OR REPLACE FUNCTION ROOM_RENT_PENAL(BRANCH_ID VARCHAR,RM_ID VARCHAR,RM_NO VARCHAR) RETURN VARCHAR 
  IS 
            --DECLARE
              --     BRANCH_ID VARCHAR2(6):='0001';
--                   RM_ID VARCHAR2(32):='RM000002';
  --                 RM_NO VARCHAR2(32):='1';
                BLDNG_NO VARCHAR2(32);
                CURR_DT DATE;
                RENT_DUE_FRM DATE;
                RENT_DUE_DT DATE;
                RENT_DUE_AMT NUMBER(16,2):=0;
                RENT_PENAL NUMBER(16,2):=0;
                RENTAMT NUMBER(16,2):=0;
                PENAL_ROI NUMBER(16,2):=0;
                FREQ VARCHAR2(64);
                CNT NUMBER(16);
                TOT_AMT VARCHAR2(80);
                OPDAY VARCHAR2(10);
                OPYEAR VARCHAR2(10);
                OPMONTH VARCHAR2(10);
                R_DATE VARCHAR2(5);
                ARRIVEDDATE VARCHAR2(10);
                MonthDiff number;
            BEGIN
                SELECT CURR_APPL_DT INTO CURR_DT FROM DAY_END WHERE BRANCH_CODE=BRANCH_ID;
                SELECT BUILDING_NUM INTO BLDNG_NO  
                FROM RENT_PROFILE 
                WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                    AND RMNUMBER=RM_ID;
                SELECT COUNT(*) INTO CNT FROM RENT_TRANS 
                WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
                    AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED'; 
                    DBMS_OUTPUT.PUT_LINE( ' CNT ' || CNT);       
                IF CNT>0 THEN
                    SELECT MAX(RENT_PERIOD_TO) INTO RENT_DUE_DT 
                    FROM RENT_TRANS 
                    WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO 
                    AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED';
                    SELECT NVL(RR.RENT_DATE,1) + NVL(PENAL_GR_PERIOD,0) INTO R_DATE FROM RENT_REGISTER RR WHERE BUILDING_NO=BLDNG_NO AND ROOM_NO=RM_NO; 
                           
                   /* Formatted on 2017/01/06 12:47 (Formatter Plus v4.8.8) */
                SELECT TO_DATE (TO_CHAR (   TO_CHAR (R_DATE)
                                         || '/'
                                         || TO_CHAR (RENT_DUE_DT, 'MM')
                                         || '/'
                                         || TO_CHAR (RENT_DUE_DT, 'YYYY')
                                        ),
                                'DD/MM/YYYY'
                               )
                  INTO ARRIVEDDATE
                  FROM DUAL;
                    dbms_output.put_line('ARRIVEDDATE  -->'||ARRIVEDDATE);
                    RENT_DUE_DT := ARRIVEDDATE;--,'DD/MM/YYYY');     
                    CNT:=1;
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_DT ' || RENT_DUE_DT);
                    FOR I IN (SELECT EFF_DATE,RENT_AMT,RENT_FRQ,PENEL_RATE 
                        FROM RENT_DETAILS 
                        WHERE STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                            AND ROOM_STATUS='REGISTERED' AND RMNUMBER=RM_ID AND ROOMNUM=RM_NO 
                            AND EFF_DATE>=(SELECT MAX(EFF_DATE) FROM RENT_DETAILS 
                                WHERE RMNUMBER=RM_ID AND ROOMNUM=RM_NO AND EFF_DATE<=RENT_DUE_DT 
                                AND STATUS NOT IN ('DELETED') AND AUTHORIZE_STATUS='AUTHORIZED' 
                                AND ROOM_STATUS='REGISTERED') 
                            AND EFF_DATE<=CURR_DT) LOOP
                            DBMS_OUTPUT.PUT_LINE( ' CNT 2++' || CNT);       
                        IF CNT=1 THEN
                            RENT_DUE_FRM:=RENT_DUE_DT;
                            RENTAMT:=I.RENT_AMT;
                            PENAL_ROI:=I.PENEL_RATE;
                            FREQ:=I.RENT_FRQ;
                            CNT:=CNT+1;                 
                        ELSE 
                            SELECT RENT_DUE_AMT+(RENTAMT*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM))) INTO RENT_DUE_AMT FROM DUAL;
                            SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*FLOOR(MONTHS_BETWEEN(I.EFF_DATE,RENT_DUE_FRM)))/1200) INTO RENT_PENAL FROM DUAL;
                            RENT_DUE_FRM:=I.EFF_DATE;
                            RENTAMT:=I.RENT_AMT;
                            PENAL_ROI:=I.PENEL_RATE;
                            FREQ:=I.RENT_FRQ;
                            CNT:=CNT+1;
                        END IF;
                    END LOOP;
                    if to_char(CURR_DT,'dd') <= R_DATE then
                    MonthDiff := CEIL(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM)) -1;
                    Else
                    MonthDiff :=FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM));
                    End if;    
                    SELECT RENT_DUE_AMT+(RENTAMT*MonthDiff) INTO RENT_DUE_AMT FROM DUAL;
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_AMT NITHYA' || RENT_DUE_AMT); 
                    DBMS_OUTPUT.PUT_LINE( ' RENTAMT 2++' || RENTAMT); 
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_FRM' || RENT_DUE_FRM);   
                            DBMS_OUTPUT.PUT_LINE( ' CURR_DT 2++' || CURR_DT);
                     DBMS_OUTPUT.PUT_LINE( ' FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))) 2++' || FLOOR(MONTHS_BETWEEN(CURR_DT,RENT_DUE_FRM))); 
                    DBMS_OUTPUT.PUT_LINE( ' RENT_DUE_AMT 2++' || RENT_DUE_AMT); 
                    SELECT RENT_PENAL+((RENTAMT*PENAL_ROI*MonthDiff)/1200) INTO RENT_PENAL FROM DUAL;
                    --TOT_AMT:=RENT_DUE_AMT;
                     TOT_AMT:=RENT_PENAL;
                     DBMS_OUTPUT.PUT_LINE( ' PENAL RETURN ' || TOT_AMT);   
                END IF;
          RETURN TOT_AMT;    
            END;
/

-- End Version [Script Version - 0.0.250] [ReleaseVersion - 9.2.2.6]--[10-1-2017] -- by Nithya

-- Start Version [Script Version - 0.0.250] [ReleaseVersion - 9.2.2.6]--[17-2-2017] -- by Nithya
    Insert into LOOKUP_MASTER
    (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
     AUTHORIZED)
    Values
    ('DEPOSITSPRODUCT.INT_CALC_METHOD', '999', 'Installments', 'CREATED', NULL, 
    'Y');
-- End Version [Script Version - 0.0.250] [ReleaseVersion - 9.2.2.6]--[17-2-2017] -- by Nithya

-- Start Version [Script Version - 0.0.251] [ReleaseVersion - 9.2.2.6]--[14-3-2017] -- by Nithya

CREATE TABLE MULTIPLE_STANDING_ACT_DETAILS
(
  STANDING_ID        VARCHAR2(16 BYTE),
  TRANS_TYPE         VARCHAR2(10 BYTE),
  ACT_PROD_TYPE      VARCHAR2(10 BYTE),
  ACT_PROD_ID        VARCHAR2(10 BYTE),
  ACT_ACC_NO         VARCHAR2(20 BYTE),
  ACT_LAST_TRANS_DT  DATE,
  IS_ACTIVE          VARCHAR2(1 BYTE),
  STATUS             VARCHAR2(16 BYTE),
  STATUS_BY          VARCHAR2(16 BYTE),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
  AUTHORIZED_BY      VARCHAR2(32 BYTE),
  AUTHORIZED_DT      DATE,
  PARTICULARS        VARCHAR2(130 BYTE),
  TRANS_AMOUNT       NUMBER(16,2)
)

CREATE TABLE MULTIPLE_STANDING_MASTER
(
  STANDING_ID        VARCHAR2(16 BYTE),
  ACCOUNT_HEAD       VARCHAR2(30 BYTE),
  TRANS_TYPE         VARCHAR2(10 BYTE),
  MASTER_PROD_TYPE   VARCHAR2(10 BYTE),
  MASTER_PROD_ID     VARCHAR2(10 BYTE),
  MASTER_ACC_NO      VARCHAR2(20 BYTE),
  STATUS             VARCHAR2(16 BYTE),
  STATUS_BY          VARCHAR2(16 BYTE),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
  AUTHORIZED_BY      VARCHAR2(32 BYTE),
  AUTHORIZED_DT      DATE,
  PARTICULARS        VARCHAR2(130 BYTE),
  BRANCH_ID          VARCHAR2(16 BYTE),
  SI_DESCRIPTION     VARCHAR2(64 BYTE)
)

ALTER TABLE DIRECTOR_BOARD ADD TRANS_PROD_TYPE VARCHAR2(16 BYTE)

ALTER TABLE DIRECTOR_BOARD ADD TRANS_PROD_ID VARCHAR2(16 BYTE)

ALTER TABLE DIRECTOR_BOARD ADD TRANS_ACC_NO VARCHAR2(128 BYTE)

-- End Version [Script Version - 0.0.251] [ReleaseVersion - 9.2.2.6]--[14-3-2017] -- by Nithya

-- Start Version [Script Version - 0.0.252] [ReleaseVersion - 9.2.2.6]--[27-3-2017] -- by Nithya

CREATE TABLE SB_OD_ACCT_STATUS
(
  ACCT_NUM    VARCHAR2(16 BYTE),
  ACT_STATUS  VARCHAR2(16 BYTE)
)

-- End Version [Script Version - 0.0.252] [ReleaseVersion - 9.2.2.6]--[27-3-2017] -- by Nithya

-- Start Version [Script Version - 0.0.253] [ReleaseVersion - 9.2.2.6]--[28-04-2017] -- by Nithya

CREATE OR REPLACE FUNCTION GET_STANDING_AMT(prodid VARCHAR2,PRODTYPE varchar2,ACTNUM VARCHAR2,InstNo NUMBER,DEBITAMT NUMBER,ASONDATE DATE) 
RETURN NUMBER IS
   DEBITAMT1 NUMBER(16,2) := 0;
   REPAYMENTTYPE varchar2(20);
BEGIN 
   IF PRODTYPE= 'TL' THEN
    SELECT P.REPAYMENT_TYPE INTO REPAYMENTTYPE  FROM LOANS_PRODUCT p WHERE P.prod_id=prodid;
    IF REPAYMENTTYPE='EMI'
    THEN SELECT GET_TL_INST(ACTNUM)*InstNo INTO DEBITAMT1  FROM DUAL;
    ELSE DEBITAMT1:=DEBITAMT;
    END IF;
   ELSE DEBITAMT1:=DEBITAMT;
    END IF;
    RETURN DEBITAMT1;
END;
/

-- End Version [Script Version - 0.0.253] [ReleaseVersion - 9.2.2.6]--[28-04-2017] -- by Nithya

-- Start Version [Script Version - 0.0.254] [ReleaseVersion - 9.2.2.7]--[11-07-2017] -- by Revathi.L
ALTER TABLE DRF_PRODUCT ADD (NOMINEE_REQUIRED VARCHAR2(1 BYTE),NO_OF_NOMINEE NUMBER(2));

CREATE TABLE DRF_NOMINEE_DETAIL
(
  SHARE_NO        VARCHAR2(16 BYTE),
  NOMINEE_ID      VARCHAR2(8 BYTE),
  NOMINEE_NAME    VARCHAR2(64 BYTE),
  RELATIONSHIP    VARCHAR2(32 BYTE),
  STREET          VARCHAR2(256 BYTE),
  AREA            VARCHAR2(128 BYTE),
  CITY            VARCHAR2(128 BYTE),
  STATE           VARCHAR2(128 BYTE),
  PIN_CODE        VARCHAR2(16 BYTE),
  AREA_CODE       VARCHAR2(8 BYTE),
  PH_NO           VARCHAR2(64 BYTE),
  SHARE_PER       NUMBER(10),
  NOMINEE_STATUS  VARCHAR2(32 BYTE),
  NOMINEE_DOB     DATE,
  GUARDIAN_NAME   VARCHAR2(64 BYTE),
  G_STREET        VARCHAR2(256 BYTE),
  G_AREA          VARCHAR2(128 BYTE),
  G_CITY          VARCHAR2(128 BYTE),
  G_STATE         VARCHAR2(128 BYTE),
  G_PIN_CODE      VARCHAR2(16 BYTE),
  G_AREA_CODE     VARCHAR2(8 BYTE),
  G_PH_NO         VARCHAR2(64 BYTE),
  G_RELATIONSHIP  VARCHAR2(32 BYTE),
  COUNTRY_CODE    VARCHAR2(4 BYTE),
  G_COUNTRY_CODE  VARCHAR2(4 BYTE),
  STATUS          VARCHAR2(16 BYTE),
  STATUS_BY       VARCHAR2(32 BYTE),
  STATUS_DT       DATE,
  CUST_ID         VARCHAR2(16 BYTE)
);

ALTER TABLE AGENT_MASTER
ADD (TYPE VARCHAR2(1 BYTE));

ALTER TABLE SUSPENSE_ACCOUNT_MASTER ADD(DEALER_ID VARCHAR2(16 BYTE));

ALTER TABLE LOANS_FACILITY_DETAILS
ADD (DEALER_ID VARCHAR2(16 BYTE));
-- End Version [Script Version - 0.0.254] [ReleaseVersion - 9.2.2.7]--[11-07-2017] -- by Revathi.L

-- Start Version [Script Version - 0.0.255] [ReleaseVersion - 9.2.2.7]--[17-07-2017] -- By Suresh R
CREATE OR REPLACE FUNCTION GET_STANDING_AMT(prodid VARCHAR2,PRODTYPE varchar2,ACTNUM VARCHAR2,InstNo NUMBER,DEBITAMT NUMBER) 
RETURN NUMBER IS
   DEBITAMT1 NUMBER(16,2) := 0;
   REPAYMENTTYPE varchar2(20);
BEGIN 
   IF PRODTYPE= 'TL' THEN
    SELECT P.REPAYMENT_TYPE INTO REPAYMENTTYPE  FROM LOANS_PRODUCT p WHERE P.prod_id=prodid;
    IF REPAYMENTTYPE='EMI'
    THEN SELECT GET_TL_INST(ACTNUM)*InstNo INTO DEBITAMT1  FROM DUAL;
    ELSE DEBITAMT1:=DEBITAMT;
    END IF;
   ELSE DEBITAMT1:=DEBITAMT;
    END IF;
    RETURN DEBITAMT1;
END;
/

create or replace function getRDPenalMonths(noOfMonths number, instPay number) return number is
    totMonths number(5):=0;
    i number(5):=0;
    noMonths number(5):=0;
begin
noMonths:=noOfMonths;
while i<instPay loop
    if noMonths>=1 then
--        dbms_output.put_line(noMonths);
        totMonths:=totMonths+noMonths;
        noMonths:=noMonths-1;
    end if;
    i:=i+1;
end loop;
return totMonths;
end;
-- End Version [Script Version - 0.0.255] [ReleaseVersion - 9.2.2.7]--[17-07-2017] -- By Suresh R

-- Start Version [Script Version - 0.0.256] [ReleaseVersion - 9.2.2.7]--[17-07-2017] -- by Rishad

alter table LOAN_APPLICATION_REGISTER ADD (INSTALLMENT_AMOUNT NUMBER(16,2)DEFAULT 0)

-- End Version [Script Version - 0.0.256] [ReleaseVersion - 9.2.2.7]--[17-07-2017] -- by Rishad

-- Start Version [Script Version - 0.0.257] [ReleaseVersion - 9.2.2.8]--[04-08-2017] -- By Suresh R
SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12247', '133', 'DCB File Upload', 'APP01', 'DONE', 
    '8', 'com.see.truetransact.ui.transaction.dailyDepositTrans.DCBFileUploadUI', 11, 'CREATED', NULL, 
    NULL, 'DCB File Upload');
COMMIT;


SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR12247', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR12247', 'CREATED', NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR12247', 'CREATED', NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR12247', 'CREATED', NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL);
COMMIT;

CREATE TABLE DCB_CONSOL_SETTINGS
(
  BRANCHID      VARCHAR2(15 BYTE)               NOT NULL,
  INST_ID       VARCHAR2(15 BYTE)               NOT NULL,
  COLSEP        VARCHAR2(1 BYTE)                NOT NULL,
  OTHRBANKID    VARCHAR2(15 BYTE)               NOT NULL,
  SOC_BRANCHID  VARCHAR2(5 BYTE)                NOT NULL
);

SET DEFINE OFF;
Insert into DCB_CONSOL_SETTINGS
   (BRANCHID, INST_ID, COLSEP, OTHRBANKID, SOC_BRANCHID)
 Values
   ('0001', 'DCB', '|', 'AB0000001', '00301');
Insert into DCB_CONSOL_SETTINGS
   (BRANCHID, INST_ID, COLSEP, OTHRBANKID, SOC_BRANCHID)
 Values
   ('0002', 'DCB', '|', 'AB0000002', '00301');
COMMIT;

DROP TABLE DCB_CONSOLIDATION CASCADE CONSTRAINTS;

CREATE TABLE DCB_CONSOLIDATION
(
  FILE_ID      VARCHAR2(16 BYTE),
  COL1         VARCHAR2(15 BYTE),
  COL2         VARCHAR2(15 BYTE),
  COL3         VARCHAR2(15 BYTE),
  COL4         VARCHAR2(15 BYTE),
  COL5         VARCHAR2(15 BYTE),
  COL6         VARCHAR2(15 BYTE),
  COL7         VARCHAR2(15 BYTE),
  COL8         VARCHAR2(15 BYTE),
  COL9         VARCHAR2(15 BYTE),
  COL10        VARCHAR2(15 BYTE),
  COL11        VARCHAR2(15 BYTE),
  COL12        VARCHAR2(15 BYTE),
  COL13        VARCHAR2(150 BYTE),
  COL14        VARCHAR2(15 BYTE),
  COL15        VARCHAR2(15 BYTE),
  COL16        VARCHAR2(15 BYTE),
  COL17        VARCHAR2(15 BYTE),
  COL18        VARCHAR2(15 BYTE),
  COL19        VARCHAR2(15 BYTE),
  COL20        VARCHAR2(15 BYTE),
  USERNAME     VARCHAR2(15 BYTE),
  LOGDATE      DATE,
  INITIATEDBR  VARCHAR2(4 BYTE)
);

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('FILE_ID', 1, 'DCBF', TO_DATE('11/27/2013 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 10, 
    '0001');
COMMIT;

CREATE OR REPLACE VIEW DCB_CONSOL_DET1 AS 
SELECT  FILE_ID,ROWNUM AS BATCHID,(CASE WHEN  COL5 ='D' THEN 'DEBIT' ELSE 'CREDIT' END) AS TRANS_TYPE,COL7 AS AMOUNT,COL8 AS ACT_NUM,
  'DCB TR DATE -' || COL2 || ', Trtype- ' || COL6   AS PARTICULARS,COL10 AS INSTRUMENT_NO1,COL11 AS INSTRUMENT_NO2,
  NVL(COL17,'P') AS ACCOUNT_TYPE , SUBSTR(DC.COL8,5,3) AS PROD_ID,
  CASE 
  WHEN NVL(COL17,'P') ='P' THEN   ACCT_HEAD 
  WHEN NVL(COL17,'P') ='I' THEN   AC_DEBIT_INT
  WHEN NVL(COL17,'P') ='PN' THEN  PENAL_INT 
  WHEN NVL(COL17,'P') ='CI' THEN  AC_CREDIT_INT
  WHEN NVL(COL17,'P') ='N' THEN   NOTICE_CHARGES
  WHEN NVL(COL17,'P') ='A' THEN   ARBITRARY_CHARGES
  WHEN NVL(COL17,'P') ='O' THEN   OTHRCHRGS_HD
  END AS AC_HD_ID,INITIATEDBR,SUBSTR(DC.COL8,1,4) AS BRANCH_ID ,USERNAME,LOGDATE
FROM DCB_CONSOLIDATION DC
JOIN LOANS_PRODUCT LP ON LP.PROD_ID = SUBSTR(DC.COL8,5,3)
JOIN LOANS_PROD_ACHD LA ON LA.PROD_ID =  SUBSTR(DC.COL8,5,3)
 WHERE COL16 ='V' ORDER BY ROWNUM;


CREATE OR REPLACE VIEW DCB_CONSOL_DET_CONTRA AS 
SELECT FILE_ID,DC.BATCHID,(CASE WHEN  DC.TRANS_TYPE ='CREDIT' THEN 'DEBIT' ELSE 'CREDIT' END) AS TRANS_TYPE, DC.AMOUNT, DS.OTHRBANKID AS ACT_NUM,
DC.ACT_NUM AS PARTICULARS ,DC.INSTRUMENT_NO1,DC.INSTRUMENT_NO2,'P' AS ACCOUNT_TYPE, OAM.PROD_ID,
OP.PRINCIPAL_AC_HD AS AC_HD_ID,DC.INITIATEDBR,OAM.BRANCH_ID AS BRANCH_ID ,DC.USERNAME,DC.LOGDATE
     FROM DCB_CONSOL_DET1 DC 
     JOIN DCB_CONSOL_SETTINGS DS      ON     DS.BRANCHID = DC.BRANCH_ID  
     JOIN OTHER_BANKS_ACT_MASTER OAM  ON OAM.ACT_MASTER_ID = DS.OTHRBANKID  
     JOIN OTHER_BANK_ACCOUNT_PRODUCTS OP ON OP.PROD_ID = OAM.PROD_ID ORDER BY DC.BATCHID;
  

CREATE OR REPLACE VIEW DCB_CONSOL_DET  AS 
 SELECT FILE_ID,BATCHID,TRANS_TYPE,AMOUNT,ACT_NUM,PARTICULARS,INSTRUMENT_NO1,INSTRUMENT_NO2,ACCOUNT_TYPE,PROD_ID,AC_HD_ID,INITIATEDBR,BRANCH_ID,USERNAME,LOGDATE 
  FROM DCB_CONSOL_DET1  UNION ALL 
 SELECT FILE_ID,BATCHID,TRANS_TYPE,AMOUNT,ACT_NUM,PARTICULARS,INSTRUMENT_NO1,INSTRUMENT_NO2,ACCOUNT_TYPE,PROD_ID,AC_HD_ID,INITIATEDBR,BRANCH_ID,USERNAME,LOGDATE
  FROM DCB_CONSOL_DET_CONTRA  ORDER BY BATCHID; 
-- End Version [Script Version - 0.0.257] [ReleaseVersion - 9.2.2.8]--[04-08-2017] -- By Suresh R

-- Start Version [Script Version - 0.0.258] [ReleaseVersion - 9.2.2.8]--[07-08-2017] -- By Suresh R
CREATE TABLE DCB_COMPLETED_FILES
(
  FILE_ID    VARCHAR2(16 BYTE),
  FILE_NAME  VARCHAR2(128 BYTE)
);
-- End Version [Script Version - 0.0.258] [ReleaseVersion - 9.2.2.8]--[07-08-2017] -- By Suresh R

-- Start Version [Script Version - 0.0.259] [ReleaseVersion - 9.2.2.7]--[06-10-2017] -- By Nithya

ALTER TABLE MDS_SCHEME_DETAILS ADD CHANGE_MEMBER_SETTLEMENT VARCHAR2(1);

UPDATE MDS_SCHEME_DETAILS SET CHANGE_MEMBER_SETTLEMENT = 'N';

-- End Version [Script Version - 0.0.259] [ReleaseVersion - 9.2.2.7]--[06-10-2017] -- By Nithya

-- Start Version [Script Version - 0.0.259] [ReleaseVersion - 9.2.2.8]--[07-11-2017] -- By Nithya

 ALTER TABLE DEPOSITS_PRODUCT ADD IS_GROUP_DEPOSIT VARCHAR2(1) DEFAULT 'N';
   
 CREATE TABLE GROUP_DEPOSIT
(
  GROUP_NO                       VARCHAR2(10 BYTE),
  GROUP_NAME                     VARCHAR2(100 BYTE),
  SCHEME_COUNT                   NUMBER(3),
  GROUP_TYPE                     VARCHAR2(10 BYTE),
  START_DT                       DATE,
  END_DT                         DATE,
  STATUS                         VARCHAR2(32 BYTE),
  AUTHORIZED_BY                  VARCHAR2(32 BYTE),
  AUTHORIZED_DT                  DATE,
  AUTHORIZE_STATUS               VARCHAR2(16 BYTE),
  CREATED_BY                     VARCHAR2(32 BYTE),
  CREATED_DT                     DATE,
  STATUS_BY                      VARCHAR2(32 BYTE),
  STATUS_DT                      DATE,
  BRANCH_ID                      VARCHAR2(16 BYTE),
  INTEREST_AMOUNT_TYPE           VARCHAR2(20 BYTE),
  INTEREST_AMOUNT                NUMBER(5,2),
  PENAL_CALCULATION_TYPE         VARCHAR2(20 BYTE),
  PRIZED_PENAL                   NUMBER(5,2),
  NON_PRIZED_PENAL               NUMBER(5,2),
  INTEREST_RECOVERY_TYPE         VARCHAR2(20 BYTE),
  INTEREST_RECOVERY              NUMBER(5,2),
  PROD_TYPE                      VARCHAR2(10 BYTE),
  DEPOSIT_AMT                    NUMBER(16,2),
  PREMATURE_INT_REC_CALC_TYPE    VARCHAR2(20 BYTE),
  PREMATURE_INT_REC_CALC_AMOUNT  NUMBER(16,2),
  IS_INTEREST_RECOVERY           VARCHAR2(1 BYTE),
  INT_CALC_BEFORE_FULL_PAYMENT   VARCHAR2(1 BYTE),
  INT_CALC_RATE_BEFORE_PAYMENT   NUMBER(10,2)
);

ALTER TABLE BRANCH_ACNO_MAINTENANCE ADD GROUP_NO VARCHAR2(10);

ALTER TABLE DEPOSIT_ACINFO ADD GROUP_NO VARCHAR2(20 BYTE);

/* The below script is for handling the charges for group deposit account closing */
/* Insert an entry for group deposit porduct as below */

Insert into LOAN_CHARGE_DEFINITION
   (SCHEME_ID, CHARGE_ID, CHARGE_DESC, ACC_HEAD, MANDATORY, 
    DEDUCTION_ACCU, CHARGE_BASE, FROM_SLAB_AMT, TO_SLAB_AMT, FLAT_CHARGE, 
    CHARGE_RATE, DIVISIBLE_BY, ROUND_OFF_TYPE, MIN_CHARGE_AMOUNT, MAX_CHARGE_AMOUNT, 
    STATUS, STATUS_DT, STATUS_BY, AUTHORIZED_STATUS, AUTHORIZED_DT, 
    AUTHORIZED_BY, EDITABLE, CHARGE_EDITABLE, IS_DEPOSIT_OR_LOAN, DAY_WISE_CALC)
    Values
   ('DAILY GROUP DEPOSIT', 'CHRG000009', 'Penal ', '4004001006', 'N', 
    'C', 'Flat Charge', NULL, NULL, '20.00', 
    NULL, NULL, NULL, NULL, NULL, 
    'CREATED', TO_DATE('06/05/2014 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'deepa', 'AUTHORIZED', TO_DATE('06/05/2014 12:52:52', 'MM/DD/YYYY HH24:MI:SS'), 
    'aswin', 'Y', 'Y', '3', 'N');

-- End Version [Script Version - 0.0.259] [ReleaseVersion - 9.2.2.8]--[07-11-2017] -- By Nithya

-- Start Version [Script Version - 0.0.260] [ReleaseVersion - 9.2.2.8]--[17-11-2017] -- By Nithya
  ALTER TABLE LOANS_PROD_ACPARAM ADD IS_INT_PERIOD_SLAB_CALC VARCHAR2(1) DEFAULT 'N';
-- End Version [Script Version - 0.0.260] [ReleaseVersion - 9.2.2.8]--[17-11-2017] -- By Nithya

-- Start Version [Script Version - 0.0.261] [ReleaseVersion - 9.2.2.8]--[24-11-2017] -- By Suresh
UPDATE MODULE_MASTER SET STATUS='CREATED' WHERE MODULE_NAME='Remittance';

ALTER TABLE OTHER_BANK_BRANCH
ADD(BRANCH_IFSCODE VARCHAR2(16 BYTE));

ALTER TABLE BRANCH_MASTER
ADD(IFSC_CODE VARCHAR2(16 BYTE));

ALTER TABLE PARAMETERS
ADD(RTGS_GL VARCHAR2(16 BYTE));

UPDATE SCREEN_MASTER SET STATUS='DELETED' WHERE MODULE_ID='7';  --IF NOT REQ REMITTANCE ISSUE/PAYMENT ETC.,..

UPDATE SCREEN_MASTER SET STATUS='CREATED' WHERE MODULE_ID='7' AND SCREEN_NAME='RTGS/NEFT';

UPDATE MODULE_MASTER SET MODULE_NAME='RTGS/NEFT' WHERE MODULE_NAME='Remittance';

CREATE TABLE RTGS_REMIT_ISSUE
(
  RTGS_ID           VARCHAR2(16 BYTE),
  BATCH_ID          VARCHAR2(16 BYTE),
  BATCH_DT          DATE,
  PROD_ID           VARCHAR2(16 BYTE),
  SENDER_IFSC_CODE  VARCHAR2(16 BYTE),
  BANK_CODE         VARCHAR2(120 BYTE),
  BANK_NAME         VARCHAR2(120 BYTE),
  BRANCH_CODE       VARCHAR2(120 BYTE),
  BRANCH_NAME       VARCHAR2(120 BYTE),
  IFSC_CODE         VARCHAR2(16 BYTE),
  NAME              VARCHAR2(120 BYTE),
  AMOUNT            NUMBER(16,2),
  ACCOUNT_NO        VARCHAR2(32 BYTE),
  REMARKS           VARCHAR2(256 BYTE),
  EX_CALCULATED     NUMBER(16,2),
  EX_COLLECTED      NUMBER(16,2),
  SERVICE_TAX       NUMBER(16,2),
  TOTAL_AMT         NUMBER(16,2),
  TRANS_TYPE        VARCHAR2(16 BYTE),
  STATUS            VARCHAR2(32 BYTE),
  STATUS_BY         VARCHAR2(32 BYTE),
  STATUS_DT         DATE,
  AUTHORIZE_STATUS  VARCHAR2(16 BYTE),
  AUTHORIZE_BY      VARCHAR2(32 BYTE),
  AUTHORIZE_DT      DATE,
  CHARGES           NUMBER(16,2),
  UTR_NUMBER        VARCHAR2(20 BYTE),
  SEQUNCE_NO        VARCHAR2(12 BYTE),
  FILE_STATUS       VARCHAR2(12 BYTE),
  PROCESS_DT        DATE,
  F27_STATUS_DT     DATE,
  N09_STATUS_DT     DATE,
  N10_STATUS_DT     DATE,
  REJECT_REMARKS    VARCHAR2(35 BYTE),
  INITIATED_BRANCH  VARCHAR2(6 BYTE),
  RTGS_UNIQUE_ID    VARCHAR2(16 BYTE)
);

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('RTGS_ID', 0, 'ETID', TO_DATE('02/04/2015 14:46:15', 'MM/DD/YYYY HH24:MI:SS'), 16, 
    '0001');
COMMIT;

DROP TABLE REMITTANCE_PRODUCT CASCADE CONSTRAINTS;

CREATE TABLE REMITTANCE_PRODUCT
(
  PROD_ID                VARCHAR2(8 BYTE),
  PROD_DESC              VARCHAR2(128 BYTE),
  ISSUE_HD               VARCHAR2(16 BYTE),
  EXCHANGE_HD            VARCHAR2(16 BYTE),
  TELEGRAM_CHRG_HD       VARCHAR2(16 BYTE),
  REVAL_CHRG_HD          VARCHAR2(16 BYTE),
  OTHER_CHRG_HD          VARCHAR2(16 BYTE),
  LAPSED_HD              VARCHAR2(16 BYTE),
  EFT_PRODUCT            VARCHAR2(1 BYTE),
  CASH_LIMIT             NUMBER(16,2),
  PRINT_SERVICES         VARCHAR2(1 BYTE),
  PAY_HD                 VARCHAR2(16 BYTE),
  POSTAGE_HD             VARCHAR2(16 BYTE),
  DUPL_CHRG_HD           VARCHAR2(16 BYTE),
  CANCELL_CHRG_HD        VARCHAR2(16 BYTE),
  LAPSE_APPL             VARCHAR2(1 BYTE),
  LAPSE_PERIOD           NUMBER(5),
  PAY_ISSUE_BRANCH       VARCHAR2(32 BYTE),
  NUMBER_PATTERN         VARCHAR2(16 BYTE),
  SERIES_MAINTAINED      VARCHAR2(1 BYTE),
  REMARKS                VARCHAR2(128 BYTE),
  STATUS                 VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS       VARCHAR2(32 BYTE),
  AUTHORIZE_USER         VARCHAR2(32 BYTE),
  AUTHORIZE_DT           DATE,
  BASE_CURRENCY          VARCHAR2(32 BYTE),
  CREATED_BY             VARCHAR2(32 BYTE),
  CREATED_DT             DATE,
  STATUS_BY              VARCHAR2(32 BYTE),
  STATUS_DT              DATE,
  AUTHORIZE_REMARK       VARCHAR2(1024 BYTE),
  NUMBER_PATTERN_SUFFIX  VARCHAR2(16 BYTE),
  BEHAVES_LIKE           VARCHAR2(32 BYTE),
  NEW_PROCEDURE          VARCHAR2(1 BYTE),
  NEW_PROC_START_DT      DATE,
  NEW_PROC_ISSUE_HD      VARCHAR2(16 BYTE),
  MAX_AMOUNT             VARCHAR2(16 BYTE),
  MIN_AMOUNT             VARCHAR2(16 BYTE),
  NEFT_RTGS_SUSPENCE_HD  VARCHAR2(16 BYTE)
);

DROP TABLE REMITTANCE_PROD_CHARGES CASCADE CONSTRAINTS;

CREATE TABLE REMITTANCE_PROD_CHARGES
(
  PROD_ID         VARCHAR2(16 BYTE),
  CHARGE_TYPE     VARCHAR2(32 BYTE),
  AMT_RANGE_FROM  NUMBER(16,2),
  AMT_RANGE_TO    NUMBER(16,2),
  CHARGE          NUMBER(16,2),
  STATUS          VARCHAR2(16 BYTE),
  CATEGORY        VARCHAR2(32 BYTE),
  BANK_CODE       VARCHAR2(16 BYTE),
  BRANCH_CODE     VARCHAR2(16 BYTE),
  FOR_EVERY_AMT   NUMBER(16,2),
  FOR_EVERY_RATE  NUMBER(16,2),
  FOR_EVERY_TYPE  VARCHAR2(32 BYTE),
  PERCENTAGE      NUMBER(8,3),
  SERVICE_TAX     NUMBER(8,3),
  MIN_AMT         NUMBER(16,2),
  MAX_AMT         NUMBER(16,2)
);

CREATE TABLE IFSC_BANK_BRANCH
(
  IFSC_CODE          VARCHAR2(15 BYTE),
  MICR_CODE          VARCHAR2(15 BYTE),
  BRANCH_NAME        VARCHAR2(80 BYTE),
  ADDRESS            VARCHAR2(256 BYTE),
  CONTACT            VARCHAR2(16 BYTE),
  CITY               VARCHAR2(64 BYTE),
  DISTRICT           VARCHAR2(64 BYTE),
  STATE              VARCHAR2(32 BYTE),
  BANK_CODE          NUMBER(5),
  STATUS             VARCHAR2(16 BYTE),
  STATUS_BY          VARCHAR2(32 BYTE),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(16 BYTE),
  AUTHORIZED_BY      VARCHAR2(32 BYTE),
  AUTHORIZED_DT      DATE
);

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06152', '6152', 'RTGS/NEFT', 'APP01', 'DONE', 
    '7', 'com.see.truetransact.ui.remittance.rtgs.RtgsRemittanceUI', 1, 'CREATED', NULL, 
    NULL, 'RTGS');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR06152', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR06152', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR06152', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR06152', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
COMMIT;



SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12248', '2248', 'RTGS Transaction Enquiry', 'APP01', 'DONE', 
    '7', 'com.see.truetransact.ui.remittance.rtgs.RTGS Transaction Status Details', 7, 'CREATED', NULL, 
    NULL, 'RTGS Transaction Status Details');
COMMIT;

SET DEFINE OFF;
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00001', 'SCR12248', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00003', 'SCR12248', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP01014', 'SCR12248', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
Insert into GROUP_SCREENS
   (GROUP_ID, SCREEN_ID, STATUS, NEW_ALLOWED, EDIT_ALLOWED, 
    DELETE_ALLOWED, AUTH_REJ_ALLOWED, EXCEPTION_ALLOWED, PRINT_ALLOWED, INTERBRANCH_ALLOWED)
 Values
   ('GRP00002', 'SCR12248', 'CREATED', 'Y', 'Y', 
    'Y', 'Y', 'Y', 'Y', NULL);
COMMIT;

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12249', '2249', 'RTGS Other Bank Branch Details', 'APP01', 'DONE', 
    '3', 'com.see.truetransact.ui.product.remittance.RTGSOtherBankBranchUI', 12, 'CREATED', NULL, 
    NULL, 'RTGS');
COMMIT;


CREATE TABLE RTGS_NEFT_ACKNOWLEDGEMENT
(
  ACCT_NUM             VARCHAR2(25 BYTE),
  PROD_ID              VARCHAR2(8 BYTE),
  ACCT_STATUS          VARCHAR2(16 BYTE),
  ACK_DATE             DATE,
  AMOUNT               NUMBER(16,2),
  UTR_NUMBER           VARCHAR2(32 BYTE),
  BATCH_ID             VARCHAR2(12 BYTE),
  INIT_BRANCH_ID       VARCHAR2(16 BYTE),
  HOME_IFS_CODE        VARCHAR2(16 BYTE),
  OTHER_BANK_IFS_CODE  VARCHAR2(16 BYTE),
  REMARKS              VARCHAR2(200 BYTE),
  STATUS               VARCHAR2(16 BYTE),
  SENDER_ACT_NO        VARCHAR2(30 BYTE),
  SENDER_NAME          VARCHAR2(95 BYTE),
  BENEFICIARY_NAME     VARCHAR2(70 BYTE),
  STATUS_DT            DATE  DEFAULT SYSDATE,
  INWARD_FAIL_ACK_UTR  VARCHAR2(32 BYTE),
  MANUAL_REC           VARCHAR2(1 BYTE),
  FILE_NAME            VARCHAR2(70 BYTE),
  CLIENT_CODE          VARCHAR2(25 BYTE),
  CR_ACCT_NUM          VARCHAR2(30 BYTE),
  BENEFICIARY_BANK     VARCHAR2(70 BYTE)
);

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('RTGS_UNIQUE_ID', 1, 'TT', TO_DATE('02/04/2015 14:46:15', 'MM/DD/YYYY HH24:MI:SS'), 16, 
    '0001');
COMMIT;

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('CEDGE_ID', 1, 'CE', TO_DATE('02/04/2015 14:46:15', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0001');
COMMIT;


SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('CEDGE_ID_RTGS', 1, 'CE', TO_DATE('02/04/2015 14:46:15', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0001');
COMMIT;

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
    Values
   ('REMITTANCE.BEHAVES', 'EFT', 'Electronic Fund Transfer', 'CREATED', NULL, 
    'Y');
-- End Version [Script Version - 0.0.261] [ReleaseVersion - 9.2.2.8]--[24-11-2017] -- By Suresh

-- Start Version [Script Version - 0.0.262] [ReleaseVersion - 9.2.2.8]--[10-01-2018] -- By Sathiya

ALTER TABLE SMS_SUBSCRIPTION ADD CUST_ID VARCHAR2(16);

CREATE OR REPLACE PROCEDURE SMS_ACKNLOWLEDGE_UPDATE(MSG VARCHAR2, ACKNOWLEDGE VARCHAR2, 
PHONENO  NUMERIC, SENDDT  DATE, SMSID VARCHAR2,ACTNUM VARCHAR2,SMSMODULE VARCHAR2) AS
BEGIN 
MERGE INTO SMS_ACKNOWLEDGMENT SMSA USING (SELECT * FROM SMS_SUBSCRIPTION SMSS WHERE STATUS != 'DELETED' AND AUTHORIZE_STATUS = 'AUTHORIZED' AND SMSS.ACT_NUM = ACTNUM OR SMSS.CUST_ID = ACTNUM) H ON (
SMSA.ACT_NUM = ACTNUM AND SMSA.SMS_ID = SMSID
) WHEN MATCHED THEN
UPDATE SET SMSA.ACKNOWLEDGMENT = ACKNOWLEDGE
WHEN NOT MATCHED THEN
INSERT (SMSA.MESSAGE, SMSA.ACKNOWLEDGMENT, SMSA.PHONE_NO, SMSA.SEND_DATE, SMSA.SMS_ID, SMSA.ACT_NUM, SMSA.SMS_MODULE, SMSA.CREATED_DT)
VALUES (MSG, ACKNOWLEDGE, PHONENO, SENDDT, SMSID, ACTNUM,SMSMODULE, (SELECT SYSDATE FROM DUAL));
COMMIT;
END SMS_ACKNLOWLEDGE_UPDATE;

CREATE TABLE MULTIPLE_MSG_TO_SINGLE_MSG
(
  CUST_ID         VARCHAR2(16 BYTE),
  ACT_NUM         VARCHAR2(16 BYTE),
  TRANS_DT        DATE,
  STATUS          VARCHAR2(16 BYTE),
  STATUS_BY       VARCHAR2(16 BYTE),
  SATUS_DT        DATE,
  PROCESSED_FLAG  VARCHAR2(1 BYTE),
  INT_AMT NUMBER(14,2)
)

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SL_NO, STATUS)
 Values
   ('SCRA6111', '6111', 'MultipleMSGTOSingleMsgCustomerwise', 'APP01', 'DONE', 
    '6', 15, 'CREATED');
COMMIT;

call INSERT_REPORT_GROUP('SCRA6111');

UPDATE  SCREEN_MASTER SET SCREEN_NAME ='Change Customer ID Single' WHERE SCREEN_NAME='Change Customer ID';

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR06325', '6325', 'Mutiple Customer ID Change', 'APP01', 'DONE', 
    '2', NULL, 2, 'CREATED', NULL, 
    NULL, 'Mutiple Customer ID Change');
COMMIT;

CALL INSERT_REPORT_GROUP('SCR06325');

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('MULTI_CUST_ID', 0, 'CC', TO_DATE('06/23/2015 12:53:52', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '8037');
COMMIT;

ALTER TABLE CUST_ID_CHANGE ADD (MULTIPLE_BATCH_ID VARCHAR2(16 BYTE));

CREATE TABLE MULTIPLE_CUST_MERGE (MULTIPLE_BATCH_ID VARCHAR2(16 BYTE),CUSTOMER_NAME VARCHAR2(64 BYTE), SEARCHFIELD VARCHAR2(16 BYTE),MEMBER_NUM VARCHAR2(16 BYTE),ADDRESS  VARCHAR2(16 BYTE) ,
PHONE_NO VARCHAR2(10 BYTE),CARE_OF_NAME VARCHAR2(16 BYTE),CUST_ID VARCHAR2(16 BYTE),EMP_NO VARCHAR2(16 BYTE),UNIQUE_ID VARCHAR2(16 BYTE),
PANNO VARCHAR2(16 BYTE),PASSPORTNO VARCHAR2(16 BYTE),DOB DATE,CUST_BRANCH VARCHAR2(16 BYTE),CUST_BRANCH_NAME VARCHAR2(32 BYTE),
ACCOUNTNO VARCHAR2(16 BYTE),NEW_CUST_ID VARCHAR2(16 BYTE),NEW_CUST_NAME VARCHAR2(64 BYTE),INIT_BRANCH VARCHAR2(16 BYTE),
STATUS VARCHAR2(16 BYTE),STATUS_DT DATE,STATUS_BY VARCHAR2(16 BYTE),AUTH_STATUS VARCHAR2(16 BYTE),AUTH_BY VARCHAR2(16 BYTE),AUTH_DATE DATE);
 
 CREATE OR REPLACE FORCE VIEW ALL_CUSTOMER_ACCTS
(
   CUST_ID,
   NAME,
   ACT_NUM,
   PROD_TYPE,
   PROD_ID,
   PROD_DESC,
   REP_ACT_NUM,
   BRANCH_ID,
   SALARY_RECOVERY,
   LOCK_STATUS,
   ACCT_STATUS,
   BALANCE,
   BEHAVES_LIKE
)
AS
   (SELECT cust_id,
           get_joint_cust (am.act_num) AS NAME,
           am.act_num AS act_num,
           'OA' AS prod_type,
           am.prod_id,
           ap.prod_desc,
           am.act_num || '_1' AS rep_act_num,
           branch_code AS branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           am.act_status_id AS acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM act_master am, all_products ap
     WHERE     am.authorization_status = 'AUTHORIZED'
           AND am.prod_id = ap.prod_id
           AND am.status IN ('CREATED', 'MODIFIED')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (da.deposit_no) AS NAME,
           da.deposit_no AS act_num,
           'TD' AS prod_type,
           da.prod_id,
           ap.prod_desc,
           da.deposit_no || '_1' AS rep_act_num,
           branch_id,
           NVL (ds.salary_recovery, 'N') AS salary_recovery,
           NVL (ds.lock_status, 'N') AS lock_status,
           ds.acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM deposit_acinfo da, deposit_sub_acinfo ds, all_products ap
     WHERE     da.authorize_status = 'AUTHORIZED'
           AND ds.deposit_no = da.deposit_no
           AND da.prod_id = ap.prod_id
           AND da.status IN ('CREATED', 'MODIFIED', 'LIEN')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'TL' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status,
           lfd.acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM loans_facility_details lfd, loans_borrower lb, all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND behaves_like NOT IN ('OD', 'CC')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'AD' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           NVL (salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status,
           lfd.acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM loans_facility_details lfd, loans_borrower lb, all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND behaves_like IN ('OD', 'CC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'ATL' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           lfd.acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM agri_loans_facility_details lfd,
           loans_borrower lb,
           all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND behaves_like NOT IN ('AOD', 'ACC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (lfd.acct_num) AS NAME,
           lfd.acct_num AS act_num,
           'AAD' AS prod_type,
           lfd.prod_id,
           ap.prod_desc,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           lfd.acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM agri_loans_facility_details lfd,
           loans_borrower lb,
           all_products ap
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lb.borrow_no = lfd.borrow_no
           AND lfd.prod_id = ap.prod_id
           AND lfd.status IN ('CREATED', 'MODIFIED')
           AND behaves_like IN ('AOD', 'ACC')
    UNION ALL
    SELECT cust_id,
           get_joint_cust (am.suspense_acct_num) AS NAME,
           am.suspense_acct_num AS act_num,
           'SA' AS prod_type,
           am.suspense_prod_id AS prod_id,
           ap.prod_desc,
           am.suspense_prefix || am.suspense_ref_no AS rep_act_num,
           am.branch_code AS branch_id,
           'N' AS salary_recovery,
           'N' AS lock_status,
           'NEW' AS acct_status,
           clear_balance AS balance,
           BEHAVES_LIKE
      FROM suspense_account_master am, customer c, all_products ap
     WHERE     am.suspense_customer_id = c.cust_id
           AND am.authorize_status = 'AUTHORIZED'
           AND am.suspense_prod_id = ap.prod_id
           AND am.status IN ('CREATED', 'MODIFIED'));

-- End Version [Script Version - 0.0.262] [ReleaseVersion - 9.2.2.8]--[10-01-2018] -- By Sathiya

-- Satrt Version [Script Version - 0.0.263] [ReleaseVersion - 9.2.2.8]--[10-01-2018] -- By Nithya

ALTER TABLE GROUP_DEPOSIT ADD NEXT_GDS_NO NUMBER(5);
  
ALTER TABLE GROUP_DEPOSIT ADD INT_BEFORE_FULL_PAYMENT_TYPE VARCHAR2(20);

alter table SERVICE_TAX_SETTINGS add KRISHI_KALYAN_CESS  NUMBER(16,2);

alter table SERVICE_TAX_SETTINGS add SWACHH_CESS  NUMBER(16,2);

alter table SERVICE_TAX_SETTINGS add SWACHH_HEAD_ID VARCHAR(30);

alter table SERVICE_TAX_SETTINGS add KRISHI_HEAD_ID VARCHAR(30);

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12248', '133', 'Group MDS Deposit Product', 'APP01', 'DONE', 
    '3', NULL, 1, 'CREATED', NULL, 
    NULL, 'Group MDS Deposit Product');

-- End Version [Script Version - 0.0.263] [ReleaseVersion - 9.2.2.8]--[10-01-2018] -- By Nithya

-- Start Version [Script Version - 0.0.264] [ReleaseVersion - 9.2.2.8]--[01-02-2018] -- By Sathiya

ALTER TABLE SMS_PARAMETER ADD TXN_ALLOWED VARCHAR2(1) DEFAULT('N'); 

UPDATE SMS_PARAMETER SET TXN_ALLOWED = 'N';

ALTER TABLE PARAMETERS ADD SMS_ALLOWED VARCHAR(1) DEFAULT 'N';

CREATE OR REPLACE PROCEDURE SMS_ACKNLOWLEDGE_UPDATE(MSG VARCHAR2, ACKNOWLEDGE VARCHAR2, 
PHONENO  NUMERIC, SENDDT  DATE, SMSID VARCHAR2,ACTNUM VARCHAR2,SMSMODULE VARCHAR2) AS
BEGIN 
MERGE INTO SMS_ACKNOWLEDGMENT SMSA USING (SELECT * FROM SMS_SUBSCRIPTION SMSS WHERE SMSS.ACT_NUM = ACTNUM OR SMSS.CUST_ID = ACTNUM AND 
SMSS.STATUS != 'DELETED' AND AUTHORIZE_STATUS = 'AUTHORIZED' AND ROWNUM = 1) H ON (
SMSA.ACT_NUM = ACTNUM AND SMSA.SMS_ID = SMSID
) WHEN MATCHED THEN
UPDATE SET SMSA.ACKNOWLEDGMENT = ACKNOWLEDGE
WHEN NOT MATCHED THEN
INSERT (SMSA.MESSAGE, SMSA.ACKNOWLEDGMENT, SMSA.PHONE_NO, SMSA.SEND_DATE, SMSA.SMS_ID, SMSA.ACT_NUM, SMSA.SMS_MODULE, SMSA.CREATED_DT)
VALUES (MSG, ACKNOWLEDGE, PHONENO, SENDDT, SMSID, ACTNUM,SMSMODULE, (SELECT SYSDATE FROM DUAL));
COMMIT;
END SMS_ACKNLOWLEDGE_UPDATE;

-- End Version [Script Version - 0.0.264] [ReleaseVersion - 9.2.2.8]--[01-02-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.265] [ReleaseVersion - 9.2.2.8]--[06-02-2018] -- By Nithya

-- The below query is necessary because the map getSelectAccountMaintenanceTO will retrieve value from AC_HD_PARAM.
 ALTER TABLE AC_HD_PARAM ADD SERVICE_TAX_ID VARCHAR2(20);
-- Need to run the above query while deploying the release : Field SERVICE_TAX_ID should be added for GST changes
 ALTER TABLE DEPOSITS_PRODUCT ADD IS_TRANFER_CHARGES VARCHAR2(1) DEFAULT 'Y';

 -- Fields to be added for GST changes
 alter table SERVICE_TAX_SETTINGS add KRISHI_KALYAN_CESS  NUMBER(16,2);
 alter table SERVICE_TAX_SETTINGS add SWACHH_CESS  NUMBER(16,2);
 alter table SERVICE_TAX_SETTINGS add SWACHH_HEAD_ID VARCHAR(30);
 alter table SERVICE_TAX_SETTINGS add KRISHI_HEAD_ID VARCHAR(30);


Insert into LOOKUP_MASTER
(LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
AUTHORIZED)
Values
('FREQUENCY', '15', 'Fortnight', 'CREATED', NULL, 
'Y');
Insert into LOOKUP_MASTER
(LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
AUTHORIZED)
Values
('LOAN.FREQUENCY', '15', 'Fortnight', 'CREATED', NULL, 
'Y');


 
-- End Version [Script Version - 0.0.265] [ReleaseVersion - 9.2.2.8]--[06-02-2018] -- By Nithya

-- Start Version [Script Version - 0.0.266] [ReleaseVersion - 9.2.2.8]--[06-03-2018] -- By Nithya

CREATE OR REPLACE FUNCTION  GET_JOINT_CUST_NAMES (ACTNUM VARCHAR2) RETURN VARCHAR2 IS
CURSOR C1 is select cu.fname from customer cu join act_joint aj on aj.cust_id=cu.cust_id where aj.act_num=ACTNUM;
JOINT_CUST_NAMES VARCHAR2(300):=' ';
BEGIN
FOR I IN C1 LOOP
JOINT_CUST_NAMES :=JOINT_CUST_NAMES || ' & ' || I.fname ;
END LOOP; 
RETURN JOINT_CUST_NAMES;
END;
/


DROP VIEW OP_ACT_MIN_BAL;

CREATE OR REPLACE FORCE VIEW op_act_min_bal (prod_id, act_num, min_bal)
AS
   (SELECT ac.prod_id, ac.act_num,
           CASE
              WHEN ap.chk_book = 'Y'
                 THEN oap.min_bal_w_chk
              ELSE oap.min_bal_wt_chk
           END AS min_bal
      FROM act_master ac, act_param_detail ap, op_ac_account_param oap
     WHERE oap.prod_id = ac.prod_id
       AND ap.act_num = ac.act_num
       AND ac.act_status_id != 'CLOSED'
    UNION ALL
    SELECT lp.prod_id, lfd.acct_num AS act_num,
           DECODE (lfd.available_balance, 0, 0, 0) AS min_bal
      FROM loans_borrower lb, loans_facility_details lfd, loans_product lp
     WHERE lb.borrow_no = lfd.borrow_no
       AND lfd.prod_id = lp.prod_id
       AND lp.behaves_like = 'OD'
       AND lp.status != 'DELETED'
       AND lp.authorize_status = 'AUTHORIZED'
       AND lb.status NOT IN ('DELETED')
       AND (   lfd.acct_status IN
                            ('NEW', 'TRANSFER_IN', 'DECEASED', 'OPERATIONAL')
            OR lfd.acct_status IS NULL
           )
       AND lfd.status NOT IN ('DELETED')
       AND lfd.authorize_status_1 = 'AUTHORIZED'
    UNION ALL
    SELECT da.prod_id, da.deposit_no || '_1' AS act_num, 0 AS min_bal
      FROM deposit_acinfo da, deposit_sub_acinfo dsa, deposits_product dp
     WHERE da.deposit_no = dsa.deposit_no
       AND da.prod_id = dp.prod_id
       AND dp.behaves_like = 'DAILY'
       AND dsa.acct_status NOT IN ('CLOSED')
       AND da.authorize_status = 'AUTHORIZED');

-- End Version [Script Version - 0.0.266] [ReleaseVersion - 9.2.2.8]--[06-03-2018] -- By Nithya

-- Start Version [Script Version - 0.0.267] [ReleaseVersion - 9.2.2.8]--[13-03-2018] -- By Suresh
SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('OUTWARD_FILE_ID', 0, '0', TO_DATE('02/04/2015 14:46:15', 'MM/DD/YYYY HH24:MI:SS'), 3, 
    '0001');
COMMIT;
-- End Version [Script Version - 0.0.267] [ReleaseVersion - 9.2.2.8]--[13-03-2018] -- By Suresh

-- Start Version [Script Version - 0.0.268] [ReleaseVersion - 9.2.2.8]--[14-03-2018] -- By Rishad

alter table INVESTMENT_MASTER  ADD BRANCH_CODE  VARCHAR2(4) 

-- End Version [Script Version - 0.0.268] [ReleaseVersion - 9.2.2.8]--[14-03-2018] -- By Rishad

-- Start Version [Script Version - 0.0.269] [ReleaseVersion - 9.2.2.8]--[16-03-2018] -- By Sathiya
Insert into BRANCH_ACNO_MAINTENANCE
   (BRANCH_ID, PROD_ID, LAST_AC_NO, NEXT_AC_NO, CREATED_BY, 
    CREATED_DT, STATUS, STATUS_BY, STATUS_DT, AUTHORIZE_STATUS, 
    AUTHORIZE_BY, AUTHORIZE_DT, PREFIX)
 Values
   ('0002', '505', '3192', '3194', 'ADMIN', 
    TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'CREATED', 'ADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'AUTHORIZED', 
    'SYSADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), NULL);
Insert into BRANCH_ACNO_MAINTENANCE
   (BRANCH_ID, PROD_ID, LAST_AC_NO, NEXT_AC_NO, CREATED_BY, 
    CREATED_DT, STATUS, STATUS_BY, STATUS_DT, AUTHORIZE_STATUS, 
    AUTHORIZE_BY, AUTHORIZE_DT, PREFIX)
 Values
   ('0001', '505', '3192', '3194', 'ADMIN', 
    TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'CREATED', 'ADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'AUTHORIZED', 
    'SYSADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), NULL);
Insert into BRANCH_ACNO_MAINTENANCE
   (BRANCH_ID, PROD_ID, LAST_AC_NO, NEXT_AC_NO, CREATED_BY, 
    CREATED_DT, STATUS, STATUS_BY, STATUS_DT, AUTHORIZE_STATUS, 
    AUTHORIZE_BY, AUTHORIZE_DT, PREFIX)
 Values
   ('0003', '505', '3192', '3194', 'ADMIN', 
    TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'CREATED', 'ADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 'AUTHORIZED', 
    'SYSADMIN', TO_DATE('03/31/0011 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), NULL);

ALTER TABLE ACT_MASTER ADD ( CARD_ACCT_NUM VARCHAR2 (16));

ALTER TABLE ACT_MASTER ADD SPONSOR_BANK_STATUS VARCHAR2(16); 

ALTER TABLE ACT_MASTER ADD REQUESTED_TIME DATE;

ALTER TABLE ACT_MASTER ADD LINKING_ACT_NUM VARCHAR2 (16 Byte)

ALTER TABLE ACT_MASTER ADD ATM_LIMIT_AMT NUMBER (14,2);

ALTER TABLE OP_AC_ACHEAD_PARAM ADD (ATM_GL VARCHAR2(16 BYTE));

Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('CEDGE_ATMID', 1, 'CE', TO_DATE('02/04/2015 14:46:15', 'MM/DD/YYYY HH24:MI:SS'), 10, 
    '0001');

CREATE TABLE ATM_ACKNOWLEDGEMENT
(
  ACCT_NUM                 VARCHAR2(16 BYTE),
  CARD_ACCT_NUM            VARCHAR2(35 BYTE),
  TRANS_DT                 DATE,
  AMOUNT                   NUMBER(16,2),
  TRANS_TYPE               VARCHAR2(10 BYTE),
  STATUS                   VARCHAR2(16 BYTE),
  SEQUENCE_NO              VARCHAR2(10 BYTE),
  INITIATED_BRANCH         VARCHAR2(10 BYTE),
  TRAN_ID                  VARCHAR2(16 BYTE),
  TRAN_STATUS              VARCHAR2(16 BYTE),
  ERROR_CODE               VARCHAR2(16 BYTE),
  RRN                      VARCHAR2(16 BYTE),
  STATION_CODE             VARCHAR2(16 BYTE),
  ATMTYPE                  VARCHAR2(16 BYTE),
  FILE_CREATED             VARCHAR2(1 BYTE),
  FILE_CREATED_DATE        DATE,
  FILE_ACK_DT              DATE,
  FILE_TYPE                VARCHAR2(1 BYTE),
  ATMDTSTR                 VARCHAR2(10 BYTE),
  NETWORK_TYPE             VARCHAR2(5 BYTE),
  ATM_POSTTIME             VARCHAR2(10 BYTE),
  CHARGE_BIT               VARCHAR2(1 BYTE),
  CHARGE_AMT               NUMBER(16,2),
  MOP                      VARCHAR2(5 BYTE),
  STATUS_DT                DATE,
  REMARKS                  VARCHAR2(256 BYTE),
  FILE_GENERATED_FLAG      VARCHAR2(1 BYTE),
  TXN_FILE_GENERATED_FLAG  VARCHAR2(1 BYTE)
)

CREATE TABLE CARD_ACCT_STATUS
(
  CARD_ACCT_NUM      VARCHAR2(36 BYTE),
  SL_NO              NUMBER(5),
  ACTION             VARCHAR2(6 BYTE),
  ACTION_DT          DATE,
  REMARKS            VARCHAR2(250 BYTE),
  STATUS             VARCHAR2(16 BYTE),
  STATUS_BY          VARCHAR2(32 BYTE),
  STATUS_DT          DATE,
  AUTHORIZED_STATUS  VARCHAR2(32 BYTE),
  AUTHORIZED_BY      VARCHAR2(64 BYTE),
  AUTHORIZED_DT      DATE
)

CREATE TABLE SPONSOR_BANK_DETAILS
(
  ACT_NUM           VARCHAR2(16 BYTE),
  AMOUNT            NUMBER(14,2),
  CARD_ACT_NUM      VARCHAR2(64 BYTE),
  INITIATED_BRANCH  VARCHAR2(16 BYTE),
  SEQUENCE_NO       VARCHAR2(16 BYTE),
  TRANS_DT          DATE,
  TRANS_TYPE        VARCHAR2(16 BYTE),
  TRANS_ID          VARCHAR2(16 BYTE),
  STATUS            VARCHAR2(16 BYTE),
  STATUS_BY         VARCHAR2(16 BYTE),
  STATUS_DT         DATE,
  PROCESSED         VARCHAR2(1 BYTE)
)
-- End Version [Script Version - 0.0.269] [ReleaseVersion - 9.2.2.8]--[16-03-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.270] [ReleaseVersion - 9.2.2.9]--[23-03-2018] -- By Sathiya
ALTER TABLE CUST_ID_CHANGE ADD ACT_STATUS VARCHAR2(16);
-- End Version [Script Version - 0.0.270] [ReleaseVersion - 9.2.2.9]--[23-03-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.271] [ReleaseVersion - 9.2.2.9]--[05-04-2018] -- By Nithya

ALTER TABLE LOANS_PROD_INTREC ADD EMI_PENAL_CALC_BASED_ON VARCHAR2(16) DEFAULT 'MONTHS';

ALTER TABLE LOAN_TRANS_DETAILS add OVER_DUE_INT number(16,2)

ALTER TABLE LOANS_PROD_INTREC add IS_OVERDUE_INT VARCHAR2(1) DEFAULT 'N'

ALTER TABLE LOANS_PROD_ACHD ADD OVER_DUEINT_ACHD VARCHAR2 (15);

ALTER TABLE LOANS_PROD_ACHD ADD (DEBIT_OVERDUEINT_HEAD VARCHAR2(20 BYTE));

ALTER TABLE LOANS_PROD_SUBSIDY_REBATE ADD OVERDUEINT_WAIVER  VARCHAR2(1) DEFAULT 'N';


/* Calculation of overdue interest  */

CREATE OR REPLACE FUNCTION GET_EMI_OVERDUE_INTEREST(ACTNUM VARCHAR,BRANCHCODE VARCHAR) RETURN NUMBER IS 
TOTALAMOUNT NUMBER(16,2) := 0;
EMIAMOUNT NUMBER(16,2);
PROID VARCHAR2(3);
CATG VARCHAR2(50);
FDATE DATE;
TDATE DATE;
LAMT NUMBER(12,2);
INTFROM VARCHAR2(20);
INSTAMT NUMBER(12,2);
PENALRATE NUMBER(12,2);
PENAL NUMBER(12,2);
PRODUCT NUMBER;
EXPIRY_DT DATE;
TOTALDUEDAYS NUMBER;
CURRDT DATE;
OVERDUEINT NUMBER(16,2);
COUNTFORINST NUMBER; 
FULLPENAL NUMBER(16,2) := 0;
OVERDUEINTAMT NUMBER(16,2) :=0;
OVER_DUE_INT_DT DATE;

cursor c1 is SELECT * FROM LOANS_INSTALLMENT WHERE ACCT_NUM=ACTNUM AND IS_BALANCE IS NULL 
AND STATUS !='DELETED' AND nvl(active_status,'Y') ='Y' ORDER BY INSTALLMENT_SLNO;

BEGIN

SELECT LFD.PROD_ID,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT,LFD.INT_GET_FROM 
INTO PROID,CATG,FDATE,TDATE,LAMT,INTFROM  FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
WHERE LFD.BORROW_NO = LB.BORROW_NO
AND LB.BORROW_NO = LSD.BORROW_NO
AND LFD.ACCT_NUM = ACTNUM;
SELECT MAX(LI.INSTALLMENT_DT) INTO EXPIRY_DT FROM LOANS_INSTALLMENT LI WHERE LI.ACCT_NUM = ACTNUM;
SELECT D.CURR_APPL_DT INTO CURRDT FROM DAY_END D WHERE D.BRANCH_CODE = BRANCHCODE;

select max(LT.TRANS_DT) into OVER_DUE_INT_DT from LOAN_TRANS_DETAILS lt 
where LT.ACT_NUM = ACTNUM and LT.OVER_DUE_INT > 0  ;

Select to_date(CURRDT) - to_date(decode(OVER_DUE_INT_DT,NULL,EXPIRY_DT,OVER_DUE_INT_DT)) INTO TOTALDUEDAYS From dual;



IF TOTALDUEDAYS <= 0 THEN
  OVERDUEINTAMT := 0;
ELSE
SELECT GET_TL_INSTAMT(ACTNUM) INTO INSTAMT FROM DUAL;
    IF INTFROM = 'ACT' THEN
    SELECT LIM.PENAL_INTEREST INTO PENALRATE FROM LOANS_INT_MAINTENANCE LIM WHERE
    LIM.ACCT_NUM = ACTNUM AND LIM.SLNO =( SELECT MAX(LS.SLNO) FROM LOANS_INT_MAINTENANCE LS WHERE LS.ACCT_NUM = LIM.ACCT_NUM);  
    ELSE
    SELECT GET_TL_penal_rate_EMI(PROID,CATG,FDATE,TDATE,LAMT) INTO PENALRATE FROM DUAL;
    END IF;    
    SELECT GET_TL_overdue_rate_EMI(PROID,CATG,FDATE,TDATE,LAMT) into OVERDUEINT FROM DUAL;    
FOR I IN C1 LOOP 
        TOTALAMOUNT := TOTALAMOUNT + I.TOTAL_AMT ;
        EMIAMOUNT := I.TOTAL_AMT;         
        Select to_date(EXPIRY_DT) - to_date(I.INSTALLMENT_DT) INTO COUNTFORINST From dual;    
        IF COUNTFORINST = 0   THEN      
          COUNTFORINST := 1;
        END IF;         
        FULLPENAL := FULLPENAL + ((COUNTFORINST * EMIAMOUNT * PENALRATE)/36500);               
END LOOP; 
OVERDUEINTAMT := OVERDUEINTAMT + ((FULLPENAL + TOTALAMOUNT)*TOTALDUEDAYS*OVERDUEINT)/36500;
END IF;
RETURN OVERDUEINTAMT;
END;
/

/* Retrieving penal rate  */

CREATE OR REPLACE FUNCTION GET_TL_penal_rate_EMI(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN
  SELECT DRGTR.PENAL_INT into RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = 'GENERAL_CATEGORY'
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(LOANDUEDT - LOANDATE,0)
          BETWEEN from_period
              AND to_period ;            
    RETURN RATEOFINT;
END;
/

/* Retrieving overdue int rate  */

CREATE OR REPLACE FUNCTION GET_TL_overdue_rate_EMI(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN
  SELECT DRGTR.OD_INT_RATE into RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = 'GENERAL_CATEGORY'
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(LOANDUEDT - LOANDATE,0)
          BETWEEN from_period
              AND to_period ;            
    RETURN RATEOFINT;
END;
/

ALTER TABLE DEPOSITS_PROD_ACHD ADD INT_RESERVE VARCHAR2(16);

-- End Version [Script Version - 0.0.271] [ReleaseVersion - 9.2.2.9]--[05-04-2018] -- By Nithya

-- Start Version [Script Version - 0.0.272] [ReleaseVersion - 9.2.2.9]--[09-04-2018] -- By Suresh
CREATE TABLE RTGS_OUTWARD_ACK
(
  FILE_NAME  VARCHAR2(160 BYTE),
  APPL_DT    DATE,
  STATUS_DT  DATE,
  FILE_RECEIVED_COUNT NUMBER(16,2)
);
-- End Version [Script Version - 0.0.272] [ReleaseVersion - 9.2.2.9]--[09-04-2018] -- By Suresh

-- Start Version [Script Version - 0.0.273] [ReleaseVersion - 9.2.2.9]--[20-04-2018] -- By Sathiya

ALTER TABLE REMITTANCE_PRODUCT ADD RTGS_NEFT_GL_TYPE VARCHAR2(1) DEFAULT('N');

ALTER TABLE REMITTANCE_PRODUCT ADD RTGS_NEFT_PROD_TYPE VARCHAR2(16);

ALTER TABLE REMITTANCE_PRODUCT ADD RTGS_NEFT_PROD_ID VARCHAR2(16);

ALTER TABLE REMITTANCE_PRODUCT ADD RTGS_NEFT_ACT_NUM VARCHAR2(16);

-- End Version [Script Version - 0.0.273] [ReleaseVersion - 9.2.2.9]--[20-04-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.274] [ReleaseVersion - 9.2.2.9]--[10-05-2018] -- By Rishad

INSERT INTO LOOKUP_MASTER VALUES('FREQUENCY',0,'User Defined','CREATED','','Y');

-- End Version [Script Version - 0.0.274] [ReleaseVersion - 9.2.2.9]--[10-05-2018] -- By Rishad

-- Start Version [Script Version - 0.0.275] [ReleaseVersion - 9.2.2.9]--[08-06-2018] -- By Nithya

ALTER TABLE MDS_SCHEME_DETAILS ADD GROUP_NO VARCHAR2(15);

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS add IS_BONUS_TRANSFER VARCHAR2(1) DEFAULT 'Y';

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS add IS_PAYMENT_BONUS_TRANS VARCHAR2(1) DEFAULT 'N';

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS add IS_GDS VARCHAR2(1) ;

-- End Version [Script Version - 0.0.275] [ReleaseVersion - 9.2.2.9]--[08-06-2018] -- By Nithya

-- Start Version [Script Version - 0.0.276] [ReleaseVersion - 9.2.2.9]--[20-06-2018] -- By Nithya

CREATE OR REPLACE FUNCTION GET_VALID_ACCOUNT(ACT_NO VARCHAR,PROD_TYPE VARCHAR) RETURN NUMBER IS

    ACT_COUNT NUMBER(16,2) := 0;

BEGIN

    IF PROD_TYPE='AB' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM OTHER_BANKS_ACT_MASTER

        WHERE ACT_MASTER_ID=ACT_NO AND ACT_STATUS='NEW'

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZED_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='AD' OR PROD_TYPE='TL' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM LOANS_FACILITY_DETAILS

        WHERE ACCT_NUM=ACT_NO AND ACCT_STATUS='NEW'

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZE_STATUS_1='AUTHORIZED';

    ELSIF PROD_TYPE='INV' THEN

        SELECT COUNT(*) INTO ACT_COUNT

        FROM INVESTMENT_DEPOSIT INVDEP

        JOIN INVESTMENT_MASTER INVMAS ON (INVDEP.INVESTMENT_ID = INVMAS.INVESTMENT_ID)

        WHERE INVDEP.INVESTMENT_ID=ACT_NO AND INVDEP.ACCT_STATUS='NEW'

        AND INVDEP.STATUS IN ('CREATED','MODIFIED') AND INVDEP.AUTHORIZED_STATUS='AUTHORIZED'

        AND INVMAS.STATUS IN ('CREATED','MODIFIED') AND INVMAS.AUTHORIZED_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='OA' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM ACT_MASTER

        WHERE ACT_NUM=ACT_NO AND ACT_STATUS_ID='NEW'

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZATION_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='SA' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM SUSPENSE_ACCOUNT_MASTER

        WHERE SUSPENSE_ACCT_NUM=ACT_NO

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZE_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='TD' THEN

        SELECT COUNT(*) INTO ACT_COUNT

        FROM DEPOSIT_SUB_ACINFO DSA

        JOIN DEPOSIT_ACINFO DA ON (DSA.DEPOSIT_NO=DA.DEPOSIT_NO)

        WHERE (DSA.DEPOSIT_NO=ACT_NO OR DSA.DEPOSIT_NO||'_1'=ACT_NO)

        AND DSA.ACCT_STATUS='NEW' AND DA.DEPOSIT_STATUS='NEW'

        AND DSA.STATUS IN ('CREATED','MODIFIED') AND DSA.AUTHORIZE_STATUS='AUTHORIZED'

        AND DA.STATUS IN ('CREATED','MODIFIED') AND DA.AUTHORIZE_STATUS='AUTHORIZED';

    END IF;

RETURN ACT_COUNT;

END;
/

-- End Version [Script Version - 0.0.276] [ReleaseVersion - 9.2.2.9]--[20-06-2018] -- By Nithya

-- Start Version [Script Version - 0.0.277] [ReleaseVersion - 9.2.2.9]--[02-07-2018] -- By Sathiya

CREATE TABLE CBMS_PARAMETERS(
  CBMS_KEY VARCHAR2(32) NOT NULL,
  CBMS_VALUE VARCHAR2(256) NOT NULL,
  CONSTRAINT CBMS_PARAMETERS PRIMARY KEY (CBMS_KEY)
);

Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE)
 Values
   ('SMS_TEMPLATE_PATH', 'E:\TTCBS_KERALA\jboss-3.2.7\bin\template\smstemplate.xml');

-- End Version [Script Version - 0.0.277] [ReleaseVersion - 9.2.2.9]--[02-07-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.278] [ReleaseVersion - 9.2.2.10]--[04-07-2018] -- By Sathiya

CREATE OR REPLACE PACKAGE PKGDAYEND
AS
   FUNCTION GET_TRANS_ACCOUNTS(DT DATE,PRODTYPE VARCHAR2 ,BRANCHID VARCHAR2  ) RETURN TAB_TYPE_TRAN_ACCOUNTS;
   FUNCTION GET_GL_OPENINGBAL(ACHDID VARCHAR,BRANCHCODE VARCHAR,ASONDT DATE) RETURN NUMBER;
   PROCEDURE INS_ACT_DAYEND (DT DATE,INITBRANCHID VARCHAR2);
   PROCEDURE INS_DEP_DAYEND (DT DATE,INITBRANCHID VARCHAR2);
   PROCEDURE INS_LOANS_DAYEND(DT DATE,INITBRANCHID VARCHAR2); 
   PROCEDURE INS_ADV_DAYEND(DT DATE,INITBRANCHID VARCHAR2);  
   PROCEDURE INS_SUS_DAYEND(DT DATE,INITBRANCHID VARCHAR2); 
   FUNCTION INS_ALL_DAYEND(DT DATE,INITBRANCHID VARCHAR2) RETURN VARCHAR2;
   FUNCTION GET_ACC_GLBALANCE (DEDT DATE,BRANCHID VARCHAR2) RETURN TAB_TYPE_GL_ACC;
   PROCEDURE INS_GL_ABSTRACT(DEDT DATE,BRANCHID VARCHAR2);
   PROCEDURE INS_GL_ABSTRACTDB(DBDT DATE,BRANCHID VARCHAR2);
   PROCEDURE DEPOSIT_TEMP_FIELD_CLEAR;  
END PKGDAYEND;
/

CREATE OR REPLACE PACKAGE BODY PKGDAYEND AS
  FUNCTION GET_TRANS_ACCOUNTS(DT DATE,PRODTYPE VARCHAR2,BRANCHID VARCHAR2 ) RETURN TAB_TYPE_TRAN_ACCOUNTS    AS  
     TRANS_ACC TAB_TYPE_TRAN_ACCOUNTS;
     BEGIN 
       WITH         -- TRANSACTION OF ALL ACCOUNTS IN DAY END INITIATED  BRANCH
        BRTRNS AS(
        SELECT PROD_TYPE,PROD_ID,ACT_NUM,TRANS_DT,INITIATED_BRANCH,BRANCH_ID  FROM CASH_TRANS CT WHERE CT.TRANS_DT =DT AND
        CT.AUTHORIZE_STATUS='AUTHORIZED' AND CT.STATUS='CREATED' AND CT.PROD_TYPE =PRODTYPE AND   CT.BRANCH_ID =BRANCHID
        UNION
        SELECT PROD_TYPE,PROD_ID,ACT_NUM,TRANS_DT,INITIATED_BRANCH,BRANCH_ID  FROM TRANSFER_TRANS TT WHERE TT.TRANS_DT =DT AND 
         TT.AUTHORIZE_STATUS='AUTHORIZED' AND TT.STATUS='CREATED' AND TT.PROD_TYPE =PRODTYPE AND   TT.BRANCH_ID =BRANCHID),
        -- TRANSACTION OF ALL OTHER BRANCH ACCOUNTS (DAY END COMPLETED BRANCH)    INITIATED BY THE DAY END  BRANCH
        INITTRNS AS(
         SELECT PROD_TYPE,PROD_ID,ACT_NUM,TRANS_DT,INITIATED_BRANCH,BRANCH_ID  FROM CASH_TRANS CT, DAY_END DE WHERE CT.TRANS_DT =DT AND
         CT.AUTHORIZE_STATUS='AUTHORIZED' AND CT.STATUS='CREATED' AND CT.PROD_TYPE =PRODTYPE AND CT.BRANCH_ID <> BRANCHID AND  CT.INITIATED_BRANCH = BRANCHID
         AND   CT.BRANCH_ID =DE.BRANCH_CODE AND   CT.TRANS_DT < CURR_APPL_DT
         UNION
         SELECT PROD_TYPE,PROD_ID,ACT_NUM,TRANS_DT,INITIATED_BRANCH,BRANCH_ID  FROM TRANSFER_TRANS TT , DAY_END DE  WHERE TT.TRANS_DT =DT AND 
         TT.AUTHORIZE_STATUS='AUTHORIZED' AND TT.STATUS='CREATED' AND TT.PROD_TYPE =PRODTYPE  AND TT.BRANCH_ID <> BRANCHID AND  TT.INITIATED_BRANCH =BRANCHID
         AND   TT.BRANCH_ID =DE.BRANCH_CODE AND   TT.TRANS_DT < CURR_APPL_DT),
        TR  AS         
          (SELECT PROD_TYPE,PROD_ID,ACT_NUM,TRANS_DT,INITIATED_BRANCH,BRANCH_ID FROM BRTRNS GROUP BY PROD_TYPE,PROD_ID,TRANS_DT,ACT_NUM,BRANCH_ID,INITIATED_BRANCH
          UNION
          SELECT PROD_TYPE,PROD_ID,ACT_NUM,TRANS_DT,INITIATED_BRANCH,BRANCH_ID FROM INITTRNS GROUP BY PROD_TYPE,PROD_ID,TRANS_DT,ACT_NUM,BRANCH_ID,INITIATED_BRANCH) 
      SELECT TYPE_TRAN_ACCOUNTS (PROD_TYPE,PROD_ID,TRANS_DT,ACT_NUM,BRANCH_ID,INITIATED_BRANCH )
         BULK COLLECT INTO TRANS_ACC FROM  TR ;
     RETURN TRANS_ACC;     
     END GET_TRANS_ACCOUNTS;
     
FUNCTION GET_GL_OPENINGBAL(ACHDID VARCHAR,BRANCHCODE VARCHAR,ASONDT DATE) RETURN NUMBER IS 
        CLOSE_BAL NUMBER(16,2) :=0;
        BEGIN
            IF BRANCHCODE IS NOT NULL THEN   
                    BEGIN
                    SELECT SUM(NVL(DECODE (BALANCE_TYPE, 'DEBIT', -1 * CLOSE_BAL, CLOSE_BAL),0))
                                                INTO CLOSE_BAL
                                        FROM GL_ABSTRACT GA
                                       WHERE DT IN 
                                       (SELECT MAX(G.DT)  FROM GL_ABSTRACT G WHERE G.AC_HD_ID = GA.AC_HD_ID
                                       AND G.BRANCH_CODE = GA.BRANCH_CODE AND G.DT < ASONDT)   
                                       AND AC_HD_ID = ACHDID AND BRANCH_CODE = BRANCHCODE;
                    EXCEPTION WHEN OTHERS THEN
                    DBMS_OUTPUT.PUT_LINE('NO DATA FOR  '||ACHDID);
                    END;
            ELSE
                    BEGIN
                     SELECT SUM(NVL(DECODE (BALANCE_TYPE, 'DEBIT', -1 * CLOSE_BAL, CLOSE_BAL),0))
                                                INTO CLOSE_BAL
                                       FROM GL_ABSTRACT GA
                                       WHERE DT IN 
                                       (SELECT MAX(G.DT)  FROM GL_ABSTRACT G WHERE G.AC_HD_ID = GA.AC_HD_ID
                                       AND G.BRANCH_CODE = GA.BRANCH_CODE AND G.DT < ASONDT)   
                                       AND AC_HD_ID = ACHDID;
                    EXCEPTION WHEN OTHERS THEN
                    DBMS_OUTPUT.PUT_LINE('NO DATA FOR  '||ACHDID);
                    END;
            END IF;
                IF CLOSE_BAL IS NULL THEN
                CLOSE_BAL:=0;
                END IF;
            RETURN CLOSE_BAL;
END;

  PROCEDURE INS_ACT_DAYEND(DT DATE,INITBRANCHID VARCHAR2) AS   
   BEGIN     
    MERGE INTO ACT_DAYEND_BALANCE ADB
    USING (SELECT  DE.PROD_ID,DE.ACT_NUM,DE.TRANS_DT,AM.CLEAR_BALANCE FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'OA',INITBRANCHID))DE
     JOIN ACT_MASTER AM ON DE.ACT_NUM =AM.ACT_NUM)M ON ( M.ACT_NUM =ADB.ACT_NUM AND M.TRANS_DT =ADB.DAY_END_DT )
    WHEN MATCHED  THEN
      UPDATE  SET ADB.AMT = M.CLEAR_BALANCE , ADB.AVAILABLE_BALANCE=M.CLEAR_BALANCE, ADB.CLEAR_BALANCE =M.CLEAR_BALANCE
    WHEN NOT MATCHED THEN 
      INSERT  (ADB.PROD_ID, ADB.ACT_NUM, ADB.DAY_END_DT, ADB.AMT, ADB.AVAILABLE_BALANCE, ADB.CLEAR_BALANCE)
      VALUES (M.PROD_ID,M.ACT_NUM,M.TRANS_DT,M.CLEAR_BALANCE,M.CLEAR_BALANCE,M.CLEAR_BALANCE); 
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID ,   PROD_ID  ,   ERR_DT   ,   ACT_NUM ,   BRANCH_ID ,  INITIATED_BRANCH,   DESCP) 
       SELECT  '1',DE.PROD_ID,DE.TRANS_DT,DE.ACT_NUM,DE.BRANCH_ID ,DE.INITIATED_BRANCH ,'ACT_DAYEND_BALANCE' FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'OA',INITBRANCHID))DE ;
       COMMIT;   
      END;            
   END INS_ACT_DAYEND;
  
  PROCEDURE INS_DEP_DAYEND(DT DATE,INITBRANCHID VARCHAR2)  AS
   BEGIN        
    MERGE INTO DEPOSIT_DAYEND_BALANCE DDB
    USING (SELECT  DE.PROD_ID,DE.ACT_NUM,DE.TRANS_DT,DSA.CLEAR_BALANCE FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'TD',INITBRANCHID)) DE
    JOIN DEPOSIT_SUB_ACINFO DSA ON DE.ACT_NUM =DSA.DEPOSIT_NO||'_1'  ) M     ON ( M.ACT_NUM =DDB.ACT_NUM AND M.TRANS_DT = DDB.DAY_END_DT ) 
    WHEN MATCHED  THEN
      UPDATE  SET DDB.AMT = M.CLEAR_BALANCE , DDB.PAYABLE_AMT =0
    WHEN NOT MATCHED THEN 
      INSERT  (DDB.PROD_ID, DDB.ACT_NUM, DDB.DAY_END_DT, DDB.AMT, DDB.PAYABLE_AMT, DDB.LOCK_STATUS)
      VALUES (M.PROD_ID,M.ACT_NUM,M.TRANS_DT,M.CLEAR_BALANCE,0,0); 
    COMMIT;   
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID ,   PROD_ID  ,   ERR_DT   ,   ACT_NUM ,   BRANCH_ID ,  INITIATED_BRANCH,   DESCP) 
       SELECT  '1',DE.PROD_ID,DE.TRANS_DT,DE.ACT_NUM,DE.BRANCH_ID ,DE.INITIATED_BRANCH ,'DEPOSIT_DAYEND_BALANCE' FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'TD',INITBRANCHID))DE ;
       COMMIT;   
      END;      
   END INS_DEP_DAYEND;

  PROCEDURE INS_LOANS_DAYEND(DT DATE,INITBRANCHID VARCHAR2)  AS
   BEGIN        
    MERGE INTO LOANS_DAYEND_BALANCE LDB
    USING (SELECT  DE.PROD_ID,DE.ACT_NUM,DE.TRANS_DT,LFD.CLEAR_BALANCE FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'TL',INITBRANCHID)) DE
    JOIN LOANS_FACILITY_DETAILS LFD ON DE.ACT_NUM =LFD.ACCT_NUM  ) M     ON ( M.ACT_NUM =LDB.ACT_NUM AND M.TRANS_DT = LDB.DAY_END_DT ) 
    WHEN MATCHED  THEN
      UPDATE  SET LDB.AMT = M.CLEAR_BALANCE , LDB.PRINCIPAL =0-M.CLEAR_BALANCE
    WHEN NOT MATCHED THEN 
      INSERT  (LDB.PROD_ID,LDB.ACT_NUM, LDB.DAY_END_DT, LDB.AMT, LDB.PRINCIPAL )
      VALUES (M.PROD_ID,M.ACT_NUM,M.TRANS_DT,M.CLEAR_BALANCE,0-M.CLEAR_BALANCE); 
    COMMIT;   
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID ,   PROD_ID  ,   ERR_DT   ,   ACT_NUM ,   BRANCH_ID ,  INITIATED_BRANCH,   DESCP) 
       SELECT  '1',DE.PROD_ID,DE.TRANS_DT,DE.ACT_NUM,DE.BRANCH_ID ,DE.INITIATED_BRANCH ,'LOANS_DAYEND_BALANCE' FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'TL',INITBRANCHID))DE ;
       COMMIT;   
      END;      
   END INS_LOANS_DAYEND;
       
  PROCEDURE INS_ADV_DAYEND(DT DATE,INITBRANCHID VARCHAR2)  AS
   BEGIN        
    MERGE INTO ADVANCES_DAYEND_BALANCE ADB
    USING (SELECT  DE.PROD_ID,DE.ACT_NUM,DE.TRANS_DT,LFD.CLEAR_BALANCE,LFD.AVAILABLE_BALANCE,LSD.LIMIT FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'AD',INITBRANCHID)) DE
    JOIN LOANS_FACILITY_DETAILS LFD ON DE.ACT_NUM =LFD.ACCT_NUM 
    JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO =LFD.BORROW_NO) M   ON ( M.ACT_NUM =ADB.ACT_NUM AND M.TRANS_DT = ADB.DAY_END_DT ) 
    WHEN MATCHED  THEN
      UPDATE  SET ADB.AMT = M.CLEAR_BALANCE , ADB.PRINCIPAL =(0-M.CLEAR_BALANCE),
      ADB.AVAILABLE_BALANCE  = M.AVAILABLE_BALANCE,ADB.CLEAR_BALANCE =M.CLEAR_BALANCE, 
      ADB.DPLIMIT =M.LIMIT ,ADB.TOD_LIMIT =M.LIMIT,ADB.OVERALL_LIMIT =M.LIMIT, 
      ADB.LIMIT=M.LIMIT
    WHEN NOT MATCHED THEN 
      INSERT  (ADB.PROD_ID,ADB.ACT_NUM, ADB.DAY_END_DT, ADB.AMT, ADB.PRINCIPAL, ADB.AVAILABLE_BALANCE ,
       ADB.CLEAR_BALANCE , ADB.DPLIMIT, ADB.TOD_LIMIT, ADB.OVERALL_LIMIT,ADB.LIMIT )
      VALUES (M.PROD_ID,M.ACT_NUM,M.TRANS_DT,M.CLEAR_BALANCE,(0-M.CLEAR_BALANCE),M.AVAILABLE_BALANCE,M.CLEAR_BALANCE,M.LIMIT,
      M.LIMIT,M.LIMIT,M.LIMIT); 
    COMMIT;   
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID ,   PROD_ID  ,   ERR_DT   ,   ACT_NUM ,   BRANCH_ID ,  INITIATED_BRANCH,   DESCP) 
       SELECT  '1',DE.PROD_ID,DE.TRANS_DT,DE.ACT_NUM,DE.BRANCH_ID ,DE.INITIATED_BRANCH ,'ADVANCES_DAYEND_BALANCE' FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'AD',INITBRANCHID))DE ;
       COMMIT;   
      END;      
   END INS_ADV_DAYEND;  

  PROCEDURE INS_SUS_DAYEND(DT DATE,INITBRANCHID VARCHAR2)  AS
   BEGIN        
    MERGE INTO SUSPENSE_DAYEND_BALANCE SDB
    USING (SELECT  DE.PROD_ID,DE.ACT_NUM,DE.TRANS_DT,SAM.CLEAR_BALANCE  FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'SA',INITBRANCHID)) DE
    JOIN SUSPENSE_ACCOUNT_MASTER SAM ON DE.ACT_NUM =SAM.SUSPENSE_ACCT_NUM 
     ) M   ON ( M.ACT_NUM =SDB.ACT_NUM AND M.TRANS_DT = SDB.DAY_END_DT ) 
    WHEN MATCHED  THEN
      UPDATE  SET SDB.AMT = M.CLEAR_BALANCE , SDB.AVAILABLE_BALANCE =M.CLEAR_BALANCE, SDB.CLEAR_BALANCE =M.CLEAR_BALANCE 
    WHEN NOT MATCHED THEN 
      INSERT  (SDB.PROD_ID,SDB.ACT_NUM, SDB.DAY_END_DT, SDB.AMT,SDB.AVAILABLE_BALANCE , SDB.CLEAR_BALANCE   )
      VALUES (M.PROD_ID,M.ACT_NUM,M.TRANS_DT,M.CLEAR_BALANCE,M.CLEAR_BALANCE,M.CLEAR_BALANCE ); 
    COMMIT;   
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID ,   PROD_ID  ,   ERR_DT   ,   ACT_NUM ,   BRANCH_ID ,  INITIATED_BRANCH,   DESCP) 
       SELECT  '1',DE.PROD_ID,DE.TRANS_DT,DE.ACT_NUM,DE.BRANCH_ID ,DE.INITIATED_BRANCH ,'SUSPENSE_DAYEND_BALANCE' FROM TABLE ( PKGDAYEND.GET_TRANS_ACCOUNTS(DT,'SA',INITBRANCHID))DE ;
       COMMIT;   
      END;      
   END INS_SUS_DAYEND; 
  
  -- DAY END CALLING FUNCTION   
  FUNCTION INS_ALL_DAYEND(DT DATE,INITBRANCHID VARCHAR2) RETURN VARCHAR2  AS
  PRAGMA AUTONOMOUS_TRANSACTION;
   MSG VARCHAR2(25):= 'COMPLETE';
   BEGIN       
         INS_ACT_DAYEND (DT ,INITBRANCHID );
         INS_DEP_DAYEND (DT ,INITBRANCHID );
         INS_LOANS_DAYEND(DT ,INITBRANCHID ); 
         INS_ADV_DAYEND(DT ,INITBRANCHID );  
         INS_SUS_DAYEND(DT ,INITBRANCHID ); 
         DEPOSIT_TEMP_FIELD_CLEAR;
         RETURN MSG;  
    EXCEPTION
    WHEN OTHERS THEN
      MSG :='INCOMPLETE'; 
      RETURN MSG;  
 END INS_ALL_DAYEND;      
  
 FUNCTION  GET_ACC_GLBALANCE (DEDT DATE,BRANCHID VARCHAR2) RETURN TAB_TYPE_GL_ACC  AS
      PRAGMA AUTONOMOUS_TRANSACTION;
      GLABS TAB_TYPE_GL_ACC;
   PRVGLDT DATE;   
 BEGIN 
      SELECT MAX(DT) INTO PRVGLDT FROM GL_ABSTRACT WHERE DT<DEDT;
      WITH TRNS AS 
      (SELECT  AC_HD_ID,SUM(CR) AS CR,SUM(DR) AS DR FROM (
         SELECT  CT.AC_HD_ID ,SUM(CASE WHEN TRANS_TYPE ='CREDIT' THEN AMOUNT ELSE 0 END) AS CR,
        SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN AMOUNT ELSE 0 END) AS DR  FROM  CASH_TRANS CT  
        WHERE CT.TRANS_DT =DEDT AND BRANCH_ID =BRANCHID  AND CT.AUTHORIZE_STATUS ='AUTHORIZED' AND CT.STATUS NOT IN('DELETED')
        GROUP BY  CT.AC_HD_ID
        UNION ALL
        SELECT   TT.AC_HD_ID ,SUM(CASE WHEN TT.TRANS_TYPE ='CREDIT' THEN TT.AMOUNT ELSE 0 END) AS CR,
        SUM(CASE WHEN TT.TRANS_TYPE ='DEBIT' THEN TT.AMOUNT ELSE 0 END) AS DR  FROM  TRANSFER_TRANS TT  
        WHERE TT.TRANS_DT =DEDT AND TT.BRANCH_ID =BRANCHID  AND TT.AUTHORIZE_STATUS ='AUTHORIZED' AND TT.STATUS NOT IN('DELETED')
        GROUP BY TT.BRANCH_ID, TT.AC_HD_ID
        UNION ALL
        SELECT    TR.AC_HD_ID ,SUM(CASE WHEN TR.TRANS_TYPE ='CREDIT' THEN TR.AMOUNT ELSE 0 END) AS CR,
        SUM(CASE WHEN TR.TRANS_TYPE ='DEBIT' THEN TR.AMOUNT ELSE 0 END) AS DR  FROM  TRANS_REF_GL TR  
        LEFT JOIN PARAMETERS PM ON  PM.CASH_AC_HD = TR.AC_HD_ID
        WHERE TR.TRANS_DT =DEDT AND TR.BRANCH_ID = BRANCHID AND   TR.STATUS NOT IN('DELETED') AND PM.CASH_AC_HD IS NULL
        GROUP BY  TR.AC_HD_ID)TC GROUP BY  AC_HD_ID
       )
       ,BAL AS
       (SELECT  DEDT AS DET,AH.AC_HD_ID,BRANCHID AS BRANCH_CODE ,
        CASE WHEN ( MH.MJR_AC_HD_TYPE IN('INCOME','EXPENDITURE') AND TO_CHAR((PRVGLDT) , 'MM')='03' AND TO_CHAR((PRVGLDT) , 'DAY') = '31') THEN
        0 ELSE GAT.CLOSE_BAL END AS OBBAL ,GAT.BALANCE_TYPE,
        CASE WHEN MH.MJR_AC_HD_TYPE IN('LIABILITY','INCOME') THEN 1 ELSE 2 END AS BALTAG ,TRN.CR,TRN.DR,MH.MJR_AC_HD_TYPE FROM 
        MJR_AC_HD MH 
        JOIN AC_HD AH  ON AH.MJR_AC_HD_ID =MH.MJR_AC_HD_ID
        LEFT JOIN GL_ABSTRACT GAT  ON  AH.AC_HD_ID =GAT.AC_HD_ID
        LEFT JOIN
        (SELECT  AC_HD_ID, CR, DR FROM TRNS 
         UNION ALL  
         SELECT  CASH_AC_HD AS AC_HD_ID, SUM(DR) AS CR, SUM(CR) AS DR FROM TRNS ,PARAMETERS GROUP BY CASH_AC_HD  )TRN ON TRN.AC_HD_ID =AH.AC_HD_ID 
        WHERE   DT = (SELECT MAX(DT) FROM GL_ABSTRACT G WHERE DT < DEDT AND G.AC_HD_ID =GAT.AC_HD_ID AND G.BRANCH_CODE = BRANCHID  )  
        AND BRANCH_CODE = BRANCHID AND(EXISTS( SELECT * FROM (SELECT   AC_HD_ID FROM TRNS TN UNION ALL SELECT CASH_AC_HD AS AC_HD_ID  FROM PARAMETERS)ACH  WHERE   ACH.AC_HD_ID =AH.AC_HD_ID)  
       )
       ),
       BALANCE AS
       (SELECT DET, AC_HD_ID ,BRANCH_CODE,OBBAL ,
         NVL((CASE WHEN ((BAL.BALTAG =1 AND BAL.BALANCE_TYPE ='CREDIT' ) OR   (BAL.BALTAG =2 AND BAL.BALANCE_TYPE ='DEBIT' )) THEN BAL.OBBAL 
        WHEN ((BAL.BALTAG =1 AND BAL.BALANCE_TYPE ='DEBIT' ) OR   (BAL.BALTAG =2 AND BAL.BALANCE_TYPE ='CREDIT' )) THEN -1* BAL.OBBAL END),0)  
        + CASE WHEN BAL.BALTAG =2 THEN (NVL(BAL.DR,0) -NVL(BAL.CR,0)) ELSE  (NVL(BAL.CR,0) -NVL(BAL.DR,0)) END  AS CLOSEBAL ,BALANCE_TYPE,MJR_AC_HD_TYPE,BALTAG,CR,DR
        FROM BAL
        ) 
         SELECT   TYPE_GL_ACC(DET, AC_HD_ID ,BRANCH_CODE,OBBAL  ,ABS(CLOSEBAL)  ,CASE WHEN CLOSEBAL >=0   THEN DECODE(BALTAG,1,'CREDIT',2,'DEBIT')
         ELSE DECODE(BALTAG,2,'CREDIT',1,'DEBIT') END  ,MJR_AC_HD_TYPE,BALTAG,CR,DR)         
           BULK COLLECT INTO GLABS  FROM  BALANCE ;
     RETURN GLABS;     
  END GET_ACC_GLBALANCE;
 
 PROCEDURE INS_GL_ABSTRACT(DEDT DATE,BRANCHID VARCHAR2) AS   
   BEGIN     
    MERGE INTO GL_ABSTRACT GA
    USING (SELECT  
    DEDT,AC_HD_ID,BRANCH_CODE,OPN_BAL,CLOSE_BAL,BALANCE_TYPE,MJR_AC_HD_TYPE,BALTAG,CR,DR FROM TABLE( PKGDAYEND.GET_ACC_GLBALANCE(DEDT,BRANCHID))
      ) BAL ON(BAL.AC_HD_ID = GA.AC_HD_ID AND BAL.DEDT =GA.DT AND BAL.BRANCH_CODE =GA.BRANCH_CODE) 
    WHEN MATCHED  THEN
      UPDATE  SET GA.OPN_BAL =  BAL.OPN_BAL ,GA.CLOSE_BAL = BAL.CLOSE_BAL ,GA.BALANCE_TYPE =BAL.BALANCE_TYPE 
    WHEN NOT MATCHED THEN 
      INSERT  (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT,  BALANCE_TYPE, LOCK_STATUS)
      VALUES (BAL.AC_HD_ID,BAL.OPN_BAL, BAL.CLOSE_BAL,BAL.BRANCH_CODE,DEDT,BAL.BALANCE_TYPE,0); 
    COMMIT;
    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID,AC_HD_ID,PROD_ID ,ERR_DT,ACT_NUM ,BRANCH_ID ,INITIATED_BRANCH,DESCP) 
       VALUES('10',NULL,NULL,DEDT,NULL,BRANCHID,NULL,'GENERAL LEDGER DAYEND ERROR'); 
       COMMIT;   
      END;
    END;   

 PROCEDURE INS_GL_ABSTRACTDB(DBDT DATE,BRANCHID VARCHAR2) AS   
   BEGIN 
     INSERT  INTO GL_ABSTRACT (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT,  BALANCE_TYPE, LOCK_STATUS)
     SELECT AC_HD_ID, CLOSE_BAL, NULL , BRANCH_CODE,DBDT AS DT, 
      BALANCE_TYPE, LOCK_STATUS FROM  GL_ABSTRACT G, PARAMETERS PM WHERE G.AC_HD_ID = PM.CASH_AC_HD AND  BRANCH_CODE = BRANCHID AND  DT =
     (SELECT MAX(DT) FROM GL_ABSTRACT A WHERE A.DT< DBDT  AND A.AC_HD_ID =G.AC_HD_ID AND  BRANCH_CODE = BRANCHID  ) ;
     COMMIT;
          
   -- CHECK THIS IS REQUIRED BECAUSE WE NEED   GL_ABSTRACT  ENTRIES ONLY HAVE TRANSACTION ON CURRENT DATE  
   IF (TO_CHAR((DBDT) , 'MM')='03' AND TO_CHAR((DBDT) , 'DAY') = '31') THEN    
    MERGE INTO GL_ABSTRACT GA
    USING (SELECT AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE,DBDT AS DT, 
    BALANCE_TYPE, LOCK_STATUS FROM  GL_ABSTRACT G WHERE  BRANCH_CODE = BRANCHID AND  DT =
    (SELECT MAX(DT) FROM GL_ABSTRACT A WHERE A.DT< DBDT  AND A.AC_HD_ID =G.AC_HD_ID  )    
      ) BAL ON(BAL.AC_HD_ID = GA.AC_HD_ID AND BAL.DT =GA.DT AND BAL.BRANCH_CODE =GA.BRANCH_CODE) 
    WHEN MATCHED  THEN
      UPDATE  SET GA.OPN_BAL = BAL.CLOSE_BAL ,GA.CLOSE_BAL = NULL ,GA.BALANCE_TYPE =BAL.BALANCE_TYPE 
    WHEN NOT MATCHED THEN 
      INSERT  (AC_HD_ID, OPN_BAL, CLOSE_BAL, BRANCH_CODE, DT,  BALANCE_TYPE, LOCK_STATUS)
      VALUES (BAL.AC_HD_ID, BAL.CLOSE_BAL,NULL,BAL.BRANCH_CODE,DBDT,BAL.BALANCE_TYPE,0); 
    COMMIT;
   END IF; 
   MERGE INTO GL GLA
    USING (select ac_hd_id,opn_bal,CLOSE_BAL,G.branch_code,DBDT AS dt,G.balance_type from  GL_ABSTRACT G 
     WHERE G.DT = (SELECT MAX(DT) FROM GL_ABSTRACT A WHERE A.DT < DBDT AND A.AC_HD_ID =G.AC_HD_ID  ) 
      AND  G.BRANCH_CODE = BRANCHID  ) GB
      ON(GB.ac_hd_id  = GLA.ac_hd_id AND GB.branch_code = GLA.BRANCH_CODE)
    WHEN MATCHED THEN
      UPDATE SET GLA.opn_bal  =GB.CLOSE_BAL, GLA.cur_bal = GB.CLOSE_BAL ,GLA.BALANCE_TYPE = GB.BALANCE_TYPE, GLA.last_trans_dt = DBDT
    WHEN NOT MATCHED THEN 
     insert (ac_hd_id,opn_bal,cur_bal,branch_code,last_trans_dt,authorize_status,balance_type) 
      VALUES(GB.ac_hd_id,GB.CLOSE_BAL,GB.CLOSE_BAL,GB.branch_code,GB.dt,'AUTHORIZED',GB.balance_type);
    COMMIT;

    EXCEPTION
    WHEN OTHERS THEN
      BEGIN
       INSERT INTO  ERR_LOG (ERR_ID,AC_HD_ID,PROD_ID ,ERR_DT,ACT_NUM ,BRANCH_ID ,INITIATED_BRANCH,DESCP) 
       VALUES('11',NULL,NULL,DBDT,NULL,BRANCHID,NULL,'GENERAL LEDGER DAY BEGIN ERROR'); 
       COMMIT;   
      END;
    END;
    
    PROCEDURE DEPOSIT_TEMP_FIELD_CLEAR  AS   
   BEGIN     
    UPDATE DEPOSIT_SUB_ACINFO DSA set DSA.TEMP_AVAILABLE_BALANCE = NULL,DSA.TEMP_CLEAR_BALANCE = NULL,DSA.TEMP_TOTAL_BALANCE = NULL;
    COMMIT;           
   END DEPOSIT_TEMP_FIELD_CLEAR;
            
END PKGDAYEND;
/

CREATE OR REPLACE TYPE TYPE_TRAN_ACCOUNTS  AS OBJECT( 
   PROD_TYPE             VARCHAR2(5 BYTE),
   PROD_ID              VARCHAR2(5 BYTE),
   TRANS_DT             DATE,
   ACT_NUM              VARCHAR2(15 BYTE),
   BRANCH_ID            VARCHAR2(6 BYTE),
   INITIATED_BRANCH     VARCHAR2(6 BYTE)
);

CREATE OR REPLACE TYPE TAB_TYPE_TRAN_ACCOUNTS   AS TABLE OF TYPE_TRAN_ACCOUNTS;

CREATE TABLE ERR_LOG
(
  ERR_ID            VARCHAR2(5 BYTE),
  AC_HD_ID          VARCHAR2(15 BYTE),
  PROD_ID           VARCHAR2(5 BYTE),
  ERR_DT            DATE,
  ACT_NUM           VARCHAR2(15 BYTE),
  BRANCH_ID         VARCHAR2(6 BYTE),
  INITIATED_BRANCH  VARCHAR2(6 BYTE),
  DESCP             VARCHAR2(150 BYTE)
)

CREATE OR REPLACE TYPE TYPE_GL_ACC AS OBJECT( 
 DEDT           DATE,
 AC_HD_ID       VARCHAR2(15),
 BRANCH_CODE    VARCHAR2(5),
 OPN_BAL        NUMBER(19,2),
 CLOSE_BAL      NUMBER(19,2),
 BALANCE_TYPE   VARCHAR2(15), 
 MJR_AC_HD_TYPE VARCHAR2(15), 
 BALTAG         VARCHAR2(1), 
 CR             NUMBER(19,2),
 DR             NUMBER(19,2)
 );

 CREATE OR REPLACE TYPE TAB_TYPE_GL_ACC AS TABLE OF TYPE_GL_ACC;

Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE)
 Values
   ('RELEASE_VERSION', '9.2.2.10');

-- End Version [Script Version - 0.0.278] [ReleaseVersion - 9.2.2.10]--[04-07-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.279] [ReleaseVersion - 9.2.2.10]--[30-07-2018] -- By Rishad

CREATE OR REPLACE TYPE "TYPE_ALL_TRANS" as object (
TRANS_ID    VARCHAR2 (24 Byte)    ,
BATCH_ID    VARCHAR2 (16 Byte)    ,
AC_HD_ID    VARCHAR2 (50 Byte)    ,
ACT_NUM    VARCHAR2 (16 Byte)    ,
AMOUNT    NUMBER    ,
TRANS_TYPE    VARCHAR2 (32 Byte)    ,
INST_TYPE    VARCHAR2 (128 Byte)    ,
TRANS_DT    DATE    ,
INIT_TRANS_ID    VARCHAR2 (32 Byte)    ,
INIT_CHANN_TYPE    VARCHAR2 (32 Byte)    ,
PARTICULARS    VARCHAR2 (1041 Byte)    ,
INSTRUMENT_NO1    VARCHAR2 (32 Byte)    ,
INSTRUMENT_NO2    VARCHAR2 (32 Byte)    ,
PROD_ID    VARCHAR2 (30 Byte)    ,
PROD_TYPE    VARCHAR2 (32 Byte)    ,
AUTHORIZE_STATUS    VARCHAR2 (32 Byte)    ,
AUTHORIZE_BY    VARCHAR2 (32 Byte)    ,
AUTHORIZE_DT    DATE    ,
AUTHORIZE_REMARKS    VARCHAR2 (1024 Byte)    ,
STATUS_BY    VARCHAR2 (32 Byte)    ,
BRANCH_ID    VARCHAR2 (32 Byte)    ,
STATUS_DT    DATE    ,
TRANS_MODE    VARCHAR2 (16 Byte)    ,
INITIATED_BRANCH    VARCHAR2 (32 Byte)    ,
AUTHORIZE_STATUS_2    VARCHAR2 (32 Byte)    ,
LINK_BATCH_ID    VARCHAR2 (16 Byte)    ,
PAYMENT_STATUS    VARCHAR2 (10 Byte)    ,
GL_TRANS_ACT_NUM    VARCHAR2 (16 Byte)    ,
NARRATION    VARCHAR2 (500 Byte)    ,
SINGLE_TRANS_ID    VARCHAR2 (20 Byte)    ,
TRANS_MOD_TYPE    VARCHAR2 (10 Byte)    ,
SCREEN_NAME    VARCHAR2 (100 Byte)    
);
/

CREATE OR REPLACE TYPE TAB_TYPE_ALL_TRANS as table of type_all_trans;
/

CREATE OR REPLACE FUNCTION ALL_TRANS_FUNCT(BRANCH_CODE VARCHAR2,curDate Date) RETURN TAB_TYPE_ALL_TRANS PIPELINED IS
PRAGMA AUTONOMOUS_TRANSACTION;
TYPE REF0 IS REF CURSOR;
    TRCURSOR REF0;
OUTREC TYPE_ALL_TRANS := TYPE_ALL_TRANS(NULL,NULL,NULL,NULL,0,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
BEGIN
OPEN TRCURSOR FOR
SELECT 
trans_id,batch_id,ac_hd_id,act_num,amount,trans_type,inst_type,trans_dt,init_trans_id,init_chann_type,particulars,instrument_no1,instrument_no2,prod_id,
prod_type,authorize_status,authorize_by,authorize_dt,authorize_remarks,status_by,branch_id,status_dt,trans_mode,initiated_branch,authorize_status_2,link_batch_id,
payment_status,gl_trans_act_num,narration,single_trans_id,trans_mod_type,screen_name
FROM
(SELECT "TRANS_ID", '' AS "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
           "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT", "TOKEN_NO",
           "INIT_TRANS_ID", "INIT_CHANN_TYPE", "PARTICULARS", "STATUS",
           "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID", "PROD_TYPE",
           "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID", "STATUS_DT",
           'CASH' AS "TRANS_MODE", "INITIATED_BRANCH", "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID", "PAYMENT_STATUS",
           gl_trans_act_num AS "GL_TRANS_ACT_NUM", narration AS "NARRATION",
           single_trans_id AS "SINGLE_TRANS_ID",
           trans_mod_type AS "TRANS_MOD_TYPE", screen_name AS "SCREEN_NAME"
      FROM "CASH_TRANS" where TRANS_DT=curDate AND BRANCH_ID=BRANCH_CODE AND AUTHORIZE_STATUS='AUTHORIZED'
    UNION ALL
    SELECT "TRANS_ID", "BATCH_ID", "AC_HD_ID", "ACT_NUM", "AMOUNT",
           "TRANS_DT", "TRANS_TYPE", "INST_TYPE", "INST_DT",
           NULL AS "TOKEN_NO", "INIT_TRANS_ID", "INIT_CHANN_TYPE",
           "PARTICULARS", "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2",
           "PROD_ID", "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY",
           "AUTHORIZE_DT", "AUTHORIZE_REMARKS", "STATUS_BY", "BRANCH_ID",
           "STATUS_DT", "TRANS_MODE", "INITIATED_BRANCH",
           "AUTHORIZE_STATUS_2", "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", gl_trans_act_num AS "GL_TRANS_ACT_NUM",
           narration AS "NARRATION", single_trans_id AS "SINGLE_TRANS_ID",
           trans_mod_type AS "TRANS_MOD_TYPE", screen_name AS "SCREEN_NAME"
      FROM transfer_trans where TRANS_DT=curDate AND BRANCH_ID=BRANCH_CODE AND AUTHORIZE_STATUS='AUTHORIZED'
    UNION ALL
    SELECT "INWARD_ID" AS "TRANS_ID", NULL AS "BATCH_ID", "AC_HD_ID",
           "ACCT_NO" AS "ACT_NUM", "AMOUNT", "CLEARING_DT" AS "TRANS_DT",
           'DEBIT' AS "TRANS_TYPE", "INSTRUMENT_TYPE" AS "INST_TYPE",
           "INSTRUMENT_DT" AS "INST_DT", NULL AS "TOKEN_NO",
           "SUSER_ID" AS "INIT_TRANS_ID",
           "INITIATED_BRANCH" AS "INIT_CHANN_TYPE", '' AS "PARTICULARS",
           "STATUS", "INSTRUMENT_NO1", "INSTRUMENT_NO2", "PROD_ID",
           "PROD_TYPE", "AUTHORIZE_STATUS", "AUTHORIZE_BY", "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS", "CREATED_BY" AS "STATUS_BY", "BRANCH_ID",
           "S_DATE" AS "STATUS_DT", 'CLEARING' AS "TRANS_MODE",
           "INITIATED_BRANCH", '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID", '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM", '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME"
      FROM inward_clearing
     WHERE authorize_status != 'REJECTED'
       AND inward_id NOT IN (SELECT inward_id
                               FROM inward_bouncing)
    UNION ALL
    SELECT ib.bouncing_id AS trans_id, NULL AS batch_id, ic.ac_hd_id,
           ic.acct_no AS act_num, ib.amount, ib.clearing_date AS trans_dt,
           'CREDIT' AS trans_type, ic.instrument_type AS "INST_TYPE",
           ic.instrument_dt AS "INST_DT", NULL AS "TOKEN_NO",
           ib.status_by AS "INIT_TRANS_ID",
           ic.initiated_branch AS init_chann_type,
           'INWARD RETURN : ' || ib.bouncing_reason AS particulars, ib.status,
           ic.instrument_no1, ic.instrument_no2, ic.prod_id, ic.prod_type,
           ib.authorize_status, ib.authorize_by, ib.authorize_dt,
           ic.authorize_remarks, ib.status_by, ib.branch_id, ib.status_dt,
           'CLEARING' AS "TRANS_MODE", ib.branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME"
      FROM inward_bouncing ib, inward_clearing ic
     WHERE ic.authorize_status = 'REJECTED' AND ib.inward_id = ic.inward_id
    UNION ALL
    SELECT oc.batch_id AS "TRANS_ID", oc.schedule_no AS "BATCH_ID",
           pis.ac_hd_id AS "AC_HD_ID", pis.acct_no AS "ACT_NUM",
           DECODE (t.table_name,
                   'OUTWARD_CLEARING', oc.amount,
                   pis.amount
                  ) AS amount,
           oc.outward_dt AS "TRANS_DT", 'CREDIT' AS "TRANS_TYPE",
           '' AS "INST_TYPE", NULL AS "INST_DT", NULL AS "TOKEN_NO",
           oc.status_by AS "INIT_TRANS_ID", oc.branch_id AS "INIT_CHANN_TYPE",
           'By oclg' AS "PARTICULARS", oc.status, '' AS "instrument_no1",
           '' AS "instrument_no2", '' AS "PROD_ID", '' AS "PROD_TYPE",
           'AUTHORIZED' AS authorize_status, oc.authorize_by, oc.authorize_dt,
           oc.authorize_remarks, oc.status_by, oc.branch_id, oc.status_dt,
           'CLEARING' AS "TRANS_MODE", oc.branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME"
      FROM outward_clearing oc,
           pay_in_slip pis,
           outward_tally ot,
           (SELECT   batch_id,
                     DECODE (COUNT (*),
                             1, 'PAY_IN_SLIP',
                             'OUTWARD_CLEARING'
                            ) AS table_name
                FROM outward_clearing
            GROUP BY batch_id) t
     WHERE oc.batch_id = t.batch_id
       AND pis.batch_id = t.batch_id
       AND ot.schedule_no = oc.schedule_no
       AND ot.tally_status = 'CLOSED'
    UNION ALL
    SELECT trans_id AS "TRANS_ID", NULL AS "BATCH_ID", ac_hd_id,
           NULL AS "ACT_NUM", amount, trans_dt, trans_type, inst_type,
           inst_dt, NULL AS "TOKEN_NO", init_trans_id, init_chann_type,
           particulars, status, instrument_no1, instrument_no2, prod_id,
           prod_type, 'AUTHORIZED' AS authorize_status, NULL AS authorize_by,
           NULL AS authorize_dt, NULL AS authorize_remarks, NULL AS status_by,
           branch_id, status_dt, trans_mode, branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME"
      FROM trans_ref_gl
     WHERE trans_mode = 'CLEARING'
    UNION ALL
    SELECT otr.return_id AS "TRANS_ID", otr.batch_id AS "BATCH_ID",
           '' AS "AC_HD_ID", otr.acct_no AS actnum, otr.amount,
           otr.clearing_date AS "TRANS_DT", 'DEBIT' AS trans_type,
           otc.instrument_type AS inst_type, otc.instrument_dt AS "INST_DT",
           NULL AS "TOKEN_NO", otr.status_by AS "INIT_TRANS_ID",
           otr.branch_id AS "INIT_CHANN_TYPE",
           'OUTWARD RETURN : ' || otc.authorize_remarks AS patriculars,
           otr.status, otr.instrument_no1, otr.instrument_no2,
           '' AS "PROD_ID", '' AS "PROD_TYPE", otr.authorize_status,
           otr.authorize_by, otr.authorize_dt, otr.authorize_remarks,
           otr.status_by, otr.branch_id, otr.status_dt,
           'CLEARING' AS "TRANS_MODE", otr.initiated_branch,
           '' AS "AUTHORIZE_STATUS_2", '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS", '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION", '' AS "SINGLE_TRANS_ID", '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME"
      FROM outward_return otr, outward_clearing otc
     WHERE otc.authorize_status = 'REJECTED' AND otr.batch_id = otc.batch_id);
 LOOP
            FETCH
             TRCURSOR INTO 
            OUTREC.trans_id,
            OUTREC.batch_id,
            OUTREC.ac_hd_id,
            OUTREC.act_num,
            OUTREC.amount,OUTREC.trans_type,OUTREC.inst_type,OUTREC.trans_dt,OUTREC.init_trans_id,OUTREC.init_chann_type,OUTREC.particulars,
            OUTREC.instrument_no1,OUTREC.instrument_no2,OUTREC.prod_id,OUTREC.prod_type,OUTREC.authorize_status,OUTREC.authorize_by,
            OUTREC.authorize_dt,OUTREC.authorize_remarks,OUTREC.status_by,OUTREC.branch_id,OUTREC.status_dt,OUTREC.trans_mode,
            OUTREC.initiated_branch,OUTREC.authorize_status_2,OUTREC.link_batch_id,OUTREC.payment_status,OUTREC.gl_trans_act_num,
            OUTREC.narration,OUTREC.single_trans_id,OUTREC.trans_mod_type,OUTREC.screen_name;
            EXIT WHEN TRCURSOR%NOTFOUND;
            PIPE ROW(OUTREC);                               
  END LOOP;
  CLOSE TRCURSOR;
  RETURN;
END;
/

CREATE TABLE DAILY_SCHEDULE_INFO
(
  TABLE_NAME   VARCHAR2(25 BYTE),
  ACT_NUM      VARCHAR2(25 BYTE),
  OPBAL        NUMBER(16,2),
  ARRIVED_BAL  NUMBER(16,2),
  CLOSE_BAL    NUMBER(16,2),
  DIFF         NUMBER(16,2),
  BRANCH_CODE  VARCHAR2(15 BYTE),
  TRANS_DT     DATE,
  RESOLVED_DT  DATE
)

CREATE OR REPLACE TYPE "TYPE_TABLENAME" AS OBJECT (
   TABLE_NAME    VARCHAR2(35),
   PROD_DESC     VARCHAR(30)
);
/

CREATE OR REPLACE FUNCTION get_tab_table_name(prod_id1 varchar2) RETURN TAB_TYPE_TABLENAME PIPELINED IS
 l_tab  TYPE_TABLENAME := TYPE_TABLENAME(NULL,NULL);
BEGIN
FOR e in
(select A.PROD_DESC ,case A.PROD_TYPE WHEN 'OA' THEN 'ACT_MASTER'
WHEN 'SA' THEN 'SUSPENSE_ACCOUNT_MASTER'
WHEN 'AB' THEN 'OTHER_BANKS_ACT_MASTER'
WHEN 'TD' THEN 'DEPOSIT_ACINFO'
WHEN  'TL' THEN 'LOANS_FACILITY_DETAILS'
WHEN  'MDS' THEN  'MDS_MASTER_MAINTENANCE'
ELSE 'OTHER' END TABLE_NAME 
 from ALL_PRODUCTS a where  A.PROD_ID=prod_id1)
loop
 l_tab.PROD_DESC:=e.PROD_DESC;
 l_tab.TABLE_NAME:=e.table_name;
 PIPE ROW (l_tab);
end loop;
  RETURN;
END;
/

CREATE OR REPLACE TYPE TYPE_DATA_CHECKING AS OBJECT (
  TABLE_NAME     VARCHAR2(25),
  MASTER_TABLE   VARCHAR2(25),
  ACT_NUM       VARCHAR2(20),
  MESSAGE       VARCHAR2(50)
);
/

CREATE OR REPLACE TYPE TAB_TYPE_DATA_CHECKING AS TABLE OF TYPE_DATA_CHECKING;
/

CREATE TABLE DATA_CHECKING_INFO
(
  TABLE_NAME    VARCHAR2(25 BYTE),
  MASTER_TABLE  VARCHAR2(25 BYTE),
  ACT_NUM       VARCHAR2(20 BYTE),
  MESSAGE       VARCHAR2(50 BYTE),
  BRANCH_CODE   VARCHAR2(6 BYTE),
  TRANS_DT      DATE,
  RESOLVED_DT   DATE
)

CREATE OR REPLACE FUNCTION DATA_CHECKING (CURRDATE    DATE,
                                                  BR_CODE     VARCHAR2)
   RETURN TAB_TYPE_DATA_CHECKING
IS
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   DECLARE
      L_TAB     TAB_TYPE_DATA_CHECKING := TAB_TYPE_DATA_CHECKING ();
      AMOUNT1   NUMBER (16, 2) := 0;
      AMOUNT2   NUMBER (16, 2) := 0;
      COUNT1    NUMBER := 0;
      BLIKE     VARCHAR2 (20) := NULL;

      CURSOR C
      IS
         SELECT DECODE (BATCH_ID, NULL, TRANS_ID, BATCH_ID) AS BATCH_ID,
                TRANS_ID AS TRANS_ID,
                DECODE (ACT_NUM, NULL, LINK_BATCH_ID, ACT_NUM)
                   AS LINK_BATCH_ID,
                TRANS_MOD_TYPE,
                PROD_ID,
                PROD_TYPE,
                TRANS_MODE,
                BRANCH_ID
           FROM TABLE (ALL_TRANS_FUNCT (BR_CODE, CURRDATE));

   BEGIN
      FOR I IN C
      LOOP
         AMOUNT1 := 0;
         AMOUNT2 := 0;
         COUNT1 := 0;

         IF (I.TRANS_MOD_TYPE = 'OA')
         THEN
            IF (I.TRANS_MODE = 'TRANSFER')
            THEN
               SELECT SUM (NVL (AMOUNT, 0))
                 INTO AMOUNT1
                 FROM ALL_TRANS A
                WHERE     A.TRANS_DT = CURRDATE
                      AND A.TRANS_ID = I.TRANS_ID
                      AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                      AND A.BRANCH_ID = I.BRANCH_ID;

               SELECT COUNT (*)
                 INTO COUNT1
                 FROM PASS_BOOK P
                WHERE     P.TRANS_ID = I.TRANS_ID
                      AND P.TRANS_DT = CURRDATE
                      AND P.ACT_NUM = I.LINK_BATCH_ID;

               IF (COUNT1 = 0)
               THEN
                  L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_DATA_CHECKING ('PASS_BOOK',
                                         'TRANSFER_TRANS',
                                         I.LINK_BATCH_ID,
                                         'NO RECORD IN PASS BOOK');
               ELSIF (COUNT1 = 1)
               THEN
                  SELECT DECODE (NVL (DEBIT, 0),
                                 0, NVL (CREDIT, 0),
                                 NVL (DEBIT, 0))
                    INTO AMOUNT2
                    FROM PASS_BOOK p
                   WHERE     P.TRANS_ID = I.TRANS_ID
                         AND TRANS_DT = CURRDATE
                         AND ACT_NUM = I.LINK_BATCH_ID;

                  IF (AMOUNT1 <> AMOUNT2)
                  THEN
                     L_TAB.EXTEND;
                     L_TAB (L_TAB.LAST) :=
                        TYPE_DATA_CHECKING ('PASS_BOOK',
                                            'TRANSFER_TRANS',
                                            I.LINK_BATCH_ID,
                                            'VALUE MISMATCH');
                  END IF;
               END IF;
            ELSIF (I.TRANS_MODE = 'CASH')
            THEN
               SELECT SUM (NVL (AMOUNT, 0))
                 INTO AMOUNT1
                 FROM ALL_TRANS A
                WHERE     A.TRANS_DT = CURRDATE
                      AND A.TRANS_ID = I.TRANS_ID
                      AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                      AND A.BRANCH_ID = I.BRANCH_ID;

               SELECT COUNT (*)
                 INTO COUNT1
                 FROM PASS_BOOK P
                WHERE     P.TRANS_ID = I.TRANS_ID
                      AND TRANS_DT = CURRDATE
                      AND ACT_NUM = I.LINK_BATCH_ID;

               IF (COUNT1 = 0)
               THEN
                  L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_DATA_CHECKING ('PASS_BOOK',
                                         'CASH_TRANS',
                                         I.LINK_BATCH_ID,
                                         'NO RECORD IN PASS BOOK');
               ELSIF (COUNT1 = 1)
               THEN
                  SELECT DECODE (NVL (DEBIT, 0),
                                 0, NVL (CREDIT, 0),
                                 NVL (DEBIT, 0))
                    INTO AMOUNT2
                    FROM PASS_BOOK P
                   WHERE     P.TRANS_ID = I.TRANS_ID
                         AND TRANS_DT = CURRDATE
                         AND ACT_NUM = I.LINK_BATCH_ID;

                  IF (AMOUNT1 <> AMOUNT2)
                  THEN
                     L_TAB.EXTEND;
                     L_TAB (L_TAB.LAST) :=
                        TYPE_DATA_CHECKING ('PASS_BOOK',
                                            'CASH_TRANS',
                                            I.LINK_BATCH_ID,
                                            'VALUE MISMATCH');
                  END IF;
               END IF;
            END IF;                                             --transfer end
         ELSIF (I.TRANS_MOD_TYPE = 'TL')
         THEN
            IF (I.TRANS_MODE = 'TRANSFER')
            THEN
               SELECT NVL (SUM (AMOUNT), 0)
                 INTO AMOUNT1
                 FROM ALL_TRANS A
                WHERE     A.TRANS_DT = CURRDATE
                      AND A.BATCH_ID = I.BATCH_ID
                      AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                      AND A.BRANCH_ID = I.BRANCH_ID
                      AND A.LINK_BATCH_ID = I.LINK_BATCH_ID;

               SELECT COUNT (*)
                 INTO COUNT1
                 FROM LOAN_TRANS_DETAILS L
                WHERE     SUBSTR (L.TRANS_ID, 1, INSTR (L.TRANS_ID, '_') - 1) =
                             I.BATCH_ID
                      AND TRANS_DT = CURRDATE
                      AND ACT_NUM = I.LINK_BATCH_ID;

               IF (COUNT1 = 0)
               THEN
                  L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_DATA_CHECKING ('LOAN_TRANS_DETAILS',
                                         'TRANSFER_TRANS',
                                         I.LINK_BATCH_ID,
                                         'NO RECORD IN LOAN_TRANS_DETAILS');
               ELSE
                  SELECT SUM (
                            (  NVL (PRINCIPLE, 0)
                             + NVL (INTEREST, 0)
                             + NVL (IBAl, 0)
                             + NVL (PENAL, 0)
                             + NVL (PIBAL, 0)
                             + NVL (EXPENSE, 0)
                             + NVL (EBAL, 0)
                             + NVL (EXCESS_AMT, 0)
                             + NVL (POSTAGE_CHARGE, 0)
                             + NVL (ARBITARY_CHARGE, 0)
                             + NVL (LEGAL_CHARGE, 0)
                             + NVL (INSURANCE_CHARGE, 0)
                             + NVL (MISC_CHARGES, 0)
                             + NVL (EXE_DEGREE, 0)
                             + NVL (ADVERTISE_CHARGE, 0)
                             + NVL (EXE_DEGREE, 0)
                             + NVL (NOTICE_CHARGES, 0)))
                            AS AMOUNT
                    INTO AMOUNT2
                    FROM LOAN_TRANS_DETAILS L
                   WHERE     L.TRANS_DT = CURRDATE
                         AND SUBSTR (l.TRANS_ID,
                                     1,
                                     INSTR (l.TRANS_ID, '_') - 1) =
                                I.BATCH_ID
                         AND L.ACT_NUM = I.LINK_BATCH_ID;

                  IF (AMOUNT1 <> AMOUNT2)
                  THEN
                     L_TAB.EXTEND;
                     L_TAB (L_TAB.LAST) :=
                        TYPE_DATA_CHECKING ('LOAN_TRANS_DETAILS',
                                            'TRANSFER_TRANS',
                                            I.LINK_BATCH_ID,
                                            'VALUE MISMATCH');
                  END IF;
               END IF;
            ELSIF (I.TRANS_MODE = 'CASH')
            THEN
               SELECT NVL (SUM (AMOUNT), 0)
                 INTO AMOUNT1
                 FROM ALL_TRANS A
                WHERE     A.TRANS_DT = CURRDATE
                      AND A.TRANS_ID = I.BATCH_ID
                      AND TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                      AND A.LINK_BATCH_ID = I.LINK_BATCH_ID;

               SELECT COUNT (*)
                 INTO COUNT1
                 FROM LOAN_TRANS_DETAILS L
                WHERE     L.TRANS_ID = I.BATCH_ID
                      AND L.TRANS_DT = CURRDATE
                      AND L.ACT_NUM = I.LINK_BATCH_ID;

               IF (COUNT1 = 0)
               THEN
                  L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_DATA_CHECKING ('LOAN_TRANS_DETAILS',
                                         'CASH_TRANS',
                                         I.LINK_BATCH_ID,
                                         'NO RECORD IN LOAN_TRANS_DETAILS');
               ELSE
                  SELECT SUM (
                            (  NVL (PRINCIPLE, 0)
                             + NVL (INTEREST, 0)
                             + NVL (IBAl, 0)
                             + NVL (PENAL, 0)
                             + NVL (PIBAL, 0)
                             + NVL (EXPENSE, 0)
                             + NVL (EBAL, 0)
                             + NVL (EXCESS_AMT, 0)
                             + NVL (POSTAGE_CHARGE, 0)
                             + NVL (ARBITARY_CHARGE, 0)
                             + NVL (LEGAL_CHARGE, 0)
                             + NVL (INSURANCE_CHARGE, 0)
                             + NVL (MISC_CHARGES, 0)
                             + NVL (EXE_DEGREE, 0)
                             + NVL (ADVERTISE_CHARGE, 0)
                             + NVL (EXE_DEGREE, 0)
                             + NVL (NOTICE_CHARGES, 0)))
                            AS AMOUNT
                    INTO AMOUNT2
                    FROM LOAN_TRANS_DETAILS L
                   WHERE     L.TRANS_DT = CURRDATE
                         AND L.TRANS_ID = I.BATCH_ID
                         AND L.ACT_NUM = I.LINK_BATCH_ID;

                  IF (AMOUNT1 <> AMOUNT2)
                  THEN
                     L_TAB.EXTEND;
                     L_TAB (L_TAB.LAST) :=
                        TYPE_DATA_CHECKING ('LOAN_TRANS_DETAILS',
                                            'CASH_TRANS',
                                            I.LINK_BATCH_ID,
                                            'VALUE MISMATCH');
                  END IF;
               END IF;
            END IF;                                            ---transfer end
         ELSIF (I.TRANS_MOD_TYPE = 'AD')
         THEN
            IF (I.TRANS_MODE = 'TRANSFER')
            THEN
               SELECT NVL (SUM (AMOUNT), 0)
                 INTO AMOUNT1
                 FROM ALL_TRANS A
                WHERE     A.TRANS_DT = CURRDATE
                      AND A.BATCH_ID = I.BATCH_ID
                      AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                      AND A.LINK_BATCH_ID = I.LINK_BATCH_ID
                      AND A.BRANCH_ID = I.BRANCH_ID;

               SELECT COUNT (*)
                 INTO COUNT1
                 FROM ADV_TRANS_DETAILS A
                WHERE     SUBSTR (A.TRANS_ID, 1, INSTR (A.TRANS_ID, '_') - 1) =
                             I.BATCH_ID
                      AND A.TRANS_DT = CURRDATE
                      AND A.ACT_NUM = I.LINK_BATCH_ID;

               IF (COUNT1 = 0)
               THEN
                  L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_DATA_CHECKING ('ADV_TRANS_DETAILS',
                                         'TRANSFER_TRANS',
                                         I.LINK_BATCH_ID,
                                         'NO RECORD IN ADV_TRANS_DETAILS');
               ELSE
                  SELECT SUM (
                            (  NVL (PRINCIPLE, 0)
                             + NVL (INTEREST, 0)
                             + NVL (IBAl, 0)
                             + NVL (PENAL, 0)
                             + NVL (PIBAL, 0)
                             + NVL (EXPENSE, 0)
                             + NVL (EBAL, 0)
                             + NVL (EXCESS_AMT, 0)
                             + NVL (POSTAGE_CHARGE, 0)
                             + NVL (ARBITARY_CHARGE, 0)
                             + NVL (LEGAL_CHARGE, 0)
                             + NVL (INSURANCE_CHARGE, 0)
                             + NVL (MISC_CHARGES, 0)
                             + NVL (EXE_DEGREE, 0)
                             + NVL (EXE_DEGREE, 0)))
                            AS AMOUNT
                    INTO AMOUNT2
                    FROM ADV_TRANS_DETAILS A
                   WHERE     A.TRANS_DT = CURRDATE
                         AND SUBSTR (A.TRANS_ID,
                                     1,
                                     INSTR (A.TRANS_ID, '_') - 1) =
                                I.BATCH_ID
                         AND A.ACT_NUM = I.LINK_BATCH_ID;

                  IF (AMOUNT1 <> AMOUNT2)
                  THEN
                     L_TAB.EXTEND;
                     L_TAB (L_TAB.LAST) :=
                        TYPE_DATA_CHECKING ('ADV_TRANS_DETAILS',
                                            'TRANSFER_TRANS',
                                            I.LINK_BATCH_ID,
                                            'VALUE MISMATCH');
                  END IF;

                  SELECT NVL (SUM (AMOUNT), 0)
                    INTO AMOUNT1
                    FROM ALL_TRANS A
                   WHERE     A.TRANS_DT = CURRDATE
                         AND A.BATCH_ID = I.BATCH_ID
                         AND TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                         AND A.ACT_NUM = I.LINK_BATCH_ID
                         AND A.BRANCH_ID = I.BRANCH_ID;


                  IF (AMOUNT1 > 0)
                  THEN
                     SELECT COUNT (*)
                       INTO COUNT1
                       FROM PASS_BOOK P
                      WHERE     P.BATCH_ID = I.BATCH_ID
                            AND P.TRANS_DT = CURRDATE
                            AND P.ACT_NUM = I.LINK_BATCH_ID;

                     IF (COUNT1 = 0)
                     THEN
                        L_TAB.EXTEND;
                        L_TAB (L_TAB.LAST) :=
                           TYPE_DATA_CHECKING ('PASS_BOOK',
                                               'TRANSFER_TRANS',
                                               I.LINK_BATCH_ID,
                                               'NO RECORD IN PASS BOOK');
                     ELSIF (COUNT1 = 1)
                     THEN
                        SELECT DECODE (DEBIT, NULL, CREDIT, DEBIT)
                          INTO AMOUNT2
                          FROM PASS_BOOK P
                         WHERE     P.BATCH_ID = I.BATCH_ID
                               AND TRANS_DT = CURRDATE
                               AND ACT_NUM = I.LINK_BATCH_ID;

                        IF (AMOUNT1 <> AMOUNT2)
                        THEN
                           L_TAB.EXTEND;
                           L_TAB (L_TAB.LAST) :=
                              TYPE_DATA_CHECKING ('PASS_BOOK',
                                                  'TRANSFER_TRANS',
                                                  I.LINK_BATCH_ID,
                                                  'VALUE MISMATCH');
                        END IF;
                     END IF;
                  END IF;
               END IF;
            ELSIF (I.TRANS_MODE = 'CASH')
            THEN
               SELECT NVL (SUM (AMOUNT), 0)
                 INTO AMOUNT1
                 FROM ALL_TRANS A
                WHERE     A.TRANS_DT = CURRDATE
                      AND A.TRANS_ID = I.BATCH_ID
                      AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                      AND A.LINK_BATCH_ID = I.LINK_BATCH_ID
                      AND A.BRANCH_ID = I.BRANCH_ID;

               SELECT COUNT (*)
                 INTO COUNT1
                 FROM ADV_TRANS_DETAILS A
                WHERE     A.TRANS_ID = I.BATCH_ID
                      AND A.TRANS_DT = CURRDATE
                      AND A.ACT_NUM = I.LINK_BATCH_ID;

               IF (COUNT1 = 0)
               THEN
                  L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_DATA_CHECKING ('ADV_TRANS_DETAILS',
                                         'CASH_TRANS',
                                         I.LINK_BATCH_ID,
                                         'NO RECORD IN ADV_TRANS_DETAILS');
               ELSE
                  SELECT SUM (
                            (  NVL (PRINCIPLE, 0)
                             + NVL (INTEREST, 0)
                             + NVL (IBAl, 0)
                             + NVL (PENAL, 0)
                             + NVL (PIBAL, 0)
                             + NVL (EXPENSE, 0)
                             + NVL (EBAL, 0)
                             + NVL (EXCESS_AMT, 0)
                             + NVL (POSTAGE_CHARGE, 0)
                             + NVL (ARBITARY_CHARGE, 0)
                             + NVL (LEGAL_CHARGE, 0)
                             + NVL (INSURANCE_CHARGE, 0)
                             + NVL (MISC_CHARGES, 0)
                             + NVL (EXE_DEGREE, 0)
                             + NVL (EXE_DEGREE, 0)))
                            AS AMOUNT
                    INTO AMOUNT2
                    FROM ADV_TRANS_DETAILS L
                   WHERE L.TRANS_DT = CURRDATE AND L.TRANS_ID = I.BATCH_ID;

                  IF (AMOUNT1 <> AMOUNT2)
                  THEN
                     L_TAB.EXTEND;
                     L_TAB (L_TAB.LAST) :=
                        TYPE_DATA_CHECKING ('LOAN_TRANS_DETAILS',
                                            'CASH_TRANS',
                                            I.LINK_BATCH_ID,
                                            'VALUE MISMATCH');
                  END IF;

                  SELECT NVL (SUM (AMOUNT), 0)
                    INTO AMOUNT1
                    FROM ALL_TRANS A
                   WHERE     A.TRANS_DT = CURRDATE
                         AND A.TRANS_ID = I.BATCH_ID
                         AND TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                         AND A.ACT_NUM = I.LINK_BATCH_ID
                         AND A.BRANCH_ID = I.BRANCH_ID;

                  IF (AMOUNT1 > 0)
                  THEN
                     SELECT COUNT (*)
                       INTO COUNT1
                       FROM PASS_BOOK P
                      WHERE     P.TRANS_ID = I.BATCH_ID
                            AND TRANS_DT = CURRDATE
                            AND ACT_NUM = I.LINK_BATCH_ID;

                     IF (COUNT1 = 0)
                     THEN
                        L_TAB.EXTEND;
                        L_TAB (L_TAB.LAST) :=
                           TYPE_DATA_CHECKING ('PASS_BOOK',
                                               'CASH_TRANS',
                                               I.LINK_BATCH_ID,
                                               'NO RECORD IN PASS BOOK');
                     ELSIF (COUNT1 = 1)
                     THEN
                        SELECT DECODE (DEBIT, NULL, CREDIT, DEBIT)
                          INTO AMOUNT2
                          FROM PASS_BOOK P
                         WHERE     P.TRANS_ID = I.BATCH_ID
                               AND TRANS_DT = CURRDATE
                               AND ACT_NUM = I.LINK_BATCH_ID;

                        IF (AMOUNT1 <> AMOUNT2)
                        THEN
                           L_TAB.EXTEND;
                           L_TAB (L_TAB.LAST) :=
                              TYPE_DATA_CHECKING ('PASS_BOOK',
                                                  'CASH_TRANS',
                                                  I.LINK_BATCH_ID,
                                                  'VALUE MISMATCH');
                        END IF;
                     END IF;
                  END IF;
               END IF;
            ---end
            END IF;                                             --transfer end
         ELSIF (I.TRANS_MOD_TYPE = 'TD')
         THEN
            IF (I.PROD_TYPE = 'TD')
            THEN
               IF (I.TRANS_MODE = 'TRANSFER')
               THEN
                  SELECT a.BEHAVES_LIKE
                    INTO BLIKE
                    FROM ALL_PRODUCTS A
                   WHERE A.PROD_ID = I.PROD_ID;

                  IF (BLIKE = 'RECURRING')
                  THEN
                     SELECT SUM (AMOUNT)
                       INTO AMOUNT1
                       FROM ALL_TRANS A
                      WHERE     A.TRANS_DT = CURRDATE
                            AND A.BATCH_ID = I.BATCH_ID
                            AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                            AND A.BRANCH_ID = I.BRANCH_ID;

                     SELECT COUNT (*)
                       INTO COUNT1
                       FROM DEPOSIT_RECURRING D
                      WHERE    D.DEPOSIT_NO_SUB = I.LINK_BATCH_ID
                            OR     D.DEPOSIT_NO_SUB = I.LINK_BATCH_ID + '_1'
                               AND D.TRANS_DT = CURRDATE;


                     IF (COUNT1 = 0)
                     THEN
                        L_TAB.EXTEND;
                        L_TAB (L_TAB.LAST) :=
                           TYPE_DATA_CHECKING (
                              'DEPOSIT_RECURRING',
                              'TRANSFER_TRANS',
                              I.LINK_BATCH_ID,
                              'NO RECORD IN DEPOSIT_RECURRING');
                     ELSE
                        SELECT NVL (SUM (AMOUNT), 0)
                          INTO AMOUNT2
                          FROM DEPOSIT_RECURRING D
                         WHERE    D.DEPOSIT_NO_SUB = I.LINK_BATCH_ID
                               OR     D.DEPOSIT_NO_SUB =
                                         I.LINK_BATCH_ID + '_1'
                                  AND D.TRANS_DT = CURRDATE;

                        IF (AMOUNT1 <> AMOUNT2)
                        THEN
                           L_TAB.EXTEND;
                           L_TAB (L_TAB.LAST) :=
                              TYPE_DATA_CHECKING ('DEPOSIT_RECURRING',
                                                  'TRANSFER_TRANS',
                                                  I.LINK_BATCH_ID,
                                                  'VALUE MISMATCH');
                        END IF;
                     END IF;
                  END IF;
               ELSIF (I.TRANS_MODE = 'CASH')
               THEN
                  SELECT A.BEHAVES_LIKE
                    INTO BLIKE
                    FROM ALL_PRODUCTS A
                   WHERE A.PROD_ID = I.PROD_ID;

                  IF (BLIKE = 'RECURRING')
                  THEN
                     SELECT SUM (AMOUNT)
                       INTO AMOUNT1
                       FROM ALL_TRANS A
                      WHERE     A.TRANS_DT = CURRDATE
                            AND A.TRANS_ID = I.BATCH_ID
                            AND A.TRANS_MOD_TYPE = I.TRANS_MOD_TYPE
                            AND A.BRANCH_ID = I.BRANCH_ID;

                     SELECT COUNT (*)
                       INTO COUNT1
                       FROM DEPOSIT_RECURRING D
                      WHERE    D.DEPOSIT_NO_SUB = I.LINK_BATCH_ID
                            OR     D.DEPOSIT_NO_SUB = I.LINK_BATCH_ID + '_1'
                               AND D.TRANS_DT = CURRDATE;

                     IF (COUNT1 = 0)
                     THEN
                        L_TAB.EXTEND;
                        L_TAB (L_TAB.LAST) :=
                           TYPE_DATA_CHECKING (
                              'DEPOSIT_RECURRING',
                              'CAH_TRANS',
                              I.LINK_BATCH_ID,
                              'NO RECORD IN DEPOSIT_RECURRING');
                     ELSE
                        SELECT NVL (SUM (AMOUNT), 0)
                          INTO AMOUNT2
                          FROM DEPOSIT_RECURRING D
                         WHERE     D.DEPOSIT_NO_SUB = I.LINK_BATCH_ID
                               AND D.TRANS_DT = CURRDATE;

                        IF (AMOUNT1 <> AMOUNT2)
                        THEN
                           L_TAB.EXTEND;
                           L_TAB (L_TAB.LAST) :=
                              TYPE_DATA_CHECKING ('DEPOSIT_RECURRING',
                                                  'TRANSFER_TRANS',
                                                  I.LINK_BATCH_ID,
                                                  'VALUE MISMATCH');
                        END IF;
                     END IF;
                  END IF;
               END IF;
            END IF;
         END IF;
      END LOOP;

      FOR I IN (SELECT * FROM TABLE (L_TAB))
      LOOP
         --         DBMS_OUTPUT.put_line (
         --               'last loop'
         --            || i.TABLE_NAME
         --            || AMOUNT2
         --            || i.MASTER_TABLE
         --            || i.ACT_NUM);

         MERGE INTO DATA_CHECKING_INFO A
              USING (SELECT I.TABLE_NAME AS TABLE_NAME,
                            I.MASTER_TABLE AS MASTER_TABLE,
                            I.ACT_NUM AS ACT_NUM,
                            I.MESSAGE AS MESSAGE,
                            BR_CODE AS BRCODE,
                            CURRDATE AS CURDATE
                       FROM DUAL) B
                 ON (    A.ACT_NUM = B.ACT_NUM
                     AND A.TABLE_NAME = B.TABLE_NAME
                     AND A.MASTER_TABLE = B.MASTER_TABLE
                     AND A.TRANS_DT = B.CURDATE
                     AND A.BRANCH_CODE = B.BRCODE)
         WHEN MATCHED
         THEN
            UPDATE SET A.MESSAGE = B.MESSAGE
         WHEN NOT MATCHED
         THEN
            INSERT     (TABLE_NAME,
                        MASTER_TABLE,
                        ACT_NUM,
                        MESSAGE,
                        BRANCH_CODE,
                        TRANS_DT)
                VALUES (B.TABLE_NAME,
                        B.MASTER_TABLE,
                        B.ACT_NUM,
                        B.MESSAGE,
                        BR_CODE,
                        CURRDATE);

         COMMIT;
      END LOOP;

      RETURN L_TAB;
   END;
END;
/

CREATE OR REPLACE TYPE "TYPE_SCHEDULE" AS OBJECT (
   TABLE_NAME    VARCHAR2(25),
   ACT_NUM       VARCHAR2(20),
   OPBAL         NUMBER(16,2),
   ARRIVED_BAL       NUMBER(16,2),
   CLOSE_BAL       NUMBER(16,2),
   DIFF       NUMBER(16,2),
   BRANCH_CODE  varchar2(15),
   PROD_DESC     VARCHAR(100)
);
/

CREATE OR REPLACE TYPE TAB_TYPE_SCHEDULE AS TABLE OF TYPE_SCHEDULE;
/

CREATE OR REPLACE FUNCTION schedule_product (
   br_code    VARCHAR2,
   curdate    DATE,
   prevdate   DATE
)
   RETURN tab_type_schedule PIPELINED
IS
   PRAGMA AUTONOMOUS_TRANSACTION;

   TYPE ref0 IS REF CURSOR;
   trcursor   ref0;
   outrec     type_schedule
                        := type_schedule (NULL, NULL, NULL, 0, 0, 0, 0, NULL);
BEGIN
   OPEN trcursor FOR
    SELECT table_name, act_num, opbal, act_bal, closebal, diff, branch_id,
             prod_desc
        FROM (SELECT   a.table_name, act_num, a.prod_desc, opbal,
                       opbal - dr_amt + cr_amt act_bal, closebal,
                       (opbal - dr_amt + cr_amt) - closebal diff, prod_id,
                       branch_id
                  FROM (SELECT   act_num, opbal, dr_amt, cr_amt,
                                 opbal - dr_amt + cr_amt act_bal, closebal,
                                 (opbal - dr_amt + cr_amt) - closebal diff,
                                 prod_id, branch_id
                            FROM (SELECT   act_num,
                                           NVL (PkgReports.fngetbal (act_num, prevdate),
                                                0
                                               ) opbal,
                                           SUM (DECODE (trans_type,
                                                        'DEBIT', NVL (amount,
                                                                      0
                                                                     ),
                                                        0
                                                       )
                                               ) dr_amt,
                                           SUM (DECODE (trans_type,
                                                        'CREDIT', NVL (amount,
                                                                       0
                                                                      ),
                                                        0
                                                       )
                                               ) cr_amt,
                                           NVL (PkgReports.fngetbal (act_num, curdate),
                                                0
                                               ) closebal,
                                           all_product_accts1.prod_id,
                                           all_product_accts1.branch_id
                                      FROM all_product_accts1,
                                           rep_sub_day_book
                                     WHERE (   rep_sub_day_book.acc_no =
                                                    all_product_accts1.act_num
                                            OR rep_sub_day_book.acc_no =
                                                  all_product_accts1.rep_act_num
                                           )
                                       AND trans_dt = curdate
                                       AND all_product_accts1.branch_id =
                                                                       br_code
                                       AND all_product_accts1.PROD_TYPE NOT IN ('MDS','AB')
                                  GROUP BY act_num,
                                           all_product_accts1.prod_id,
                                           all_product_accts1.branch_id
                                  UNION ALL
                                  SELECT   act_num,
                                           NVL (PkgReports.fngetbal (act_num, prevdate),
                                                0
                                               ) opbal,
                                           0 dr_amt,
                                           SUM (NVL (amount, 0)) cr_amt,
                                           NVL (PkgReports.fngetbal (act_num, curdate),
                                                0
                                               ) closebal,
                                           all_product_accts1.prod_id,
                                           all_product_accts1.branch_id
                                      FROM all_product_accts1,
                                           daily_deposit_trans
                                     WHERE all_product_accts1.rep_act_num(+) =
                                                   daily_deposit_trans.acc_num
                                       AND all_product_accts1.branch_id =
                                                                       br_code
                                       AND trn_dt(+) = curdate
                                  GROUP BY act_num,
                                           all_product_accts1.prod_id,
                                           all_product_accts1.branch_id)
                           WHERE opbal - dr_amt + cr_amt <> closebal
                        ORDER BY act_num),
                       TABLE (get_tab_table_name (prod_id)) a
              UNION ALL
              SELECT   'GL' AS table_name, a.ac_hd_id AS act_num,
                       ac_hd_desc AS prod_desc, opn_bal AS opbal,
                       calc_close_bal AS act_bal, close_bal AS closebal,
                       calc_close_bal - close_bal AS diff, NULL AS prod_id,
                       branch_code AS branch_id
                  FROM (SELECT a.branch_code, a.ac_hd_id, opn_bal,
                               NVL (debit, 0) debit, NVL (credit, 0) credit,
                                 opn_bal
                               - NVL (debit, 0)
                               + NVL (credit, 0) calc_close_bal,
                               close_bal
                          FROM (SELECT ac_hd_id,
                                       DECODE (balance_type,
                                               'DEBIT', -1
                                                * NVL (close_bal, 0),
                                               NVL (close_bal, 0)
                                              ) AS opn_bal,
                                       dt, branch_code, balance_type
                                  FROM gl_abstract a
                                 WHERE dt = prevdate AND branch_code = br_code) a,
                               (SELECT   ac_hd_id, trans_dt, branch_code,
                                         NVL (SUM (  debit_cash
                                                   + debit_transfer
                                                   + debit_clearing
                                                  ),
                                              0
                                             ) debit,
                                         NVL (SUM (  credit_cash
                                                   + credit_transfer
                                                   + credit_clearing
                                                  ),
                                              0
                                             ) credit
                                    FROM rep_day_book_final
                                   WHERE trans_dt = curdate
                                     AND branch_code = br_code
                                GROUP BY ac_hd_id, trans_dt, branch_code
                                UNION
                                SELECT   ac_hd_id, trans_dt,
                                         branch_id AS branch_code,
                                         SUM (DECODE (trans_type,
                                                      'DEBIT', amount,
                                                      0
                                                     )
                                             ) debit,
                                         SUM (DECODE (trans_type,
                                                      'CREDIT', amount,
                                                      0
                                                     )
                                             ) credit
                                    FROM trans_ref_gl
                                   WHERE trans_dt = curdate
                                     AND trans_mode != 'CLEARING'
                                     AND branch_id = br_code
                                GROUP BY ac_hd_id, trans_dt, branch_id) b,
                               (SELECT ac_hd_id,
                                       DECODE (balance_type,
                                               'DEBIT', -1 * NVL (cur_bal, 0),
                                               NVL (cur_bal, 0)
                                              ) close_bal,
                                       branch_code, balance_type
                                  FROM gl a
                                 WHERE branch_code = br_code) c
                         WHERE a.ac_hd_id = c.ac_hd_id(+)
                           AND b.ac_hd_id(+) = c.ac_hd_id
                           AND a.branch_code = c.branch_code(+)
                           AND b.branch_code(+) = c.branch_code) a,
                       ac_hd b
                WHERE a.ac_hd_id = b.ac_hd_id AND calc_close_bal <> close_bal
              ORDER BY act_num);

   LOOP
      FETCH trcursor
       INTO outrec.table_name, outrec.act_num, outrec.opbal,
            outrec.arrived_bal, outrec.close_bal, outrec.diff,
            outrec.branch_code, outrec.prod_desc;
      MERGE INTO daily_schedule_info a
         USING (SELECT outrec.table_name AS table_name, outrec.act_num as act_num,outrec.opbal AS opbal,outrec.arrived_bal as arrived_bal
         , outrec.close_bal as close_bal ,outrec.diff as diff,outrec.branch_code as branch_code,curdate as currdate FROM DUAL) b
         ON (a.act_num = b.act_num AND a.BRANCH_CODE=b.branch_code AND a.TRANS_DT=b.currdate)
         WHEN MATCHED THEN
            UPDATE
               SET a.opbal = b.opbal, a.arrived_bal = b.arrived_bal,a.close_bal = b.close_bal,a.diff = b.diff
         WHEN NOT MATCHED THEN
            INSERT (table_name, act_num,opbal,arrived_bal,close_bal,diff,branch_code,TRANS_DT)
            VALUES (b.table_name, b.act_num, b.opbal,b.arrived_bal,b.close_bal,b.diff,b.branch_code,curdate);
            Commit;
      EXIT WHEN trcursor%NOTFOUND;
      PIPE ROW (outrec);
   END LOOP;
   CLOSE trcursor;
   RETURN;
END;
/

-- End Version [Script Version - 0.0.279] [ReleaseVersion - 9.2.2.10]--[30-07-2018] -- By Rishad

-- End Version [Script Version - 0.0.280] [ReleaseVersion - 9.2.2.10]--[08-08-2018] -- By Nithya

ALTER TABLE MDS_MONEY_PAYMENT_DETAILS ADD DIFAULTER_BONUS NUMBER(14,2)

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS add FORFEITE_HD_Y_N varchar2(1) default 'N'

CREATE OR REPLACE FUNCTION GET_TL_overdue_rate_EMI(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN
  SELECT DRGTR.OD_INT_RATE into RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = CATG
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(LOANDUEDT - LOANDATE,0)
          BETWEEN from_period
              AND to_period ;            
    RETURN RATEOFINT;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_penal_rate_EMI(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN
  SELECT DRGTR.PENAL_INT into RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = CATG
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(LOANDUEDT - LOANDATE,0)
          BETWEEN from_period
              AND to_period ;            
    RETURN RATEOFINT;
END;
/

CREATE OR REPLACE FUNCTION GET_EMI_OVERDUE_INTEREST(ACTNUM VARCHAR,BRANCHCODE VARCHAR) RETURN NUMBER IS 
TOTALAMOUNT NUMBER(16,2) := 0;
EMIAMOUNT NUMBER(16,2);
PROID VARCHAR2(3);
CATG VARCHAR2(50);
FDATE DATE;
TDATE DATE;
LAMT NUMBER(12,2);
INTFROM VARCHAR2(20);
INSTAMT NUMBER(12,2);
PENALRATE NUMBER(12,2);
PENAL NUMBER(12,2);
PRODUCT NUMBER;
EXPIRY_DT DATE;
TOTALDUEDAYS NUMBER;
CURRDT DATE;
OVERDUEINT NUMBER(16,2);
COUNTFORINST NUMBER; 
FULLPENAL NUMBER(16,2) := 0;
OVERDUEINTAMT NUMBER(16,2) :=0;
OVER_DUE_INT_DT DATE;
cursor c1 is SELECT * FROM LOANS_INSTALLMENT WHERE ACCT_NUM=ACTNUM AND IS_BALANCE IS NULL 
AND STATUS !='DELETED' AND nvl(active_status,'Y') ='Y' ORDER BY INSTALLMENT_SLNO;
BEGIN
SELECT LFD.PROD_ID,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT,LFD.INT_GET_FROM 
INTO PROID,CATG,FDATE,TDATE,LAMT,INTFROM  FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
WHERE LFD.BORROW_NO = LB.BORROW_NO
AND LB.BORROW_NO = LSD.BORROW_NO
AND LFD.ACCT_NUM = ACTNUM;
SELECT MAX(LI.INSTALLMENT_DT) INTO EXPIRY_DT FROM LOANS_INSTALLMENT LI WHERE LI.ACCT_NUM = ACTNUM;
SELECT D.CURR_APPL_DT INTO CURRDT FROM DAY_END D WHERE D.BRANCH_CODE = BRANCHCODE;
select max(LT.TRANS_DT) into OVER_DUE_INT_DT from LOAN_TRANS_DETAILS lt 
where LT.ACT_NUM = ACTNUM and LT.OVER_DUE_INT > 0  ;
Select to_date(CURRDT) - to_date(decode(OVER_DUE_INT_DT,NULL,EXPIRY_DT,OVER_DUE_INT_DT)) INTO TOTALDUEDAYS From dual;
IF TOTALDUEDAYS <= 0 THEN
  OVERDUEINTAMT := 0;
ELSE
SELECT GET_TL_INSTAMT(ACTNUM) INTO INSTAMT FROM DUAL;
    IF INTFROM = 'ACT' THEN
    SELECT LIM.PENAL_INTEREST INTO PENALRATE FROM LOANS_INT_MAINTENANCE LIM WHERE
    LIM.ACCT_NUM = ACTNUM AND LIM.SLNO =( SELECT MAX(LS.SLNO) FROM LOANS_INT_MAINTENANCE LS WHERE LS.ACCT_NUM = LIM.ACCT_NUM);  
    ELSE
    SELECT GET_TL_penal_rate_EMI(PROID,CATG,FDATE,TDATE,LAMT) INTO PENALRATE FROM DUAL;
    END IF;    
    SELECT GET_TL_overdue_rate_EMI(PROID,CATG,FDATE,TDATE,LAMT) into OVERDUEINT FROM DUAL;    
FOR I IN C1 LOOP 
        TOTALAMOUNT := TOTALAMOUNT + I.TOTAL_AMT ;
        EMIAMOUNT := I.TOTAL_AMT;         
        Select to_date(EXPIRY_DT) - to_date(I.INSTALLMENT_DT) INTO COUNTFORINST From dual;    
        IF COUNTFORINST = 0   THEN      
          COUNTFORINST := 1;
        END IF;         
        FULLPENAL := FULLPENAL + ((COUNTFORINST * EMIAMOUNT * PENALRATE)/36500);               
END LOOP; 
OVERDUEINTAMT := OVERDUEINTAMT + ((FULLPENAL + TOTALAMOUNT)*TOTALDUEDAYS*OVERDUEINT)/36500;
END IF;
RETURN OVERDUEINTAMT;
END;
/

SET DEFINE OFF;
Insert into SCREEN_MASTER
(SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS,
MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE,
RECORD_KEY_COL, SCREEN_DESC)
Values
('SCR09996', '3101', 'KCC Renewal', 'APP01', 'DONE',
'5', NULL, 42, 'CREATED', NULL,
NULL, 'KCC Renewal');
COMMIT;

call INSERT_REPORT_GROUP('SCR09996')

-- End Version [Script Version - 0.0.280] [ReleaseVersion - 9.2.2.10]--[08-08-2018] -- By Nithya

-- Start Version [Script Version - 0.0.281] [ReleaseVersion - 9.2.2.10]--[09-08-2018] -- By Sathiya
ALTER TABLE DEPOSIT_INTEREST ADD SL_NO NUMERIC(6);

ALTER TABLE DEPOSIT_SUB_ACINFO ADD RENEWED_DT DATE;

CREATE OR REPLACE FUNCTION GET_TD_RENEWCOUNT(ACTNUMBER VARCHAR) RETURN NUMBER IS
RENEWCOUNT NUMBER:=0;
BEGIN
BEGIN
SELECT SUM(CNT) INTO RENEWCOUNT FROM( 
select count(*) AS CNT from DEPOSIT_SUB_ACINFO_SAMENO dss where DSS.DEPOSIT_NO = ACTNUMBER
and DSS.AUTHORIZE_STATUS = 'AUTHORIZED' AND DSS.STATUS NOT IN ('DELETED')
UNION ALL
select count(*)  AS CNT from DEPOSIT_SUB_ACINFO DSA where DSA.DEPOSIT_NO = ACTNUMBER
and DSA.AUTHORIZE_STATUS = 'AUTHORIZED' AND DSA.STATUS NOT IN ('DELETED'));
EXCEPTION WHEN OTHERS THEN
DBMS_OUTPUT.PUT_LINE('NO DATA FOUND FOR ACTNUMBER'||ACTNUMBER);
END;
RETURN RENEWCOUNT;
END;
-- End Version [Script Version - 0.0.281] [ReleaseVersion - 9.2.2.10]--[09-08-2018] -- By Sathiya

-- Start Version [Script Version - 0.0.282] [ReleaseVersion - 9.2.2.10]--[18-09-2018] -- By Kannan AR
CREATE OR REPLACE Function Get_OD_ExpDate(MemberNo Varchar,opDate Date) return Date is
--DECLARE 
--MEMBERNO VARCHAR2(10) :='A0761';
--OPDATE DATE := '01-AUG-2018';
RetireDt Date;
ExpiryDate Date;
EXPMONTH VARCHAR2(10);
OPDAY VARCHAR2(10);
OPYEAR VARCHAR2(10);
ARRIVEDDATE VARCHAR2(10);
ARRDATE DATE;
Begin
SELECT EXP_MONTH INTO EXPMONTH FROM LOAN_APPLICATION_PARAM_ECS EL WHERE EL.PROD_ID = '101';
SELECT TO_CHAR(OPDATE,'DD') INTO OPDAY FROM DUAL;
SELECT TO_CHAR(OPDATE,'YYYY') INTO OPYEAR FROM DUAL;
SELECT '31'||'/'||EXPMONTH||'/'||OPYEAR INTO  ARRIVEDDATE FROM DUAL;
ARRDATE := TO_DATE(ARRIVEDDATE,'DD/MM/YYYY');
IF OPDATE > ARRDATE THEN 
SELECT ADD_MONTHS(ARRDATE,12) INTO ExpiryDate FROM DUAL;
ELSE
ExpiryDate := ARRDATE;
END IF;
/* This Change made as pr the request by Santhosh Sir RBI ECS Secretary on 06/07/2018 */
if to_char(ExpiryDate,'mm/yyyy')= to_char(OPDATE,'mm/yyyy') then
SELECT ADD_MONTHS(ARRDATE,12) INTO ExpiryDate FROM DUAL;
END IF;
begin
/* This part has been modified as per the instruction from bank as on 21/07/2017 the Due date should be after Retirement Date + 1 Month */
Select LAST_DAY(addmonths(C.RETIREMENT_DT,C.RETIREMENT_DT,1)) into RetireDt from Customer c where C.MEMBERSHIP_NO = MemberNo;
Exception when others then
dbms_output.put_line('No Data');
End;
if ExpiryDate > RetireDt then
ExpiryDate := RetireDt;
End if;
Return ExpiryDate;
--dbms_output.put_line('ExpiryDate'||ExpiryDate);
End;
-- End Version [Script Version - 0.0.282] [ReleaseVersion - 9.2.2.10]--[18-09-2018] -- By Kannan AR

-- Start Version [Script Version - 0.0.283] [ReleaseVersion - 9.2.2.10]--[19-09-2018] -- By Nithya

ALTER TABLE MDS_MONEY_PAYMENT_DETAILS ADD DEFAULTER_BONUS NUMBER(14,2)

ALTER TABLE LOANS_PROD_INTREC add PREMATURE_CLOSE_CALC_REQUIRED VARCHAR2(1) DEFAULT 'N'

CREATE OR REPLACE FUNCTION GET_LOAN_PRECLOSURE_INTEREST(ACTNUM VARCHAR,BRANCHCODE VARCHAR) RETURN NUMBER IS 
EMIAMOUNT NUMBER(16,2);
PROID VARCHAR2(3);
CATG VARCHAR2(50);
FDATE DATE;
TDATE DATE;
LAMT NUMBER(12,2);
TOTAL_EMI_PAID_INTEREST NUMBER(16,2);
INTFROM VARCHAR2(20);
INSTAMT NUMBER(12,2);
PENALRATE NUMBER(12,2);
PRODUCT NUMBER;
TOTALDUEDAYS NUMBER;
CURRDT DATE; 
INTERESTAMOUNT NUMBER(16,2) :=0;
BEGIN
SELECT LFD.PROD_ID,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT,LFD.INT_GET_FROM 
INTO PROID,CATG,FDATE,TDATE,LAMT,INTFROM  FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
WHERE LFD.BORROW_NO = LB.BORROW_NO
AND LB.BORROW_NO = LSD.BORROW_NO
AND LFD.ACCT_NUM = ACTNUM;
SELECT SUM (INTEREST) INTO TOTAL_EMI_PAID_INTEREST  FROM LOAN_TRANS_DETAILS  WHERE ACT_NUM = ACTNUM
AND AUTHORIZE_STATUS = 'AUTHORIZED'
AND TRANS_TYPE = 'CREDIT'; 
SELECT D.CURR_APPL_DT INTO CURRDT FROM DAY_END D WHERE D.BRANCH_CODE = BRANCHCODE;
Select to_date(CURRDT) - to_date(FDATE) INTO TOTALDUEDAYS From dual;
IF INTFROM = 'ACT' THEN
 SELECT LIM.PENAL_INTEREST INTO PENALRATE FROM LOANS_INT_MAINTENANCE LIM WHERE
  LIM.ACCT_NUM = ACTNUM AND LIM.SLNO =( SELECT MAX(LS.SLNO) FROM LOANS_INT_MAINTENANCE LS WHERE LS.ACCT_NUM = LIM.ACCT_NUM);  
 ELSE
  SELECT GET_TL_penal_rate_EMI(PROID,CATG,FDATE,TDATE,LAMT) INTO PENALRATE FROM DUAL;
END IF;  
INTERESTAMOUNT := ((LAMT*PENALRATE*TOTALDUEDAYS)/36500) - TOTAL_EMI_PAID_INTEREST;  
IF INTERESTAMOUNT <= 0 THEN
  INTERESTAMOUNT := 0;
END IF;     
RETURN INTERESTAMOUNT;
END;
/

CREATE OR REPLACE FUNCTION GET_LOAN_PRECLOSURE_PENAL(ACTNUM VARCHAR,BRANCHCODE VARCHAR) RETURN NUMBER IS 
/*This function has been written for requirement fromMVNL. They need penal as zero if premature closure
 Made as a function which return zero, so that if any other bank requires the penal greater than zero for preclosure, its only need to
 alter the function, no need of code changes.
*/
PENALAMOUNT NUMBER(16,2) :=0;
BEGIN  
PENALAMOUNT := 0; 
RETURN PENALAMOUNT;
END;
/

ALTER TABLE GAHAN_PROPERTY_DETAILS ADD OWNER_NO2 VARCHAR2(20);

CREATE OR REPLACE FUNCTION get_kcc_penal_int(ACTNUM VARCHAR,LOANDATE DATE,ASONDT DATE)
RETURN NUMBER IS
--DECLARE
--ACTNUM VARCHAR2(16) := '0001276000160';
--ASONDT DATE := '01-MAR-2014' ;
    PENINTRECEIVABLE NUMBER(16,2) := 0;
    PENALRECEIVED NUMBER(16,2) := 0;
    PENAL NUMBER(16,2) := 0;
    PENINTRECEIVED NUMBER(16,2) := 0;
    BALANCE NUMBER(16,2) := 0;
    PENROI NUMBER(8,2) := 0;
    DUEDATE DATE;
    LASTINTDATE DATE;
    PENRECFRM DATE;
    STARTDATE DATE;
    TRNDATE DATE;
    PRNBAL NUMBER(16,2) := 0;
    CATG VARCHAR2(25);
    PRIN_CREDIT NUMBER(16,2):= 0;
    DATE_DIFF number(16);
BEGIN
    BALANCE := GET_ADV_BALANCE(ACTNUM,ASONDT);
    IF BALANCE <= 0 THEN
         PENINTRECEIVABLE := 0;
    END IF; 
    SELECT 
          CASE WHEN
                    (
                        SELECT P.CALENDAR_FREQ
                        FROM LOANS_FACILITY_DETAILS F
                        JOIN LOANS_PROD_INTREC P ON P.PROD_ID = F.PROD_ID
                        WHERE F.ACCT_NUM = ACTNUM
                    ) = 'Y' 
                THEN
                    (     
                        SELECT P.LAST_DR_INT_APPLDT 
                        FROM ADVANCES_PARAM_DETAILS P
                        WHERE P.ACT_NUM = ACTNUM AND P.STATUS != 'DELETED'
                    )
                ELSE
                    F.LAST_INT_CALC_DT
          END,
          SD.TO_DT,GET_TL_PENROI(F.PROD_ID,F.ACCT_NUM,SD.FROM_DT,SD.LIMIT,F.INT_GET_FROM),
          CASE WHEN
                    (
                        SELECT P.CALENDAR_FREQ
                        FROM LOANS_FACILITY_DETAILS F
                        JOIN LOANS_PROD_INTREC P ON P.PROD_ID = F.PROD_ID
                        WHERE F.ACCT_NUM = ACTNUM
                    ) = 'Y' 
                THEN
                    (     
                        SELECT P.LAST_DR_INT_APPLDT 
                        FROM ADVANCES_PARAM_DETAILS P
                        WHERE P.ACT_NUM = ACTNUM AND P.STATUS != 'DELETED'
                    )
                ELSE
                    F.LAST_INT_CALC_DT + 1
          END INTO LASTINTDATE,DUEDATE,PENROI,PENRECFRM
    FROM LOANS_SANCTION_DETAILS SD
    JOIN LOANS_FACILITY_DETAILS F ON SD.BORROW_NO = F.BORROW_NO
    WHERE F.ACCT_NUM = ACTNUM;
    DECLARE 
      CURSOR LOANTRANS IS 
        SELECT T.TRANS_DT,T.PRINCIPLE,T.TRN_CODE,(CASE WHEN LSD.TO_DT < ADD_MONTHS(T.TRANS_DT,12) THEN LSD.TO_DT ELSE ADD_MONTHS(T.TRANS_DT,12) END) AS DUEDATE
        FROM ADV_TRANS_DETAILS T
        JOIN LOANS_FACILITY_DETAILS LFD ON LFD.ACCT_NUM = T.ACT_NUM
        JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
        WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.PRINCIPLE > 0 AND T.TRN_CODE = 'DP'
--        UNION
--        SELECT TO_DATE(ASONDT,'DD-MM-YYYY') AS TRANS_DT,0 AS PRINCIPLE,'DP' AS TRN_CODE,NULL AS DUEDATE
--        FROM DUAL
        ORDER BY TRANS_DT ASC;
        TRANSDT ADV_TRANS_DETAILS.TRANS_DT%TYPE;
        I NUMBER(16,2) := 0;
        PRN_CREDIT NUMBER(16,2);
    BEGIN
        FOR TRN IN LOANTRANS LOOP
            SELECT NVL(SUM(NVL(T.PRINCIPLE,0)),0) INTO PRN_CREDIT FROM ADV_TRANS_DETAILS T 
            WHERE  T.ACT_NUM = ACTNUM AND T.TRN_CODE = 'C*' AND T.TRANS_DT <= TRN.DUEDATE;
            BALANCE := TRN.PRINCIPLE - PRN_CREDIT;
            IF BALANCE  > 0 THEN
                PENINTRECEIVABLE  := PENINTRECEIVABLE  +  (BALANCE * (ASONDT - (TRN.DUEDATE + 1)  ) * PENROI/ 36500);
--                DBMS_OUTPUT.PUT_LINE(PENINTRECEIVABLE||' ' ||BALANCE|| ' '||TRN.DUEDATE||' '||ASONDT||' ' ||DATE_DIFF );
            ELSE
                PENINTRECEIVABLE := 0;
            END IF;
        END LOOP;
    END;
    SELECT NVL(SUM(T.PENAL),0) INTO PENINTRECEIVED
    FROM ADV_TRANS_DETAILS T
    WHERE T.ACT_NUM = ACTNUM AND
          T.TRANS_DT > PENRECFRM AND T.TRANS_DT <= ASONDT AND
          T.TRANS_TYPE = 'CREDIT';
    PENINTRECEIVABLE := PENINTRECEIVABLE - PENINTRECEIVED;
    PENINTRECEIVABLE := ROUND(PENINTRECEIVABLE,0); 
    IF PENINTRECEIVABLE < 0 THEN
        PENINTRECEIVABLE := 0;
    END IF;
    SELECT SUM(ADV.PENAL) INTO PENALRECEIVED FROM ADV_TRANS_DETAILS ADV WHERE
    ADV.ACT_NUM = ACTNUM;
    PENAL := PENINTRECEIVABLE - PENALRECEIVED;
    IF PENAL < 0 THEN
        PENAL := 0;
    END IF;
   RETURN PENAL;
END;
/

alter table SERVICE_TAX_DETAILS add KRISHI_KALYAN_CESS number(16,2);

alter table SERVICE_TAX_DETAILS add SWACHH_CESS number(16,2);

ALTER TABLE DEPOSIT_NOMINEE_DETAIL ADD NOMINEE_CURRENT_STATUS VARCHAR2(20);

-- End Version [Script Version - 0.0.283] [ReleaseVersion - 9.2.2.10]--[19-09-2018] -- By Nithya

-- Start Version [Script Version - 0.0.284] [ReleaseVersion - 9.2.2.10]--[01-10-2018] -- By Nithya

ALTER TABLE DEPO_MASTER ADD CGST_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD SGST_AC_HD_ID VARCHAR2(16);

ALTER TABLE INDEND_REGISTER ADD SGST_AMT NUMBER(16,2);

ALTER TABLE INDEND_REGISTER ADD CGST_AMT NUMBER(16,2);

CREATE OR REPLACE FUNCTION GET_RD_INTEREST(ACTNUM VARCHAR,ASONDATE DATE)
RETURN NUMBER IS
    DEPOSITDT  DATE;
    INSTALLMENT_AMOUNT NUMBER(16,2) := 0;
    TOTAL_INT_DRAWN NUMBER(16,2) := 0;
    ROI NUMBER(16,2) := 0;
    SUB_NO VARCHAR2(2);
    DUE_DATE DATE;
    BALANCE NUMBER(16,2) := 0;
    NO_OF_INST_PAID NUMBER(16,2) := 0;
    NO_OF_INST_PAID_COMPOUND INTEGER;
    LAST_PAID_DATE DATE;
    CALC_DATE DATE;
    INTEREST NUMBER(16,2) := 0;
    CLS_DATE DATE;
BEGIN
    SELECT S.DEPOSIT_DT,S.DEPOSIT_SUB_NO,S.MATURITY_DT,S.DEPOSIT_AMT,NVL(S.RATE_OF_INT,0),S.CLOSE_DT,S.TOTAL_INT_DRAWN
    INTO DEPOSITDT,SUB_NO,DUE_DATE,INSTALLMENT_AMOUNT,ROI,CLS_DATE,TOTAL_INT_DRAWN
    FROM DEPOSIT_SUB_ACINFO S
    WHERE S.DEPOSIT_NO = ACTNUM;
    IF ASONDATE > DUE_DATE THEN
        CALC_DATE := DUE_DATE;
    ELSE
        CALC_DATE := ASONDATE;
    END IF;    
    IF CLS_DATE <= ASONDATE THEN
        RETURN INTEREST;
    END IF;
    IF ROI = 0 THEN
        RETURN INTEREST;
    END IF;
    SELECT SUM(DR.AMOUNT) INTO BALANCE
    FROM DEPOSIT_RECURRING DR
    WHERE DR.DEPOSIT_NO_SUB = ACTNUM || '_' || SUB_NO AND
         (DR.TRANS_DT IS NOT NULL AND DR.TRANS_DT <= ASONDATE);
    IF BALANCE <= 0 THEN
        RETURN INTEREST;
    END IF;
    SELECT MAX(DR.TRANS_DT) INTO LAST_PAID_DATE
    FROM DEPOSIT_RECURRING DR
    WHERE DR.DEPOSIT_NO_SUB = ACTNUM || '_' || SUB_NO AND
         (DR.TRANS_DT IS NOT NULL AND DR.TRANS_DT <= ASONDATE);         
    NO_OF_INST_PAID := BALANCE/INSTALLMENT_AMOUNT;
    NO_OF_INST_PAID_COMPOUND := FLOOR(NO_OF_INST_PAID/3);
    IF NO_OF_INST_PAID < 3 THEN
        INTEREST := (BALANCE * (CALC_DATE-LAST_PAID_DATE) * ROI)/36500;
        RETURN INTEREST;
    END IF;
    IF NO_OF_INST_PAID >= 3 THEN
        INTEREST := (ROUND((INSTALLMENT_AMOUNT * (POWER((1+(ROI/400)),NO_OF_INST_PAID_COMPOUND) - 1)) / 
                           (1- POWER((1+(ROI/400)),(-1/3))))) - BALANCE;                    
    END IF;
    IF ((NO_OF_INST_PAID-NO_OF_INST_PAID_COMPOUND) > 0) THEN
        INTEREST := INTEREST + ((BALANCE *  (CALC_DATE-LAST_PAID_DATE) * ROI)/36500);
    END IF;
    INTEREST := INTEREST - TOTAL_INT_DRAWN;
    IF INTEREST < 0 THEN
        INTEREST := 0;
    END IF;
    INTEREST := ROUND(INTEREST);
    RETURN INTEREST;
--    DBMS_OUTPUT.PUT_LINE(TO_CHAR(BALANCE));
--    DBMS_OUTPUT.PUT_LINE(TO_CHAR(NO_OF_INST_PAID));
--    DBMS_OUTPUT.PUT_LINE('NO_OF_INST_PAID_COMPOUND '|| TO_CHAR(NO_OF_INST_PAID_COMPOUND));
--    DBMS_OUTPUT.PUT_LINE('LAST_PAID_DATE ' ||TO_CHAR(LAST_PAID_DATE));
--    DBMS_OUTPUT.PUT_LINE(TO_CHAR(INTEREST));
END;
/

-- End Version [Script Version - 0.0.284] [ReleaseVersion - 9.2.2.10]--[01-10-2018] -- By Nithya

-- Start Version [Script Version - 0.0.285] [ReleaseVersion - 9.2.2.11]--[27-12-2018] -- By Nithya

CREATE OR REPLACE FORCE VIEW all_transactions_view (trans_id,
                                                        batch_id,
                                                        ac_hd_id,
                                                        act_num,
                                                        amount,
                                                        trans_dt,
                                                        trans_type,
                                                        inst_type,
                                                        inst_dt,
                                                        particulars,
                                                        status,
                                                        instrument_no1,
                                                        instrument_no2,
                                                        prod_id,
                                                        prod_type,
                                                        authorize_status,
                                                        authorize_by,
                                                        status_by,
                                                        status_dt,
                                                        trans_mode,
                                                        branch_id,
                                                        initiated_branch,
                                                        authorize_status_2,
                                                        single_trans_id,
                                                        link_batch_id,
                                                        trans_mod_type,
                                                        narration
                                                       )
AS
   SELECT trans_id, batch_id, ac_hd_id, NVL (act_num, link_batch_id), amount,
          trans_dt, trans_type, inst_type, inst_dt, particulars, status,
          instrument_no1, instrument_no2, prod_id, prod_type,
          authorize_status, authorize_by, status_by, status_dt, trans_mode,
          branch_id, initiated_branch, authorize_status_2, single_trans_id,
          link_batch_id, trans_mod_type, narration
     FROM (SELECT   trans_id, batch_id, ac_hd_id, act_num, amount, trans_dt,
                    trans_type, inst_type, inst_dt, particulars, status,
                    instrument_no1, instrument_no2, prod_id, prod_type,
                    authorize_status, authorize_by, status_by, status_dt,
                    trans_mode, branch_id, initiated_branch,
                    authorize_status_2, single_trans_id, link_batch_id,
                    trans_mod_type, narration
               FROM all_trans
/* Script added for updating dayend balance of Daily Deposit accounts */
           UNION ALL
           SELECT   TO_CHAR (trans_id), batch_id,
                    (SELECT acct_head
                       FROM deposits_product
                      WHERE prod_id = SUBSTR (acc_num, 5, 3)) AS ac_hd_id,
                    acc_num AS act_num, amount, trn_dt AS trans_dt,
                    trans_type, '' AS inst_type, NULL AS inst_dt, particulars,
                    status, '' AS instrument_no1, '' AS instrument_no2,
                    SUBSTR (acc_num, 5, 3) AS prod_id, prod_type,
                    authorize_status, authorize_by, '' AS status_by,
                    trn_dt AS status_dt, trans_mode,
                    SUBSTR (acc_num, 1, 4) AS branch_id, initiated_branch,
                    '' AS authorize_status_2, '' AS single_trans_id,
                    '' AS link_batch_id, '' AS trans_mod_type,
                    '' AS narration
               FROM daily_deposit_trans
           ORDER BY status_dt);

-- End Version [Script Version - 0.0.285] [ReleaseVersion - 9.2.2.11]--[27-12-2018] -- By Nithya

-- Start Version [Script Version - 0.0.286] [ReleaseVersion - 9.2.2.11]--[16-01-2019] -- By Kannan AR

UPDATE CBMS_PARAMETERS  SET CBMS_VALUE='9.2.2.11'  WHERE CBMS_KEY='RELEASE_VERSION'

ALTER TABLE DEPOSIT_SUB_ACINFO ADD (TEMP_RENEWED_DT  DATE);

select ac_hd_id, count(*) from ac_hd_param group by ac_hd_id having count(*)>1 

-- if duplication exists should not allow to add primary key

alter table ac_hd_param add primary key ac_hd_id
 
ALTER TABLE AC_HD_PARAM
 ADD CONSTRAINT AC_HD_PARAM_PK
 ENABLE
 VALIDATE;


ALTER TABLE AC_HD_PARAM
 MODIFY CONSTRAINT AC_HD_PARAM_PK
 ENABLE
 VALIDATE;
 
SELECT * FROM GL A WHERE NOT EXISTS (SELECT * FROM AC_HD_PARAM WHERE A.AC_HD_ID=AC_HD_ID)

DELETE GL A WHERE NOT EXISTS (SELECT * FROM AC_HD_PARAM WHERE A.AC_HD_ID=AC_HD_ID)
    
ALTER TABLE GL ADD 
  CONSTRAINT GL_FK
  FOREIGN KEY
  (AC_HD_ID)
  REFERENCES
  AC_HD_PARAM (AC_HD_ID)
  ENABLE VALIDATE;

-- End Version [Script Version - 0.0.286] [ReleaseVersion - 9.2.2.11]--[16-01-2019] -- By Kannan AR

-- Start Version [Script Version - 0.0.287] [ReleaseVersion - 9.2.2.11]--[20-02-2019] -- By Rishad M.P

CREATE TABLE LOAN_FUTURE_TRANSACTION
(
  ACT_NUM             VARCHAR2(16 BYTE),
  INT_PAYABLE         NUMBER(16,2),
  PENAL               NUMBER(16,2),
  TOTAL_WAIVE_AMOUNT  NUMBER(16,2),
  INT_CALC_UPTO_DT    DATE,
  AUTHORIZE_STATUS    VARCHAR2(32 BYTE),
  AUTHORIZE_DT        DATE,
  STATUS              VARCHAR2(16 BYTE),
  STATUS_BY           VARCHAR2(32 BYTE),
  STATUS_DT           DATE,
  REBATE_AMT          NUMBER(16,2),
  TRANSACTION_ID      VARCHAR2(25 BYTE)
)

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCR09998', '9998', 'Loan Transaction', 'APP01', 'DONE', 
    '5', 44, 'CREATED', 'Loan Transaction');
COMMIT;

 call INSERT_REPORT_GROUP('SCR09998');

-- End Version [Script Version - 0.0.287] [ReleaseVersion - 9.2.2.11]--[20-02-2019] -- By Rishad M.P

-- Start Version [Script Version - 0.0.288] [ReleaseVersion - 9.2.2.11]--[03-06-2019] -- By Rishad M.P
--- this entire block of script no need to run  in RBI

--PLEASE ADD FIELD "REC_MODE" (PARENT FIELD IN TRANSFER_TRANS) IN ALL_TRANS VIEW 

insert into ID_GENERATION (ID_KEY,CURR_VALUE,PREFIX,LAST_UPDATED,ID_LENGTH,BRANCH_CODE) vALUES
('RECOVERY_ID',0,'SAL',sysdate,8,'0001')

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCR01150', '1150', 'Loan Recovery', 'APP01', 'DONE', 
    '5', 'com.see.truetransact.ui.termloan.recovery.LoanRecoveryUI', 43, 'CREATED', 'Loan Recovery');
COMMIT;

  call INSERT_REPORT_GROUP('SCR01150');

alter table SALARY_RECOVERY_LIST_DETAIL ADD (RECOVERY_ID VARCHAR2(20));

alter table SALARY_RECOVERY_LIST_MASTER ADD (RECOVERY_ID VARCHAR2(20));

alter table SALARY_RECOVERY_LIST_MASTER MODIFY (STATUS VARCHAR2(12));

ALTER TABLE SALARY_RECOVERY_LIST_DETAIL ADD PROCESS_STATUS VARCHAR2(15);

ALTER TABLE SALARY_RECOVERY_LIST_DETAIL ADD RECOVERED_AMOUNT NUMBER(16,2);

ALTER TABLE SALARY_RECOVERY_LIST_MASTER ADD  INSTITUTION_ID VARCHAR2(40);

CREATE OR REPLACE FORCE VIEW ALL_CUSTOMER
(
   ACT_NUM,
   CUST_ID,
   FNAME,
   MNAME,
   LNAME,
   COMM_ADDR_TYPE,
   ACT_OPEN_DT,
   MEMBERSHIP_NO,
   ACCT_STATUS,
   DIVISION
)
AS
   (SELECT am.act_num AS act_num,
           am.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name)
              AS fname,
           c.mname,
           c.lname,
           c.comm_addr_type,
           create_dt AS act_open_dt,
           membership_no,
           am.act_status_id AS acct_status,C.DIVISION AS DIVISION
      FROM act_master am, customer c
     WHERE     am.cust_id = c.cust_id
           AND am.authorization_status = 'AUTHORIZED'
           AND am.status != 'DELETED'
    UNION ALL
    SELECT da.deposit_no || '_' || dsa.deposit_sub_no AS act_num,
           da.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name)
              AS fname,
           c.mname,
           c.lname,
           c.comm_addr_type,
           created_dt AS act_open_dt,
           membership_no,
           dsa.acct_status,C.DIVISION AS DIVISION
      FROM deposit_acinfo da, deposit_sub_acinfo dsa, customer c
     WHERE     da.cust_id = c.cust_id
           AND da.authorize_status = 'AUTHORIZED'
           AND da.status != 'DELETED'
           AND da.deposit_no = dsa.deposit_no
    UNION ALL
    SELECT lfd.acct_num AS act_num,
           lb.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name)
              AS fname,
           c.mname,
           c.lname,
           c.comm_addr_type,
           acct_open_dt AS act_open_dt,
           membership_no,
           lfd.acct_status,C.DIVISION AS DIVISION
      FROM loans_borrower lb, loans_facility_details lfd, customer c
     WHERE     lb.borrow_no = lfd.borrow_no
           AND lb.cust_id = c.cust_id
           AND lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.status != 'DELETED'
    UNION ALL
    SELECT am.suspense_acct_num AS act_num,
           am.suspense_customer_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name)
              AS fname,
           c.mname,
           c.lname,
           c.comm_addr_type,
           suspense_open__date AS act_open_dt,
           membership_no,
           'NEW' AS acct_status,C.DIVISION AS DIVISION
      FROM suspense_account_master am, customer c
     WHERE     am.suspense_customer_id = c.cust_id
           AND am.authorize_status = 'AUTHORIZED'
           AND am.status != 'DELETED'
    UNION ALL
    SELECT am.chittal_no AS act_num,
           c.cust_id,
           DECODE (c.cust_type,
                   'INDIVIDUAL', fname || ' ' || mname || ' ' || lname,
                   comp_name)
              AS fname,
           c.mname,
           c.lname,
           c.comm_addr_type,
           am.appln_dt AS act_open_dt,
           c.membership_no,
           msd.status AS acct_status,C.DIVISION AS DIVISION
      FROM mds_application am, customer c, mds_scheme_details msd
     WHERE     am.member_no = c.membership_no
           AND am.scheme_name = msd.scheme_name
           AND am.authorize_status = 'AUTHORIZED'
           AND am.status != 'DELETED');

CREATE TABLE INSTITUTION_MASTER
(
  INST_ID                VARCHAR2(25 BYTE),
  INST_NAME              VARCHAR2(60 BYTE),
  INST_BRANCH_NAME       VARCHAR2(100 BYTE),
  ADRESS                 VARCHAR2(128 BYTE),
  ADDRESS1                  VARCHAR2(128 BYTE),
  ADDRESS2                    VARCHAR2(128 BYTE),
  PINCODE               VARCHAR(8 BYTE),
  STATUS_BY              VARCHAR2(15 BYTE),
  STATUS_DT              DATE,
  CREATED_BY             VARCHAR2(15 BYTE),
  CREATE_DT               DATE,
  STATUS                 VARCHAR2(8 BYTE)
  )

CREATE SEQUENCE INST_seq
  START WITH 1
  INCREMENT BY 1;

CREATE OR REPLACE TRIGGER INST_TR 
BEFORE INSERT ON INSTITUTION_MASTER 
FOR EACH ROW

BEGIN
  SELECT 'INST000'||INST_seq.NEXTVAL 
  INTO   :new.INST_ID
  FROM   dual;
END;

CREATE OR REPLACE TYPE "TYPE_RECOVERYDUELIST"     AS 
            OBJECT (emp_refno VARCHAR2 (32 Byte),
                    MEM_NAME  VARCHAR2 (128 Byte),
                    PROD_DESC VARCHAR2 (128 Byte),
                    ACT_NUM VARCHAR2 (16 Byte),
                    PROD_TYPE VARCHAR2 (8 Byte),
                    PROD_ID VARCHAR2 (8 Byte),
                    AMOUNT NUMBER (16,2),
                    SALARY_RECOVERY VARCHAR2(1),
                    CUSTOMERGROUP VARCHAR2(1),
                    DE_STATUS VARCHAR2(20),
                    DUE_STATUS VARCHAR2(20),
                    MEMBER_NO VARCHAR2(20),
                    INST_NAME VARCHAR2(70),
                    INST_BRANCH_NAME VARCHAR2(70)
                    )
/


CREATE OR REPLACE TYPE "TAB_TYPE_RECOVERYDUELIST"   AS TABLE OF TYPE_RecoveryDueList
/

CREATE OR REPLACE FORCE VIEW ALL_PRODUCT_ACCTS_RECOVERY1
(
   ACT_NUM,
   CUST_ID,
   PROD_TYPE,
   PROD_ID,
   REP_ACT_NUM,
   BRANCH_ID,
   SALARY_RECOVERY,
   LOCK_STATUS,
   ACCT_STATUS,
   AUTHORIZATION_STATUS,
   CLOSED_DT,
   CREATE_DT
)
AS
   (SELECT lfd.acct_num AS act_num,
           lb.cust_id,
           'TL' AS prod_type,
           lfd.prod_id,
           lfd.acct_num || '_1' AS rep_act_num,
           branch_id,
           NVL (lfd.salary_recovery, 'N') AS salary_recovery,
           NVL (lock_status, 'N') AS lock_status,
           lfd.acct_status,
           lfd.authorize_status_1,
           acct_close_dt AS closed_dt,
           acct_open_dt AS create_dt
      FROM loans_facility_details lfd,
           loans_borrower lb,
           LOANS_PROD_ACPARAM lpa
     WHERE     lfd.authorize_status_1 = 'AUTHORIZED'
           AND lfd.borrow_no = lb.borrow_no
           AND LPA.PROD_ID = LFD.PROD_ID
           AND NVL (LPA.SALARY_RECOVERY, 'N') = 'Y'
           AND LFD.ACCT_STATUS NOT IN ('CLOSED')
           AND NVL (LFD.SALARY_RECOVERY, 'N') = 'Y'
           AND lfd.status != 'DELETED'
           AND NOT EXISTS
                      (SELECT prod_id
                         FROM loans_product
                        WHERE     behaves_like IN ('OD', 'CC')
                              AND prod_id = lfd.prod_id));

CREATE OR REPLACE FORCE VIEW ALL_PRODUCT_ACCTS_RECOVERY
(
   ACT_NUM,
   PROD_TYPE,
   PROD_ID,
   REP_ACT_NUM,
   BRANCH_ID,
   SALARY_RECOVERY,
   LOCK_STATUS,
   ACCT_STATUS
)
AS
   (SELECT act_num,
           prod_type,
           prod_id,
           rep_act_num,
           branch_id,
           salary_recovery,
           lock_status,
           acct_status
      FROM all_product_accts_recovery1
    UNION ALL
    SELECT act_num,
           prod_type,
           prod_id,
           old_act_num AS rep_act_num,
           branch_id,
           salary_recovery,
           lock_status,
           acct_status
      FROM old_ac_nos tt, all_product_accts_recovery1 apa
     WHERE new_act_num = act_num);

CREATE OR REPLACE FUNCTION Load_getDueForRecoveryList(IntCalcDate Date,INSTITUTION_NAME VARCHAR2) RETURN TAB_TYPE_RecoveryDueList AS RecoveryDueList TAB_TYPE_RecoveryDueList;
BEGIN
SELECT TYPE_RecoveryDueList(emp_refno,MEM_NAME,PROD_DESC,ACT_NUM,PROD_TYPE,PROD_ID,AMOUNT,SALARY_RECOVERY,CUSTOMERGROUP,DE_STATUS,DUE_STATUS,MEMBER_NO,INST_NAME,
INST_BRANCH_NAME)
BULK COLLECT INTO RecoveryDueList FROM(
SELECT   *
    FROM (
            SELECT DISTINCT C.CUST_ID AS emp_refno,
                             c.fname
                          || ' '
                          || c.mname
                          || ' '
                          || c.lname AS "MEM_NAME",
                          ap.prod_desc, c.act_num, apa.prod_type, apa.prod_id,
                          NULL AS amount, apa.salary_recovery,
                          DECODE (cu.customergroup,
                                  'Canteen', '0',
                                  '1'
                                 ) AS customergroup,
                          '' AS de_status, 'NOT_DUE' AS due_status,C.MEMBERSHIP_NO AS MEMBER_NO,I.INST_NAME,I.INST_BRANCH_NAME
                     FROM 
                          all_products ap,
                          all_product_accts_recovery apa,
                          all_customer c,
                          customer cu,INSTITUTION_MASTER I
                    WHERE  (   c.act_num = apa.act_num
                           OR c.act_num = apa.rep_act_num
                          )
                      AND apa.prod_id = ap.prod_id
                      AND apa.acct_status Not in ('CLOSED')
                      AND c.DIVISION=I.INST_BRANCH_NAME
                      AND c.DIVISION is not null
                       AND TRIM(I.INST_NAME)=TRIM(INSTITUTION_NAME)
                      AND cu.customer_status = 'PRESENT'
                     -- AND cu.cust_type_id IN ('MEMBER') 
                                           
             ) a
ORDER BY emp_refno);

Return RecoveryDueList;
End;
/


CREATE OR REPLACE FUNCTION GET_TL_ROI_RE(PRODID VARCHAR,CATG VARCHAR,LOANDATE DATE,LOANDUEDT DATE, LOANAMOUNT NUMBER)
RETURN NUMBER IS
    RATEOFINT NUMBER(16,2) := 0;
BEGIN

    SELECT drgtr.roi INTO RATEOFINT
  FROM deposit_roi_group drg,
       deposit_roi_group_cat drgc,
       deposit_roi_group_prod drgp,
       deposit_roi_group_type_rate drgtr
 WHERE drg.roi_group_id = drgc.roi_group_id
   AND drg.roi_group_id = drgp.roi_group_id
   AND drg.roi_group_id = drgtr.roi_group_id
   AND drg.product_type IN ('TL', 'AD')
   AND drgp.prod_id = PRODID
   AND DRGC.CATEGORY_ID = CATG
   AND LOANAMOUNT BETWEEN from_amount AND to_amount
   AND (   (LOANDATE >= roi_date AND LOANDATE <= roi_end_date)
        OR (roi_date <= LOANDATE AND roi_end_date IS NULL)
       )
   AND NVL(TRUNC(TO_DATE(LOANDUEDT,'DD-MM-YYYY')- TO_DATE(LOANDATE,'DD-MM-YYYY')),0)
          BETWEEN from_period
              AND to_period ;              
    RETURN RATEOFINT;
END;
/

CREATE OR REPLACE FUNCTION GET_LAST_FINENDDATE(F_DATE DATE) 
RETURN DATE IS
FINENDDATE DATE;
MON VARCHAR2(3);
BEGIN
    MON := TO_CHAR(F_DATE,'MON'); 
    IF (MON = 'JAN' OR MON = 'FEB' OR MON = 'MAR') THEN
        FINENDDATE := CAST('31-MAR-' || (TO_NUMBER(TO_CHAR(F_DATE,'YYYY')) - 1) AS DATE);
    ELSE
        FINENDDATE := CAST('31-MAR-' || (TO_NUMBER(TO_CHAR(F_DATE,'YYYY'))) AS DATE);
    END IF;
    RETURN FINENDDATE;
END;
/


CREATE OR REPLACE FUNCTION GET_TL_INTERESTRECBLE_recovery(ACTNUM VARCHAR,ASONDT DATE,Recoverytype varchar)
RETURN NUMBER IS
    INTRECEIVABLE NUMBER(16,2) := 0;
    INTRECEIVED NUMBER(16,2) := 0;
    ROI NUMBER(16,2) := 0;
    TRNDATE DATE; 
    PRNBAL NUMBER(16,2) := 0;
    LASTINTCALCDATE DATE;
    STARTDATE DATE;
    CATG varchar2(32);
    LOANDATE DATE;
    SDATE DATE;
    CNT NUMBER;
    LAST_RECDATE DATE;
    FLG NUMBER := 0;
    status VARCHAR2(10);
    lastintdate date;
BEGIN
    SELECT LSD.FROM_DT INTO LOANDATE  FROM LOANS_SANCTION_DETAILS LSD,LOANS_FACILITY_DETAILS LFD WHERE LSD.BORROW_NO = LFD.BORROW_NO
    AND LFD.ACCT_NUM = ACTNUM; 
    SELECT F.LAST_INT_CALC_DT INTO LASTINTCALCDATE
    FROM LOANS_FACILITY_DETAILS F 
    WHERE F.ACCT_NUM = ACTNUM;
    BEGIN
    select SR.INT_CALC_UPTO_DT into lastintdate  from SALARY_RECOVERY_LIST_DETAIL sr where SR.INT_CALC_UPTO_DT = LASTINTCALCDATE
    and SR.ACT_NUM = actnum;
    EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('NO INTEREST DATE');
    --lastintdate := LASTINTCALCDATE; 
    END;
      
    --DBMS_OUTPUT.PUT_LINE('lastintdate   ='||lastintdate);
    SELECT NVL(MAX(T.TRANS_DT),LOANDATE) INTO STARTDATE 
                FROM LOAN_TRANS_DETAILS T
                WHERE T.ACT_NUM =ACTNUM AND T.TRANS_DT < ASONDT and T.PRINCIPLE > 0 AND
                T.TRANS_DT in (select max(LTD.TRANS_DT) from 
                loan_trans_details ltd where LTD.ACT_NUM = T.ACT_NUM
                and LTD.TRANS_TYPE = 'CREDIT' AND LTD.PRINCIPLE > 0 AND LTD.TRANS_DT < ASONDT);       --AND UPTO_DT_INT = 'Y';
                dbms_output.put_line('startdate  pras='||STARTDATE);
     If lastintdate is null then            
     SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM LOAN_TRANS_DETAILS LT
     WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > STARTDATE AND LT.TRANS_DT <= ASONDT;
     Else     
     SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM LOAN_TRANS_DETAILS LT
     WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > STARTDATE AND LT.TRANS_DT <= ASONDT;
     End if;
     
     --dbms_output.put_line('STARTDATE   ='||STARTDATE);
    IF LASTINTCALCDATE < ASONDT THEN
         if lastintdate = LASTINTCALCDATE  then
            if Recoverytype = 'Recovery' then 
                STARTDATE := LASTINTCALCDATE;
                DBMS_OUTPUT.PUT_LINE('STARTDATE IST  ='||STARTDATE);
            end if;
         else
          STARTDATE := LASTINTCALCDATE + 1;
         End if;
         --dbms_output.put_line('STARTDATE     ='||STARTDATE);
    ELSE
        SDATE := STARTDATE;
        DBMS_OUTPUT.PUT_LINE('SDATE   ='||SDATE);
    END IF;
    --DBMS_OUTPUT.PUT_LINE('LAST_RECDATE   ='||LAST_RECDATE);
    --DBMS_OUTPUT.PUT_LINE(STARTDATE||'NEAR LOOP' );
    --SELECT NVL(SUM(LT.INTEREST),0) INTO INTRECEIVED FROM LOAN_TRANS_DETAILS LT
    --WHERE LT.ACT_NUM = ACTNUM AND LT.TRANS_DT > STARTDATE AND LT.TRANS_DT <= ASONDT;
    SELECT CASE WHEN LFD.INT_GET_FROM = 'ACT' THEN
                    (SELECT LIM.INTEREST FROM LOANS_INT_MAINTENANCE LIM WHERE LIM.ACCT_NUM = LFD.ACCT_NUM)
                WHEN LFD.INT_GET_FROM = 'PROD' THEN
                   GET_TL_ROI_RE(LFD.PROD_ID,LB.CATEGORY,LSD.FROM_DT,LSD.TO_DT,LSD.LIMIT)
                ELSE 0 END INTO ROI
    FROM LOANS_FACILITY_DETAILS LFD
    JOIN LOANS_SANCTION_DETAILS LSD ON LFD.BORROW_NO = LSD.BORROW_NO
    JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
    WHERE LFD.ACCT_NUM = ACTNUM;
DECLARE CURSOR LOANTRANS IS 
    SELECT T.TRANS_DT,T.PRINCIPLE,T.TRN_CODE
    FROM LOAN_TRANS_DETAILS T
    WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT <= ASONDT AND T.TRANS_DT >= STARTDATE AND T.PRINCIPLE > 0 
    UNION
    SELECT ASONDT AS TRANS_DT,0 AS PRINCIPLE,'DP' AS TRN_CODE
    FROM DUAL
    ORDER BY TRANS_DT ASC;
    TRANSDT LOAN_TRANS_DETAILS.TRANS_DT%TYPE;
    I NUMBER(16,2) := 0;
    DATEDIFF NUMBER;
    FLAG NUMBER := 0  ;
    BEGIN
        FOR TRN IN LOANTRANS LOOP
            SELECT NVL(SUM(CASE WHEN T.TRN_CODE = 'DP' THEN 1 ELSE -1 END * T.PRINCIPLE),0) INTO PRNBAL  
            FROM LOAN_TRANS_DETAILS T
            WHERE T.ACT_NUM = ACTNUM AND T.TRANS_DT < TRN.TRANS_DT;
            --dbms_output.put_line('FLAG  ='||FLAG);
            if Recoverytype = 'Direct' then  
                IF FLAG = 0 THEN 
                TRNDATE := TRN.TRANS_DT ;
                DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                FLAG := 1;
                ELSE
                    IF FLG = 1 THEN 
                        TRNDATE := TRN.TRANS_DT ;
                        DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    ELSE
                    TRNDATE := TRN.TRANS_DT ;
                    DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    DATEDIFF := DATEDIFF + 1;
                    END IF;
                END IF;
            Else
               IF FLAG = 0 THEN 
                TRNDATE := TRN.TRANS_DT ;
                DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                --dbms_output.put_line('DATEDIFF   =inside loop else flag 0'||DATEDIFF);
                FLAG := 1;
               ELSE
                    IF FLG = 1 THEN 
                        TRNDATE := TRN.TRANS_DT ;
                        DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    ELSE
                    TRNDATE := TRN.TRANS_DT ;
                    DATEDIFF := TRN.TRANS_DT - STARTDATE  ;
                    DATEDIFF := DATEDIFF + 1;
                    END IF;
               END IF;
            End if;
            --dbms_output.put_line(DATEDIFF);
            INTRECEIVABLE := INTRECEIVABLE +  (PRNBAL * DATEDIFF * ROI/ 36500);
           --dbms_output.put_line('flag  ='||flag||'    '||INTRECEIVED||' ' ||PRNBAL||' '||TRN.TRANS_DT||'ROI= '||ROI||' '||STARTDATE||''||'DATE DIFF ='||DATEDIFF ||' '||INTRECEIVABLE); 
            STARTDATE := TRN.TRANS_DT;
        END LOOP;
    END;
    --DBMS_OUTPUT.PUT_LINE('INTRECEIVED   ='||INTRECEIVED);
    INTRECEIVABLE := INTRECEIVABLE - NVL(INTRECEIVED,0);
    IF INTRECEIVABLE < 0 THEN
       INTRECEIVABLE := 0;
    END IF;
    INTRECEIVABLE := ROUND(INTRECEIVABLE);
        BEGIN
            SELECT NVL(lfd.acct_status,'NEW')
            INTO status
            FROM loans_facility_details lfd 
            WHERE lfd.acct_num = actnum 
            AND (LFD.acct_close_dt IS NULL
                  OR LFD.acct_close_dt > GET_LAST_FINENDDATE(asondt) AND LFD.acct_close_dt <= ASONDT
                 );
        EXCEPTION WHEN OTHERS THEN
        STATUS := 'NEW';
        END;
  IF STATUS = NULL THEN 
  STATUS := 'NEW';
  END IF;
    IF STATUS = 'CLOSED' THEN
    RETURN 0;
    --dbms_output.put_line(INTRECEIVABLE);
    END IF;
   RETURN INTRECEIVABLE;
    --dbms_output.put_line(INTRECEIVABLE);
END;
/


CREATE OR REPLACE FUNCTION GET_TL_INSTAMT(ACTNUM VARCHAR2) RETURN NUMBER IS 
    INST_AMT NUMBER(16,2) := 0;
    INSTTYPE VARCHAR2(50);
    EMI VARCHAR2(10);
    COUNTR NUMBER;
BEGIN
SELECT lrs.install_type, NVL (lrs.emi_in_simpleintrest, 'N')
  INTO insttype, emi
  FROM loans_repay_schedule lrs
 WHERE lrs.acct_num = actnum AND LRS.STATUS != 'DELETED' AND lrs.REPAY_ACTIVE='Y' ;
IF INSTTYPE = 'EMI' AND EMI = 'N' THEN 
    SELECT COUNT(*),I.TOTAL_AMT INTO COUNTR,INST_AMT 
    FROM LOANS_INSTALLMENT I WHERE I.ACCT_NUM = ACTNUM 
    AND I.STATUS != 'DELETED' AND NVL(I.ACTIVE_STATUS,'Y') = 'Y'
    GROUP BY I.TOTAL_AMT  HAVING COUNT(I.TOTAL_AMT) > 1; 
    RETURN INST_AMT; 
ELSE
    SELECT MAX(I.PRINCIPAL_AMT) INTO INST_AMT
    FROM LOANS_INSTALLMENT I
    WHERE I.ACCT_NUM = ACTNUM AND I.STATUS != 'DELETED' AND
    NVL(I.ACTIVE_STATUS,'Y') = 'Y' AND
          I.INSTALLMENT_SLNO = (SELECT max(LI.INSTALLMENT_SLNO)
                                FROM LOANS_INSTALLMENT LI 
                                WHERE LI.ACCT_NUM = ACTNUM AND LI.STATUS != 'DELETED' 
                                AND NVL(LI.ACTIVE_STATUS,'Y') = 'Y' ); 
    RETURN INST_AMT; 
End if;
END;
/


CREATE OR REPLACE FUNCTION GET_TL_BALANCE(ACTNUM VARCHAR,ASONDT DATE)
RETURN NUMBER IS
COLLECTEDPRN NUMBER(16,2) := 0;
BEGIN
    SELECT NVL(SUM(CASE WHEN T.TRANS_TYPE = 'DEBIT' THEN 1 ELSE -1 END * T.PRINCIPLE),0) INTO COLLECTEDPRN
    FROM LOAN_TRANS_DETAILS T
    WHERE T.ACT_NUM = ACTNUM AND T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.TRANS_DT <= ASONDT;
    RETURN COLLECTEDPRN; 
END;
/



CREATE OR REPLACE FUNCTION GET_TL_STATUS_RECOVERY(ACTNUM VARCHAR,ASONDT DATE) RETURN VARCHAR IS
RECEIVABLE NUMBER(12,2);
RECD NUMBER(12,2);
LOAN_STATUS VARCHAR2(100);
INST_TYPE VARCHAR2(100);
EMITYPE VARCHAR2(1);
REPAYDT DATE;
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' AND lrs.REPAY_ACTIVE='Y';
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'Y' THEN
            BEGIN
            SELECT NVL (SUM (LIM.TOTAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECBLE');
            END ;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0) + NVL(LTD.INTEREST,0) )  INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE  LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECD ');
            END;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'  '||RECD);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE);
            IF RECEIVABLE <= 0  THEN
                LOAN_STATUS := 'EMIADVANCE';
                ELSE
                LOAN_STATUS := 'EMIDUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE
    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'N' THEN
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECBLE UNIFORM PRINCIPLE');
            END;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE   LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECD UNIFORM PRINCIPLE');
            END;
            RECEIVABLE := RECEIVABLE -  RECD;
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'UNIFORM ADVANCE';
                ELSE
                LOAN_STATUS := 'UNIFORM DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('UNIFORM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE 
   IF INST_TYPE = 'LUMP_SUM' OR INST_TYPE = 'EYI' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA');
            END;
            --DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM 
            AND LTD.TRANS_TYPE = 'CREDIT' AND  LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            RECEIVABLE := RECEIVABLE -  RECD; 
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'LUMPSUM ADVANCE';
                ELSE
                LOAN_STATUS := 'LUMPSUM DUE';
            END IF; 
            --DBMS_OUTPUT.PUT_LINE('LUMPSUM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
    END IF;
   END IF;
END IF;
RETURN LOAN_STATUS;
END;
/


CREATE OR REPLACE FUNCTION GET_TL_STATUS(ACTNUM VARCHAR,ASONDT DATE) RETURN VARCHAR IS
RECEIVABLE NUMBER(12,2);
RECD NUMBER(12,2);
LOAN_STATUS VARCHAR2(100);
INST_TYPE VARCHAR2(100);
EMITYPE VARCHAR2(1);
REPAYDT DATE;
BEHAVES VARCHAR2(20);
BEGIN
       SELECT  LP.BEHAVES_LIKE INTO BEHAVES  FROM  LOANS_PRODUCT LP WHERE LP.PROD_ID = SUBSTR(ACTNUM,5,3) ;
       
      IF BEHAVES = 'OD' THEN
      INST_TYPE := 'LUMP_SUM';
      ELSE
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' AND lrs.REPAY_ACTIVE='Y';
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
      END IF;
IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'Y' THEN
            BEGIN
            SELECT NVL (SUM (LIM.TOTAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECBLE');
            END ;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0) + NVL(LTD.INTEREST,0) )  INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE  LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
             DBMS_OUTPUT.PUT_LINE('NO DATA  IN RECD ');
            END;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'  '||RECD);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE);
            IF RECEIVABLE <= 0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE
    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'N' THEN
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECBLE UNIFORM PRINCIPLE');
            END;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE   LTD.TRANS_TYPE = 'CREDIT' AND LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN RECD UNIFORM PRINCIPLE');
            END;
            RECEIVABLE := RECEIVABLE -  RECD;
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('UNIFORM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE 
   IF INST_TYPE = 'LUMP_SUM' OR INST_TYPE = 'EYI' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA');
            END;
            --DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM 
            AND LTD.TRANS_TYPE = 'CREDIT' AND  LTD.TRANS_DT <= ASONDT;
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            RECEIVABLE := RECEIVABLE -  RECD; 
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF; 
            --DBMS_OUTPUT.PUT_LINE('LUMPSUM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
    ELSE
     IF INST_TYPE = 'LUMP_SUM' AND BEHAVES = 'OD' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA');
            END;
            /*BEGIN
            /*SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ; 
            END; */ 
            DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            
            IF REPAYDT < ASONDT THEN
            RECEIVABLE := GET_ADV_BALANCE(ACTNUM,ASONDT);
            ELSE 
            RECEIVABLE := 0;
            END IF; 
            
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            
            SELECT SUM (NVL (LTD.PRINCIPLE , 0)) INTO RECD
            FROM ADV_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM
            AND LTD.TRANS_TYPE = 'CREDIT' AND  LTD.TRANS_DT <= ASONDT;
            
            
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            RECEIVABLE := RECEIVABLE -  RECD; 
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'ADVANCE';
                ELSE
                LOAN_STATUS := 'DUE';
            END IF; 
     
     
     
     END IF; 
    
    END IF;
    
    
   END IF;
END IF;
RETURN LOAN_STATUS;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_RECBLE_RECOVERY(ACTNUM VARCHAR,ASONDT DATE) RETURN NUMBER IS
RECEIVABLE NUMBER(12,2);
RECD NUMBER(12,2);
LOAN_STATUS VARCHAR2(100);
INST_TYPE VARCHAR2(100);
EMITYPE VARCHAR2(1);
REPAYDT DATE;
INSTAMT NUMBER(12,2);
PRINCBAL NUMBER(12,2);
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        where LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED'  AND lrs.REPAY_ACTIVE='Y' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        
         BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO REPAYDATE FOR LUMPSUM');
            END;
            
IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'Y' THEN
            BEGIN
            SELECT NVL (SUM (LIM.TOTAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE_EMI RECBLE');
            END;
            --DBMS_OUTPUT.PUT_LINE('RECEIVABLE   ='||RECEIVABLE);
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0) + NVL(LTD.INTEREST,0) )  INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT AND TRANS_TYPE = 'CREDIT';
            EXCEPTION WHEN OTHERS THEN 
             DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE_EMI RECD');
            END;
            DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'  '||RECD);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            IF RECEIVABLE IS NULL THEN 
            RECEIVABLE := 0;
            END IF;             
            INSTAMT := GET_TL_INSTAMT(ACTNUM);
            IF  RECEIVABLE < INSTAMT THEN
                RECEIVABLE := INSTAMT;
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE);
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'EMIADVANCE';
                ELSE
                LOAN_STATUS := 'EMIDUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('EMI = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE
    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND EMITYPE = 'N' THEN
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
            FROM LOANS_INSTALLMENT LIM
            WHERE LIM.ACCT_NUM = ACTNUM AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE RECBLE');
            END;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT
            AND LTD.TRANS_TYPE ='CREDIT'  ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE RECD');
            END;
            --RECEIVABLE := RECEIVABLE -  RECD;
            DBMS_OUTPUT.PUT_LINE(' RECEIVABLE uniform ='||RECEIVABLE||'   '||'RECD ='||RECD);
            
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            IF RECEIVABLE IS NULL THEN 
            RECEIVABLE := 0;
            END IF;
            INSTAMT := GET_TL_INSTAMT(ACTNUM);
            PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
            
            
            IF REPAYDT < asondt then
                IF  RECEIVABLE < INSTAMT THEN
                   
                    IF PRINCBAL < RECEIVABLE THEN
                    RECEIVABLE := NVL(PRINCBAL,0);
                    ELSE 
                    RECEIVABLE := INSTAMT;
                    END IF;
                END IF;
            End if;
            
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'UNIFORM ADVANCE';
                ELSE
                LOAN_STATUS := 'UNIFORM DUE';
            END IF;
            --DBMS_OUTPUT.PUT_LINE('UNIFORM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
ELSE 
   IF INST_TYPE = 'LUMP_SUM' OR INST_TYPE = 'EYI' THEN
            BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO REPAYDATE FOR LUMPSUM');
            END;
            BEGIN
            SELECT NVL (SUM (LIM.PRINCIPAL_AMT), 0) INTO RECEIVABLE
              FROM LOANS_INSTALLMENT LIM
             WHERE LIM.ACCT_NUM = ACTNUM
               AND LIM.INSTALLMENT_DT >= REPAYDT
               AND LIM.INSTALLMENT_DT <= ASONDT AND LIM.STATUS = 'CREATED' ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA LUMPSUM RECEIVABLE');
            END;
             BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT
            AND LTD.TRANS_TYPE ='CREDIT'  ;
            EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN UNIFORM_PRINCIPLE RECD');
            END;
            INSTAMT := GET_TL_INSTAMT(ACTNUM);
            PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            DBMS_OUTPUT.PUT_LINE(RECEIVABLE);
            IF RECEIVABLE IS NULL THEN
            RECEIVABLE := 0;
            END IF;
            BEGIN
            SELECT SUM (NVL (LTD.PRINCIPLE, 0)) INTO RECD
            FROM LOAN_TRANS_DETAILS LTD
            WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT <= ASONDT
            AND LTD.TRANS_TYPE = 'CREIDT'  ;
            EXCEPTION WHEN OTHERS THEN 
            RECD := 0;
            END;
            IF RECD IS NULL THEN
            RECD := 0;
            END IF;
            DBMS_OUTPUT.PUT_LINE(RECEIVABLE || '   '||RECD  );
            RECEIVABLE := RECEIVABLE -  RECD; 
            RECEIVABLE := NVL(RECEIVABLE,0) -  NVL(RECD,0);
            IF RECEIVABLE IS NULL THEN 
            RECEIVABLE := 0;
            END IF;
            
            IF RECEIVABLE <=0  THEN
                LOAN_STATUS := 'LUMPSUM ADVANCE';
                ELSE
                LOAN_STATUS := 'LUMPSUM DUE';
            END IF; 
            --DBMS_OUTPUT.PUT_LINE('LUMPSUM = '||RECEIVABLE||'LOAN_STATUS = '||LOAN_STATUS);
    END IF;
   END IF;
END IF;
--DBMS_OUTPUT.PUT_LINE('LOAN_STATUS  ='||LOAN_STATUS||'   '||RECEIVABLE);
RETURN RECEIVABLE;
END;
/



CREATE OR REPLACE FUNCTION GET_TL_LASTRECOVERY_TYPE(ACTNUM VARCHAR,ASONDT DATE) RETURN VARCHAR IS
LASTTRANSDT DATE; 
TRANSMODE VARCHAR2(100);
TRANSMETHOD VARCHAR2(100);
BEGIN
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
        SELECT TRIM(NVL(MAX(SUBSTR(ATA.TRANS_ALL_ID,1,2)),MAX(REC_MODE))) INTO TRANSMODE   FROM  ALL_TRANS ATA
         WHERE ATA.TRANS_DT = LASTTRANSDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
           --dbms_output.put_line('LASTTRANSDT   ='||LASTTRANSDT);
        IF TRANSMODE = 'RP' THEN 
                TRANSMETHOD := 'Salary Recovery';
            ELSE
                IF TRANSMODE = 'SI' OR TRANSMODE = 'TE' THEN 
                    TRANSMETHOD := 'Deduction SI';        
                ELSE
                    IF TRANSMODE = 'TA' THEN 
                        TRANSMETHOD := 'By Recovery Cash/Transfer';
                    ELSE
                        IF TRANSMODE IS NULL THEN
                            TRANSMETHOD := 'By Direct Cash/Transfer';
                        END IF; 
                END IF;
            END IF;
        END IF;
RETURN TRANSMETHOD ;
END;
/

CREATE OR REPLACE FUNCTION GET_TL_PRINCRECBLE(ACTNUM VARCHAR, ASONDT DATE,RECOVERYTYPE VARCHAR) RETURN NUMBER IS
LASTINTDATE DATE;
PENDINGPRINCIPLE NUMBER(12,2);
PENDINGINTEREST NUMBER(12,2);
PENDNGPENAL NUMBER(12,2);
LASTRECOVERYDATE DATE;
PRINCPAYABLE NUMBER(12,2);
INST_TYPE VARCHAR2(50);
EMITYPE VARCHAR2(100);
RECEIVABLE NUMBER(12,2);
TRANSMETHOD VARCHAR2(100);
INTRECBLE NUMBER(12,2);
INSTCOUNT NUMBER(10);
INSTAMT NUMBER(12,2);
NOOFINST NUMBER(12,2);
PRINCBAL NUMBER(12,2);
REPAYDT DATE;
LASTTRANSDT DATE;
RECOVERYFLAG VARCHAR2(100);
INSTAMTRECD NUMBER(12,2);
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL(LRS.EMI_IN_SIMPLEINTREST,'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        WHERE LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED'  AND lrs.REPAY_ACTIVE='Y';
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        TRANSMETHOD := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        RECEIVABLE   := GET_TL_RECBLE_RECOVERY(ACTNUM,ASONDT);
        INTRECBLE := GET_TL_INTERESTRECBLE_RECOVERY(ACTNUM,ASONDT,RECOVERYTYPE);
        PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
        INSTAMT :=  GET_TL_INSTAMT(ACTNUM);
        DBMS_OUTPUT.PUT_LINE(INST_TYPE||'   '||EMITYPE||'   RECEIVABLE  ='||RECEIVABLE||'   PRINCBAL='||PRINCBAL||'   INSTAMT='||INSTAMT);        
        BEGIN
            SELECT LSD.REPAYMENT_DT INTO REPAYDT FROM LOANS_FACILITY_DETAILS LFD 
            JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO = LFD.BORROW_NO
            JOIN LOANS_BORROWER LB ON LB.BORROW_NO = LFD.BORROW_NO
            WHERE LFD.ACCT_NUM = ACTNUM;
        EXCEPTION WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('NO DATA IN LSD');
        END;
        --DBMS_OUTPUT.PUT_LINE('INST_TYPE  ='||INST_TYPE||'EMITYPE    '||EMITYPE||'REPAYDT   '||REPAYDT||'  '||'RECEIVABLE ='||RECEIVABLE);
        
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';           
        SELECT ADD_MONTHS(LAST_DAY(ASONDT),-1) INTO LASTRECOVERYDATE FROM DUAL;           
        BEGIN
        SELECT MAX(SRLD.INT_CALC_UPTO_DT) INTO LASTINTDATE  FROM SALARY_RECOVERY_LIST_DETAIL SRLD,DAY_END DE 
        WHERE SRLD.STATUS = 'CREATED' AND SRLD.ACT_NUM = ACTNUM AND SRLD.INT_CALC_UPTO_DT <= ASONDT;
        EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('NO DATA IN SRLD');
        END;
        BEGIN                               
        SELECT NVL(PRINCIPAL,0) - NVL(REC_PRINCIPAL,0),NVL(INTEREST,0)-NVL(REC_INTEREST,0) ,NVL(PENAL,0)-NVL(REC_PENAL,0) INTO
        PENDINGPRINCIPLE ,PENDINGINTEREST,PENDNGPENAL FROM SALARY_RECOVERY_LIST_DETAIL SRLD
        WHERE SRLD.ACT_NUM = ACTNUM
        AND SRLD.INT_CALC_UPTO_DT = LASTINTDATE;
        EXCEPTION WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('NO DATA IN SRLD PENDING');
        END ;
        
            IF RECEIVABLE <= 0 THEN
               if REPAYDT < ASONDT THEN
                   IF PRINCBAL < INSTAMT THEN
                         RECEIVABLE := PRINCBAL;
                   ELSE
                         RECEIVABLE := INSTAMT;
                   END IF;
               END IF;
            END IF; 
            
            DBMS_OUTPUT.PUT_LINE('LASTRECOVERYDATE   '||LASTRECOVERYDATE||'   '||'RECEIVABLE actual    ='||RECEIVABLE);
            
          /* FORMATTED ON 2015/07/02 14:26 (FORMATTER PLUS V4.8.8) */
            IF RECOVERYTYPE = 'Direct' then
            BEGIN
            SELECT  CASE WHEN LRS.INSTALL_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  LRS.EMI_IN_SIMPLEINTREST = 'Y' THEN
            SUM(LTD.PRINCIPLE  + LTD.INTEREST)
            ELSE
            SUM(NVL(LTD.PRINCIPLE,0)) END INTO INSTAMTRECD            
            FROM LOAN_TRANS_DETAILS LTD,LOANS_REPAY_SCHEDULE LRS WHERE LTD.ACT_NUM = ACTNUM AND LTD.TRANS_DT > LASTRECOVERYDATE
            AND LTD.TRANS_DT <= ASONDT AND LTD.TRANS_TYPE = 'CREDIT'
            AND LRS.ACCT_NUM = LTD.ACT_NUM  AND lrs.REPAY_ACTIVE='Y'
            GROUP BY LRS.INSTALL_TYPE,LRS.EMI_IN_SIMPLEINTREST;
            EXCEPTION WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('NO DATA IN ALL_TRANS DURING THIS MONTH');
            END;
            RECEIVABLE := nvl(RECEIVABLE,0) - nvl(INSTAMTRECD,0);                  
            END IF;
            DBMS_OUTPUT.PUT_LINE('PRINCRECD  ='||INSTAMTRECD||'  '||'RECEIVABLE    ='||RECEIVABLE);
        
         /* CONDITION 1*/
                                       
        /*RECOVERY A/CS THEN*/       
           IF PENDNGPENAL = 0 AND PENDINGINTEREST = 0 AND PENDINGPRINCIPLE = 0 THEN
            RECOVERYFLAG := 'RecoveryCompleted';
           ELSE
            RECOVERYFLAG := 'RecoveryPartial';
           END IF;           
        /*CHECK LAST TRANSACTION OF A/C  */   
           IF LASTTRANSDT > LASTRECOVERYDATE THEN
                IF RECEIVABLE <= 0 THEN 
                    RECOVERYFLAG := 'RecoveryCompleted';
                    RECEIVABLE := 0;
                ELSE
                    RECOVERYFLAG := 'RecoveryPartial';
                END IF;
           END IF;           
    /*  HERE CONSIDER THE RECEIVABLE */
    
    
    
    DBMS_OUTPUT.PUT_LINE('RECOVERYFLAG   ='||RECOVERYFLAG);
    
    /* CONDITION 2*/
           IF RECOVERYTYPE = 'Recovery' THEN
              IF RECEIVABLE < 0  THEN
                 IF PRINCBAL < INSTAMT THEN
                     RECEIVABLE := PRINCBAL;
                 ELSE
                     RECEIVABLE := INSTAMT;
                 END IF;
              END IF;
           ELSE
               IF RECEIVABLE < 0   THEN
                  IF RECOVERYFLAG = 'RecoveryCompleted' THEN
                     RECEIVABLE := 0;
                      DBMS_OUTPUT.PUT_LINE(' condition 2 Direct Completed   ='||PRINCBAL);
                  ELSE
                      IF LASTTRANSDT >LASTRECOVERYDATE THEN
                         IF PRINCBAL < INSTAMT THEN
                             RECEIVABLE := PRINCBAL;
                         ELSE
                             RECEIVABLE := INSTAMT;
                         END IF;
                      END IF;
                      DBMS_OUTPUT.PUT_LINE(' condition 2 Direct Partial   ='||PRINCBAL);
                  END IF;
               END IF;
           END IF;
           /*  CONDITION 3  */
--           IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' THEN  
--               IF RECEIVABLE < INSTAMT THEN
--                 IF PRINCBAL < INSTAMT THEN
--                     RECEIVABLE := PRINCBAL;
--                 ELSE
--                     RECEIVABLE := INSTAMT;
--                 END IF;
--               END IF;
--               DBMS_OUTPUT.PUT_LINE(' CONDITION 3 EMI   ='||RECEIVABLE);
--           ELSE
--               IF REPAYDT < ASONDT THEN
--               PRINCBAL := 0 ;
--               END IF;
--               DBMS_OUTPUT.PUT_LINE(' CONDITION 3 LUMPSUM   ='||RECEIVABLE);
--           END IF;
    /*  END OF CONSIDER THE RECEIVABLE */ 
               /*  HERE CONSIDERING THE PRINCIPLE PAYABLE  */
            DBMS_OUTPUT.PUT_LINE('RECEIVABLE     ='||RECEIVABLE);        
    IF RECOVERYTYPE = 'Recovery' THEN
           IF RECEIVABLE > 0 THEN
                    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                        IF PRINCBAL < INSTAMT  THEN
                                 PRINCPAYABLE := PRINCBAL;
                        ELSE
                                 PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                        END IF;                     
                    ELSE
                        If INST_TYPE = 'LUMP_SUM' Then 
                            if REPAYDT < ASONDT THEN
                                PRINCPAYABLE := RECEIVABLE;
                            Else
                                PRINCPAYABLE := 0;
                            End if;
                        Else
                          PRINCPAYABLE := RECEIVABLE;  
                        End if;
                    END IF;
           ELSE
                    IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                       IF RECOVERYFLAG = 'RecoveryPartial' THEN                         
                            IF INTRECBLE > INSTAMT THEN
                                NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                            ELSE
                                IF PRINCBAL < INSTAMT  THEN
                                    PRINCPAYABLE := PRINCBAL;
                                ELSE
                                    PRINCPAYABLE := INSTAMT;
                                END IF;
                            END IF;
                            WHILE INSTCOUNT <= NOOFINST
                            LOOP
                              INSTCOUNT := INSTCOUNT + 1;
                              IF PRINCPAYABLE >=PRINCBAL THEN
                               PRINCPAYABLE := PRINCBAL;
                              ELSE
                              PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                              END IF; 
                              --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                            END LOOP;
                       END IF;
                    ELSE
                       DBMS_OUTPUT.PUT_LINE('I AM HERE IN LUMPSUM');
                       IF RECOVERYFLAG = 'RecoveryPartial' THEN
                         IF REPAYDT < ASONDT THEN
                         DBMS_OUTPUT.PUT_LINE('I AM HERE');
                               IF INTRECBLE > INSTAMT THEN
                                  NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                               ELSE
                                    IF PRINCBAL < INSTAMT  THEN
                                        PRINCPAYABLE := PRINCBAL;
                                    ELSE
                                        PRINCPAYABLE := INSTAMT;
                                    END IF;
                               END IF;
                                WHILE INSTCOUNT <= NOOFINST
                                LOOP
                                  INSTCOUNT := INSTCOUNT + 1;
                                  IF PRINCPAYABLE >=PRINCBAL THEN
                                   PRINCPAYABLE := PRINCBAL;
                                  ELSE
                                  PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                  END IF; 
                                  --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                END LOOP;
                              IF INTRECBLE < INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                              ELSE
                                        IF PRINCBAL < INSTAMT  THEN
                                            PRINCPAYABLE := PRINCBAL;
                                        ELSE
                                            PRINCPAYABLE := INSTAMT;
                                        END IF;
                                            
                                    WHILE INSTCOUNT <= NOOFINST
                                    LOOP
                                      INSTCOUNT := INSTCOUNT + 1;
                                      IF PRINCPAYABLE >=PRINCBAL THEN
                                       PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                      PRINCPAYABLE := INSTAMT ;
                                      END IF; 
                                      --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                    END LOOP;
                                      IF PRINCPAYABLE >= PRINCBAL THEN
                                        PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                        PRINCPAYABLE := INSTAMT;
                                      END IF;
                              END IF;
                         ELSE
                         PRINCPAYABLE := 0;
                         END IF;
                       ELSE
                       PRINCPAYABLE := 0;
                       END IF;
                    END IF;
           END IF;
   -- DBMS_OUTPUT.PUT_LINE('PRINCPAYABLE   ='||PRINCPAYABLE||'INTRECBLE  ='||INTRECBLE||'   INSTAMT ='||INSTAMT);
    ELSE
         --IF TRANSMETHOD = 'BY RECOVERY CASH/TRANSFER' OR TRANSMETHOD = 'DEDUCTION SI' OR TRANSMETHOD = 'BY DIRECT CASH/TRANSFER' THEN
          --DBMS_OUTPUT.PUT_LINE('I AM OUTSIDE');
             IF RECEIVABLE > 0 THEN
                            IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                               IF RECEIVABLE < INSTAMT THEN
                               PRINCPAYABLE := RECEIVABLE;
                               ELSE
                               dbms_output.put_line('hey i am here');
                                    IF INTRECBLE > INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);
                                        if NOOFINST = 1 then
                                        NOOFINST := NOOFINST + 1;
                                        end if;
                                        dbms_output.put_line('NOOFINST = '||NOOFINST);
                                        PRINCPAYABLE := RECEIVABLE; 
                                        dbms_output.put_line('PRINCPAYABLE =   '||PRINCPAYABLE||'  '||'PRINCBAL  '||PRINCBAL );
                                        FOR INSTCOUNT IN 1..NOOFINST -1
                                        LOOP
                                             IF PRINCPAYABLE >=PRINCBAL THEN
                                               PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                              PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                             END IF; 
                                        dbms_output.put_line('PRINCPAYABLE =   '||PRINCPAYABLE||'  '||'PRINCBAL  '||PRINCBAL );    
                                        END LOOP;
                                       PRINCPAYABLE := PRINCPAYABLE - INTRECBLE;
                                    else
                                    PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                                    END IF;
                               dbms_output.put_line('hey i am here  II');
                               --PRINCPAYABLE := RECEIVABLE - INTRECBLE;
                               END IF;
                            ELSE
                                PRINCPAYABLE := RECEIVABLE;
                            END IF;
             ELSE
                            IF INST_TYPE = 'UNIFORM_PRINCIPLE_EMI' AND  EMITYPE = 'Y' THEN
                               IF RECOVERYFLAG = 'RecoveryPartial' THEN                         
                                    IF INTRECBLE > INSTAMT THEN
                                        NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                    ELSE
                                        IF PRINCBAL < INSTAMT  THEN
                                            PRINCPAYABLE := PRINCBAL;
                                        ELSE
                                            PRINCPAYABLE := INSTAMT;
                                        END IF;
                                    END IF;
                                    WHILE INSTCOUNT <= NOOFINST
                                    LOOP
                                      INSTCOUNT := INSTCOUNT + 1;
                                      IF PRINCPAYABLE >=PRINCBAL THEN
                                       PRINCPAYABLE := PRINCBAL;
                                      ELSE
                                      PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                      END IF; 
                                      --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                    END LOOP;
                               END IF;
                            ELSE
                               IF RECOVERYFLAG = 'RecoveryPartial' THEN
                                 IF REPAYDT < ASONDT THEN
                                 DBMS_OUTPUT.PUT_LINE('I AM HERE');
                                       IF INTRECBLE > INSTAMT THEN
                                          NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                       ELSE
                                            IF PRINCBAL < INSTAMT  THEN
                                                PRINCPAYABLE := PRINCBAL;
                                            ELSE
                                                PRINCPAYABLE := INSTAMT;
                                            END IF;
                                       END IF;
                                        WHILE INSTCOUNT <= NOOFINST
                                        LOOP
                                          INSTCOUNT := INSTCOUNT + 1;
                                          IF PRINCPAYABLE >=PRINCBAL THEN
                                           PRINCPAYABLE := PRINCBAL;
                                          ELSE
                                          PRINCPAYABLE := PRINCPAYABLE + INSTAMT;
                                          END IF; 
                                          --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                        END LOOP;
                                      IF INTRECBLE < INSTAMT THEN
                                                NOOFINST :=  TRUNC(INTRECBLE/INSTAMT);        
                                      ELSE
                                                IF PRINCBAL < INSTAMT  THEN
                                                    PRINCPAYABLE := PRINCBAL;
                                                ELSE
                                                    PRINCPAYABLE := INSTAMT;
                                                END IF;
                                                    
                                            WHILE INSTCOUNT <= NOOFINST
                                            LOOP
                                              INSTCOUNT := INSTCOUNT + 1;
                                              IF PRINCPAYABLE >=PRINCBAL THEN
                                               PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                              PRINCPAYABLE := INSTAMT ;
                                              END IF; 
                                              --DBMS_OUTPUT.PUT_LINE('INSTCOUNT='||INSTCOUNT);
                                            END LOOP;
                                              IF PRINCPAYABLE >= PRINCBAL THEN
                                                PRINCPAYABLE := PRINCBAL;
                                              ELSE
                                                PRINCPAYABLE := INSTAMT;
                                              END IF;
                                      END IF;
                                 ELSE
                                 PRINCPAYABLE := 0;
                                 END IF;
                               ELSE
                               PRINCPAYABLE := 0;
                               END IF;
                            END IF;
             END IF;     -- END IF;
    END IF;
    IF PRINCPAYABLE IS NULL THEN 
    PRINCPAYABLE := 0 ;
    END IF;
RETURN PRINCPAYABLE;
--DBMS_OUTPUT.PUT_LINE('PRINCPAYABLE   ='||PRINCPAYABLE||'  '||'INTRECBLE  ='||INTRECBLE||INST_TYPE||'   '||EMITYPE||'RECEIVABLE  ='||RECEIVABLE||'   PRINCBAL='||PRINCBAL||'   INSTAMT='||INSTAMT);
--DBMS_OUTPUT.PUT_LINE('REPAYDT   ='||REPAYDT||'     TRANSMETHOD  ='||TRANSMETHOD||'   '||PRINCPAYABLE);
END;
/


CREATE OR REPLACE function GET_RecoveryTL(ACTNUM varchar2,ASONDT date,Recoverytype varchar) Return varchar is
RecoveryDetails varchar2(500);
INST_TYPE VARCHAR2(50);
EMITYPE VARCHAR2(1);
RECEIVABLE NUMBER(16,2);
FROMDT DATE;
TODT DATE;
CATG VARCHAR2(50);
LIMITR NUMBER(16,2);
PRODID VARCHAR2(10);
INTRECBLE NUMBER(16,2);
LASTTRANSDT DATE;
PRINCBAL NUMBER(16,2);
PRINCPAYABLE NUMBER(16,2);
INSTAMT NUMBER(16,2);
TransMethod Varchar2(100);
INTGETFROM VARCHAR2(10);
LOAN_STATUS VARCHAR2(100);
PENALINTRATE NUMBER(12,2);
PENALRECBLE NUMBER(12,2);
monthopdate date;
LOANSTATUS VARCHAR2(15);
LI_COUNT NUMBER;
REMITTEDSTATUS VARCHAR2(50);
FULLRECOVERED NUMBER;
RECOVERYDATE DATE;
BEGIN
        BEGIN
        SELECT LRS.INSTALL_TYPE,NVL (LRS.EMI_IN_SIMPLEINTREST, 'N') INTO INST_TYPE,EMITYPE
        FROM LOANS_REPAY_SCHEDULE LRS
        where LRS.ACCT_NUM = ACTNUM AND LRS.STATUS != 'DELETED' AND lrs.REPAY_ACTIVE='Y' ;
        EXCEPTION WHEN OTHERS THEN 
        DBMS_OUTPUT.PUT_LINE('NO DATA IN LRS');
        END;
        SELECT MAX (ATA.TRANS_DT) INTO LASTTRANSDT
          FROM ALL_TRANS ATA
         WHERE ATA.TRANS_DT <= ASONDT
           AND ATA.LINK_BATCH_ID = ACTNUM
           AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED'
           AND ATA.STATUS = 'CREATED';
        SELECT LSD.FROM_DT,LSD.TO_DT,LB.CATEGORY,LSD.LIMIT,LFD.PROD_ID,LFD.INT_GET_FROM INTO FROMDT,TODT,CATG,LIMITR,PRODID,INTGETFROM 
        FROM LOANS_FACILITY_DETAILS LFD,LOANS_SANCTION_DETAILS LSD,LOANS_BORROWER LB
        WHERE LFD.BORROW_NO = LSD.BORROW_NO
        AND LSD.BORROW_NO = LB.BORROW_NO
        AND LFD.ACCT_NUM = ACTNUM;
        TRANSMETHOD  := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        DBMS_OUTPUT.PUT_LINE(TRANSMETHOD);
        SELECT LAST_DAY(ADD_MONTHS(ASONDT,-1)) + 1 INTO MONTHOPDATE FROM DUAL;
        SELECT  COUNT(*) INTO LI_COUNT FROM ALL_TRANS ATA WHERE ATA.TRANS_DT >= MONTHOPDATE
        AND  ATA.TRANS_DT <= ASONDT AND ATA.AUTHORIZE_STATUS = 'AUTHORIZED' AND ATA.LINK_BATCH_ID = ACTNUM AND ATA.TRANS_TYPE = 'CREDIT' ;
        LOANSTATUS := GET_TL_STATUS(ACTNUM,ASONDT);
        IF LOANSTATUS = 'ADVANCE'  --AND LI_COUNT > 0 
        THEN
        REMITTEDSTATUS := 'PAID';
        ELSE
        IF TRANSMETHOD = 'Salary Recovery' THEN
        SELECT LAST_DAY(ADD_MONTHS(ASONDT,-1)) INTO RECOVERYDATE FROM DUAL;
        SELECT COUNT(*) INTO FULLRECOVERED FROM SALARY_RECOVERY_LIST_DETAIL SR WHERE SR.INT_CALC_UPTO_DT = RECOVERYDATE AND
        SR.TOTAL_DEMAND = NVL(SR.REC_PRINCIPAL,0) + NVL(SR.REC_PENAL,0) + NVL(SR.REC_INTEREST,0) + NVL(SR.REC_CHARGES,0)
        AND SR.ACT_NUM = ACTNUM;
        DBMS_OUTPUT.PUT_LINE(FULLRECOVERED);
            IF FULLRECOVERED > 0 THEN
            REMITTEDSTATUS := 'PAID';
            ELSE
            REMITTEDSTATUS := 'NOT PAID';
            END IF;
        ELSE
        REMITTEDSTATUS := 'NOT PAID';
        END IF;
        END IF;
        TRANSMETHOD  := GET_TL_LASTRECOVERY_TYPE(ACTNUM,ASONDT);
        /*RECEIVABLE   := GET_TL_RECBLE_RECOVERY(ACTNUM,ASONDT);*/
        LOAN_STATUS  := GET_TL_STATUS_RECOVERY(ACTNUM,ASONDT);
        PENALINTRATE := 0;/*GET_TL_PENROI(PRODID,CATG,ACTNUM,FROMDT,TODT,LIMITR,INTGETFROM);*/
        PRINCBAL := GET_TL_BALANCE(ACTNUM,ASONDT);
        INSTAMT :=  GET_TL_INSTAMT(ACTNUM);
        INTRECBLE := GET_TL_INTERESTRECBLE_recovery(ACTNUM,ASONDT,Recoverytype);
        Penalrecble := 0; /* GET_TL_PENINTEREST(ACTNUM,FROMDT,ASONDT,PENALINTRATE); */
        PRINCPAYABLE   := GET_TL_PRINCRECBLE(ACTNUM,ASONDT,Recoverytype);
RecoveryDetails := 'ACTNUM='||actnum||':'||'LOAN_STATUS='||LOAN_STATUS||':'||'Transmethod='||Transmethod||':'||'INSTAMT ='||INSTAMT||':'||'PRINCPAYABLE='||PRINCPAYABLE||':'||'intrecble='||intrecble||':'||'Penalrecble='||Penalrecble||':'||'REMITTEDSTATUS='||REMITTEDSTATUS||':';
--dbms_output.put_line(RecoveryDetails) ;
Return RecoveryDetails;
END;
/

-- End Version [Script Version - 0.0.288] [ReleaseVersion - 9.2.2.11]--[03-06-2019] -- By Rishad M.P

-- Start Version [Script Version - 0.0.289] [ReleaseVersion - 9.2.2.11]--[07-03-2019] -- By Nithya

CREATE TABLE INWARD_FILE_MANAGEMENT
(
  APPLN_DT            DATE,
  APPLN_NO            VARCHAR2(20 BYTE),
  FILE_NO             VARCHAR2(20 BYTE),
  MEMBER_NO           VARCHAR2(10 BYTE),
  SUBMITTED_BY        VARCHAR2(30 BYTE),
  ADDRESS             VARCHAR2(50 BYTE),
  PARTICULARS         VARCHAR2(50 BYTE),
  REMARKS             VARCHAR2(50 BYTE),
  SUBMITTED_TO        VARCHAR2(20 BYTE),
  SUBMISSION_DT1      DATE,
  SUBMISSION_DT2      DATE,
  SUBMISSION_DT3      DATE,
  SUBMISSION_ACTION1  VARCHAR2(50 BYTE),
  SUBMISSION_ACTION2  VARCHAR2(50 BYTE),
  SUBMISSION_ACTION3  VARCHAR2(50 BYTE),
  APPROVAL_SATUS      VARCHAR2(20 BYTE),
  APPROVAL_DT1        DATE,
  APPROVAL_DT2        DATE,
  APPROVAL_DT3        DATE,
  APPROVAL_ACTION1    VARCHAR2(50 BYTE),
  APPROVAL_ACTION2    VARCHAR2(50 BYTE),
  APPROVAL_ACTION3    VARCHAR2(50 BYTE),
  BRANCH_ID           VARCHAR2(4 BYTE),
  CREATED_DT          DATE,
  CREATED_BY          VARCHAR2(20 BYTE),
  STATUS              VARCHAR2(20 BYTE)
)

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('APPROVED_STATUS', 'PENDING', 'PENDING', 'MODIFIED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SUBMITTED_TO', 'BOARD', 'BOARD', 'MODIFIED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SUBMITTED_TO', 'SECRETARY', 'SECRETARY', 'MODIFIED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('APPROVED_STATUS', 'APPROVED', 'APPROVED', 'MODIFIED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('APPROVED_STATUS', 'REJECTED', 'REJECTED', 'MODIFIED', NULL, 
    'Y');

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCRA6121', '5005', 'File Management', 'APP01', 'DONE', 
    '37', NULL, 3, 'CREATED', NULL, 
    NULL, NULL);

Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('FILE_NO', 7, 'FM', TO_DATE('05/05/2012 00:00:00', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0001');


SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12244', '2242', 'Batch Process', 'APP01', 'DONE', 
    '4', 'Batch Process', 3, 'CREATED', NULL, 
    NULL, 'Batch Process');
COMMIT;

-- Script for Batch process - Done by Gibi -- Package attached as new file
    Insert into LOOKUP_MASTER
       (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,  AUTHORIZED)
     Values
       ('APP.EXECUTION', '1', 'OPERATIVE INTR. APPLICATION', 'CREATED', NULL,    'Y');
    COMMIT;

    Insert into LOOKUP_MASTER
       (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,  AUTHORIZED)
     Values
       ('APP.EXECUTION', '2', 'OPERATIVE FOLIO CHARGE', 'CREATED', NULL,  'Y');
    COMMIT;

    Insert into LOOKUP_MASTER
       (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,  AUTHORIZED)
     Values
       ('APP.EXECUTION', '3', 'OPERATIVE INOPERATIVE CHARGE', 'CREATED', NULL, 'Y');
    COMMIT;

    Insert into LOOKUP_MASTER
       (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,  AUTHORIZED)
     Values
       ('APP.EXECUTION', '4', 'OPERATIVE SMS CHARGE', 'CREATED', NULL, 'Y');
    COMMIT;

    Insert into LOOKUP_MASTER
       (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,  AUTHORIZED)
     Values
       ('APP.EXECUTION', '5', 'CUMULATIVE INTR. APPLICATION ', 'CREATED', NULL,  'Y');
    COMMIT;

    CREATE VIEW app_exec_products
    AS
   SELECT '1' AS exctype, prod_id, prod_desc, ac_hd_id,
          'Act_int_processlst' AS reportname
     FROM op_ac_product
    WHERE authorized_status = 'AUTHORIZED'
   UNION
   SELECT '5' AS exctype, prod_id, prod_desc, acct_head AS ac_hd_id,
          'Cumm_int_processlst' AS reportname
     FROM deposits_product
    WHERE authorize_status = 'AUTHORIZED' AND behaves_like IN ('CUMMULATIVE');

CREATE OR REPLACE VIEW app_exec_param
AS
   SELECT exctype, dn.last_appl_dt + 1 AS frdt,
          ADD_MONTHS (dn.last_appl_dt,
                      CASE
                         WHEN (cr_int_appl_freq = 30)
                            THEN 1
                         WHEN (cr_int_appl_freq = 90)
                            THEN 3
                         WHEN (cr_int_appl_freq = 180)
                            THEN 6
                         WHEN (    cr_int_appl_freq > 360
                               AND cr_int_appl_freq <= 366
                              )
                            THEN 12
                      END
                     ) AS todt,
          dn.branch_code, dn.prod_id, dn.last_appl_dt
     FROM (SELECT '1' AS exctype, dp.branch_code, dp.prod_id, last_appl_dt,
                  oi.cr_int_appl_freq,
                  MAX (last_appl_dt) OVER (PARTITION BY dp.branch_code, dp.prod_id ORDER BY dp.branch_code,
                   dp.prod_id) AS mxintapp
             FROM deposit_provision dp, op_ac_intpay_param oi
            WHERE dp.prod_id = oi.prod_id AND dp.remarks = 'APPLICATION') dn
    WHERE dn.last_appl_dt = dn.mxintapp;


-- End

-- End Version [Script Version - 0.0.289] [ReleaseVersion - 9.2.2.11]--[07-03-2019] -- By Nithya

-- Start Version [Script Version - 0.0.290] [ReleaseVersion - 9.2.2.11]--[20-03-2019] -- By Rishad

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SL_NO, STATUS, SCREEN_DESC)
 Values
   ('SCR09999', '9999', 'OverDue Remainder', 'APP01', 'DONE', 
    '5', 45, 'CREATED', 'OverDue Reminder');
COMMIT;


 call INSERT_REPORT_GROUP('SCR09999');

CREATE OR REPLACE TYPE "TAB_TYPE_LOAN_DUE_SPLIT" AS TABLE OF TYPE_LOAN_DUE_SPLIT;
/

CREATE OR REPLACE TYPE "TYPE_LOAN_DUE_SPLIT" AS OBJECT (
   ACT_NUM       VARCHAR2(20),
   BRANCH_CODE  VARCHAR2(15),
   PROD_DESC     VARCHAR(100),
   FROM_DT      DATE,
   TO_DT        DATE,
   AMOUNT        NUMBER(16,2),
   INTEREST_AMOUNT NUMBER(16,2),
   DUE_COUNT      NUMBER,
   MOBILE_NO      VARCHAR2(20)
);
/
  CREATE GLOBAL TEMPORARY TABLE LOAN_DUE_SPLIT (
  ACT_NUM           VARCHAR2(20),
  INSTALLMENT_SLNO           NUMBER,
  INSTALLMENT_DT           DATE,
  PRINCIPAL_AMT           NUMBER(16,2),
  INSTALLMENT_PAID  VARCHAR2(2)
)
ON COMMIT DELETE ROWS;

CREATE OR REPLACE FUNCTION GET_LOAN_DUE_SPLIT (BR_CODE    VARCHAR2,
                                               PRODID    VARCHAR2,
                                               FREQ       NUMBER DEFAULT 1)
        --donot change anything --by rishad
   RETURN TAB_TYPE_LOAN_DUE_SPLIT
IS
   PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
   DECLARE
      L_TAB      TAB_TYPE_LOAN_DUE_SPLIT := TAB_TYPE_LOAN_DUE_SPLIT ();
      INTEREST_AMOUNT    NUMBER (16, 2) := 0;
   --   PROD_ID    VARCHAR2 (30) := '304';
      CURRDATE   DATE;
      COUNTER    NUMBER := 0;

      CURSOR C
      IS
         SELECT L.ACCT_NUM,
                L.BRANCH_ID,
                ABS (L.CLEAR_BALANCE) AS AMOUNT,
                LS.LIMIT AS SANCTION_AMOUNT,
                LS.FROM_DT,
                LS.TO_DT,
                LP.PROD_DESC,S.MOBILE_NO
           FROM LOANS_PRODUCT LP
                JOIN LOANS_FACILITY_DETAILS L ON LP.PROD_ID = L.PROD_ID
                JOIN LOANS_SANCTION_DETAILS LS ON L.BORROW_NO = LS.BORROW_NO LEFT JOIN SMS_SUBSCRIPTION S ON L.ACCT_NUM= S.ACT_NUM
          WHERE     L.AUTHORIZE_STATUS_1 = 'AUTHORIZED'
                AND L.ACCT_STATUS NOT IN ('CLOSED', 'DELETED')
                AND LP.PROD_ID = PRODID;

   BEGIN
      SELECT D.CURR_APPL_DT
        INTO CURRDATE
        FROM DAY_END d
       WHERE D.BRANCH_CODE = BR_CODE;

      FOR I IN C
      LOOP
         COUNTER := 0;
         INTEREST_AMOUNT :=0;
         INSERT INTO LOAN_DUE_SPLIT
            SELECT I.ACCT_NUM,
                   A.*,
                   CASE
                      WHEN   (I.SANCTION_AMOUNT - I.AMOUNT)
                           - (A.INSTALLMENT_SLNO * A.PRINCIPAL_AMT) >= 0
                      THEN
                         'Y'
                      WHEN   (I.SANCTION_AMOUNT - I.AMOUNT)
                           - ( (A.INSTALLMENT_SLNO - 1) * NVL(LAG(A.PRINCIPAL_AMT) OVER (ORDER BY A.INSTALLMENT_SLNO),0)) >
                              0
                      THEN
                         'Y'
                      ELSE
                         'N'
                   END
                      INSTALLMENT_PAID
              FROM (SELECT NUM AS INSTALLMENT_SLNO,
                           DT AS INSTALLMENT_DT,
                           CASE
                              WHEN NUM = TOTAL_INST
                              THEN
                                   I.SANCTION_AMOUNT
                                 - AMOUNT * (TOTAL_INST - 1)
                              ELSE
                                 AMOUNT
                           END
                              PRINCIPAL_AMT
                      FROM (    SELECT LEVEL AS NUM,
                                       ADD_MONTHS (
                                          I.FROM_DT,
                                          LEVEL * FREQ)
                                          DT,
                                       ROUND (
                                          (  I.SANCTION_AMOUNT
                                           / ROUND (
                                                MONTHS_BETWEEN (
                                                 I.TO_DT,
                                                   I.FROM_DT))))
                                          AS amount,
                                       ROUND (
                                          MONTHS_BETWEEN (I.TO_DT,
                                             I.FROM_DT))
                                          AS TOTAL_INST
                                  FROM DUAL
                            CONNECT BY LEVEL <=
                                            MONTHS_BETWEEN (
                                              I.TO_DT,I.FROM_DT)
                                          / FREQ)) A;

           SELECT COUNT (*)
             INTO COUNTER
             FROM LOAN_DUE_SPLIT LD
            WHERE     LD.INSTALLMENT_DT <= CURRDATE
                  AND LD.ACT_NUM = I.ACCT_NUM
                  AND LD.INSTALLMENT_PAID = 'N'
         ORDER BY INSTALLMENT_SLNO;
         IF (COUNTER > 0)
         THEN
           --  DBMS_OUTPUT.PUT_LINE('COUNTER : ' || COUNTER || ' I.ACCT_NUM : ' || I.ACCT_NUM || 'CURRDATE  ' ||  CURRDATE);
            SELECT GET_TL_INTEREST (I.ACCT_NUM, I.FROM_DT, CURRDATE) INTO INTEREST_AMOUNT FROM DUAL;
               L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_LOAN_DUE_SPLIT (I.ACCT_NUM,
                                         BR_CODE,
                                         I.PROD_DESC,
                                         I.FROM_DT,
                                         I.TO_DT,
                                         I.AMOUNT,INTEREST_AMOUNT,COUNTER,I.MOBILE_NO);
         END IF;
       COMMIT;
      END LOOP;
      RETURN L_TAB;
   END;
END;
/

-- End Version [Script Version - 0.0.290] [ReleaseVersion - 9.2.2.11]--[20-03-2019] -- By Rishad


-- Start Version [Script Version - 0.0.291] [ReleaseVersion - 9.2.2.11]--[02-04-2019] -- By Rishad

CREATE OR REPLACE FUNCTION GET_TD_INTEREST_LOCKER(DEPOSITNO VARCHAR,DEPOSITDT DATE,
                                                   DEPOSITAMT NUMBER,ROI NUMBER,CLOSEDDATE DATE,ASONDT DATE,PERIOD NUMBER)
RETURN NUMBER IS
    INTPAYABLE NUMBER(16,2) := 0;
    INTPAID NUMBER(16,2) := 0;
    INTUPTODATE DATE := ASONDT;
BEGIN
    IF NVL(CLOSEDDATE,ADD_MONTHS(ASONDT,1)) <= ASONDT THEN
        RETURN INTPAID;
    END IF;    
    BEGIN
        SELECT NVL(TOTAL_INT_DRAWN,0) INTO INTPAID
        FROM DEPOSIT_SUB_ACINFO
         WHERE DEPOSIT_NO = DEPOSITNO;
    EXCEPTION
    WHEN OTHERS THEN
        INTPAID := 0;
    END;
    IF period> 0 THEN
        INTPAYABLE := DEPOSITAMT * ROI * (INTUPTODATE - DEPOSITDT)/36500;
    ELSE
        INTPAYABLE := DEPOSITAMT * ROI * MONTHS_BETWEEN(INTUPTODATE,DEPOSITDT)/1200;
    END IF;
    INTPAYABLE := INTPAYABLE-INTPAID;
    IF INTPAYABLE < 0 THEN
        INTPAYABLE := 0;
    END IF;
    INTPAYABLE := ROUND(INTPAYABLE,0);
    RETURN INTPAYABLE;
END;
/


CREATE OR REPLACE TYPE "TYPE_LOCKER_DEPOSIT" AS OBJECT (
   LOCKER_NUM       VARCHAR2(20),
   ISSUE_DT         DATE,
   EXP_DT           DATE,
   LOCKER_PROD_ID   VARCHAR2(6),
   LOCKER_ACT_NUM    VARCHAR2(15),
   PROD_ID         VARCHAR2(6),
   PROD_TYPE       VARCHAR2(6),
   DEBIT_ACT_NUM   VARCHAR2(15),
   DEPOSIT_INTEREST NUMBER(16,2),
   COMMISION        NUMBER(16,2),
   SERVICE_CHARGE   NUMBER(16,2),
   GST              NUMBER(16,2)
);
/


CREATE OR REPLACE TYPE "TAB_TYPE_LOCKER_DEPOSIT" AS TABLE OF TYPE_LOCKER_DEPOSIT;
/

CREATE OR REPLACE FUNCTION GET_ACHD_TAX (ACHD VARCHAR2, AMOUNT NUMBER)
   RETURN NUMBER
IS
   TAX_AMT         NUMBER (16, 2) := 0;
   SERV_TAX_APPL   VARCHAR2 (1);
   SERV_TAX_ID     VARCHAR2 (15);
   SCGST_RATE      NUMBER (16, 2) := 0;
   CGST_RATE       NUMBER (16, 2) := 0;
   SER_TAX_RATE         NUMBER (16, 2) := 0;
   SER_SCGST       NUMBER (16, 2) := 0;
   SER_CGST        NUMBER (16, 2) := 0;
   SER_TAX         NUMBER (16, 2) := 0;
BEGIN
   SELECT SERVICE_TAX_APPLICABLE, SERVICE_TAX_ID
     INTO SERV_TAX_APPL, SERV_TAX_ID
     FROM AC_HD_PARAM
    WHERE     AC_HD_ID = ACHD
          AND AUTHORIZE_STATUS = 'AUTHORIZED'
          AND STATUS != 'DELETED';

   IF (SERV_TAX_APPL = 'Y')
   THEN
      SELECT swachh_cess, krishi_kalyan_cess, SERVICE_TAX
        INTO CGST_RATE, SCGST_RATE, SER_TAX_RATE
        FROM service_tax_settings
       WHERE     (status NOT IN ('DELETED', 'UNFREEZED') OR status IS NULL)
             AND authorized_status = 'AUTHORIZED'
             AND SERVICETAX_GEN_ID = SERV_TAX_ID;

      SER_SCGST := SER_SCGST + (AMOUNT * (SCGST_RATE / 100));
      SER_CGST := SER_CGST + (AMOUNT * (CGST_RATE / 100));
      SER_TAX := SER_TAX + (AMOUNT * (SER_TAX_RATE / 100));
   END IF;

   TAX_AMT := SER_SCGST + SER_CGST + SER_TAX;
   RETURN TAX_AMT;
END;
/

--- rent charge based on rent prod based
CREATE OR REPLACE FUNCTION GET_LOCKER_DEPOSIT_DETAILS (BR_CODE VARCHAR2,PRODID VARCHAR2,MONTH VARCHAR2,YEAR VARCHAR2)
   
   RETURN TAB_TYPE_LOCKER_DEPOSIT
IS
 PRAGMA AUTONOMOUS_TRANSACTION;
 CURRDATE   DATE;
 COUNTER    NUMBER := 0;
 EXPDATE    DATE;
 SERVICE_TAX_REQ VARCHAR2(1);
 LOCKER_RENT_ACHD VARCHAR2(15);
 LOCKER_SERV_HEAD VARCHAR2(15);
 RENT_TAX    NUMBER (16,2):=0;
 SER_TAX    NUMBER(16,2):=0;
 EXPDATE1      VARCHAR2(14) :='01/'||MONTH||'/'||YEAR;
 RENT_SERVICE_TAX  NUMBER (16,2):=0;
BEGIN
    SELECT D.CURR_APPL_DT INTO CURRDATE FROM DAY_END D WHERE D.BRANCH_CODE = BR_CODE; 
    SELECT LAST_DAY(TO_DATE(EXPDATE1,'DD/MM/YYYY')) INTO EXPDATE FROM DUAL;
    SELECT P.SERVICE_TAX_REQ INTO SERVICE_TAX_REQ FROM PARAMETERS P;
    SELECT LOC_RENT_AC_HD,SERV_TAX_AC_HD INTO LOCKER_RENT_ACHD,LOCKER_SERV_HEAD FROM LOCKER_PRODUCT WHERE PROD_ID = PRODID;
    DECLARE
      L_TAB      TAB_TYPE_LOCKER_DEPOSIT := TAB_TYPE_LOCKER_DEPOSIT ();
   CURSOR C
      IS
 SELECT LOCKER_NUM,
        ISSUE_DT,
        EXP_DT,
        CUSTOMER_NAME,
        L.ACT_NUM,
        L.PROD_ID,
        L.PROD_TYPE,
        L.PRODUCT_ID,
        L.CUSTOMER_ID_CR,
        GET_TD_INTEREST_LOCKER (D.DEPOSIT_NO,
        D.DEPOSIT_DT,
        D.DEPOSIT_AMT,
        D.RATE_OF_INT,
        D.CLOSE_DT,
        CURRDATE,
        D.DEPOSIT_PERIOD_DD)
        AS DEPOSIT_INTEREST,LC.COMMISION,LC.SERVICE_TAX
        FROM LOCKER_MASTER l
        JOIN DEPOSIT_SUB_ACINFO d
        ON L.CUSTOMER_ID_CR = D.DEPOSIT_NO || '_' || D.DEPOSIT_SUB_NO
        JOIN  LOCKER_PROD_CHARGES LC ON L.PROD_ID=LC.PROD_ID AND LC.END_DT IS NULL AND LC.CHARGE_TYPE='RENT_CHARGES'
        WHERE     L.PROD_ID = PRODID
        AND EXP_DT <= EXPDATE
        AND LOCKER_STATUS_ID != 'CLOSED'
        AND AUTHORIZATION_STATUS = 'AUTHORIZED'
        AND L.DEPOSIT_LINK_NO IS NOT NULL
        AND L.PROD_TYPE = 'TD'
        AND GET_TD_INTEREST_LOCKER (D.DEPOSIT_NO,
        D.DEPOSIT_DT,
        D.DEPOSIT_AMT,
        D.RATE_OF_INT,
        D.CLOSE_DT,CURRDATE,
        D.DEPOSIT_PERIOD_DD)>=LC.COMMISION;

   BEGIN
      FOR I IN C
      LOOP
      IF(I.COMMISION>0)
      THEN
      RENT_SERVICE_TAX := (I.COMMISION*I.SERVICE_TAX)/100;
      END IF;
      
        IF(SERVICE_TAX_REQ='Y')
         THEN
          SELECT GET_ACHD_TAX(LOCKER_RENT_ACHD,I.COMMISION) INTO RENT_TAX  FROM DUAL;
           SELECT GET_ACHD_TAX(LOCKER_SERV_HEAD,0) INTO SER_TAX  FROM DUAL;
         END IF;
         IF(I.DEPOSIT_INTEREST>=(I.COMMISION+RENT_SERVICE_TAX+ROUND(RENT_TAX+SER_TAX)))
         THEN
                    L_TAB.EXTEND;
                  L_TAB (L_TAB.LAST) :=
                     TYPE_LOCKER_DEPOSIT (I.LOCKER_NUM,
                                         I.ISSUE_DT,
                                         I.EXP_DT,I.PROD_ID
                                       ,I.ACT_NUM,I.PRODUCT_ID,I.PROD_TYPE,I.CUSTOMER_ID_CR,I.DEPOSIT_INTEREST,I.COMMISION,RENT_SERVICE_TAX,ROUND(RENT_TAX+SER_TAX));
         END IF;
         
      COMMIT;
      END LOOP;
      RETURN L_TAB;
   END;
END;
/

-- End Version [Script Version - 0.0.291] [ReleaseVersion - 9.2.2.11]--[02-04-2019] -- By Rishad

-- Start Version [Script Version - 0.0.292] [ReleaseVersion - 9.2.2.12]--[17-04-2019] -- By Nithya

ALTER TABLE LOANS_PROD_INTREC ADD GOLD_LOAN_OVERDUE_INT VARCHAR2(1) DEFAULT 'N';

ALTER TABLE LOANS_PROD_INTREC ADD GRACE_GOLD_LOAN_OVERDUE_INT NUMBER(3);

CREATE OR REPLACE FUNCTION addmonths(deposit_dt date, pass_dt date, noofmonths number) return date is
temp_dt date;
begin
temp_dt:=add_months(pass_dt,noofmonths);
if to_number(to_char(deposit_dt,'dd'))>to_number(to_char(last_day(temp_dt),'dd')) then
temp_dt:=last_day(temp_dt);
else
temp_dt:=to_date(to_char(deposit_dt,'dd')||'-'||to_char(temp_dt,'mm')||to_char(temp_dt,'yyyy'), 'dd-mm-yyyy');
end if;
--dbms_output.put_line('inside else:'||deposit_dt||' / temp_dt'||temp_dt);
return temp_dt;
end;
/

ALTER TABLE DEPOSITS_PROD_RENEWAL ADD SLAB_SELECTION_METHOD VARCHAR2(40);

-- End Version [Script Version - 0.0.292] [ReleaseVersion - 9.2.2.12]--[17-04-2019] -- By Nithya

-- Start Version [Script Version - 0.0.293] [ReleaseVersion - 9.2.2.11]--[05-27-2019] -- By Rishad

ALTER TABLE OP_AC_CHARGES_PARAM ADD (FOLIO_CHARGE_TYPE VARCHAR2(15 BYTE) DEFAULT 'FIXED',
FOLIO_RESTRICTION_FRQ        VARCHAR2(15 BYTE), FOLIO_RESTRICTION_PERIOD     NUMBER(5));

-- End Version [Script Version - 0.0.293] [ReleaseVersion - 9.2.2.11]--[05-27-2019] -- By Rishad 

-- Start Version [Script Version - 0.0.293] [ReleaseVersion - 9.2.2.11]--[04-Jul-2019] -- By Suresh R
ALTER TABLE MULTIPLE_MSG_TO_SINGLE_MSG ADD (SCREEN_NAME  VARCHAR2(128 BYTE));
-- End Version [Script Version - 0.0.293] [ReleaseVersion - 9.2.2.11]--[04-Jul-2019] -- By Suresh R

-- Start Version [Script Version - 0.0.294] [ReleaseVersion - 9.2.2.12]--[12-Jul-2019] -- By Sanju
CREATE TABLE RESERVE_DEPRECIATION_ACHD
(
  AC_HD_ID   VARCHAR2(16 BYTE),
  INC_AC_HD  VARCHAR2(16 BYTE),
  EXP_AC_HD  VARCHAR2(16 BYTE)
)

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    SCREEN_DESC)
 Values
   ('SCRF3015', '3015', 'Reserve Depreciation AcHd', 'APP01', 'DONE', 
    '30', 'Reserve Depreciation AcHd', 9, 'CREATED', 'REPORT', 
    'Reserve Depreciation AcHd');

call INSERT_REPORT_GROUP('SCRF3015');
-- End Version [Script Version - 0.0.294] [ReleaseVersion - 9.2.2.12]--[12-Jul-2019] -- By Sanju

-- Start Version [Script Version - 0.0.295] [ReleaseVersion - 9.2.2.12]--[15-Jul-2019] -- By Sanju

CREATE OR REPLACE PROCEDURE RDACHD_UPDATE (ACHDID VARCHAR,INCACHD VARCHAR,EXPACHD VARCHAR) AS 
BEGIN
 MERGE INTO RESERVE_DEPRECIATION_ACHD RDAH USING (SELECT AH.AC_HD_ID FROM AC_HD AH WHERE AH.AC_HD_ID= ACHDID)
 H ON (
        RDAH.AC_HD_ID = ACHDID
        ) WHEN MATCHED THEN
  UPDATE SET  RDAH.INC_AC_HD=INCACHD, RDAH.EXP_AC_HD=EXPACHD
        WHEN NOT MATCHED THEN

        INSERT (AC_HD_ID, INC_AC_HD, EXP_AC_HD)
        VALUES (ACHDID, INCACHD, EXPACHD);
COMMIT;
END RDACHD_UPDATE;

CREATE OR REPLACE function GETACHD_DESC(ACHD VARCHAR2) RETURN VARCHAR2 IS
    ACHD_NAME VARCHAR2(128);
BEGIN
    SELECT  AC_HD_DESC INTO ACHD_NAME FROM AC_HD WHERE AC_HD_ID=ACHD;
    RETURN ACHD_NAME;
    EXCEPTION WHEN OTHERS THEN RETURN NULL;
END;
-- End Version [Script Version - 0.0.295] [ReleaseVersion - 9.2.2.12]--[15-Jul-2019] -- By Sanju

-- Start Version [Script Version - 0.0.296] [ReleaseVersion - 9.2.2.12]--[16-Jul-2019] -- By Suresh R
ALTER TABLE MULTIPLE_MSG_TO_SINGLE_MSG ADD  (SCREEN_NAME  VARCHAR2(128 BYTE));

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCRS06122', '6122', 'Indent Closing', 'APP01', 'DONE', 
    '30', 'com.see.truetransact.ui.indend.IndentClosingUI', 8, 'CREATED', NULL, 
    NULL, NULL);
COMMIT;

call INSERT_REPORT_GROUP('SCRS06122');

SET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INDEND_STOCK_TYPE', 'DAMAGE', 'DAMAGE', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INDEND_STOCK_TYPE', 'DEFICIT', 'DEFICIT', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INDEND_STOCK_TYPE', 'CLOSING', 'CLOSING', 'CREATED', NULL, 
    'Y');
COMMIT;

CREATE TABLE INDEND_CLOSE_STOCK
(
  DEPID               VARCHAR2(32 BYTE),
  CLOSING_DT          DATE,
  CLOSING_AMT         NUMBER(16,2),
  CLOS_PERC_LESS_AMT  NUMBER(16,2),
  STOCK_TYPE          VARCHAR2(7 BYTE),
  CLOSE_STOCK_TYPE    VARCHAR2(9 BYTE),
  BRANCH_CODE         VARCHAR2(16 BYTE),
  STATUS_DT           DATE                      DEFAULT SYSDATE,
  STATUS_BY           VARCHAR2(16 BYTE),
  STATUS              VARCHAR2(16 BYTE)
);

ALTER TABLE DEPO_MASTER ADD (PROFIT_PERCENTAGE NUMBER(5,2));

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCRS06123', '6123', 'Reserve/Depreciation Entry', 'APP01', 'DONE', 
    '30', 'com.see.truetransact.ui.indend.IndentClosingUI', 9, 'CREATED', NULL, 
    NULL, NULL);
COMMIT;

call INSERT_REPORT_GROUP('SCRS06123');

CREATE TABLE RESERVE_DEPRECIATION
(
  RD_ID        VARCHAR2(16 BYTE),
  AC_HD_ID     VARCHAR2(16 BYTE)                NOT NULL,
  AC_HD_DESC   VARCHAR2(128 BYTE),
  BRANCH_CODE  VARCHAR2(16 BYTE),
  FIN_DT       DATE,
  AMOUNT       NUMBER(16,2),
  RES_OR_DEPR  VARCHAR2(1 BYTE),
  STATUS_DT    DATE                             DEFAULT SYSDATE
);

SET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INDEND_CLOSE_TYPE', 'DEPRECIATION', 'DEPRECIATION', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INDEND_CLOSE_TYPE', 'RESERVE', 'RESERVE', 'CREATED', NULL, 
    'Y');
COMMIT;

SET DEFINE OFF;
Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('RESERVE_DEP_ID', 0, 'RD', TO_DATE('06/18/2004 17:42:56', 'MM/DD/YYYY HH24:MI:SS'), 10, 
    '0001');
COMMIT;

CREATE OR REPLACE FUNCTION CALC_INDEND_CLOSING_AMT(DEPOID VARCHAR,CLOSEDT DATE, BRANCHCODE VARCHAR, STOCKTYPE VARCHAR) RETURN NUMBER IS
 CLOSEAMT NUMBER (16, 2);
 LASTYEARCLOSEAMT NUMBER (16, 2);
 INDEND_PURCHASE_AMT NUMBER (16, 2);
 SALE_PURCHASE_RETUTN1 NUMBER (16, 2);
 SALE_PURCHASE_RETUTN2 NUMBER (16, 2);
 LASTTEAREND_DT DATE;
BEGIN
    SELECT ADD_MONTHS(CLOSEDT, -12) INTO LASTTEAREND_DT FROM DUAL;
     
    SELECT NVL(CLOSING_AMT,0) INTO LASTYEARCLOSEAMT FROM INDEND_CLOSE_STOCK CS WHERE CLOSING_DT=LASTTEAREND_DT AND STOCK_TYPE=STOCKTYPE
    AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;
    
    SELECT SUM(NVL(AMOUNT,0)) INTO INDEND_PURCHASE_AMT  FROM INDEND_REGISTER WHERE STATUS!='DELETED' AND AUTHORIZE_STATUS='AUTHORIZED'
    AND TRANS_TYPE IN('Purchase','Sales Return') AND TRAN_DATE BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;
    
    SELECT SUM(NVL(TT.AMOUNT,0)) INTO SALE_PURCHASE_RETUTN1 FROM TRANSFER_TRANS TT, INDEND_REGISTER IR WHERE TT.STATUS!='DELETED' 
    AND TT.AUTHORIZE_STATUS='AUTHORIZED' AND AC_HD_ID IN((SELECT DISTINCT PUR_RET_AC_HD_ID FROM DEPO_MASTER WHERE DEPOID=DEPOID)) 
    AND TRANS_DT BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND IR.IRID=LINK_BATCH_ID AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE; 
    
    SELECT SUM(NVL(TT.AMOUNT,0)) INTO SALE_PURCHASE_RETUTN2 FROM TRANSFER_TRANS TT, INDEND_REGISTER IR WHERE TT.STATUS!='DELETED' 
    AND TT.AUTHORIZE_STATUS='AUTHORIZED' AND AC_HD_ID IN((SELECT DISTINCT SALES_AC_HD_ID FROM DEPO_MASTER WHERE DEPOID=DEPOID)) 
    AND TRANS_DT BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND IR.IRID=LINK_BATCH_ID AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;

    CLOSEAMT:=NVL(LASTYEARCLOSEAMT,0)+NVL(INDEND_PURCHASE_AMT,0)-NVL(SALE_PURCHASE_RETUTN1,0)-NVL(SALE_PURCHASE_RETUTN2,0);
    
   RETURN CLOSEAMT;
 END;
/

ALTER TABLE DEPO_MASTER ADD (STOCK_AC_HD_ID VARCHAR2 (16));

CREATE OR REPLACE FUNCTION RESERVE_PREV_CLOSING_AMT(ACHDID VARCHAR,CLOSEDT DATE, BRANCHCODE VARCHAR) RETURN NUMBER IS
 PREV_CLOSEAMT NUMBER (16, 2);
  LASTTEAREND_DT DATE;
BEGIN
    SELECT ADD_MONTHS(CLOSEDT, -12) INTO LASTTEAREND_DT FROM DUAL;
     
    SELECT NVL(AMOUNT,0) INTO PREV_CLOSEAMT FROM RESERVE_DEPRECIATION WHERE RES_OR_DEPR='R' AND FIN_DT=LASTTEAREND_DT AND AC_HD_ID=ACHDID AND BRANCH_CODE=BRANCHCODE;
    
   RETURN PREV_CLOSEAMT;
 END;
/
-- End Version [Script Version - 0.0.296] [ReleaseVersion - 9.2.2.12]--[16-Jul-2019] -- By Suresh R


-- Start Version [Script Version - 0.0.297] [ReleaseVersion - 9.2.2.13]--[25-Jul-2019] -- By Sathiya

ALTER TABLE SMS_ACKNOWLEDGMENT ADD ACK_ID VARCHAR(128);

ALTER TABLE SMS_ACKNOWLEDGMENT ADD PROCESSED_COUNT NUMERIC(3) DEFAULT 1;

CREATE OR REPLACE PROCEDURE SMS_ACKNLOWLEDGE_UPDATE(MSG VARCHAR2, ACKNOWLEDGE VARCHAR2, 
PHONENO  NUMERIC, SENDDT  DATE, SMSID VARCHAR2,ACTNUM VARCHAR2,SMSMODULE VARCHAR2,ACKNOWLEDGE_ID VARCHAR2,PROCESS_COUNT NUMERIC) AS
BEGIN 
MERGE INTO SMS_ACKNOWLEDGMENT SMSA USING (SELECT * FROM SMS_SUBSCRIPTION SMSS WHERE SMSS.ACT_NUM = ACTNUM OR SMSS.CUST_ID = ACTNUM AND 
SMSS.STATUS != 'DELETED' AND AUTHORIZE_STATUS = 'AUTHORIZED' AND ROWNUM = 1) H ON (
SMSA.ACT_NUM = ACTNUM AND SMSA.SMS_ID = SMSID
) WHEN MATCHED THEN
UPDATE SET SMSA.ACKNOWLEDGMENT = ACKNOWLEDGE,SMSA.ACK_ID = ACKNOWLEDGE_ID,SMSA.PROCESSED_COUNT = PROCESS_COUNT
WHEN NOT MATCHED THEN
INSERT (SMSA.MESSAGE, SMSA.ACKNOWLEDGMENT, SMSA.PHONE_NO, SMSA.SEND_DATE, SMSA.SMS_ID, SMSA.ACT_NUM, SMSA.SMS_MODULE, 
SMSA.CREATED_DT, SMSA.ACK_ID)
VALUES (MSG, ACKNOWLEDGE, PHONENO, SENDDT, SMSID, ACTNUM,SMSMODULE, (SELECT SYSDATE FROM DUAL), ACKNOWLEDGE_ID);
COMMIT;
END SMS_ACKNLOWLEDGE_UPDATE;

ALTER TABLE CBMS_PARAMETERS ADD DESCRIPTION VARCHAR2(256)

ALTER TABLE PARAMETERS DROP COLUMN SMS_ALLOWED

Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE,DESCRIPTION)
 Values
   ('SMS_SCHEDULE_END_HRS', '20','Railway Time format need to provide EX: 20 - 8PM');
   
Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE,DESCRIPTION)
 Values
   ('SMS_SCHEDULE_PERIOD_INTERVAL_MIN', '240','Every schedule will run on particular time interval');   
   
Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE,DESCRIPTION)
 Values
   ('SMS_PROCESSING_COUNT', '2','This will check each account count and this, If exceeds will not execute');  

Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE,DESCRIPTION)
 Values
   ('SMS_ALLOWED', 'Y','If the flag Y then will work');  

ALTER TABLE SMS_SUBSCRIPTION ADD (CHEQUE_BOOK_REQUEST varchar2(2), CHEQUE_BOOK_STOP varchar2(2))

ALTER TABLE SMS_SUBSCRIPTION ADD (DR_CASH_LIMIT numeric(14,2),CR_CASH_LIMIT numeric(14,2),DR_TRANSFER_LIMIT numeric(14,2),
CR_TRANSFER_LIMIT numeric(14,2),ACT_BALANCE_LIMIT numeric(14,2))

CREATE TABLE NB_REQUEST_MAINTENANCE (CUST_ID VARCHAR2(16), ACT_NUM VARCHAR(16),REQUESTED_SCREEN VARCHAR(32), CARD_NO NUMBER(14,2),STATUS VARCHAR2(16),
STATUS_BY VARCHAR2(16),STATUS_DT DATE, AUTHORIZE_STATUS VARCHAR2(16),AUTHORIZE_BY VARCHAR2(16), AUTHORIZE_DATE DATE)

ALTER TABLE NB_REQUEST_MAINTENANCE ADD (CHEQUE_BOOK_REQUEST NUMERIC(6),NO_OF_CHEQUE_LEAVES NUMERIC(14),USAGE_TYPE VARCHAR2(16))

ALTER TABLE NB_REQUEST_MAINTENANCE ADD (START_CHEQUE_NO NUMERIC(6),END_CHEQUE_NO NUMERIC(14),STOP_CHEQUE_REASON VARCHAR2(32))

ALTER TABLE INTBK_PAYEE ADD (STATUS VARCHAR2(12), STATUS_BY VARCHAR2(32), STATUS_DT DATE, LIMIT_AMOUNT NUMERIC(14,2),
AUTHORIZE_STATUS VARCHAR2(12), AUTHORIZE_BY VARCHAR2(32), AUTHORIZE_DT DATE)

ALTER TABLE INTBK_PAYEE ADD ACCT_STATUS VARCHAR2(16)

-- End Version [Script Version - 0.0.297] [ReleaseVersion - 9.2.2.13]--[25-Jul-2019] -- By Sathiya

-- Start Version [Script Version - 0.0.298] [ReleaseVersion - 9.2.2.13]--[30-Jul-2019] -- By Nithya K
CREATE OR REPLACE FUNCTION CHECK_MINOR_DEPOSIT (ACTNUM VARCHAR2,BRANCHCODE VARCHAR2) RETURN VARCHAR2 IS
MINOR VARCHAR2(16);
AGE NUMBER(3);
DOB DATE;
CURRDT DATE;
BEGIN
SELECT C.DOB INTO DOB FROM CUSTOMER C WHERE C.CUST_ID = (SELECT D.CUST_ID FROM DEPOSIT_ACINFO D WHERE D.DEPOSIT_NO = ACTNUM);
SELECT D.CURR_APPL_DT INTO CURRDT FROM DAY_END D WHERE D.BRANCH_CODE = BRANCHCODE;
IF DOB IS NOT NULL THEN 
select floor ((MONTHS_BETWEEN (CURRDT, DOB)) / 12) INTO AGE from dual;
ELSE
AGE :=0;
END IF;
IF AGE < 18 AND AGE != 0 THEN
MINOR := 'MINOR';
ELSE
MINOR := 'MAJOR';
END IF;
RETURN MINOR;
END;
/

ALTER TABLE DEPOSIT_SUB_ACINFO_SAMENO ADD RENEWED_DT DATE;

ALTER TABLE ARC_CHARGE_DEFINITION ADD ARC_FEE_ROUNDOFF VARCHAR2(30);

CREATE OR REPLACE FUNCTION CHECK_GDS_BANK_ADVANCE_DONE (GROUPNO VARCHAR2,BRANCHCODE VARCHAR2) RETURN VARCHAR2 IS
BANK_ADVANCE_STATUS VARCHAR2(16);
NO_OF_CHITAL NUMBER(3);
CURRDT DATE;
BEGIN
SELECT D.CURR_APPL_DT INTO CURRDT FROM DAY_END D WHERE D.BRANCH_CODE = BRANCHCODE;
select count(*) into NO_OF_CHITAL from MDS_BANK_ADVANCE mds
where MDS.SCHEME_NAME in ( select MS.SCHEME_NAME from MDS_SCHEME_DETAILS ms, GROUP_DEPOSIT gd where  
GD.GROUP_NO = MS.GROUP_NO and MS.GROUP_NO = GROUPNO and GD.BRANCH_ID = BRANCHCODE )
and to_char(to_date(MDS.BANK_ADV_DT),'MM-YYYY')  = to_char(to_date(CURRDT),'MM-YYYY') ;
IF NO_OF_CHITAL > 0 THEN
BANK_ADVANCE_STATUS := 'DONE';
ELSE
BANK_ADVANCE_STATUS := 'PENDING';
END IF;
RETURN BANK_ADVANCE_STATUS;
END;
/

ALTER TABLE DEPOSITS_PROD_SCHEME  ADD DD_TRANS_ENTRY VARCHAR2(1);

SET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('FREQUENCY', '0', 'USER_DEFINED_GOLD_LOAN', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('LOAN.FREQUENCY', '0', 'USER_DEFINED_GOLD_LOAN', 'CREATED', NULL, 
    'Y');
COMMIT;
-- End Version [Script Version - 0.0.298] [ReleaseVersion - 9.2.2.13]--[30-Jul-2019] -- By Nithya K

-- Start Version [Script Version - 0.0.299] [ReleaseVersion - 9.2.2.13]--[13-Aug-2019] -- By Suresh R
CREATE OR REPLACE FUNCTION CALC_INDEND_CLOSING_AMT(DEPOID VARCHAR,CLOSEDT DATE, BRANCHCODE VARCHAR, STOCKTYPE VARCHAR) RETURN NUMBER IS
 CLOSEAMT NUMBER (16, 2);
 LASTYEARCLOSEAMT NUMBER (16, 2);
 INDEND_PURCHASE_AMT NUMBER (16, 2);
 SALE_PURCHASE_RETUTN1 NUMBER (16, 2);
 SALE_PURCHASE_RETUTN2 NUMBER (16, 2);
 LASTTEAREND_DT DATE;
BEGIN
    SELECT ADD_MONTHS(CLOSEDT, -12) INTO LASTTEAREND_DT FROM DUAL;
    /*SELECT NVL(CLOSING_AMT,0) INTO LASTYEARCLOSEAMT FROM INDEND_CLOSE_STOCK CS WHERE CLOSING_DT=LASTTEAREND_DT AND STOCK_TYPE=STOCKTYPE
    AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;
    SELECT SUM(NVL(AMOUNT,0)) INTO INDEND_PURCHASE_AMT  FROM INDEND_REGISTER WHERE STATUS!='DELETED' AND AUTHORIZE_STATUS='AUTHORIZED'
    AND TRANS_TYPE IN('Purchase','Sales Return') AND TRAN_DATE BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;
    SELECT SUM(NVL(TT.AMOUNT,0)) INTO SALE_PURCHASE_RETUTN1 FROM ALL_TRANS TT WHERE TT.STATUS!='DELETED' 
    AND TT.AUTHORIZE_STATUS='AUTHORIZED' AND AC_HD_ID IN((SELECT DISTINCT PUR_RET_AC_HD_ID FROM DEPO_MASTER WHERE DEPOID=DEPOID)) 
    AND TRANS_DT BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND TT.BRANCH_ID=BRANCHCODE; 
    SELECT SUM(NVL(TT.AMOUNT,0)) INTO SALE_PURCHASE_RETUTN2 FROM ALL_TRANS TT WHERE TT.STATUS!='DELETED' 
    AND TT.AUTHORIZE_STATUS='AUTHORIZED' AND AC_HD_ID IN((SELECT DISTINCT SALES_AC_HD_ID FROM DEPO_MASTER WHERE DEPOID=DEPOID)) 
    AND TRANS_DT BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND TT.BRANCH_ID=BRANCHCODE;
    CLOSEAMT:=NVL(LASTYEARCLOSEAMT,0)+NVL(INDEND_PURCHASE_AMT,0)-NVL(SALE_PURCHASE_RETUTN1,0)-NVL(SALE_PURCHASE_RETUTN2,0);
    */
    SELECT  (NVL(SUM(NVL(CLOSING_AMT,0)),0)+NVL(SUM(NVL(IR.PURCHASE_AMT,0)),0)) - NVL(SUM(NVL(IR.AMOUNT,0)),0) INTO CLOSEAMT      
            FROM INDEND_CLOSE_STOCK IT 
            JOIN  DEPO_MASTER  DM ON DM.DEPID = IT.DEPID 
            LEFT JOIN (SELECT  BRANCH_CODE,DEPID,SUM((CASE WHEN TRANS_TYPE = 'Purchase' THEN 1 WHEN TRANS_TYPE = 'Purchase' THEN -1 ELSE 0 END) * PURCHASE_AMT ) AS PURCHASE_AMT 
            ,SUM((CASE WHEN TRANS_TYPE = 'Sales Return' THEN -1 WHEN TRANS_TYPE = 'Sales' THEN 1 ELSE 0 END) * AMOUNT ) AS AMOUNT 
            FROM INDEND_REGISTER WHERE TRAN_DATE BETWEEN LASTTEAREND_DT+1 AND CLOSEDT   AND  AUTHORIZE_STATUS='AUTHORIZED' AND   STATUS NOT IN('DELETED' ) AND  
            TRANS_TYPE IN('Purchase','Purchase Return','Sales','Sales Return') GROUP BY BRANCH_CODE,DEPID ) IR  
            ON IR.DEPID  = IT.DEPID  AND IR.BRANCH_CODE = IT.BRANCH_CODE
            WHERE IT.STOCK_TYPE='CLOSING' AND IT.CLOSING_DT = LASTTEAREND_DT 
            AND DM.DEPID=DEPOID AND IT.BRANCH_CODE=BRANCHCODE
            AND ((DM.DEPID ||IT.BRANCH_CODE) NOT IN(SELECT DEPID ||BRANCH_CODE FROM INDEND_CLOSE_STOCK IT  
            WHERE STOCK_TYPE='CLOSING' AND CLOSING_DT = CLOSEDT))
            GROUP BY DM.DEPID,DM.DEPO_NAME,IT.BRANCH_CODE,DM.STOCK_AC_HD_ID,PROFIT_PERCENTAGE;
    IF(CLOSEAMT<=0) THEN 
        CLOSEAMT:=0;
    END IF;
   RETURN CLOSEAMT;
 END;
/
-- End Version [Script Version - 0.0.299] [ReleaseVersion - 9.2.2.13]--[13-Aug-2019] -- By Suresh R

-- Start Version [Script Version - 0.0.300] [ReleaseVersion - 9.2.2.14]--[11-Oct-2019] -- By Kannan AR
Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE)
 Values
   ('EXECUTE_SI_DAY_BEGIN', 'N');
-- End Version [Script Version - 0.0.300] [ReleaseVersion - 9.2.2.14]--[11-Oct-2019] -- By Kannan AR

-- Start Version [Script Version - 0.0.301] [ReleaseVersion - 9.2.2.14]--[15-Oct-2019] -- By Sanju

ALTER TABLE BORROWING_MASTER ADD  ACT_STATUS varchar2(32);

ALTER TABLE BORROWING_MASTER ADD  CLOSED_DATE DATE;

ALTER TABLE INVESTMENT_MASTER ADD  ACCT_STATUS varchar2(32);

ALTER TABLE INVESTMENT_MASTER ADD  CLOSE_DT DATE;

-- End Version [Script Version - 0.0.301] [ReleaseVersion - 9.2.2.14]--[15-Oct-2019] -- By Sanju

-- Start Version [Script Version - 0.0.302] [ReleaseVersion - 9.2.2.14]--[18-Oct-2019] -- By Nithya

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS ADD BANK_ADV_FORFIET VARCHAR2(1) DEFAULT 'N';

ALTER TABLE MDS_ACCT_HEAD ADD  PART_PAY_BONUS_RECOVERY VARCHAR(16);

Insert into LOOKUP_MASTER
(LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
AUTHORIZED)
Values
('ACCOUNTS_OTHER_BANK', 'BR', 'Borrowings', 'CREATED', 'Y', 
'Y');

-- End Version [Script Version - 0.0.302] [ReleaseVersion - 9.2.2.14]--[18-Oct-2019] -- By Nithya

-- Start Version [Script Version - 0.0.303] [ReleaseVersion - 9.2.2.14]--[22-Oct-2019] -- By Nithya

ALTER TABLE DEPOSITS_PROD_RD ADD RD_CLOSING_SB_DEPOSIT_ROI VARCHAR2(1) DEFAULT 'N';

ALTER TABLE DEPOSITS_PROD_RD ADD RD_CLOSING_PENAL_REQUIRED VARCHAR2(1) DEFAULT 'N';

ALTER TABLE DEPOSITS_PROD_SCHEME ADD DEATH_CLAIM_INT VARCHAR2(1) DEFAULT 'Y';

ALTER TABLE  DEPOSITS_PROD_RD ADD PRE_CLOSE_INT_PROD_ID VARCHAR2(8);

ALTER TABLE DEPOSITS_PROD_RD ADD PRE_CLOSE_INT_METHOD VARCHAR2(30);

ALTER TABLE  DEPOSITS_PROD_RD ADD NORMAL_CLOSE_INT_PROD_ID VARCHAR2(8);

ALTER TABLE DEPOSITS_PROD_RD ADD NORMAL_CLOSE_INT_METHOD VARCHAR2(30);

CREATE OR REPLACE FUNCTION CALCULATE_CLOSING_INT_RATE (DEPOSITNO VARCHAR2,CUSTID VARCHAR2,INTPRODID VARCHAR2,INTPRODTYPE VARCHAR2,DEPOSITDT DATE,BRANCHCODE VARCHAR2) RETURN VARCHAR2 IS
BANK_ADVANCE_STATUS VARCHAR2(16);
RATE_OF_INT NUMBER(16,2);
CURRDT DATE;
PRODTYPE VARCHAR2(8);
NOOFDAYS NUMBER(16);
BEGIN
SELECT D.CURR_APPL_DT INTO CURRDT FROM DAY_END D WHERE D.BRANCH_CODE = BRANCHCODE;
SELECT CURRDT - DEPOSITDT INTO NOOFDAYS FROM DUAL;
IF INTPRODTYPE = 'SB Rate' THEN
   PRODTYPE := 'OA';
ELSE  
   PRODTYPE := 'TD';
END IF;
SELECT NVL(ROI,0) INTO RATE_OF_INT
  FROM deposit_roi_group_type_rate drgtr,
       deposit_roi_group_cat drgc,
       deposit_acinfo da,
       deposit_roi_group drg,
       deposit_roi_group_prod drgp
 WHERE da.cust_id = CUSTID
   AND da.deposit_no = DEPOSITNO
   AND da.CATEGORY = drgc.category_id
   AND drgtr.roi_group_id = drgp.roi_group_id
   AND drgp.prod_id = INTPRODID
   AND drgp.roi_group_id = drgc.roi_group_id
   AND drg.product_type = PRODTYPE
   AND drgc.roi_group_id = drg.roi_group_id
   AND (   (DEPOSITDT BETWEEN drgtr.roi_date AND drgtr.roi_end_date)
        OR (drgtr.roi_date <= DEPOSITDT AND drgtr.roi_end_date IS NULL)
       )
   AND drg.status != 'DELETED'
   AND drgp.status != 'DELETED'
   AND drgc.status != 'DELETED'
   AND drgtr.status != 'DELETED'
   AND NOOFDAYS BETWEEN from_period AND to_period;   
   RETURN RATE_OF_INT;
END;
/

CREATE OR REPLACE FUNCTION GET_RD_CLOSING_INT_RATE (DEPOSITNO VARCHAR2,PRODID VARCHAR2,CLOSING_METHOD VARCHAR2,BRANCHCODE VARCHAR2) RETURN VARCHAR2 IS
PRECLOSUREPRODID VARCHAR2(8);
PRECLOSUREMETHOD VARCHAR2(30);
NORMALCLOSUREPRODID VARCHAR2(8);
NORMALCLOSUREMETHOD VARCHAR2(30);
RATEOFINT NUMBER(16,2);
DEPOSITDT DATE;
CUSTID VARCHAR2(30);
BEGIN
SELECT PRE_CLOSE_INT_PROD_ID,PRE_CLOSE_INT_METHOD ,NORMAL_CLOSE_INT_PROD_ID,NORMAL_CLOSE_INT_METHOD  INTO PRECLOSUREPRODID,PRECLOSUREMETHOD,
NORMALCLOSUREPRODID,NORMALCLOSUREMETHOD FROM DEPOSITS_PROD_RD 
WHERE PROD_ID = PRODID;
SELECT D.DEPOSIT_DT, DS.CUST_ID INTO DEPOSITDT,CUSTID FROM DEPOSIT_SUB_ACINFO D,DEPOSIT_ACINFO DS 
WHERE DS.DEPOSIT_NO = D.DEPOSIT_NO AND D.DEPOSIT_NO = DEPOSITNO;
IF CLOSING_METHOD = 'PRECLOSE' THEN
   RATEOFINT := CALCULATE_CLOSING_INT_RATE(DEPOSITNO,CUSTID,PRECLOSUREPRODID,PRECLOSUREMETHOD,DEPOSITDT,BRANCHCODE);
ELSE
   RATEOFINT := CALCULATE_CLOSING_INT_RATE(DEPOSITNO,CUSTID,NORMALCLOSUREPRODID,NORMALCLOSUREMETHOD,DEPOSITDT,BRANCHCODE);
END IF;
RETURN RATEOFINT;
END;
/

CREATE OR REPLACE FUNCTION GET_RD_CLOSING_OTHER_RATE_INT (DEPOSITNO VARCHAR2,ROI NUMBER,BRANCHCODE VARCHAR2) RETURN NUMBER IS
int_amt NUMBER(16,2);
CURRDT DATE;
BEGIN
SELECT D.MATURITY_DT INTO CURRDT FROM DEPOSIT_SUB_ACINFO D WHERE D.DEPOSIT_NO = DEPOSITNO;
SELECT nvl(SUM ((dr.amount * ROI * (CURRDT - dr.trans_dt))
            / 36500
           ),0) INTO int_amt
  FROM deposit_acinfo da JOIN deposit_recurring dr
       ON dr.deposit_no_sub = da.deposit_no || '_1'
 WHERE da.deposit_no = DEPOSITNO
   AND dr.trans_dt IS NOT NULL;
RETURN int_amt;
END;
/

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('RATE_SELECTION', 'Deposit Rate', 'Deposit Rate', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('RATE_SELECTION', 'SB Rate', 'SB Rate', 'CREATED', NULL, 
    'Y');

-- End Version [Script Version - 0.0.303] [ReleaseVersion - 9.2.2.14]--[22-Oct-2019] -- By Nithya

-- Start Version [Script Version - 0.0.304] [ReleaseVersion - 9.2.2.14]--[23-Oct-2019] -- By Nithya

SET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SMSPRODUCTS', 'OA', 'Operative Account', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SMSPRODUCTS', 'TD', 'Deposits', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SMSPRODUCTS', 'TL', 'Term Loans', 'CREATED', 'N', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SMSPRODUCTS', 'MDS', 'MDS', 'CREATED', NULL, 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('SMSPRODUCTS', 'SHARE', 'Share', 'CREATED', NULL, 
    'Y');
COMMIT;

-- End Version [Script Version - 0.0.304] [ReleaseVersion - 9.2.2.14]--[23-Oct-2019] -- By Nithya

-- Start Version [Script Version - 0.0.305] [ReleaseVersion - 9.2.2.14]--[24-Oct-2019] -- By Kannan AR
CREATE OR REPLACE FUNCTION isTransferTransInterBranch(INIT_BRANCH varchar2, TRN_DT date, BATCH_NO varchar2) return number is 
cnt number(5):=0;
begin
SELECT COUNT (*) into cnt
                      FROM transfer_trans TT2
                     WHERE (INITIATED_BRANCH, TRANS_DT, BATCH_ID) IN
                              (SELECT INITIATED_BRANCH, TRANS_DT, BATCH_ID
                                 FROM TRANSFER_TRANS TT1
                                WHERE     TT1.INITIATED_BRANCH !=
                                             TT1.BRANCH_ID
                                      AND TT1.TRANS_DT = TRN_DT
                                      AND TT1.INITIATED_BRANCH =
                                             INIT_BRANCH
                                      AND TT1.BATCH_ID = BATCH_NO);
return cnt;
end;

CREATE OR REPLACE FUNCTION isCashTransInterBranch(INIT_BRANCH varchar2, TRN_DT date, BATCH_NO varchar2) return number is 
cnt number(5):=0;
begin
SELECT COUNT (*) into cnt
                      FROM cash_trans CT2
                     WHERE (INITIATED_BRANCH, TRANS_DT, TRANS_ID) IN
                              (SELECT INITIATED_BRANCH, TRANS_DT, TRANS_ID
                                 FROM cash_trans CT1
                                WHERE     CT1.INITIATED_BRANCH !=
                                             CT1.BRANCH_ID
                                      AND CT1.TRANS_DT = TRN_DT
                                      AND CT1.INITIATED_BRANCH =
                                             INIT_BRANCH
                                      AND CT1.TRANS_ID = BATCH_NO);
return cnt;
end;

/* Formatted on 17-10-2019 12:15:29 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FORCE VIEW ALL_TRANS
(
   TRANS_ID,
   BATCH_ID,
   AC_HD_ID,
   ACT_NUM,
   AMOUNT,
   TRANS_DT,
   TRANS_TYPE,
   INST_TYPE,
   INST_DT,
   TOKEN_NO,
   INIT_TRANS_ID,
   INIT_CHANN_TYPE,
   PARTICULARS,
   STATUS,
   INSTRUMENT_NO1,
   INSTRUMENT_NO2,
   PROD_ID,
   PROD_TYPE,
   AUTHORIZE_STATUS,
   AUTHORIZE_BY,
   AUTHORIZE_DT,
   AUTHORIZE_REMARKS,
   STATUS_BY,
   BRANCH_ID,
   STATUS_DT,
   TRANS_MODE,
   INITIATED_BRANCH,
   AUTHORIZE_STATUS_2,
   LINK_BATCH_ID,
   PAYMENT_STATUS,
   GL_TRANS_ACT_NUM,
   NARRATION,
   SINGLE_TRANS_ID,
   TRANS_MOD_TYPE,
   SCREEN_NAME,
   INTERBRANCH_FLAG
)
AS
   (SELECT "TRANS_ID",
           '' AS "BATCH_ID",
           "AC_HD_ID",
           "ACT_NUM",
           "AMOUNT",
           "TRANS_DT",
           "TRANS_TYPE",
           "INST_TYPE",
           "INST_DT",
           "TOKEN_NO",
           "INIT_TRANS_ID",
           "INIT_CHANN_TYPE",
           "PARTICULARS",
           "STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           "AUTHORIZE_STATUS",
           "AUTHORIZE_BY",
           "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           "STATUS_BY",
           "BRANCH_ID",
           "STATUS_DT",
           'CASH' AS "TRANS_MODE",
           "INITIATED_BRANCH",
           "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           "PAYMENT_STATUS",
           gl_trans_act_num AS "GL_TRANS_ACT_NUM",
           narration AS "NARRATION",
           single_trans_id AS "SINGLE_TRANS_ID",
           trans_mod_type AS "TRANS_MOD_TYPE",
           screen_name AS "SCREEN_NAME",
          CASE
              WHEN (isCashTransInterBranch (initiated_branch, trans_dt, TRANS_ID)) > 0
              THEN
                 'Y'
              ELSE
                 'N'
           END
              AS "INTERBRANCH_FLAG"
      FROM "CASH_TRANS"
    UNION ALL
    SELECT "TRANS_ID",
           "BATCH_ID",
           "AC_HD_ID",
           "ACT_NUM",
           "AMOUNT",
           "TRANS_DT",
           "TRANS_TYPE",
           "INST_TYPE",
           "INST_DT",
           NULL AS "TOKEN_NO",
           "INIT_TRANS_ID",
           "INIT_CHANN_TYPE",
           "PARTICULARS",
           "STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           "AUTHORIZE_STATUS",
           "AUTHORIZE_BY",
           "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           "STATUS_BY",
           "BRANCH_ID",
           "STATUS_DT",
           "TRANS_MODE",
           "INITIATED_BRANCH",
           "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS",
           gl_trans_act_num AS "GL_TRANS_ACT_NUM",
           narration AS "NARRATION",
           single_trans_id AS "SINGLE_TRANS_ID",
           trans_mod_type AS "TRANS_MOD_TYPE",
           screen_name AS "SCREEN_NAME",
           CASE
              WHEN (isTransferTransInterBranch (initiated_branch, trans_dt, BATCH_ID)) > 0
              THEN
                 'Y'
              ELSE
                 'N'
           END
              AS "INTERBRANCH_FLAG"
      FROM transfer_trans
    UNION ALL
    SELECT "INWARD_ID" AS "TRANS_ID",
           NULL AS "BATCH_ID",
           "AC_HD_ID",
           "ACCT_NO" AS "ACT_NUM",
           "AMOUNT",
           "CLEARING_DT" AS "TRANS_DT",
           'DEBIT' AS "TRANS_TYPE",
           "INSTRUMENT_TYPE" AS "INST_TYPE",
           "INSTRUMENT_DT" AS "INST_DT",
           NULL AS "TOKEN_NO",
           "SUSER_ID" AS "INIT_TRANS_ID",
           "INITIATED_BRANCH" AS "INIT_CHANN_TYPE",
           '' AS "PARTICULARS",
           "STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           "AUTHORIZE_STATUS",
           "AUTHORIZE_BY",
           "AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           "CREATED_BY" AS "STATUS_BY",
           "BRANCH_ID",
           "S_DATE" AS "STATUS_DT",
           'CLEARING' AS "TRANS_MODE",
           "INITIATED_BRANCH",
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID",
           '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME",
           'N' AS "INTERBRANCH_FLAG"
      FROM inward_clearing
     WHERE     authorize_status != 'REJECTED'
           AND inward_id NOT IN (SELECT inward_id FROM inward_bouncing)
    UNION ALL
    SELECT ib.bouncing_id AS trans_id,
           NULL AS batch_id,
           ic.ac_hd_id,
           ic.acct_no AS act_num,
           ib.amount,
           ib.clearing_date AS trans_dt,
           'CREDIT' AS trans_type,
           ic.instrument_type AS "INST_TYPE",
           ic.instrument_dt AS "INST_DT",
           NULL AS "TOKEN_NO",
           ib.status_by AS "INIT_TRANS_ID",
           ic.initiated_branch AS init_chann_type,
           'INWARD RETURN : ' || ib.bouncing_reason AS particulars,
           ib.status,
           ic.instrument_no1,
           ic.instrument_no2,
           ic.prod_id,
           ic.prod_type,
           ib.authorize_status,
           ib.authorize_by,
           ib.authorize_dt,
           ic.authorize_remarks,
           ib.status_by,
           ib.branch_id,
           ib.status_dt,
           'CLEARING' AS "TRANS_MODE",
           ib.branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID",
           '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME",
           'N' AS "INTERBRANCH_FLAG"
      FROM inward_bouncing ib, inward_clearing ic
     WHERE ic.authorize_status = 'REJECTED' AND ib.inward_id = ic.inward_id
    UNION ALL
    SELECT oc.batch_id AS "TRANS_ID",
           oc.schedule_no AS "BATCH_ID",
           pis.ac_hd_id AS "AC_HD_ID",
           pis.acct_no AS "ACT_NUM",
           DECODE (t.table_name, 'OUTWARD_CLEARING', oc.amount, pis.amount)
              AS amount,
           oc.outward_dt AS "TRANS_DT",
           'CREDIT' AS "TRANS_TYPE",
           '' AS "INST_TYPE",
           NULL AS "INST_DT",
           NULL AS "TOKEN_NO",
           oc.status_by AS "INIT_TRANS_ID",
           oc.branch_id AS "INIT_CHANN_TYPE",
           'By oclg' AS "PARTICULARS",
           oc.status,
           '' AS "instrument_no1",
           '' AS "instrument_no2",
           '' AS "PROD_ID",
           '' AS "PROD_TYPE",
           'AUTHORIZED' AS authorize_status,
           oc.authorize_by,
           oc.authorize_dt,
           oc.authorize_remarks,
           oc.status_by,
           oc.branch_id,
           oc.status_dt,
           'CLEARING' AS "TRANS_MODE",
           oc.branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID",
           '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME",
           'N' AS "INTERBRANCH_FLAG"
      FROM outward_clearing oc,
           pay_in_slip pis,
           outward_tally ot,
           (  SELECT batch_id,
                     DECODE (COUNT (*), 1, 'PAY_IN_SLIP', 'OUTWARD_CLEARING')
                        AS table_name
                FROM outward_clearing
            GROUP BY batch_id) t
     WHERE     oc.batch_id = t.batch_id
           AND pis.batch_id = t.batch_id
           AND ot.schedule_no = oc.schedule_no
           AND ot.tally_status = 'CLOSED'
    UNION ALL
    SELECT trans_id AS "TRANS_ID",
           NULL AS "BATCH_ID",
           ac_hd_id,
           NULL AS "ACT_NUM",
           amount,
           trans_dt,
           trans_type,
           inst_type,
           inst_dt,
           NULL AS "TOKEN_NO",
           init_trans_id,
           init_chann_type,
           particulars,
           status,
           instrument_no1,
           instrument_no2,
           prod_id,
           prod_type,
           'AUTHORIZED' AS authorize_status,
           NULL AS authorize_by,
           NULL AS authorize_dt,
           NULL AS authorize_remarks,
           NULL AS status_by,
           branch_id,
           status_dt,
           trans_mode,
           branch_id AS initiated_branch,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID",
           '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME",
           'N' AS "INTERBRANCH_FLAG"
      FROM trans_ref_gl
     WHERE trans_mode = 'CLEARING'
    UNION ALL
    SELECT otr.return_id AS "TRANS_ID",
           otr.batch_id AS "BATCH_ID",
           '' AS "AC_HD_ID",
           otr.acct_no AS actnum,
           otr.amount,
           otr.clearing_date AS "TRANS_DT",
           'DEBIT' AS trans_type,
           otc.instrument_type AS inst_type,
           otc.instrument_dt AS "INST_DT",
           NULL AS "TOKEN_NO",
           otr.status_by AS "INIT_TRANS_ID",
           otr.branch_id AS "INIT_CHANN_TYPE",
           'OUTWARD RETURN : ' || otc.authorize_remarks AS patriculars,
           otr.status,
           otr.instrument_no1,
           otr.instrument_no2,
           '' AS "PROD_ID",
           '' AS "PROD_TYPE",
           otr.authorize_status,
           otr.authorize_by,
           otr.authorize_dt,
           otr.authorize_remarks,
           otr.status_by,
           otr.branch_id,
           otr.status_dt,
           'CLEARING' AS "TRANS_MODE",
           otr.initiated_branch,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           '' AS "PAYMENT_STATUS",
           '' AS "GL_TRANS_ACT_NUM",
           '' AS "NARRATION",
           '' AS "SINGLE_TRANS_ID",
           '' AS "TRANS_MOD_TYPE",
           '' AS "SCREEN_NAME",
           'N' AS "INTERBRANCH_FLAG"
      FROM outward_return otr, outward_clearing otc
     WHERE otc.authorize_status = 'REJECTED' AND otr.batch_id = otc.batch_id);

/* Formatted on 17-10-2019 12:15:09 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FORCE VIEW ALL_TRANSACTIONS_VIEW
(
   TRANS_ID,
   BATCH_ID,
   AC_HD_ID,
   ACT_NUM,
   AMOUNT,
   TRANS_DT,
   TRANS_TYPE,
   INST_TYPE,
   INST_DT,
   PARTICULARS,
   STATUS,
   INSTRUMENT_NO1,
   INSTRUMENT_NO2,
   PROD_ID,
   PROD_TYPE,
   AUTHORIZE_STATUS,
   AUTHORIZE_BY,
   STATUS_BY,
   STATUS_DT,
   TRANS_MODE,
   BRANCH_ID,
   INITIATED_BRANCH,
   AUTHORIZE_STATUS_2,
   SINGLE_TRANS_ID,
   LINK_BATCH_ID,
   TRANS_MOD_TYPE,
   NARRATION,
   INTERBRANCH_FLAG
)
AS
   SELECT trans_id,
          batch_id,
          ac_hd_id,
          NVL (act_num, link_batch_id),
          amount,
          trans_dt,
          trans_type,
          inst_type,
          inst_dt,
          particulars,
          status,
          instrument_no1,
          instrument_no2,
          prod_id,
          prod_type,
          authorize_status,
          authorize_by,
          status_by,
          status_dt,
          trans_mode,
          branch_id,
          initiated_branch,
          authorize_status_2,
          single_trans_id,
          link_batch_id,
          trans_mod_type,
          narration,INTERBRANCH_FLAG
     FROM (SELECT trans_id,
                  batch_id,
                  ac_hd_id,
                  act_num,
                  amount,
                  trans_dt,
                  trans_type,
                  inst_type,
                  inst_dt,
                  particulars,
                  status,
                  instrument_no1,
                  instrument_no2,
                  prod_id,
                  prod_type,
                  authorize_status,
                  authorize_by,
                  status_by,
                  status_dt,
                  trans_mode,
                  branch_id,
                  initiated_branch,
                  authorize_status_2,
                  single_trans_id,
                  link_batch_id,
                  trans_mod_type,
                  narration,INTERBRANCH_FLAG
             FROM all_trans
           /* Script added for updating dayend balance of Daily Deposit accounts */
           UNION ALL
           SELECT TO_CHAR (trans_id),
                  batch_id,
                  (SELECT acct_head
                     FROM deposits_product
                    WHERE prod_id = SUBSTR (acc_num, 5, 3))
                     AS ac_hd_id,
                  acc_num AS act_num,
                  amount,
                  trn_dt AS trans_dt,
                  trans_type,
                  '' AS inst_type,
                  NULL AS inst_dt,
                  particulars,
                  status,
                  '' AS instrument_no1,
                  '' AS instrument_no2,
                  SUBSTR (acc_num, 5, 3) AS prod_id,
                  prod_type,
                  authorize_status,
                  authorize_by,
                  '' AS status_by,
                  trn_dt AS status_dt,
                  trans_mode,
                  SUBSTR (acc_num, 1, 4) AS branch_id,
                  initiated_branch,
                  '' AS authorize_status_2,
                  '' AS single_trans_id,
                  '' AS link_batch_id,
                  '' AS trans_mod_type,
                  '' AS narration,
                  'N' AS INTERBRANCH_FLAG
             FROM daily_deposit_trans
           ORDER BY status_dt);

/* Formatted on 17-10-2019 15:52:22 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FORCE VIEW ALL_INTERBRANCH_VIEW
(
   TRANS_ID,
   BATCH_ID,
   AC_HD_ID,
   AC_HD_DESC,
   ACT_NUM,
   AMOUNT,
   TRANS_DT,
   TRANS_TYPE,
   INST_TYPE,
   INST_DT,
   PARTICULARS,
   STATUS,
   INSTRUMENT_NO1,
   INSTRUMENT_NO2,
   PROD_ID,
   PROD_TYPE,
   AUTHORIZE_STATUS,
   AUTHORIZE_BY,
   STATUS_BY,
   STATUS_DT,
   TRANS_MODE,
   BRANCH_ID,
   INITIATED_BRANCH,
   IBR_BRANCH,
   IBR_INITIATED_BRANCH,
   AUTHORIZE_STATUS_2,
   INTERBRANCH_FLAG,
   IBR_TRANS_MODE
)
AS
     SELECT "TRANS_ID",
            "BATCH_ID",
            "AC_HD_ID",
            "AC_HD_DESC",
            "ACT_NUM",
            "AMOUNT",
            "TRANS_DT",
            "TRANS_TYPE",
            "INST_TYPE",
            "INST_DT",
            "PARTICULARS",
            "STATUS",
            "INSTRUMENT_NO1",
            "INSTRUMENT_NO2",
            "PROD_ID",
            "PROD_TYPE",
            "AUTHORIZE_STATUS",
            "AUTHORIZE_BY",
            "STATUS_BY",
            "STATUS_DT",
            "TRANS_MODE",
            "BRANCH_ID",
            "INITIATED_BRANCH",
            IBR_BRANCH,
            IBR_INITIATED_BRANCH,
            "AUTHORIZE_STATUS_2",
            "INTERBRANCH_FLAG",
            IBR_TRANS_MODE
       FROM INTERBRANCH_VIEW
   ORDER BY status_dt;

/* Formatted on 17-10-2019 15:52:36 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FORCE VIEW INTERBRANCH_VIEW
(
   TRANS_ID,
   BATCH_ID,
   AC_HD_ID,
   AC_HD_DESC,
   ACT_NUM,
   AMOUNT,
   TRANS_DT,
   TRANS_TYPE,
   INST_TYPE,
   INST_DT,
   TOKEN_NO,
   INIT_TRANS_ID,
   INIT_CHANN_TYPE,
   PARTICULARS,
   STATUS,
   INSTRUMENT_NO1,
   INSTRUMENT_NO2,
   PROD_ID,
   PROD_TYPE,
   AUTHORIZE_STATUS,
   AUTHORIZE_BY,
   AUTHORIZE_DT,
   AUTHORIZE_REMARKS,
   STATUS_BY,
   BRANCH_ID,
   STATUS_DT,
   TRANS_MODE,
   INITIATED_BRANCH,
   IBR_BRANCH,
   IBR_INITIATED_BRANCH,
   AUTHORIZE_STATUS_2,
   LINK_BATCH_ID,
   INTERBRANCH_FLAG,
   IBR_TRANS_MODE
)
AS
   (SELECT "TRANS_ID",
           CT.TRANS_ID AS "BATCH_ID",
           CT."AC_HD_ID",
           AH."AC_HD_DESC",
           "ACT_NUM",
           "AMOUNT",
           "TRANS_DT",
           "TRANS_TYPE",
           "INST_TYPE",
           "INST_DT",
           "TOKEN_NO",
           "INIT_TRANS_ID",
           "INIT_CHANN_TYPE",
           "PARTICULARS",
           CT."STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           CT."AUTHORIZE_STATUS",
           CT."AUTHORIZE_BY",
           CT."AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           CT."STATUS_BY",
           "BRANCH_ID",
           CT."STATUS_DT",
           'TRANSFER' AS "TRANS_MODE",
           "INITIATED_BRANCH",
           "BRANCH_ID" AS IBR_BRANCH,
           "INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           CASE
              WHEN (SELECT COUNT (*)
                      FROM CASH_TRANS
                     WHERE     CT.TRANS_DT = TRANS_DT
                           AND CT.INITIATED_BRANCH != BRANCH_ID
                           AND CT.INITIATED_BRANCH = INITIATED_BRANCH
                           AND CT.TRANS_ID = TRANS_ID) > 0
              THEN
                 'Y'
              ELSE
                 'N'
           END
              AS "INTERBRANCH_FLAG",
           'CASH' AS IBR_TRANS_MODE
      FROM "CASH_TRANS" CT, AC_HD AH
     WHERE AH.AC_HD_ID = CT.AC_HD_ID AND CT.INITIATED_BRANCH != CT.BRANCH_ID
    UNION ALL
    SELECT "TRANS_ID",
           CT.TRANS_ID AS "BATCH_ID",
           CT."AC_HD_ID",
           AH."AC_HD_DESC",
           "ACT_NUM",
           "AMOUNT",
           "TRANS_DT",
           "TRANS_TYPE",
           "INST_TYPE",
           "INST_DT",
           "TOKEN_NO",
           "INIT_TRANS_ID",
           "INIT_CHANN_TYPE",
           "PARTICULARS",
           CT."STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           CT."AUTHORIZE_STATUS",
           CT."AUTHORIZE_BY",
           CT."AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           CT."STATUS_BY",
           "BRANCH_ID",
           CT."STATUS_DT",
           'CASH' AS "TRANS_MODE",
           "INITIATED_BRANCH",
           "BRANCH_ID" AS IBR_BRANCH,
           "INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           'N' AS "INTERBRANCH_FLAG",
           'CASH' AS IBR_TRANS_MODE
      FROM "CASH_TRANS" CT, AC_HD AH
     WHERE AH.AC_HD_ID = CT.AC_HD_ID AND CT.INITIATED_BRANCH = CT.BRANCH_ID
    UNION ALL
    SELECT "TRANS_ID",
           "BATCH_ID",
           TT."AC_HD_ID",
           "AC_HD_DESC",
           "ACT_NUM",
           "AMOUNT",
           "TRANS_DT",
           "TRANS_TYPE",
           "INST_TYPE",
           "INST_DT",
           NULL AS "TOKEN_NO",
           "INIT_TRANS_ID",
           "INIT_CHANN_TYPE",
           "PARTICULARS",
           TT."STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           TT."AUTHORIZE_STATUS",
           TT."AUTHORIZE_BY",
           TT."AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           TT."STATUS_BY",
           "BRANCH_ID",
           TT."STATUS_DT",
           "TRANS_MODE",
           "INITIATED_BRANCH",
           "BRANCH_ID" AS IBR_BRANCH,
           "INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           "AUTHORIZE_STATUS_2",
           "LINK_BATCH_ID" AS "LINK_BATCH_ID",
           CASE
              WHEN (SELECT COUNT (*)
                      FROM transfer_trans TT1
                     WHERE (INITIATED_BRANCH, TRANS_DT, BATCH_ID) IN
                              (SELECT INITIATED_BRANCH, TRANS_DT, BATCH_ID
                                 FROM TRANSFER_TRANS TT1
                                WHERE     TT1.INITIATED_BRANCH !=
                                             TT1.BRANCH_ID
                                      AND TT1.TRANS_DT = TT.TRANS_DT
                                      AND TT1.INITIATED_BRANCH =
                                             TT.INITIATED_BRANCH
                                      AND TT1.BATCH_ID = TT.BATCH_ID)) > 0
              THEN
                 'Y'
              ELSE
                 'N'
           END
              AS "INTERBRANCH_FLAG",
           'TRANSFER' AS IBR_TRANS_MODE
      FROM transfer_trans TT, AC_HD AH
     WHERE AH.AC_HD_ID = TT.AC_HD_ID
    UNION ALL
    SELECT "INWARD_ID" AS "TRANS_ID",
           NULL AS "BATCH_ID",
           IC."AC_HD_ID",
           "AC_HD_DESC",
           "ACCT_NO" AS "ACT_NUM",
           "AMOUNT",
           "CLEARING_DT" AS "TRANS_DT",
           'DEBIT' AS "TRANS_TYPE",
           "INSTRUMENT_TYPE" AS "INST_TYPE",
           "INSTRUMENT_DT" AS "INST_DT",
           NULL AS "TOKEN_NO",
           "SUSER_ID" AS "INIT_TRANS_ID",
           "INITIATED_BRANCH" AS "INIT_CHANN_TYPE",
           '' AS "PARTICULARS",
           IC."STATUS",
           "INSTRUMENT_NO1",
           "INSTRUMENT_NO2",
           "PROD_ID",
           "PROD_TYPE",
           IC."AUTHORIZE_STATUS",
           IC."AUTHORIZE_BY",
           IC."AUTHORIZE_DT",
           "AUTHORIZE_REMARKS",
           "CREATED_BY" AS "STATUS_BY",
           "BRANCH_ID",
           "S_DATE" AS "STATUS_DT",
           'CLEARING' AS "TRANS_MODE",
           "INITIATED_BRANCH",
           "BRANCH_ID" AS IBR_BRANCH,
           "INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           'N' AS "INTERBRANCH_FLAG",
           'CLEARING' AS IBR_TRANS_MODE
      FROM inward_clearing ic, AC_HD AH
     WHERE     IC.authorize_status != 'REJECTED'
           AND AH.AC_HD_ID = IC.AC_HD_ID
           AND prod_type != 'RM'                            -- Added by Rajesh
           AND inward_id NOT IN
                  (SELECT inward_id
                     FROM inward_bouncing ib
                    WHERE ib.inward_schedule_no = ic.schedule_no)
    UNION ALL
    SELECT oc.batch_id AS "TRANS_ID",
           oc.schedule_no AS "BATCH_ID",
           pis.ac_hd_id AS "AC_HD_ID",
           "AC_HD_DESC",
           pis.acct_no AS "ACT_NUM",
           DECODE (t.table_name,
                   'OUTWARD_CLEARING', oc.amount,
                   (pis.amount + NVL (pis.convert_amt, 0)))
              AS amount,
           oc.outward_dt AS "TRANS_DT",
           'CREDIT' AS "TRANS_TYPE",
           '' AS "INST_TYPE",
           NULL AS "INST_DT",
           NULL AS "TOKEN_NO",
           oc.status_by AS "INIT_TRANS_ID",
           oc.branch_id AS "INIT_CHANN_TYPE",
           'By oclg' AS "PARTICULARS",
           oc.status,
           '' AS "instrument_no1",
           '' AS "instrument_no2",
           '' AS "PROD_ID",
           '' AS "PROD_TYPE",
           'AUTHORIZED' AS authorize_status,
           oc.authorize_by,
           oc.authorize_dt,
           oc.authorize_remarks,
           oc.status_by,
           oc.branch_id,
           oc.status_dt,
           'CLEARING' AS "TRANS_MODE",
           oc.INITIATED_BRANCH AS initiated_branch,
           OC."BRANCH_ID" AS IBR_BRANCH,
           OC."INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           'N' AS "INTERBRANCH_FLAG",
           'CLEARING' AS IBR_TRANS_MODE
      FROM outward_clearing oc,
           pay_in_slip pis,
           outward_tally ot,
           AC_HD AH,
           (  SELECT batch_id,
                     outward_dt,
                     schedule_no,
                     DECODE (COUNT (*), 1, 'PAY_IN_SLIP', 'OUTWARD_CLEARING')
                        AS table_name
                FROM outward_clearing, AC_HD AH
            GROUP BY batch_id, outward_dt, schedule_no) t
     WHERE     oc.batch_id = t.batch_id
           AND AH.AC_HD_ID = PIS.AC_HD_ID
           AND pis.batch_id = t.batch_id
           AND ot.schedule_no = oc.schedule_no
           AND ot.tally_status = 'CLOSED'
           AND oc.authorize_status = 'REALIZED'
           AND oc.schedule_no = pis.schedule_no
           AND oc.batch_id = pis.batch_id
           AND oc.outward_dt = pis.pay_in_slip_dt
           AND oc.outward_dt = t.outward_dt
           AND oc.schedule_no = t.schedule_no
           AND AH.AC_HD_ID = pis.AC_HD_ID
    UNION ALL
    SELECT (CASE
               WHEN LENGTH (TRANS_ID) > 10 THEN SUBSTR (TRANS_ID, 10, 17)
               ELSE TRANS_ID
            END)
              AS "TRANS_ID",
           (CASE
               WHEN LENGTH (TRANS_ID) > 10 THEN SUBSTR (TRANS_ID, 1, 8)
               ELSE TRANS_ID
            END)
              AS "BATCH_ID",
           TR.ac_hd_id,
           "AC_HD_DESC",
           NULL AS "ACT_NUM",
           amount,
           trans_dt,
           trans_type,
           inst_type,
           inst_dt,
           NULL AS "TOKEN_NO",
           init_trans_id,
           init_chann_type,
           particulars,
           TR.status,
           instrument_no1,
           instrument_no2,
           prod_id,
           prod_type,
           'AUTHORIZED' AS authorize_status,
           NULL AS authorize_by,
           NULL AS authorize_dt,
           NULL AS authorize_remarks,
           NULL AS status_by,
           branch_id,
           TR.status_dt,
           trans_mode,
           INITIATED_BRANCH AS initiated_branch,
           "BRANCH_ID" AS IBR_BRANCH,
           "INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           'N' AS "INTERBRANCH_FLAG",
           trans_mode AS IBR_TRANS_MODE
      FROM trans_ref_gl TR, AC_HD AH
     WHERE     trans_mode = 'CLEARING'
           AND trans_type = 'DEBIT'
           AND AH.AC_HD_ID = TR.AC_HD_ID
    UNION ALL
    SELECT (CASE
               WHEN LENGTH (TRANS_ID) > 10 THEN SUBSTR (TRANS_ID, 10, 17)
               ELSE TRANS_ID
            END)
              AS "TRANS_ID",
           (CASE
               WHEN LENGTH (TRANS_ID) > 10 THEN SUBSTR (TRANS_ID, 1, 8)
               ELSE TRANS_ID
            END)
              AS "BATCH_ID",
           trg.ac_hd_id,
           "AC_HD_DESC",
           NULL AS "ACT_NUM",
           trg.amount,
           trg.trans_dt,
           trg.trans_type,
           trg.inst_type,
           trg.inst_dt,
           NULL AS "TOKEN_NO",
           trg.init_trans_id,
           trg.init_chann_type,
           trg.particulars,
           trg.status,
           trg.instrument_no1,
           trg.instrument_no2,
           trg.prod_id,
           trg.prod_type,
           'AUTHORIZED' AS authorize_status,
           NULL AS authorize_by,
           NULL AS authorize_dt,
           NULL AS authorize_remarks,
           NULL AS status_by,
           trg.branch_id,
           trg.status_dt,
           trg.trans_mode,
           trg.INITIATED_BRANCH AS initiated_branch,
           TRG."BRANCH_ID" AS IBR_BRANCH,
           trg."INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           CASE
              WHEN (SELECT COUNT (*)
                      FROM trans_ref_gl
                     WHERE     trg.TRANS_DT = TRANS_DT
                           AND trg.INITIATED_BRANCH != BRANCH_ID
                           AND trg.INITIATED_BRANCH = INITIATED_BRANCH
                           AND trg.TRANS_ID = TRANS_ID) > 0
              THEN
                 'Y'
              ELSE
                 CASE
                    WHEN (SELECT COUNT (*)
                            FROM trans_ref_gl
                           WHERE     EXISTS
                                        (SELECT IBR_AC_HD
                                           FROM PARAMETERS
                                          WHERE trg.AC_HD_ID = IBR_AC_HD)
                                 AND trg.TRANS_DT = TRANS_DT
                                 AND trg.TRANS_ID = TRANS_ID
                                 AND trg.INITIATED_BRANCH = INITIATED_BRANCH) >
                            0
                    THEN
                       'Y'
                    ELSE
                       'N'
                 END
           END
              AS "INTERBRANCH_FLAG",
           TRG.trans_mode AS IBR_TRANS_MODE
      FROM trans_ref_gl trg, AC_HD AH
     WHERE            --trg.ac_hd_id IN (SELECT IBR_AC_HD FROM parameters) AND
          TRG  .AC_HD_ID = AH.AC_HD_ID
           AND TRG.status != 'DELETED'
           AND TRG.trans_mode <> 'CLEARING'
    UNION ALL
    SELECT trans_id AS "TRANS_ID",
           NULL AS "BATCH_ID",
           tr.ac_hd_id,
           "AC_HD_DESC",
           NULL AS "ACT_NUM",
           tr.amount,
           trans_dt,
           trans_type,
           inst_type,
           inst_dt,
           NULL AS "TOKEN_NO",
           init_trans_id,
           init_chann_type,
           particulars,
           tr.status,
           tr.instrument_no1,
           tr.instrument_no2,
           tr.prod_id,
           tr.prod_type,
           'AUTHORIZED' AS authorize_status,
           NULL AS authorize_by,
           NULL AS authorize_dt,
           NULL AS authorize_remarks,
           NULL AS status_by,
           tr.branch_id,
           TR.status_dt,
           trans_mode,
           tr.INITIATED_BRANCH AS initiated_branch,
           TR."BRANCH_ID" AS IBR_BRANCH,
           tr."INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           'N' AS "INTERBRANCH_FLAG",
           trans_mode AS IBR_TRANS_MODE
      FROM trans_ref_gl tr, inward_clearing ic, AC_HD AH
     WHERE     trans_mode = 'CLEARING'
           AND AH.AC_HD_ID = TR.AC_HD_ID
           AND trans_type = 'CREDIT'
           AND ic.inward_id = tr.trans_id
           AND ic.authorize_status = 'AUTHORIZED'
    UNION ALL
    SELECT otr.return_id AS "TRANS_ID",
           otr.batch_id AS "BATCH_ID",
           '' AS "AC_HD_ID",
           '' AS "AC_HD_DESC",
           otr.acct_no AS actnum,
           otr.amount,
           otr.clearing_date AS "TRANS_DT",
           'DEBIT' AS trans_type,
           otc.instrument_type AS inst_type,
           otc.instrument_dt AS "INST_DT",
           NULL AS "TOKEN_NO",
           otr.status_by AS "INIT_TRANS_ID",
           otr.branch_id AS "INIT_CHANN_TYPE",
           'OUTWARD RETURN : ' || otc.authorize_remarks AS patriculars,
           otr.status,
           otr.instrument_no1,
           otr.instrument_no2,
           '' AS "PROD_ID",
           '' AS "PROD_TYPE",
           otr.authorize_status,
           otr.authorize_by,
           otr.authorize_dt,
           otr.authorize_remarks,
           otr.status_by,
           otr.branch_id,
           otr.status_dt,
           'CLEARING' AS "TRANS_MODE",
           otr.initiated_branch,
           otr."INITIATED_BRANCH" AS IBR_INITIATED_BRANCH,
           OTR."BRANCH_ID" AS IBR_BRANCH,
           '' AS "AUTHORIZE_STATUS_2",
           '' AS "LINK_BATCH_ID",
           'N' AS "INTERBRANCH_FLAG",
           'CLEARING' AS IBR_TRANS_MODE
      FROM outward_return otr, outward_clearing otc
     WHERE otc.authorize_status = 'REJECTED' AND otr.batch_id = otc.batch_id);

-- End Version [Script Version - 0.0.305] [ReleaseVersion - 9.2.2.14]--[24-Oct-2019] -- By Kannan AR

-- Start Version [Script Version - 0.0.305] [ReleaseVersion - 9.2.2.14]--[25-Oct-2019] -- By Sanju

Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE)
 Values
   ('RISK_FUND_AGE_LIMIT', '70');

-- End Version [Script Version - 0.0.305] [ReleaseVersion - 9.2.2.14]--[25-Oct-2019] -- By Sanju

-- Start Version [Script Version - 0.0.306] [ReleaseVersion - 9.2.2.14]--[29-Oct-2019] -- By Nithya

ALTER TABLE LOANS_PRODUCT ADD GOLD_STOCK_PHOTO_REQUIRED VARCHAR2(1) DEFAULT 'N';

ALTER TABLE SECURITY_DETAILS ADD STOCK_PHOTO_FILE BLOB;

-- End Version [Script Version - 0.0.306] [ReleaseVersion - 9.2.2.14]--[29-Oct-2019] -- By Nithya

-- Start Version [Script Version - 0.0.307] [ReleaseVersion - 9.2.2.14]--[04-Nov-2019] -- By Rohit

Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE)
 Values
   ('LOAN_NOTICE_AUTO_AUTHORIZE', 'Y');

ALTER TABLE LOANS_ACCT_CHARGE_DETAILS ADD BATCH_ID VARCHAR2(14);
ALTER TABLE LOANS_ACCT_CHARGE_DETAILS ADD BRANCH_ID VARCHAR2(14);
ALTER TABLE LOANS_NOTICE_CHARGE_DETAILS	ADD NOTICE_TYPE VARCHAR2(32);

Insert into ID_GENERATION
   (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH, 
    BRANCH_CODE)
 Values
   ('AUTO_BATCH_ID', 1, 'BI', TO_DATE('05/05/2004 16:17:44', 'MM/DD/YYYY HH24:MI:SS'), 8, 
    '0004');

-- End Version [Script Version - 0.0.307] [ReleaseVersion - 9.2.2.14]--[04-Nov-2019] -- By Rohit

-- Start Version [Script Version - 0.0.308] [ReleaseVersion - 9.2.2.14]--[11-Nov-2019] -- By Sathiya

DROP TRIGGER ACT_BAL_TRIGGER;

CREATE OR REPLACE TRIGGER ACT_BAL_TRIGGER
   BEFORE UPDATE
   ON ACT_MASTER
   FOR EACH ROW
   WHEN (OLD.AVAILABLE_BALANCE != NEW.AVAILABLE_BALANCE)
DECLARE
   INVALID_BAL_AMT   EXCEPTION;

   PRAGMA EXCEPTION_INIT (INVALID_BAL_AMT, -20111);
BEGIN
   DBMS_OUTPUT.PUT_LINE (
         'clear_balance:'
      || :old.clear_balance
      || ' / old available_balance:'
      || :old.available_balance
      || ' / new available_balance:'
      || :new.available_balance);

   IF :OLD.CLEAR_BALANCE < :NEW.AVAILABLE_BALANCE
   THEN
      DBMS_OUTPUT.PUT_LINE ('Available Balance exceeding Clear Balance..');

      raise_application_error (
         -20111,
         'Available Balance exceeding Clear Balance...');
   END IF;
END;
/


/* Formatted on 11-11-2019 16:10:49 (QP5 v5.227.12220.39754) */
DROP TRIGGER ACT_FREEZE_TRIGGER;

CREATE OR REPLACE TRIGGER ACT_FREEZE_TRIGGER
   BEFORE UPDATE
   ON ACT_MASTER
   FOR EACH ROW
   WHEN (OLD.FREEZE_AMT != NEW.FREEZE_AMT)
DECLARE
   INVALID_FREEZE_AMT   EXCEPTION;

   PRAGMA EXCEPTION_INIT (INVALID_FREEZE_AMT, -20112);
BEGIN
   DBMS_OUTPUT.PUT_LINE (
         'clear_balance:'
      || :old.clear_balance
      || ' / available_balance:'
      || :old.available_balance
      || ' / FREEZE_AMT:'
      || :new.FREEZE_AMT);

   IF :NEW.FREEZE_AMT < 0
   THEN
      DBMS_OUTPUT.PUT_LINE ('Freeze amount going Negative..');

      raise_application_error (-20112, 'Freeze amount going Negative...');
   END IF;
END;
-- End Version [Script Version - 0.0.308] [ReleaseVersion - 9.2.2.14]--[11-Nov-2019] -- By Sathiya

-- Start Version [Script Version - 0.0.309] [ReleaseVersion - 9.2.2.15]--[25-Nov-2019] -- By Nithya

CREATE OR REPLACE FUNCTION check_gds_auction_required (
   groupno      VARCHAR2,
   branchcode   VARCHAR2
)
   RETURN VARCHAR2
IS
   auctionentryrequired   VARCHAR2 (16);
   no_of_chital           NUMBER (3);
   currdt                 DATE;
   totalpaidinst          NUMBER (3);
   bandadvinst            NUMBER (3);
   totalinsttobepaid      NUMBER (3);
   bankadvproduct         NUMBER (3);
BEGIN
   SELECT COUNT (*)
     INTO bankadvproduct
     FROM mds_scheme_details ms,
          group_deposit gd,
          mds_product_general_details mpg
    WHERE gd.group_no = ms.group_no
      AND ms.group_no = groupno
      AND gd.branch_id = branchcode
      AND ms.prod_id = mpg.prod_id
      AND mpg.default_chit_owners = 'Y'
      AND mpg.advance_collection = 'Y';

   IF bankadvproduct > 0
   THEN
      SELECT MAX (mp.installment_no)
        INTO bandadvinst
        FROM mds_prized_money_details mp
       WHERE mp.scheme_name IN (
                SELECT ms.scheme_name
                  FROM mds_scheme_details ms, group_deposit gd
                 WHERE gd.group_no = ms.group_no
                   AND ms.group_no = groupno
                   AND gd.branch_id = branchcode);

      SELECT COUNT (*)
        INTO no_of_chital
        FROM mds_bank_advance mds
       WHERE mds.scheme_name IN (
                SELECT ms.scheme_name
                  FROM mds_scheme_details ms, group_deposit gd
                 WHERE gd.group_no = ms.group_no
                   AND ms.group_no = groupno
                   AND gd.branch_id = branchcode)
         AND mds.installment_no = bandadvinst
         AND mds.authorize_status = 'AUTHORIZED';

      IF no_of_chital > 0
      THEN
         auctionentryrequired := 'Y';
      ELSE
         SELECT SUM (mds.no_of_inst)
           INTO totalpaidinst
           FROM mds_trans_details mds
          WHERE mds.scheme_name IN (
                   SELECT ms.scheme_name
                     FROM mds_scheme_details ms, group_deposit gd
                    WHERE gd.group_no = ms.group_no
                      AND ms.group_no = groupno
                      AND gd.branch_id = branchcode)
            AND mds.status NOT IN ('DELETED')
            AND mds.authorize_status = 'AUTHORIZED';

         SELECT SUM (mds.total_no_of_members) * bandadvinst
           INTO totalinsttobepaid
           FROM mds_scheme_details mds
          WHERE mds.scheme_name IN (
                   SELECT ms.scheme_name
                     FROM mds_scheme_details ms, group_deposit gd
                    WHERE gd.group_no = ms.group_no
                      AND ms.group_no = groupno
                      AND gd.branch_id = branchcode);

         IF totalpaidinst < totalinsttobepaid
         THEN
            auctionentryrequired := 'N';
         ELSE
            auctionentryrequired := 'Y';
         END IF;
      END IF;
   ELSE
      auctionentryrequired := 'Y';
   END IF;

   RETURN auctionentryrequired;
END;
/


ALTER TABLE LOANS_PRODUCT ADD BLOCK_IF_LIMIT_EXCEEDS VARCHAR2(1) DEFAULT 'N';

ALTER TABLE ACT_INTEREST_TRIAL ADD INT_POSTING_POSSIBLE VARCHAR2(1);


DROP TYPE TAB_TYPE_ADV_INTR;

CREATE OR REPLACE TYPE TYPE_ADV_INTR AS OBJECT
(
    ACTNUM      VARCHAR2(15),
    DEBITINT    NUMBER(16,2),
    PENALINT    NUMBER(16,2),
    CREDITINT   NUMBER(16,2),
    LIMIT_EXD_PST   VARCHAR2(1)
);

CREATE OR REPLACE TYPE  TAB_TYPE_ADV_INTR   AS TABLE OF TYPE_ADV_INTR;
/

CREATE OR REPLACE FUNCTION get_adv_crdr_interest (
   actnum   VARCHAR,
   fromdt   DATE,
   todat    DATE
)
   RETURN tab_type_adv_intr
AS
   PRAGMA AUTONOMOUS_TRANSACTION;
   tyadvintr         tab_type_adv_intr;
   crintrate         NUMBER (16, 2)    := 0;
   debitinterest     NUMBER (16, 2)    := 0;
   creditinterest    NUMBER (16, 2)    := 0;
   interest          VARCHAR2 (50);
   intget            VARCHAR2 (10);
   catg              VARCHAR2 (30);
   startdat          DATE;
   intfrmdt          DATE;
   enddt             DATE;
   limt              NUMBER (16);
   prodid            NUMBER (10);
   penalamt          NUMBER (16, 2)    := 0;
   intcol            NUMBER (16, 2)    := 0;
   pencol            NUMBER (16, 2)    := 0;
   penalrequired     VARCHAR (1)       := 'Y';
   calforlimtexeed   VARCHAR (1)       := 'N';
   limit_exd_pst     VARCHAR (1)       := 'Y';
   clrbalance        NUMBER (16, 2);
BEGIN
   DELETE FROM odintr_cal
         WHERE act_num = actnum AND frmdate = fromdt AND todate = todat;

   COMMIT;

   SELECT lfd.prod_id, lfd.int_get_from, lb.CATEGORY, lsd.from_dt,
          lsd.to_dt, lsd.LIMIT
     INTO prodid, intget, catg, startdat,
          enddt, limt
     FROM loans_facility_details lfd JOIN loans_sanction_details lsd
          ON lsd.borrow_no = lfd.borrow_no
          JOIN loans_borrower lb ON lb.borrow_no = lfd.borrow_no
    WHERE lfd.acct_num = actnum;

   INSERT INTO odintr_cal
               (act_num, dt, principal, prd, rt, llimit, duedt, penrate,
                penalamt, frmdate, todate)
      SELECT   act_num, trans_dt,
               SUM (principal) OVER (PARTITION BY act_num ORDER BY act_num,
                trans_dt) AS bal,
               (  TO_DATE (NVL (LEAD (trans_dt, 1) OVER (ORDER BY trans_dt),
                                todat
                               )
                          )
                - trans_dt
               ) AS prd,
               rt, limt, enddt,
               get_tl_penroi (prodid, actnum, startdat, limt, intget), 0,
               fromdt, todat
          FROM (SELECT act_num, TO_DATE (fromdt) /*-1*/ AS trans_dt,
                       (-1 * amt) AS principal, get_tl_roinew (actnum) AS rt
                  FROM advances_dayend_balance
                 WHERE act_num = actnum
                   AND day_end_dt =
                          (SELECT MAX (day_end_dt)
                             FROM advances_dayend_balance
                            WHERE act_num = actnum AND day_end_dt <= fromdt)
                                       /* COMENT  =  IF U PASS FROMDATE  01 */
                UNION ALL
                SELECT   act_num, trans_dt,
                         SUM ((DECODE (trans_type,
                                       'DEBIT', principle,
                                       -1 * principle
                                      )
                              )
                             ) principal,
                         get_tl_roinew (actnum) AS rt
                    FROM adv_trans_details
                   WHERE act_num = actnum
                     AND principle > 0
                     AND trans_dt BETWEEN   fromdt
                                          + 1 /*COMENT +1 IF U PASS FROMDATE  01 */ AND todat
                GROUP BY act_num, trans_dt) tr
      ORDER BY act_num, trans_dt;

   COMMIT;

   UPDATE odintr_cal
      SET todt = dt + prd
    WHERE act_num = actnum AND frmdate = fromdt AND todate = todat;

   COMMIT;

   UPDATE odintr_cal
      SET penalprd =
             CASE
                WHEN (CASE
                         WHEN dt >= duedt
                            THEN prd
                         ELSE (todt - duedt)
                      END) > 0
                   THEN (CASE
                            WHEN dt >= duedt
                               THEN prd
                            ELSE (todt - duedt)
                         END)
                ELSE 0
             END
    WHERE act_num = actnum AND frmdate = fromdt AND todate = todat;

   COMMIT;

   UPDATE odintr_cal
      SET intramt = (principal * prd * rt) / 36500.00
    WHERE principal >= 0
      AND act_num = actnum
      AND frmdate = fromdt
      AND todate = todat;

   COMMIT;

   --->CREDIT INTEREST CALC
   SELECT get_tl_roi_crint (prodid, catg, startdat, enddt, limt)
     INTO crintrate
     FROM DUAL;

   UPDATE odintr_cal
      SET intramt = (principal * prd * crintrate) / 36500.00
    WHERE principal < 0
      AND act_num = actnum
      AND frmdate = fromdt
      AND todate = todat;

   COMMIT;

   --->CREDIT INTEREST CALC
   SELECT   ROUND (SUM (CASE
                           WHEN principal > 0
                              THEN NVL (intramt, 0)
                           ELSE 0
                        END), 0),
            ROUND (SUM (CASE
                           WHEN principal > 0
                              THEN 0
                           ELSE NVL (intramt, 0)
                        END), 0)
       INTO debitinterest,
            creditinterest
       FROM odintr_cal
      WHERE act_num = actnum AND frmdate = fromdt AND todate = todat
   GROUP BY act_num;

   IF penalrequired = 'Y'
   THEN
      IF calforlimtexeed = 'Y'
      THEN
         UPDATE odintr_cal
            SET penalamt =
                     (  (CASE
                            WHEN principal > limt
                               THEN limt
                            ELSE principal
                         END)
                      * penalprd
                      * penrate
                     )
                   / 36500.00
          WHERE penalprd > 0
            AND principal >= 0
            AND NVL (penrate, 0) > 0
            AND frmdate = fromdt
            AND todate = todat;

         COMMIT;

         UPDATE odintr_cal
            SET penalamt =
                     NVL (penalamt, 0)
                   + (principal - limt * prd * penrate) / 36500.00
          WHERE prd > 0
            AND principal - limt > 0
            AND NVL (penrate, 0) > 0
            AND frmdate = fromdt
            AND todate = todat;

         COMMIT;
      ELSE
         UPDATE odintr_cal
            SET penalamt = (principal * penalprd * penrate) / 36500.00
          WHERE penalprd > 0
            AND principal >= 0
            AND NVL (penrate, 0) > 0
            AND frmdate = fromdt
            AND todate = todat;

         COMMIT;
      END IF;
   ELSE
      penalamt := 0;
   END IF;

   SELECT SUM (penalamt)
     INTO penalamt
     FROM odintr_cal
    WHERE act_num = actnum AND frmdate = fromdt AND todate = todat;
   penalamt := 0.0;
   limit_exd_pst := 'Y';
   SELECT type_adv_intr (actnum,
                         debitinterest,
                         penalamt,
                         creditinterest,
                         limit_exd_pst
                        )
   BULK COLLECT INTO tyadvintr
     FROM DUAL;

   RETURN tyadvintr;
END;
/

CREATE OR REPLACE FUNCTION get_limit_exceed_post (
   actnum   VARCHAR,
   fromdt   DATE,
   todt     DATE
)
   RETURN VARCHAR2
IS
   limitexceed   VARCHAR2 (20);
BEGIN
   SELECT limit_exd_pst
     INTO limitexceed
     FROM TABLE (get_adv_crdr_interest (actnum, fromdt, todt));
   RETURN limitexceed;
END;
/

ALTER TABLE MDS_MONEY_PAYMENT_DETAILS ADD PAYMENT_TAX_AMT NUMBER(16,2);

ALTER TABLE MDS_MONEY_PAYMENT_DETAILS ADD DEFAULTER_RECEIPT_TAX_AMT NUMBER(16,2);

-- End Version [Script Version - 0.0.309] [ReleaseVersion - 9.2.2.15]--[25-Nov-2019] -- By Nithya

-- Start Version [Script Version - 0.0.310] [ReleaseVersion - 9.2.2.15]--[28-Dec-2019] -- By Sathiya
CREATE TABLE CUSTOMER_OTP_DETAILS
(
  CUST_ID        VARCHAR2(14 BYTE),
  DR_ACT_NUM     VARCHAR2(14 BYTE),
  CR_ACT_NUM     VARCHAR2(14 BYTE),
  OTP_NUM        VARCHAR2(32 BYTE),
  CREATED_DT     DATE,
  TRANS_AMT      NUMBER(14,2),
  VALIDATED_OTP  VARCHAR2(1 BYTE)               DEFAULT 'N',
  TRANS_ID       VARCHAR2(32 BYTE)
)
-- End Version [Script Version - 0.0.310] [ReleaseVersion - 9.2.2.15]--[28-Dec-2019] -- By Sathiya

-- Start Version [Script Version - 0.0.311] [ReleaseVersion - 9.2.2.14]--[12-Dec-2019] -- By Rishad(Script merged from sprint 14 version by Sathiya)

-- Following function and type are created by GIBI 
CREATE OR REPLACE TYPE "TYPE_ACC_VALIDATE"    AS OBJECT
(
 VALDATE        INT,
 MSG            VARCHAR2(500),
 CLR_BAL        NUMBER(19,2),
 TRNS_BAL       NUMBER(19,2),
 PRODID         VARCHAR2(5),
 ACHDID         VARCHAR2(15),
 PRODTYPE       VARCHAR2(5),
 DR_SHDOW_BAL   NUMBER(19,2),
 CR_SHDOW_BAL   NUMBER(19,2), 
 DR_SHDOW_MST   NUMBER(19,2),
 CR_SHDOW_MST   NUMBER(19,2)
  );

CREATE OR REPLACE TYPE "TAB_TYPE_ACC_VALIDATE"    AS TABLE OF TYPE_ACC_VALIDATE; 
/

CREATE OR REPLACE PACKAGE PKG_APP_VALDATE
AS 
 -- SELECT * FROM TABLE(PKG_APP_VALDATE.ACCOUNT_VALIDATE ('0001104001277',0,0)); 
 FUNCTION  ACCOUNT_VALIDATE(ACTNUM VARCHAR2,PRNCRAMT NUMBER,PRNDRAMT NUMBER) RETURN TAB_TYPE_ACC_VALIDATE;
END PKG_APP_VALDATE;
/


CREATE OR REPLACE PACKAGE BODY PKG_APP_VALDATE AS
 FUNCTION  ACCOUNT_VALIDATE(ACTNUM VARCHAR2,PRNCRAMT NUMBER,PRNDRAMT NUMBER) RETURN TAB_TYPE_ACC_VALIDATE   IS
 VL  TAB_TYPE_ACC_VALIDATE;
 --- SELECT * FROM TABLE(PKG_APP_VALDATE.ACCOUNT_VALIDATE ('0001104001277',0,0));
 MSG            VARCHAR2(500):='';
 VALDATE        INT:=1;
 CLR_BAL        NUMBER(19,2):=0;
 TRNS_BAL       NUMBER(19,2):=0;
 PRODID         VARCHAR2(5);
 ACHDID         VARCHAR2(15);
 PRODTYPE       VARCHAR2(5);
 DR_SHDOW_BAL   NUMBER(19,2):=0;
 CR_SHDOW_BAL   NUMBER(19,2):=0;
 DR_SHDOW_MST   NUMBER(19,2):=0;
 CR_SHDOW_MST   NUMBER(19,2):=0;
 BEHVS          VARCHAR2(75);
 LMTAMT         NUMBER(19,2):=0;
 BEGIN
   SELECT SUBSTR(ACTNUM,5,3) INTO PRODID  FROM DUAL;
   SELECT  PROD_TYPE,AC_HD_ID,BEHAVES_LIKE  INTO  PRODTYPE,ACHDID,BEHVS  FROM ALL_PRODUCTS WHERE PROD_ID = PRODID;
   IF PRODTYPE ='OA' AND BEHVS <>'DAILY' THEN
      SELECT  CLEAR_BALANCE,SHADOW_CREDIT,SHADOW_DEBIT INTO CLR_BAL,CR_SHDOW_MST, DR_SHDOW_MST  FROM ACT_MASTER AM WHERE ACT_NUM = ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN -1* NVL(AMOUNT,0) ELSE  NVL(AMOUNT,0) END)  INTO  TRNS_BAL FROM ALL_TRANS AT
      JOIN OP_AC_PRODUCT OBP ON   OBP.PROD_ID=AT.PROD_ID AND OBP.AC_HD_ID=AT.AC_HD_ID
      WHERE  AT.AUTHORIZE_STATUS='AUTHORIZED' AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN   NVL(AMOUNT,0) ELSE  0 END),
      SUM(CASE WHEN TRANS_TYPE ='CREDIT' THEN   NVL(AMOUNT,0) ELSE  0 END)   INTO  DR_SHDOW_BAL,CR_SHDOW_BAL FROM ALL_TRANS AT
      JOIN OP_AC_PRODUCT OBP ON   OBP.PROD_ID=AT.PROD_ID AND OBP.AC_HD_ID=AT.AC_HD_ID
      JOIN  DAY_END DE  ON DE.CURR_APPL_DT = AT.TRANS_DT AND DE.BRANCH_CODE = AT.BRANCH_ID
      WHERE  AT.AUTHORIZE_STATUS IS NULL AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;  
      IF NVL(TRNS_BAL,0) <> NVL(CLR_BAL,0) THEN
       VALDATE:=0;
       MSG := MSG|| 'BALANCE MISMATCH, CLEAR BALANCE -' || CAST(CLR_BAL AS VARCHAR2) || ', TRANSACTION BALANCE - ' || CAST(TRNS_BAL AS VARCHAR2);
      ELSIF DR_SHDOW_MST <> DR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW DEBIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
      ELSIF  (NVL(CLR_BAL,0) - (NVL(DR_SHDOW_MST,0) +NVL(PRNDRAMT,0))) <0 THEN
        VALDATE:=0;
        MSG := MSG|| 'NOT ENOUGH BALANCE, CLEAR BALANCE = ' || CAST(CLR_BAL AS VARCHAR2)  ;                    
      /* ELSIF CR_SHDOW_MST  <> CR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW CREDIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
     */
      END IF;
   ELSIF PRODTYPE ='TD' AND BEHVS <>'DAILY' THEN  
      SELECT  CLEAR_BALANCE,SHADOW_CREDIT,SHADOW_DEBIT INTO CLR_BAL,CR_SHDOW_MST, DR_SHDOW_MST  FROM ACT_MASTER AM WHERE ACT_NUM = ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN -1* NVL(AMOUNT,0) ELSE  NVL(AMOUNT,0) END)  INTO  TRNS_BAL FROM ALL_TRANS AT
      JOIN DEPOSITS_PRODUCT DP ON   DP.PROD_ID=AT.PROD_ID AND DP.ACCT_HEAD=AT.AC_HD_ID
      WHERE  AT.AUTHORIZE_STATUS='AUTHORIZED' AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN   NVL(AMOUNT,0) ELSE  0 END),
      SUM(CASE WHEN TRANS_TYPE ='CREDIT' THEN   NVL(AMOUNT,0) ELSE  0 END)   INTO  DR_SHDOW_BAL,CR_SHDOW_BAL FROM ALL_TRANS AT
      JOIN DEPOSITS_PRODUCT DP ON   DP.PROD_ID=AT.PROD_ID AND DP.ACCT_HEAD=AT.AC_HD_ID
      JOIN  DAY_END DE  ON DE.CURR_APPL_DT = AT.TRANS_DT AND DE.BRANCH_CODE = AT.BRANCH_ID
      WHERE  AT.AUTHORIZE_STATUS IS NULL AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;  
      IF NVL(TRNS_BAL,0) <> NVL(CLR_BAL,0) THEN
       VALDATE:=0;
       MSG := MSG|| 'BALANCE MISMATCH, CLEAR BALANCE -' || CAST(CLR_BAL AS VARCHAR2) || ', TRANSACTION BALANCE - ' || CAST(TRNS_BAL AS VARCHAR2);
      ELSIF DR_SHDOW_MST <> DR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW DEBIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
      ELSIF  (NVL(CLR_BAL,0) - (NVL(DR_SHDOW_MST,0) +NVL(PRNDRAMT,0))) <0 THEN
        VALDATE:=0;
        MSG := MSG|| 'NOT ENOUGH BALANCE, CLEAR BALANCE = ' || CAST(CLR_BAL AS VARCHAR2)  ;                    
      /* ELSIF CR_SHDOW_MST  <> CR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW CREDIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
     */
      END IF;          
   ELSIF PRODTYPE ='AD' THEN  
      SELECT  -1*LFD.CLEAR_BALANCE AS CLEAR_BALANCE ,LFD.SHADOW_CREDIT,LFD.SHADOW_DEBIT,LSD.LIMIT INTO CLR_BAL,CR_SHDOW_MST, DR_SHDOW_MST,LMTAMT  FROM LOANS_FACILITY_DETAILS LFD
      JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO =LFD.BORROW_NO  WHERE LFD.ACCT_NUM = ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN  NVL(AMOUNT,0) ELSE  -1* NVL(AMOUNT,0) END)  INTO  TRNS_BAL FROM ALL_TRANS AT
      JOIN LOANS_PRODUCT LP ON   LP.PROD_ID=AT.PROD_ID AND LP.ACCT_HEAD=AT.AC_HD_ID
      WHERE  AT.AUTHORIZE_STATUS='AUTHORIZED' AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN   NVL(AMOUNT,0) ELSE  0 END),
      SUM(CASE WHEN TRANS_TYPE ='CREDIT' THEN   NVL(AMOUNT,0) ELSE  0 END)   INTO  DR_SHDOW_BAL,CR_SHDOW_BAL FROM ALL_TRANS AT
      JOIN LOANS_PRODUCT LP ON   LP.PROD_ID=AT.PROD_ID AND LP.ACCT_HEAD=AT.AC_HD_ID
      JOIN  DAY_END DE  ON DE.CURR_APPL_DT = AT.TRANS_DT AND DE.BRANCH_CODE = AT.BRANCH_ID
      WHERE  AT.AUTHORIZE_STATUS IS NULL AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;  
      IF NVL(TRNS_BAL,0) <> NVL(CLR_BAL,0) THEN
       VALDATE:=0;
       MSG := MSG|| 'BALANCE MISMATCH, CLEAR BALANCE -' || CAST(CLR_BAL AS VARCHAR2) || ', TRANSACTION BALANCE - ' || CAST(TRNS_BAL AS VARCHAR2);
      ELSIF DR_SHDOW_MST <> DR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW DEBIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
      ELSIF  (NVL(LMTAMT,0) - (NVL(CLR_BAL,0) + NVL(DR_SHDOW_MST,0) +NVL(PRNDRAMT,0))) <0 THEN
        VALDATE:=0;
        MSG := MSG|| 'NOT ENOUGH BALANCE, CLEAR BALANCE = ' || CAST(CLR_BAL AS VARCHAR2)  ;                    
      /* ELSIF CR_SHDOW_MST  <> CR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW CREDIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
     */
      END IF;  
   ELSIF PRODTYPE ='TL' THEN  
      SELECT  -1*LFD.CLEAR_BALANCE AS CLEAR_BALANCE,LFD.SHADOW_CREDIT,LFD.SHADOW_DEBIT,LSD.LIMIT INTO CLR_BAL,CR_SHDOW_MST, DR_SHDOW_MST,LMTAMT  FROM LOANS_FACILITY_DETAILS LFD
      JOIN LOANS_SANCTION_DETAILS LSD ON LSD.BORROW_NO =LFD.BORROW_NO  WHERE LFD.ACCT_NUM = ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN  NVL(AMOUNT,0) ELSE  -1* NVL(AMOUNT,0) END)  INTO  TRNS_BAL FROM ALL_TRANS AT
      JOIN LOANS_PRODUCT LP ON   LP.PROD_ID=AT.PROD_ID AND LP.ACCT_HEAD=AT.AC_HD_ID
      WHERE  AT.AUTHORIZE_STATUS='AUTHORIZED' AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;
      SELECT   SUM(CASE WHEN TRANS_TYPE ='DEBIT' THEN   NVL(AMOUNT,0) ELSE  0 END),
      SUM(CASE WHEN TRANS_TYPE ='CREDIT' THEN   NVL(AMOUNT,0) ELSE  0 END)   INTO  DR_SHDOW_BAL,CR_SHDOW_BAL FROM ALL_TRANS AT
      JOIN LOANS_PRODUCT LP ON   LP.PROD_ID=AT.PROD_ID AND LP.ACCT_HEAD=AT.AC_HD_ID
      JOIN  DAY_END DE  ON DE.CURR_APPL_DT = AT.TRANS_DT AND DE.BRANCH_CODE = AT.BRANCH_ID
      WHERE  AT.AUTHORIZE_STATUS IS NULL AND AT.STATUS NOT IN('DELETED' ) AND ACT_NUM  =ACTNUM;  
      IF NVL(TRNS_BAL,0) <> NVL(CLR_BAL,0) THEN
       VALDATE:=0;
       MSG := MSG|| 'BALANCE MISMATCH, CLEAR BALANCE -' || CAST(CLR_BAL AS VARCHAR2) || ', TRANSACTION BALANCE - ' || CAST(TRNS_BAL AS VARCHAR2);
      ELSIF DR_SHDOW_MST <> DR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW DEBIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
      ELSIF  (NVL(LMTAMT,0) - (NVL(CLR_BAL,0) + NVL(DR_SHDOW_MST,0) +NVL(PRNDRAMT,0))) <0 THEN
        VALDATE:=0;
        MSG := MSG|| 'NOT ENOUGH BALANCE, CLEAR BALANCE = ' || CAST(CLR_BAL AS VARCHAR2)  ;                    
      /* ELSIF CR_SHDOW_MST  <> CR_SHDOW_BAL THEN
        VALDATE:=0;
        MSG := MSG|| 'SHADOW CREDIT MISMATCH  -' || CAST(CR_SHDOW_MST AS VARCHAR2) || ', - ' || CAST(CR_SHDOW_BAL AS VARCHAR2);
     */
      END IF;    
/*            
  ELSIF PRODTYPE ='OA' AND BEHVS ='DAILY' THEN  
  ELSIF PRODTYPE ='TD' AND BEHVS ='DAILY'  THEN  
 */      
   END IF;  
    SELECT TYPE_ACC_VALIDATE(VALDATE , MSG , CLR_BAL , TRNS_BAL , PRODID , ACHDID, PRODTYPE , DR_SHDOW_BAL, CR_SHDOW_BAL,  DR_SHDOW_MST, CR_SHDOW_MST) BULK COLLECT
    INTO  VL FROM (SELECT VALDATE , MSG , CLR_BAL , TRNS_BAL , PRODID , ACHDID, PRODTYPE , DR_SHDOW_BAL, CR_SHDOW_BAL,  DR_SHDOW_MST, CR_SHDOW_MST FROM DUAL)VR  ;
    RETURN VL;
 END  ACCOUNT_VALIDATE;
 END PKG_APP_VALDATE;
/

-- End Version [Script Version - 0.0.311] [ReleaseVersion - 9.2.2.14]--[12-Dec-2019] -- By RIshad (Script merged from sprint 14 version by Sathiya)


-- Start Version [Script Version - 0.0.312] [ReleaseVersion - 9.2.2.15]--[05-Dec-2019] -- By Rishad


CREATE OR REPLACE FORCE VIEW ALL_EMPLOYEE_ACCOUNTS
(
   EMPLOYEE_ID,
   ACT_NUM,
   ACCT_STATUS
)
AS
   (SELECT E.EMPLOYEEID,
        E.NET_SALARY_ACC_NO AS ACT_NUM,
        AM.ACT_STATUS_ID AS ACCT_STATUS
   FROM EMPLOYEE_MASTER E, ACT_MASTER AM
  WHERE     AM.ACT_STATUS_ID = 'CLOSED'
        AND E.NET_SALARY_ACC_NO = AM.ACT_NUM
        AND E.EMP_STATUS = 'Service'
        AND E.AUTHORIZE_STATUS = 'AUTHORIZED'
        AND E.NET_SALARY_PROD_TYPE = 'OA'
 UNION ALL
 SELECT E.EMPLOYEEID,
        E.NET_SALARY_ACC_NO AS ACT_NUM,
        LFD.ACCT_STATUS AS ACCT_STATUS
   FROM EMPLOYEE_MASTER E, LOANS_FACILITY_DETAILS LFD
  WHERE     LFD.ACCT_STATUS = 'CLOSED'
        AND E.NET_SALARY_ACC_NO = LFD.ACCT_NUM
        AND E.EMP_STATUS = 'Service'
        AND E.AUTHORIZE_STATUS = 'AUTHORIZED'
        AND E.NET_SALARY_PROD_TYPE = 'AD');


CREATE OR REPLACE FUNCTION GET_TL_INT_COLL_NOTICE(LOAN_NUM VARCHAR2,FDATE DATE)
RETURN NUMBER IS
    INT_AMT NUMBER(16,2) := 0;
BEGIN
    BEGIN
        SELECT NVL(SUM(NVL(T.INTEREST,0)),0) INTO INT_AMT
        FROM LOAN_TRANS_DETAILS T
        WHERE T.ACT_NUM = LOAN_NUM AND T.TRANS_TYPE = 'CREDIT' AND T.TRANS_DT > FDATE ;
    EXCEPTION
        WHEN OTHERS THEN INT_AMT := 0;
    END;
    RETURN INT_AMT;
END;
/

ALTER TABLE RENEWAL_TEMP_DETAILS ADD (PREVIOUS_INT NUMBER(16,2) DEFAULT 0)


-- End Version [Script Version - 0.0.312] [ReleaseVersion - 9.2.2.15]--[05-dec-2019] -- By Rishad

-- Start Version [Script Version - 0.0.313] [ReleaseVersion - 9.2.2.15]--[01-Jan-2020] -- By Nithya

CREATE OR REPLACE FUNCTION get_gds_application_completed (
   groupno      VARCHAR2,
   branchcode   VARCHAR2
)
   RETURN VARCHAR2
IS
   applnentered          VARCHAR2 (16);
   total_amount_scheme   NUMBER (16, 2);
   currdt                DATE;
   applnsum              NUMBER (16, 2);
BEGIN
   SELECT NVL(SUM (msd.total_amount_scheme),0)
     INTO total_amount_scheme
     FROM mds_scheme_details msd
    WHERE msd.group_no = groupno AND msd.branch_code = branchcode;

   SELECT NVL (SUM (ma.inst_amt), 0)
     INTO applnsum
     FROM mds_application ma
    WHERE ma.scheme_name IN (
                     SELECT m.scheme_name
                       FROM mds_scheme_details m
                      WHERE m.group_no = groupno
                            AND m.branch_code = branchcode)
      AND ma.status != 'DELETED'
      AND (ma.authorize_status IS NULL OR ma.authorize_status = 'AUTHORIZED'
          );

   IF total_amount_scheme > applnsum
   THEN
      applnentered := 'N';
   ELSE
      applnentered := 'Y';
   END IF;

   RETURN applnentered;
END;
/

-- End Version [Script Version - 0.0.313] [ReleaseVersion - 9.2.2.15]--[01-Jan-2020] -- By Nithya

-- Start Version [Script Version - 0.0.314] [ReleaseVersion - 9.2.2.15]--[07-Jan-2020] -- By Sanju

 ALTER TABLE USER_MASTER ADD APPRAISER_ID  CHAR(1 BYTE);

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    SCREEN_DESC)
 Values
   ('SCRS6181', '9721', 'PassBook_New', 'APP01', 'DONE', 
    '8', 'rejected_list', 9, 'CREATED', 'REPORT', 
    'rejected_list');

    call INSERT_REPORT_GROUP('SCRS6181');

INSERT INTO LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,     AUTHORIZED)
   SELECT LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,     AUTHORIZED FROM 
  (SELECT 'GNPASSBOOK.MODULE' AS LOOKUP_ID , 'D' AS LOOKUP_REF_ID, 'Operative' AS LOOKUP_DESC, 'CREATED' AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL UNION ALL
   SELECT 'GNPASSBOOK.MODULE'  AS LOOKUP_ID , 'T' AS LOOKUP_REF_ID, 'Deposits' AS LOOKUP_DESC, 'CREATED' AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL UNION ALL
   SELECT 'GNPASSBOOK.MODULE'  AS LOOKUP_ID, 'A' AS LOOKUP_REF_ID, 'Advances' AS LOOKUP_DESC, 'CREATED'  AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL UNION ALL
   SELECT 'GNPASSBOOK.MODULE'  AS LOOKUP_ID, 'L' AS LOOKUP_REF_ID, 'TermLoans' AS LOOKUP_DESC, 'CREATED' AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL  UNION ALL
   SELECT 'GNPASSBOOK.MODULE' AS LOOKUP_ID, 'M' AS LOOKUP_REF_ID, 'MDS' AS LOOKUP_DESC, 'CREATED'  AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL)LK
   WHERE LOOKUP_REF_ID NOT IN(SELECT LOOKUP_REF_ID FROM LOOKUP_MASTER LM WHERE LM.LOOKUP_ID ='GNPASSBOOK.MODULE');

ALTER TABLE MDS_MASTER_MAINTENANCE ADD ( PASSBOOK_LINENO         NUMBER(5));

CREATE TABLE PARAM_SETTINGS
(
  PARAM_ID     INTEGER                          NOT NULL,
  EXCTYPE      INTEGER,
  PROD_ID      VARCHAR2(5 BYTE),
  BRANCH_ID    VARCHAR2(5 BYTE),
  PARAM_DESC   VARCHAR2(75 BYTE)                NOT NULL,
  PARAM_VALUE  VARCHAR2(75 BYTE)                NOT NULL,
  SAVE_DATE    DATE                             DEFAULT SYSDATE,
  SAVE_USER    VARCHAR2(75 BYTE),
  PAR_DET      VARCHAR2(75 BYTE)
);

INSERT INTO PARAM_SETTINGS
   (PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,     PARAM_VALUE, SAVE_DATE, SAVE_USER)
SELECT 11, NULL, NULL, NULL, 'PASSBOOK_OA', '30',  '01APR2019' , 'admin' FROM DUAL UNION ALL
SELECT 12, NULL, NULL, NULL, 'PASSBOOK_TD', '30',  '01APR2019' , 'admin' FROM DUAL UNION ALL
SELECT 13, NULL, NULL, NULL, 'PASSBOOK_AD', '30',  '01APR2019' , 'admin' FROM DUAL UNION ALL
SELECT 14, NULL, NULL, NULL, 'PASSBOOK_TL', '30',  '01APR2019' , 'admin' FROM DUAL;

CREATE INDEX INDXPARAM_SETTINGS_001 ON PARAM_SETTINGS(PARAM_ID, EXCTYPE, PROD_ID);  

CREATE INDEX INDXPARAM_SETTINGS_002 ON PARAM_SETTINGS(PARAM_DESC, PAR_DET);   

ALTER TABLE PARAM_SETTINGS ADD PAR_DET VARCHAR2(75);

CREATE TABLE GN_PASSBOOK (
    ACT_NUM       VARCHAR2(15),
    IDNO          INT ,
    TRANS_DT      DATE, 
    TRANS_ID      VARCHAR2(75),
    PRNCR         NUMBER(19,2),
    PRNDR         NUMBER(19,2),
    BAL           NUMBER(19,2), 
    INTR          NUMBER(19,2),
    PENAL         NUMBER(19,2),
    OTH_AMT       NUMBER(19,2),
    INSTR_NO1     VARCHAR2(25),
    INSTR_DT1     DATE,
    BONUS         NUMBER(19,2),
    NARR          VARCHAR2 (250) NULL ,
    POST_TAG      INT   DEFAULT (0),
    PAGENO        INT,
    SAVE_DT       DATE,
    RWID          VARCHAR2(75)
) ;

CREATE  GLOBAL TEMPORARY TABLE TMP_GN_PASSBOOK (
    ACT_NUM       VARCHAR2(15),
    IDNO          INT ,
    TRANS_DT      DATE, 
    TRANS_ID      VARCHAR2(75),
    PRNCR         NUMBER(19,2),
    PRNDR         NUMBER(19,2),
    BAL           NUMBER(19,2), 
    INTR          NUMBER(19,2),
    PENAL         NUMBER(19,2),
    OTH_AMT       NUMBER(19,2),
    INSTR_NO1     VARCHAR2(25),
    INSTR_DT1     DATE,
    BONUS         NUMBER(19,2),
    NARR          VARCHAR2 (250) NULL ,
    POST_TAG      INT   DEFAULT (0),
    PAGENO        INT,
    SAVE_DT       DATE,
    RWID          VARCHAR2(75)
     ) ON COMMIT PRESERVE ROWS; 

	INSERT INTO PARAM_SETTINGS(PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,PARAM_VALUE, SAVE_DATE, SAVE_USER,PAR_DET)
	(SELECT 11, NULL, NULL, NULL, 'PASSBOOK_OA', '38',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL UNION ALL
	SELECT 12, NULL, NULL, NULL, 'PASSBOOK_TD', '38',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL UNION ALL
	SELECT 13, NULL, NULL, NULL, 'PASSBOOK_AD', '38',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL UNION ALL
	SELECT 14, NULL, NULL, NULL, 'PASSBOOK_TL', '38',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL)
	
	INSERT INTO PARAM_SETTINGS(PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,     PARAM_VALUE, SAVE_DATE, SAVE_USER,PAR_DET)
	(SELECT 21, NULL, NULL, NULL, 'PASSBOOK_OA', '01APR2019',  '31MAR2019' , 'admin','PRINT_START_DT' FROM DUAL UNION ALL
	SELECT 22, NULL, NULL, NULL, 'PASSBOOK_TD', '01APR2019',  '31MAR2019' , 'admin','PRINT_START_DT' FROM DUAL UNION ALL
	SELECT 23, NULL, NULL, NULL, 'PASSBOOK_AD', '01APR2019',  '31MAR2019' , 'admin','PRINT_START_DT' FROM DUAL UNION ALL
	SELECT 24, NULL, NULL, NULL, 'PASSBOOK_TL', '01APR2019',  '31MAR2019' , 'admin','PRINT_START_DT' FROM DUAL);
	
	INSERT INTO PARAM_SETTINGS(PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,     PARAM_VALUE, SAVE_DATE, SAVE_USER,PAR_DET)
	(SELECT 31, NULL, NULL, NULL, 'PASSBOOK_OA', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL UNION ALL
	SELECT 34, NULL, NULL, NULL, 'PASSBOOK_TD', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL UNION ALL
	SELECT 36, NULL, NULL, NULL, 'PASSBOOK_AD', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL UNION ALL
	SELECT 39, NULL, NULL, NULL, 'PASSBOOK_TL', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL)

    CREATE OR REPLACE FORCE VIEW GN_PASS_BK_AC
(
   PROD_ID,
   PROD_DESC,
   PROD_TYPE,
   ACTYPE
)
AS
   SELECT DISTINCT OP.PROD_ID,
                   PROD_DESC,
                   'OA' AS PROD_TYPE,
                   'D' AS ACTYPE
     FROM OP_AC_PRODUCT OP, PARAM_SETTINGS
    WHERE     PARAM_DESC = 'PASSBOOK_OA'
          AND STATUS NOT IN ('DELETED')
          AND AUTHORIZED_STATUS = 'AUTHORIZED'
   UNION ALL
   SELECT DISTINCT DP.PROD_ID,
                   PROD_DESC,
                   'TD' AS PROD_TYPE,
                   'T' AS ACTYPE
     FROM DEPOSITS_PRODUCT DP, PARAM_SETTINGS
    WHERE     PARAM_DESC = 'PASSBOOK_TD'
          AND STATUS NOT IN ('DELETED')
          AND AUTHORIZE_STATUS = 'AUTHORIZED'
          AND BEHAVES_LIKE = 'RECURRING'
   UNION ALL
   SELECT DISTINCT LP.PROD_ID,
                   PROD_DESC,
                   'AD' AS PROD_TYPE,
                   'A' AS ACTYPE
     FROM LOANS_PRODUCT LP, PARAM_SETTINGS
    WHERE     BEHAVES_LIKE = 'OD'
          AND PARAM_DESC = 'PASSBOOK_AD'
          AND LP.STATUS NOT IN ('DELETED')
          AND LP.AUTHORIZE_STATUS = 'AUTHORIZED'
   UNION ALL
   SELECT DISTINCT LP.PROD_ID,
                   PROD_DESC,
                   'TL' AS PROD_TYPE,
                   'L' AS ACTYPE
     FROM LOANS_PRODUCT LP, PARAM_SETTINGS
    WHERE     BEHAVES_LIKE != 'OD'
          AND PARAM_DESC = 'PASSBOOK_TL'
          AND LP.STATUS NOT IN ('DELETED')
          AND LP.AUTHORIZE_STATUS = 'AUTHORIZED'
   UNION ALL
   SELECT DISTINCT MD.SCHEME_NAME AS PROD_ID,
                   MD.SCHEME_DESC AS PROD_DESC,
                   'MDS' AS PROD_TYPE,
                   'M' AS ACTYPE
     FROM MDS_SCHEME_DETAILS MD, PARAM_SETTINGS
    WHERE     PARAM_DESC = 'PASSBOOK_MDS'
          AND MD.STATUS NOT IN ('DELETED')
          AND MD.AUTHORIZEd_STATUS = 'AUTHORIZED';

     CREATE OR REPLACE FUNCTION  GN_PASSBK_PROCESS (MODULE_TYPE VARCHAR2, ACTNUM VARCHAR2, INITDT DATE,INITSLNO INT,INIT_TAG INT) RETURN VARCHAR2 IS
PRAGMA AUTONOMOUS_TRANSACTION;
-- LAST PRINT LINE ONWARDS
-- SELECT GN_PASSBK_PROCESS ('OA','0001104004020',NULL,NULL,0) FROM DUAL;
-- INITIALISE
--  SELECT GN_PASSBK_PROCESS ('OA','0001104004020','01APR2018',5,1) FROM DUAL; 
 REC_PER_PAGE INT; 
 PRINT_STRT_DT DATE;
 ACT_OPN_DT DATE;
 TMP_OB NUMBER(19,2);
 CNT INT:=0;
 PRV_PRINT_CNT INT;
 MST_CLR_BALANCE NUMBER(19,2);
 PSBK_CLR_BALANCE NUMBER(19,2);
 MSG VARCHAR2(75);
 SKIPLNE INT;
 SKIPCNT  INT;
 INIT_DT DATE;
 INIT_SLNO INT;
  BEGIN   
     COMMIT;
     DELETE TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM;
     COMMIT;
     IF INIT_TAG =1 THEN 
      DELETE FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM;
      COMMIT;
     ELSE
      DELETE FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM AND POST_TAG =0;
      COMMIT;  
     END IF;  
     IF INITSLNO IS NULL THEN
          INIT_SLNO:=1;
     ELSE 
          INIT_SLNO:=INITSLNO;     
     END IF;
     SELECT COUNT(*) INTO PRV_PRINT_CNT FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM AND POST_TAG =1;
    IF MODULE_TYPE ='OA' THEN
     IF INITDT IS NULL THEN
      SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_START_DT';
     ELSE 
      INIT_DT:= INITDT;
     END IF;
     SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
       WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
     SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM ACT_MASTER AM WHERE AM.ACT_NUM = ACTNUM;
     SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_OA'  AND    PAR_DET ='RECORDS_PER_PAGE';
     SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_START_DT';   
      IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
         CNT:=1;
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT)
          SELECT ACT_NUM,IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, 
           BONUS, NARR, POST_TAG,PAGENO, SAVE_DT FROM  GN_PASSBOOK WHERE TRANS_DT=(SELECT MIN(TRANS_DT) FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM) 
           AND   ACT_NUM = ACTNUM AND POST_TAG =1;
           COMMIT;
           SELECT MIN(TRANS_DT)+1 INTO PRINT_STRT_DT FROM  TMP_GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
           SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE ACT_NUM  = ACTNUM AND IDNO = (SELECT MAX(IDNO) FROM TMP_GN_PASSBOOK WHERE ACT_NUM  = ACTNUM)  ;                               
      ELSIF (INIT_TAG =0 AND PRINT_STRT_DT IS NOT NULL AND ACT_OPN_DT < PRINT_STRT_DT) OR (INIT_TAG =1  AND ACT_OPN_DT < INIT_DT )  THEN
         --CNT:=1;
         IF INIT_TAG =1  AND INIT_SLNO >1 THEN
            INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
             SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
             NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
             FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
             COMMIT;
         END IF;         
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
          SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO, (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)  AS  TRANS_DT,'Opening' AS TRANS_ID,NULL AS PRNCR,NULL AS PRNDR, 
          SUM(AMOUNT) AS BAL,NULL AS INTR, NULL AS PENAL, NULL AS OTH_AMT, NULL AS INSTR_NO1, NULL AS INSTR_DT1,NULL AS BONUS, 'Opening' AS NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
          FROM ( SELECT TRANS_DT,'' AS BATCH_ID,TRANS_ID,TRANS_TYPE,(DECODE(TRANS_TYPE,'DEBIT',-1,1)* AMOUNT) AS AMOUNT,C.ROWID AS RWID  FROM CASH_TRANS C ,OP_AC_PRODUCT P  WHERE C.AC_HD_ID = P.AC_HD_ID  AND 
           SUBSTR(C.ACT_NUM,5,3) = P.PROD_ID AND  C.TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)     AND 
           C.ACT_NUM =ACTNUM AND C.AUTHORIZE_STATUS ='AUTHORIZED' AND C.STATUS NOT IN('DELETED') 
          UNION ALL 
           SELECT TRANS_DT,BATCH_ID,TRANS_ID,TRANS_TYPE,(DECODE(TRANS_TYPE,'DEBIT',-1,1)* AMOUNT) AS AMOUNT,T.ROWID AS RWID  FROM TRANSFER_TRANS T ,OP_AC_PRODUCT P  WHERE T.AC_HD_ID =  P.AC_HD_ID   AND 
           SUBSTR(T.ACT_NUM,5,3) = P.PROD_ID AND T.TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)  AND 
           T.ACT_NUM =ACTNUM AND T.AUTHORIZE_STATUS ='AUTHORIZED' AND T.STATUS NOT IN('DELETED') ) TR ;   
           COMMIT;
           SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
      END IF;
     COMMIT;                                      
     INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
      SELECT ACTNUM ,
            SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID)+CNT
             AS IDNO,  TRANS_DT,  TRANS_ID,DECODE(TRANS_TYPE,'CREDIT',AMOUNT,0) AS PRNCR,DECODE(TRANS_TYPE,'DEBIT',AMOUNT,0) AS   PRNDR, 
         SUM((DECODE(TR.TRANS_TYPE,'DEBIT',-1,1)* AMOUNT)) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID)+NVL(TMP_OB,0) AS BAL,NULL AS INTR, NULL AS PENAL, NULL AS OTH_AMT, 
         INSTRUMENT_NO1 AS INSTR_NO1, INSTRUMENT_NO2 AS INSTR_DT1,NULL AS BONUS,PARTICULARS AS  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.RWID,TR.TRANS_TYPE DESC)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
        FROM (
       SELECT TRANS_DT, TRANS_ID,TRANS_TYPE,AMOUNT,C.INSTRUMENT_NO1,C.INSTRUMENT_NO2,C.PARTICULARS,C.STATUS_DT,C.ROWID AS RWID  FROM CASH_TRANS C ,OP_AC_PRODUCT P  WHERE C.AC_HD_ID = P.AC_HD_ID  AND 
        SUBSTR(C.ACT_NUM,5,3) = P.PROD_ID AND  C.TRANS_DT >= (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END) AND 
        C.ACT_NUM =ACTNUM AND C.AUTHORIZE_STATUS ='AUTHORIZED' AND C.STATUS NOT IN('DELETED') 
      UNION ALL 
        SELECT TRANS_DT,BATCH_ID||'_'||TRANS_ID AS TRANS_ID,TRANS_TYPE,AMOUNT,T.INSTRUMENT_NO1,T.INSTRUMENT_NO2,T.PARTICULARS,T.STATUS_DT,T.ROWID AS RWID  FROM TRANSFER_TRANS T ,OP_AC_PRODUCT P  WHERE T.AC_HD_ID =  P.AC_HD_ID   AND 
        SUBSTR(T.ACT_NUM,5,3) = P.PROD_ID AND  t.TRANS_DT >=  (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END) AND 
        T.ACT_NUM =ACTNUM AND T.AUTHORIZE_STATUS ='AUTHORIZED' AND T.STATUS NOT IN('DELETED')   ) TR    
          ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID; 
     COMMIT;
      INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
      WITH TMPPS AS(         
                    SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                     FROM   TMP_GN_PASSBOOK TP WHERE POST_TAG =0 AND  NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =TP.IDNO)),
           SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                      (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                      (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                    ),
           PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                    SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                    NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                    SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1)
               SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
               CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                 ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
   (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM PSBKALL ORDER BY IDNO,TAG,ORDNO, TRANS_DT ;
      COMMIT;
      DELETE FROM TMP_GN_PASSBOOK; 
      COMMIT;
      SELECT BAL INTO PSBK_CLR_BALANCE FROM GN_PASSBOOK GP WHERE TRANS_DT IS NOT NULL AND  ACT_NUM =ACTNUM AND IDNO =(SELECT MAX(IDNO) FROM  GN_PASSBOOK   WHERE TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) ;  
      IF MST_CLR_BALANCE = PSBK_CLR_BALANCE THEN
       MSG:='1 PROCESS COMPLETED';    
      ELSE
       --DELETE FROM GN_PASSBOOK GP WHERE POST_TAG =0 AND ACT_NUM =ACTNUM;
       COMMIT; 
       MSG:='0 BALANCE AMOUNT MISMATCH '|| CAST(MST_CLR_BALANCE AS VARCHAR2)   || ', ' || CAST(PSBK_CLR_BALANCE AS VARCHAR2 )  || ' = ' ||  CAST((MST_CLR_BALANCE - PSBK_CLR_BALANCE)  AS VARCHAR2 )  ;
      END IF; 
      RETURN MSG ;  
    END IF;
  END;

  -- End Version [Script Version - 0.0.314] [ReleaseVersion - 9.2.2.15]--[07-Jan-2019] -- By Sanju

-- Start Version [Script Version - 0.0.315] [ReleaseVersion - 9.2.2.15]--[21-Jan-2019] -- By Sathiya

CREATE TABLE SCREEN_ACCESS_HISTORY
(
  USER_ID     VARCHAR2(32 BYTE),
  APPL_DT     DATE,
  MODULE      VARCHAR2(32 BYTE),
  SCREEN      VARCHAR2(64 BYTE),
  BRANCH_ID   VARCHAR2(32 BYTE),
  IP_ADDR     VARCHAR2(32 BYTE),
  OPEN_TIME   DATE,
  CLOSE_TIME  DATE
);
-- End Version [Script Version - 0.0.315] [ReleaseVersion - 9.2.2.15]--[21-Jan-2019] -- By Sathiya

-- Start Version [Script Version - 0.0.316] [ReleaseVersion - 9.2.2.16]--[04-Feb-2019] -- By Sanju

 ALTER TABLE CUSTOMER ADD MOBILE_APP_LOGIN_STATUS  VARCHAR2(1 BYTE)     DEFAULT 'N'

-- End Version [Script Version - 0.0.316] [ReleaseVersion - 9.2.2.16]--[04-Feb-2019] -- By Sanju

-- Start Version [Script Version - 0.0.317] [ReleaseVersion - 9.2.2.17]--[19-Feb-2020] -- By Sathiya
CREATE TABLE BENEFICIARY_ACT_DETAILS
(
  CR_ACT_NUM        VARCHAR2(16 BYTE),
  CUST_NAME         VARCHAR2(128 BYTE),
  CUST_ADDRESS      VARCHAR2(256 BYTE),
  IFS_CODE          VARCHAR2(14 BYTE),
  BANK_NAME         VARCHAR2(64 BYTE),
  BRANCH_NAME       VARCHAR2(128 BYTE),
  STATUS            VARCHAR2(14 BYTE),
  STATUS_BY         VARCHAR2(32 BYTE),
  STATUS_DT         DATE,
  AUTHORIZE_STATUS  VARCHAR2(14 BYTE),
  AUTHORIZE_BY      VARCHAR2(14 BYTE),
  AUTHORIZE_DT      DATE,
  AUTH_OTP          VARCHAR2(14 BYTE),
  VALIDATED         VARCHAR2(14 BYTE),
  CUST_ID           VARCHAR2(14 BYTE)
)
-- Start Version [Script Version - 0.0.317] [ReleaseVersion - 9.2.2.17]--[19-Feb-2020] -- By Sathiya

-- Start Version [Script Version - 0.0.318] [ReleaseVersion - 9.2.2.16]--[11-Mar-2020] -- By Rishad

Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'ARBITRARY CHARGES', 'Arbitrary Charges', 'CREATED', 'Y');
   Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'EXECUTION DECREE CHARGES', 'Execution Decree Charges', 'CREATED', 'Y');
   
   Insert into COREDB.LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'INSURANCE CHARGES', 'Insurance Charges', 'CREATED', 'Y');
   
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'LEGAL CHARGES', 'Legal Charges', 'CREATED', 'Y');
   
   Insert into COREDB.LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'MISCELLANEOUS CHARGES', 'Miscellaneous Charges', 'CREATED', 'Y');
   
   Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'OTHER CHARGES', 'Other Charges', 'CREATED', 'Y');
   
   Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, AUTHORIZED)
 Values
   ('TERMLOAN.RISK_CHARGE_TYPE', 'ADVERTISE CHARGES', 'Advertisement Charges', 'CREATED', 'Y');

-- End Version [Script Version - 0.0.318] [ReleaseVersion - 9.2.2.16]--[11-Mar-2019] -- By Rishad

-- Start Version [Script Version - 0.0.319] [ReleaseVersion - 9.2.2.16]--[06-APr-2020] -- By Rishad

ALTER TABLE PERSONAL_SURETY_CONFIGURATION  ADD MAXIMUM_LOAN_PER_SURETY NUMBER (3);

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SL_NO, STATUS)
 Values
   ('SCR03017', '016', 'Dividend And Drf', 'APP01', 'DONE', 
    '15', 56, 'CREATED');

call INSERT_REPORT_GROUP('SCR03017');

-- End Version [Script Version - 0.0.319] [ReleaseVersion - 9.2.2.16]--[06-APr-2020] -- By Rishad

-- Start Version [Script Version - 0.0.320] [ReleaseVersion - 9.2.2.16]--[07-APR-2020] -- By Nithya

ALTER TABLE TDS_CONFIG ADD PAN_PERCENTAGE NUMBER(8,2);

Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    SCREEN_DESC)
 Values
   ('SCRS6181', '9721', 'Gold Security', 'APP01', 'DONE', 
    '2', 'Gold Security', 9, 'CREATED', 'REPORT', 
    'Gold Security');

CREATE TABLE CUST_GOLD_SECURITY_DETAILS
(
  CUST_ID                   VARCHAR2(16 BYTE),
  SECURITY_NO               NUMBER(4),
  SECURITY_CATEGORY         VARCHAR2(32 BYTE),
  PURITY                    VARCHAR2(16 BYTE),
  GROSS_WEIGHT              NUMBER(16,3),
  NET_WEIGHT                NUMBER(16,3),
  SECURITY_VALUE            NUMBER(16,2),
  MARKET_RATE               VARCHAR2(16 BYTE),
  PARTICULARS               VARCHAR2(250 BYTE),
  PLEDGE_AMT                NUMBER(16,2),
  APPRAISER_ID              VARCHAR2(16 BYTE),
  AS_ON                     DATE,
  AVAILABLE_SECURITY_VALUE  NUMBER(16,2),
  AUTHORIZE_REMARKS         VARCHAR2(128 BYTE),
  AUTHORIZE_STATUS          VARCHAR2(16 BYTE),
  STATUS                    VARCHAR2(32 BYTE),
  STATUS_BY                 VARCHAR2(32 BYTE),
  STATUS_DT                 DATE,
  AUTHORIZE_BY              VARCHAR2(32 BYTE),
  AUTHORIZE_DT              DATE,
  BRANCH_CODE               VARCHAR2(8 BYTE),
  IS_RELEASE                VARCHAR2(1 BYTE),
  RELEASE_DT                DATE,
  GOLD_SECURITY_ID          VARCHAR2(20 BYTE)
)

CREATE TABLE LOANS_SECURITY_GOLD_STOCK
(
  GOLD_STOCK_ID            VARCHAR2(30 BYTE),
  ACCT_NUM                 VARCHAR2(16 BYTE),
  PROD_ID                  VARCHAR2(10 BYTE),
  PROD_TYPE                VARCHAR2(10 BYTE),
  PLEDGE_AMOUNT            NUMBER(14,2),
  AS_ON                    DATE,
  REMARKS                  VARCHAR2(40 BYTE),
  RELEASE_STOCK_FROM_LOAN  VARCHAR2(1 BYTE),
  RELEASE_DT               DATE,
  BRANCH_CODE              VARCHAR2(16 BYTE),
  STATUS                   VARCHAR2(16 BYTE),
  STATUS_DT                DATE,
  STATUS_BY                VARCHAR2(16 BYTE),
  AUTHORIZE_STATUS         VARCHAR2(16 BYTE),
  AUTHORIZE_DT             DATE,
  AUTHORIZE_BY             VARCHAR2(16 BYTE)
)


ALTER TABLE DEPOSITS_PROD_RD ADD INT_APPLY_FOR_IRREGULAR_RD VARCHAR2(1) DEFAULT 'Y';

ALTER TABLE DEPOSITS_PROD_RD ADD SPECIAL_RD VARCHAR2(1) DEFAULT 'N';

ALTER TABLE DEPOSITS_PROD_RD  ADD SPECIAL_RD_INST_NO NUMBER(4);

CREATE OR REPLACE FUNCTION CHECK_SPECIAL_RD_COMPLETED (DEPOSITNO    VARCHAR2,
                                                       PRODID       VARCHAR2)
   RETURN VARCHAR2
IS
   COMPLETSTATUS        VARCHAR2 (1);
   COUNTOFINSTALLMENT   NUMBER (4);
   ACTUALINSTALLMENT    NUMBER (4);
   SPECIALRD VARCHAR2(1);
BEGIN
   SPECIALRD := 'N';
   COMPLETSTATUS := 'N';
   SELECT DSA.TOTAL_INSTALL_PAID
     INTO COUNTOFINSTALLMENT
     FROM DEPOSIT_SUB_ACINFO DSA
    WHERE DSA.DEPOSIT_NO = DEPOSITNO;

   SELECT DPR.SPECIAL_RD_INST_NO,DPR.SPECIAL_RD
     INTO ACTUALINSTALLMENT,SPECIALRD
     FROM DEPOSITS_PROD_RD DPR
    WHERE DPR.PROD_ID = PRODID;    
    
  IF SPECIALRD = 'Y' THEN
   IF (COUNTOFINSTALLMENT >= ACTUALINSTALLMENT)
   THEN
      COMPLETSTATUS := 'Y';
   ELSE
      COMPLETSTATUS := 'N';
   END IF;
  ELSE
    COMPLETSTATUS := 'N';
  END IF;  

   RETURN COMPLETSTATUS;
END;

ALTER TABLE DEPO_MASTER ADD DISCOUNT_AC_HD_ID VARCHAR2(16);

ALTER TABLE DEPO_MASTER ADD DISCOUNT_VAT_AC_HD_ID VARCHAR2(16);

SET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('INDEND_TRANSTYPE', 'Discount', 'Discount', 'CREATED', NULL, 
    'Y');
COMMIT;

ALTER TABLE LOANS_PROD_SUBSIDY_REBATE ADD LOAN_INT_PERCENT NUMBER(5,2) DEFAULT 1;

CREATE OR REPLACE FUNCTION GET_VALID_ACCOUNT(ACT_NO VARCHAR,PROD_TYPE VARCHAR) RETURN NUMBER IS

    ACT_COUNT NUMBER(16,2) := 0;

BEGIN

    IF PROD_TYPE='AB' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM OTHER_BANKS_ACT_MASTER

        WHERE ACT_MASTER_ID=ACT_NO AND ACT_STATUS='NEW'

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZED_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='AD' OR PROD_TYPE='TL' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM LOANS_FACILITY_DETAILS

        WHERE ACCT_NUM=ACT_NO AND ACCT_STATUS='NEW'

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZE_STATUS_1='AUTHORIZED';

    ELSIF PROD_TYPE='INV' THEN

        SELECT COUNT(*) INTO ACT_COUNT

        FROM INVESTMENT_DEPOSIT INVDEP

        JOIN INVESTMENT_MASTER INVMAS ON (INVDEP.INVESTMENT_ID = INVMAS.INVESTMENT_ID)

        WHERE INVDEP.INVESTMENT_ID=ACT_NO AND INVDEP.ACCT_STATUS='NEW'

        AND INVDEP.STATUS IN ('CREATED','MODIFIED') AND INVDEP.AUTHORIZED_STATUS='AUTHORIZED'

        AND INVMAS.STATUS IN ('CREATED','MODIFIED') AND INVMAS.AUTHORIZED_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='OA' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM ACT_MASTER

        WHERE ACT_NUM=ACT_NO AND ACT_STATUS_ID='NEW'

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZATION_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='SA' THEN

        SELECT COUNT(*) INTO ACT_COUNT FROM SUSPENSE_ACCOUNT_MASTER

        WHERE SUSPENSE_ACCT_NUM=ACT_NO

        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZE_STATUS='AUTHORIZED';

    ELSIF PROD_TYPE='TD' THEN

        SELECT COUNT(*) INTO ACT_COUNT

        FROM DEPOSIT_SUB_ACINFO DSA

        JOIN DEPOSIT_ACINFO DA ON (DSA.DEPOSIT_NO=DA.DEPOSIT_NO)

        WHERE (DSA.DEPOSIT_NO=ACT_NO OR DSA.DEPOSIT_NO||'_1'=ACT_NO)

        AND DSA.ACCT_STATUS='NEW' AND DA.DEPOSIT_STATUS='NEW'

        AND DSA.STATUS IN ('CREATED','MODIFIED','LIEN') AND DSA.AUTHORIZE_STATUS='AUTHORIZED'

        AND DA.STATUS IN ('CREATED','MODIFIED') AND DA.AUTHORIZE_STATUS='AUTHORIZED';

    END IF;

RETURN ACT_COUNT;

END;
/


-- End Version [Script Version - 0.0.320] [ReleaseVersion - 9.2.2.16]--[07-APR-2020] -- By Nithya

-- Start Version [Script Version - 0.0.321] [ReleaseVersion - 9.2.2.15]--[09-Apr-2020] -- By Sanju

CREATE OR REPLACE FORCE VIEW GN_PASS_BK_AC
(
   PROD_ID,
   PROD_DESC,
   PROD_TYPE,
   ACTYPE,
   LINES_PER_PAGE,
   RPTNAME
)
AS
   SELECT OP.PROD_ID,
          PROD_DESC,
          'OA' AS PROD_TYPE,
          'D' AS ACTYPE,
          PARAM_VALUE AS LINES_PER_PAGE,
          'GN_OA_PASSBK' AS RPTNAME
     FROM OP_AC_PRODUCT OP, PARAM_SETTINGS
    WHERE     PARAM_DESC = 'PASSBOOK_OA'
          AND STATUS NOT IN ('DELETED')
          AND AUTHORIZED_STATUS = 'AUTHORIZED'
   UNION ALL
   SELECT DP.PROD_ID,
          PROD_DESC,
          'TD' AS PROD_TYPE,
          'T' AS ACTYPE,
          PARAM_VALUE AS LINES_PER_PAGE,
          'GN_TD_PASSBK' AS RPTNAME
     FROM DEPOSITS_PRODUCT DP, PARAM_SETTINGS
    WHERE     PARAM_DESC = 'PASSBOOK_TD'
          AND STATUS NOT IN ('DELETED')
          AND AUTHORIZE_STATUS = 'AUTHORIZED'
          AND BEHAVES_LIKE = 'RECURRING'
   UNION ALL
   SELECT LP.PROD_ID,
          PROD_DESC,
          'AD' AS PROD_TYPE,
          'A' AS ACTYPE,
          PARAM_VALUE AS LINES_PER_PAGE,
          'GN_OD_PASSBK' AS RPTNAME
     FROM LOANS_PRODUCT LP, PARAM_SETTINGS
    WHERE     BEHAVES_LIKE = 'OD'
          AND PARAM_DESC = 'PASSBOOK_AD'
          AND LP.STATUS NOT IN ('DELETED')
          AND LP.AUTHORIZE_STATUS = 'AUTHORIZED'
   UNION ALL
   SELECT LP.PROD_ID,
          PROD_DESC,
          'TL' AS PROD_TYPE,
          'L' AS ACTYPE,
          PARAM_VALUE AS LINES_PER_PAGE,
          'GN_OD_PASSBK' AS RPTNAME
     FROM LOANS_PRODUCT LP, PARAM_SETTINGS
    WHERE     BEHAVES_LIKE != 'OD'
          AND PARAM_DESC = 'PASSBOOK_TL'
          AND LP.STATUS NOT IN ('DELETED')
          AND LP.AUTHORIZE_STATUS = 'AUTHORIZED'
   UNION ALL
   SELECT MD.SCHEME_NAME AS PROD_ID,
          MD.SCHEME_NAME || '-' || MD.SCHEME_DESC AS PROD_DESC,
          'MDS' AS PROD_TYPE,
          'M' AS ACTYPE,
          PARAM_VALUE AS LINES_PER_PAGE,
          'GN_MDS_PASSBK' AS RPTNAME
     FROM MDS_SCHEME_DETAILS MD, PARAM_SETTINGS
    WHERE     PARAM_DESC = 'PASSBOOK_MDS'
          AND MD.STATUS NOT IN ('DELETED')
          AND MD.AUTHORIZEd_STATUS = 'AUTHORIZED';
 
CREATE OR REPLACE TYPE TYPE_NAM_ADDRESS  AS OBJECT
(
  ACT_NUM                 VARCHAR2(15),
  CUSTOMER_NAME           VARCHAR2(150),
  MINOR                   VARCHAR2(5),
  ACT_STATUS_ID           VARCHAR2(15),
  ADDRESS                 VARCHAR2(500)
);
/

CREATE OR REPLACE TYPE  TAB_TYPE_NAM_ADDRESS  AS TABLE OF TYPE_NAM_ADDRESS ;
/

CREATE OR REPLACE TYPE TYPE_PBK_GRD  AS OBJECT
(
  ACT_NUM                 VARCHAR2(15),
  SLNO                    VARCHAR2(5),
  NEXT_SL_NO              VARCHAR2(5),
  TRANS_DT                DATE,
  PARTICULARS                 VARCHAR2(500),
  DEBIT                     NUMBER(19,2),
  CREDIT                    NUMBER(19,2),
  BALANCE                       NUMBER(19,2),
  INSTRUMENT_NO             VARCHAR2(15),
  INST_TYPE                 VARCHAR2(15),
  INST_DT                   VARCHAR2(15),
  PAGENO                    VARCHAR2(5),
  PREV_BAL                  NUMBER(19,2),
  TOD_LIMIT                 NUMBER(19,2),
  IDNO                      VARCHAR2(5)
);
/

CREATE OR REPLACE TYPE  TAB_TYPE_PBK_GRD  AS TABLE OF  TYPE_PBK_GRD ;
/
 
CREATE OR REPLACE TYPE  TYPE_GN_PASSBOOK_MDS AS OBJECT
(
   ACT_NUM VARCHAR2 (15),
   TRANS_DT DATE,
   TRANS_ID VARCHAR2 (20),
   PRNCR NUMBER (12,2),
   PRNDR NUMBER (12,2),
   BALANCE NUMBER (12,2),
   INTR NUMBER (12, 2),
   PENAL NUMBER (19, 2),
   OTH_AMT NUMBER (19, 2),
   INSTR_NO1 VARCHAR2(50),
   INSTR_DT1 DATE,
   BONUS_CR NUMBER (12, 2),
   BONUS_DR NUMBER (12, 2),
   DUEDATE DATE,
   NARR VARCHAR2 (500),
   INSTNO VARCHAR2(20),
   COMMISSION_PAID NUMBER(12,2)
    );
    
CREATE OR REPLACE TYPE  TAB_TYPE_GN_PASSBOOK_MDS  AS TABLE OF TYPE_GN_PASSBOOK_MDS;
/     
 
CREATE OR REPLACE FUNCTION  FUNC_GN_PASSBOOK_MDS (CHITNO VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS  IS   
      PBK_MDS TAB_TYPE_GN_PASSBOOK_MDS ;
    BEGIN  
        WITH MST
             AS (SELECT MSD.SCHEME_NAME,MSD.SCHEME_DESC,MSD.SCHEME_START_DT,MSD.SCHEME_END_DT,
                        MA.CHITTAL_NO||'_'||MA.SUB_NO AS CHITTAL_NO ,MSD.NO_OF_DIVISIONS,MSD.NO_OF_MEMBER_PER_DIVISION,
                        MSD.INSTALLMENT_AMOUNT FROM MDS_SCHEME_DETAILS MSD
                        JOIN MDS_APPLICATION MA ON MA.SCHEME_NAME = MSD.SCHEME_NAME
                  WHERE MA.CHITTAL_NO||'_'||MA.SUB_NO = CHITNO),
             PRIZED_MONEY_DET
             AS (SELECT MPD.SCHEME_NAME,MPD.DRAW_AUCTION_DATE,MPD.NEXT_INSTALLMENT_DATE AS DUEDATE,
                        MPD.INSTALLMENT_NO,MPD.CHITTAL_NO,MPD.NEXT_BONUS_AMOUNT AS BONUS_AMT,
                        M.INSTALLMENT_AMOUNT - MPD.NEXT_BONUS_AMOUNT AS SUBSCRIPTION_AMT,
                        TO_CHAR (MPD.NEXT_INSTALLMENT_DATE, 'DD') AS DUE_DAY,
                        INITCAP (TO_CHAR (MPD.NEXT_INSTALLMENT_DATE, 'MM')) AS DUE_MONTH,
                        TO_CHAR (MPD.NEXT_INSTALLMENT_DATE, 'YYYY') AS DUE_YR
                   FROM MDS_PRIZED_MONEY_DETAILS MPD 
                        JOIN MST M ON M.SCHEME_NAME = MPD.SCHEME_NAME AND MPD.AUTHORIZED_STATUS = 'AUTHORIZED' AND MPD.STATUS NOT IN ('DELETED')),
             MDS_TRANS
             AS (SELECT DENSE_RANK () OVER (ORDER BY MTD.TRANS_DT, MTD.NET_TRANS_ID)  AS START_SLNO,
                        CASE WHEN MTD.NO_OF_INST > 1  THEN
                          TO_CHAR (TO_NUMBER ((  DENSE_RANK () OVER ( ORDER BY MTD.TRANS_DT, MTD.NET_TRANS_ID)+ MTD.NO_OF_INST))- 1)
                        ELSE
                          TO_CHAR (DENSE_RANK () OVER (ORDER BY MTD.TRANS_DT, MTD.NET_TRANS_ID))
                        END  AS END_SLNO,MTD.SCHEME_NAME,MTD.CHITTAL_NO||'_'||MTD.SUB_NO AS CHITTAL_NO,MTD.NO_OF_INST,
                        MTD.TRANS_DT,MTD.NET_TRANS_ID,(MTD.INST_AMT * NO_OF_INST) - MTD.BONUS_AMT AS SUBSCRIPTION_AMT,
                        MTD.BONUS_AMT,MTD.PENAL_AMT
                   FROM MDS_TRANS_DETAILS MTD
                   JOIN MST M ON M.CHITTAL_NO = MTD.CHITTAL_NO||'_'||MTD.SUB_NO)
         SELECT     TYPE_GN_PASSBOOK_MDS (ACT_NUM,TRANS_DT,TRANS_ID,PRNCR,PRNDR,BALANCE,INTR, PENAL,OTH_AMT,INSTR_NO1,INSTR_DT1,
                                         BONUS_CR,BONUS_DR ,DUEDATE,NARR, INSTNO,COMMISSION_PAID )  BULK COLLECT INTO  PBK_MDS FROM (SELECT 
         CHITTAL_NO AS ACT_NUM,TRANS_DT,NET_TRANS_ID AS TRANS_ID, PRNCR,  PRNDR,  BALANCE,  0 as INTR,  penal_amt AS PENAL,
         0 as oth_amt,    null as instr_no1,   null as instr_dt1,  BONUS_CR,  BONUS_DR,   duedate,  narration as narr, INSTNO,COMMISSION AS COMMISSION_PAID 
         FROM            
        (SELECT CHITTAL_NO ,INSTNO,DUEDATE,TRANS_DT,NET_TRANS_ID,0 AS PRNDR,SUBSCRIPTION_AMT AS PRNCR,0 AS BONUS_DR,
        BONUS_AMT AS BONUS_CR,0 AS COMMISSION, PENAL_AMT AS PENAL_AMT,
        SUM (NVL (SUBSCRIPTION_AMT, 0) + NVL (BONUS_AMT, 0))  OVER (ORDER BY TRANS_DT, NET_TRANS_ID) AS BALANCE,NARRATION ||' [Inst No  '||INSTNO||']' as NARRATION 
          FROM (SELECT M.CHITTAL_NO,  CASE WHEN TO_NUMBER (END_SLNO) = TO_NUMBER (START_SLNO)  THEN
                             TO_CHAR (TO_NUMBER (START_SLNO))
                        ELSE
                              TO_CHAR (TO_NUMBER (START_SLNO)) || ' To ' || TO_CHAR (TO_NUMBER (END_SLNO))
                        END  AS INSTNO,
                        CASE WHEN T.NO_OF_INST > 1 THEN
                             (SELECT P.DUEDATE FROM PRIZED_MONEY_DET P WHERE TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.END_SLNO))
                        ELSE
                             P.DUEDATE
                        END AS DUEDATE, T.TRANS_DT,T.SUBSCRIPTION_AMT,T.BONUS_AMT,T.PENAL_AMT,T.NET_TRANS_ID,
                        CASE WHEN T.NO_OF_INST > 1 THEN 
                            (SELECT  trim(DUE_MONTH)||'/'||trim(DUE_YR) FROM PRIZED_MONEY_DET P WHERE TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.START_SLNO))||' To '||
                            (SELECT  trim(DUE_MONTH)||'/'||trim(DUE_YR) FROM PRIZED_MONEY_DET P WHERE TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.end_slno)) 
                        ELSE 
                            trim(DUE_MONTH)||'/'||trim(DUE_YR)
                        END AS NARRATION
                  FROM MST M
                  LEFT JOIN MDS_TRANS T ON M.CHITTAL_NO = T.CHITTAL_NO
                  LEFT JOIN PRIZED_MONEY_DET P ON P.SCHEME_NAME = M.SCHEME_NAME AND TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.END_SLNO))
        UNION ALL
        SELECT MST.CHITTAL_NO, TO_CHAR (PRIZED_INST_NO) AS PAID_INSTLNO,NULL AS INST_DUE_DT,STATUS_DT AS PAID_DT,NVL(MPD.CASH_ID,TRANS_ID) AS NET_TRANS_ID,  NVL (PRIZED_AMOUNT, 0)  AS PRNDR,0 AS PRNCR,
               BONUS_AMOUNT AS BONUS_DR, 0 AS  BONUS_CR,NVL (COMMISION_AMOUNT, 0) AS COMMISSION ,0 AS PENAL,
               NULL AS BALANCE,'Prized Inst No '|| TO_CHAR (PRIZED_INST_NO) as NARRATION
          FROM MDS_MONEY_PAYMENT_DETAILS MPD
          JOIN MST ON MST.CHITTAL_NO = MPD.CHITTAL_NO||'_'||MPD.SUB_NO  AND MPD.STATUS NOT IN ('DELETED') AND MPD.AUTHORIZED_STATUS = 'AUTHORIZED'));
     RETURN PBK_MDS;
   END;

CREATE OR REPLACE PACKAGE PKG_GN_PBK
AS
 FUNCTION GN_PB_PRN_INTDT (MODULE_TYPE VARCHAR2,ACTNUM VARCHAR2) RETURN DATE;
 FUNCTION GN_PB_NAM_ADD (ACTNUM VARCHAR2) RETURN TAB_TYPE_NAM_ADDRESS;  ---FOR NAME AND ADDRESS
 FUNCTION GN_PASSBK_PROCESS (MODULE_TYPE VARCHAR2, ACTNUM VARCHAR2, INITDT DATE,INITSLNO INT,INIT_TAG INT) RETURN VARCHAR2; --- PASSBOOK PROCESS
 FUNCTION GN_PASSBOOK_TRANS_LIST (ACTNUM VARCHAR2) RETURN TAB_TYPE_PBK_GRD; -- FOR LISTING IN GRID 
END PKG_GN_PBK;
/
CREATE OR REPLACE PACKAGE BODY PKG_GN_PBK AS 
 FUNCTION GN_PB_PRN_INTDT(MODULE_TYPE VARCHAR2,ACTNUM VARCHAR2) RETURN DATE IS
 DT DATE;
 BEGIN
  SELECT MAX(MXDT) INTO DT FROM(
  SELECT  CAST(PARAM_VALUE AS DATE) AS MXDT FROM PARAM_SETTINGS WHERE PAR_DET ='PRINT_START_DT' AND PARAM_DESC ='PASSBOOK_'||MODULE_TYPE
  UNION ALL
  SELECT MAX(TRANS_DT) AS MXDT FROM  GN_PASSBOOK  WHERE POST_TAG =1 AND TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) WHERE MXDT IS NOT NULL; 
  RETURN DT;
  END GN_PB_PRN_INTDT;
 FUNCTION GN_PB_NAM_ADD (ACTNUM VARCHAR2) RETURN TAB_TYPE_NAM_ADDRESS IS 
  -- SELECT * FROM TABLE (GN_PB_NAM_ADD('0003725000035_1'));
 NM_ADD TAB_TYPE_NAM_ADDRESS;
   BEGIN
     SELECT  TYPE_NAM_ADDRESS(ACT_NUM,CUSTOMER_NAME,MINOR,ACT_STATUS_ID,ADDRESS) BULK COLLECT INTO  NM_ADD FROM(
     SELECT AM.ACT_NUM AS ACT_NUM,DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME, MINOR, ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM ACT_MASTER AM, CUSTOMER C, CUST_ADDR CA    
     WHERE CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   AM.CUST_ID = C.CUST_ID      
     AND AM.ACT_NUM = ACTNUM  
     UNION ALL
     SELECT  AM.DEPOSIT_NO AS ACT_NUM,DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, DEPOSIT_STATUS AS ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM DEPOSIT_ACINFO AM, CUSTOMER C, CUST_ADDR CA    
     WHERE CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   AM.CUST_ID = C.CUST_ID      
     AND AM.DEPOSIT_NO = ACTNUM
     UNION ALL
     SELECT AM.ACCT_NUM AS ACT_NUM, DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, AM.ACCT_STATUS AS ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM LOANS_FACILITY_DETAILS AM,LOANS_BORROWER LB, CUSTOMER C, CUST_ADDR CA    
     WHERE AM.BORROW_NO =LB.BORROW_NO AND  CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   LB.CUST_ID = C.CUST_ID      
     AND AM.ACCT_NUM = ACTNUM 
     UNION ALL
     SELECT AM.CHITTAL_NO||'_'||AM.SUB_NO AS ACT_NUM, DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, AM.STATUS AS ACT_STATUS_ID, CA.STREET || ', ' || CA.AREA || ', ' || CA.CITY AS ADDRESS       
     FROM MDS_APPLICATION AM,  CUSTOMER C, CUST_ADDR CA    
     WHERE    CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   AM.CUST_ID = C.CUST_ID      
     AND AM.CHITTAL_NO||'_'||AM.SUB_NO = ACTNUM ||'_'||AM.SUB_NO           );   
     RETURN NM_ADD;    
  END  GN_PB_NAM_ADD;
 FUNCTION GN_PASSBK_PROCESS (MODULE_TYPE VARCHAR2, ACTNUM VARCHAR2, INITDT DATE,INITSLNO INT,INIT_TAG INT) RETURN VARCHAR2 IS
  PRAGMA AUTONOMOUS_TRANSACTION;
    -- LAST PRINT LINE ONWARDS
    -- SELECT GN_PASSBK_PROCESS ('OA','0001104004020',NULL,NULL,0) FROM DUAL;
    -- INITIALISE
    --  SELECT GN_PASSBK_PROCESS ('OA','0001104004020','01APR2018',5,1) FROM DUAL; 
     REC_PER_PAGE INT; 
     PRINT_STRT_DT DATE;
     ACT_OPN_DT DATE;
     TMP_OB NUMBER(19,2);
     CNT INT:=0;
     PRV_PRINT_CNT INT;
     MST_CLR_BALANCE NUMBER(19,2);
     PSBK_CLR_BALANCE NUMBER(19,2);
     MSG VARCHAR2(75);
     SKIPLNE INT;
     SKIPCNT  INT;
     INIT_DT DATE;
     INIT_SLNO INT;
      BEGIN   
         COMMIT;
         DELETE TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM;
         COMMIT;
         IF INIT_TAG =1 THEN 
          DELETE FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM;
          COMMIT;
         ELSE
          DELETE FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM AND POST_TAG =0;
          COMMIT;  
         END IF;  
         IF INITSLNO IS NULL THEN
              INIT_SLNO:=1;
         ELSE 
              INIT_SLNO:=INITSLNO;     
         END IF;
         SELECT COUNT(*) INTO PRV_PRINT_CNT FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM AND POST_TAG =1;
        IF MODULE_TYPE ='OA' THEN
         IF INITDT IS NULL THEN
          SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_START_DT';
         ELSE 
          INIT_DT:= INITDT;
         END IF;
         SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
         SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM ACT_MASTER AM WHERE AM.ACT_NUM = ACTNUM;
         SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_OA'  AND    PAR_DET ='RECORDS_PER_PAGE';
         SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_START_DT';   
          IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
             CNT:=1;
             INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT)
              SELECT ACT_NUM,IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, 
               BONUS, NARR, POST_TAG,PAGENO, SAVE_DT FROM  GN_PASSBOOK WHERE TRANS_DT=(SELECT MIN(TRANS_DT) FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM) 
               AND   ACT_NUM = ACTNUM AND POST_TAG =1;
               COMMIT;
               SELECT MIN(TRANS_DT)+1 INTO PRINT_STRT_DT FROM  TMP_GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
               SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE ACT_NUM  = ACTNUM AND IDNO = (SELECT MAX(IDNO) FROM TMP_GN_PASSBOOK WHERE ACT_NUM  = ACTNUM)  ;                               
          ELSIF (INIT_TAG =0 AND PRINT_STRT_DT IS NOT NULL AND ACT_OPN_DT < PRINT_STRT_DT) OR (INIT_TAG =1  AND ACT_OPN_DT < INIT_DT )  THEN
             --CNT:=1;
             IF INIT_TAG =1  AND INIT_SLNO >1 THEN
                INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
                 SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
                 NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
                 FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
                 COMMIT;
             END IF;         
             INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
              SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO, (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)  AS  TRANS_DT,'Opening' AS TRANS_ID,NULL AS PRNCR,NULL AS PRNDR, 
              SUM(AMOUNT) AS BAL,NULL AS INTR, NULL AS PENAL, NULL AS OTH_AMT, NULL AS INSTR_NO1, NULL AS INSTR_DT1,NULL AS BONUS, 'Opening' AS NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
              FROM ( SELECT TRANS_DT,'' AS BATCH_ID,TRANS_ID,TRANS_TYPE,(DECODE(TRANS_TYPE,'DEBIT',-1,1)* AMOUNT) AS AMOUNT,C.ROWID AS RWID  FROM CASH_TRANS C ,OP_AC_PRODUCT P  WHERE C.AC_HD_ID = P.AC_HD_ID  AND 
               SUBSTR(C.ACT_NUM,5,3) = P.PROD_ID AND  C.TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)     AND 
               C.ACT_NUM =ACTNUM AND C.AUTHORIZE_STATUS ='AUTHORIZED' AND C.STATUS NOT IN('DELETED') 
              UNION ALL 
               SELECT TRANS_DT,BATCH_ID,TRANS_ID,TRANS_TYPE,(DECODE(TRANS_TYPE,'DEBIT',-1,1)* AMOUNT) AS AMOUNT,T.ROWID AS RWID  FROM TRANSFER_TRANS T ,OP_AC_PRODUCT P  WHERE T.AC_HD_ID =  P.AC_HD_ID   AND 
               SUBSTR(T.ACT_NUM,5,3) = P.PROD_ID AND T.TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)  AND 
               T.ACT_NUM =ACTNUM AND T.AUTHORIZE_STATUS ='AUTHORIZED' AND T.STATUS NOT IN('DELETED') ) TR ;   
               COMMIT;
               SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
          END IF;
         COMMIT;                                      
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM ,
                SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID)+CNT
                 AS IDNO,  TRANS_DT,  TRANS_ID,DECODE(TRANS_TYPE,'CREDIT',AMOUNT,0) AS PRNCR,DECODE(TRANS_TYPE,'DEBIT',AMOUNT,0) AS   PRNDR, 
             SUM((DECODE(TR.TRANS_TYPE,'DEBIT',-1,1)* AMOUNT)) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID)+NVL(TMP_OB,0) AS BAL,NULL AS INTR, NULL AS PENAL, NULL AS OTH_AMT, 
             INSTRUMENT_NO1 AS INSTR_NO1, INST_DT AS INSTR_DT1,NULL AS BONUS,PARTICULARS AS  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.RWID,TR.TRANS_TYPE DESC)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (
           SELECT TRANS_DT, TRANS_ID,TRANS_TYPE,AMOUNT,C.INSTRUMENT_NO1,C.INST_DT,C.PARTICULARS,C.STATUS_DT,C.ROWID AS RWID  FROM CASH_TRANS C ,OP_AC_PRODUCT P  WHERE C.AC_HD_ID = P.AC_HD_ID  AND 
            SUBSTR(C.ACT_NUM,5,3) = P.PROD_ID AND  C.TRANS_DT >= (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END) AND 
            C.ACT_NUM =ACTNUM AND C.AUTHORIZE_STATUS ='AUTHORIZED' AND C.STATUS NOT IN('DELETED') 
          UNION ALL 
            SELECT TRANS_DT,BATCH_ID||'_'||TRANS_ID AS TRANS_ID,TRANS_TYPE,AMOUNT,T.INSTRUMENT_NO1,T.INST_DT,T.PARTICULARS,T.STATUS_DT,T.ROWID AS RWID  FROM TRANSFER_TRANS T ,OP_AC_PRODUCT P  WHERE T.AC_HD_ID =  P.AC_HD_ID   AND 
            SUBSTR(T.ACT_NUM,5,3) = P.PROD_ID AND  t.TRANS_DT >=  (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END) AND 
            T.ACT_NUM =ACTNUM AND T.AUTHORIZE_STATUS ='AUTHORIZED' AND T.STATUS NOT IN('DELETED')   ) TR    
              ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID; 
         COMMIT;
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(         
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE POST_TAG =0 AND  NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =TP.IDNO)),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1)
                   SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
       (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM PSBKALL ORDER BY IDNO,TAG,ORDNO, TRANS_DT ;
          COMMIT;
          DELETE FROM TMP_GN_PASSBOOK; 
          COMMIT;
          SELECT BAL INTO PSBK_CLR_BALANCE FROM GN_PASSBOOK GP WHERE TRANS_DT IS NOT NULL AND  ACT_NUM =ACTNUM AND IDNO =(SELECT MAX(IDNO) FROM  GN_PASSBOOK   WHERE TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) ;  
          IF MST_CLR_BALANCE = PSBK_CLR_BALANCE THEN
           MSG:='1 PROCESS COMPLETED';    
          ELSE
           --DELETE FROM GN_PASSBOOK GP WHERE POST_TAG =0 AND ACT_NUM =ACTNUM;
           COMMIT; 
           MSG:='0 BALANCE AMOUNT MISMATCH '|| CAST(MST_CLR_BALANCE AS VARCHAR2)   || ', ' || CAST(PSBK_CLR_BALANCE AS VARCHAR2 )  || ' = ' ||  CAST((MST_CLR_BALANCE - PSBK_CLR_BALANCE)  AS VARCHAR2 )  ;
          END IF; 
        ELSIF MODULE_TYPE ='MDS' THEN
         IF INITDT IS NULL THEN
          SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND  PAR_DET ='PRINT_START_DT';
         ELSE 
          INIT_DT:= INITDT;
         END IF;
         SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
         --SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM MDS_ AM WHERE AM.ACT_NUM = ACTNUM;
         SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND    PAR_DET ='RECORDS_PER_PAGE';
         SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND  PAR_DET ='PRINT_START_DT';   
          IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
             CNT:=1;
             INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT)
              SELECT ACT_NUM,IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, 
               BONUS, NARR, POST_TAG,PAGENO, SAVE_DT FROM  GN_PASSBOOK WHERE TRANS_DT=(SELECT MIN(TRANS_DT) FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM) 
               AND   ACT_NUM = ACTNUM AND POST_TAG =1;
               COMMIT;
               SELECT MIN(TRANS_DT)+1 INTO PRINT_STRT_DT FROM  TMP_GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
               SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE ACT_NUM  = ACTNUM AND IDNO = (SELECT MAX(IDNO) FROM TMP_GN_PASSBOOK WHERE ACT_NUM  = ACTNUM)  ;                               
          ELSIF (INIT_TAG =0 AND PRINT_STRT_DT IS NOT NULL AND ACT_OPN_DT < PRINT_STRT_DT) OR (INIT_TAG =1  AND ACT_OPN_DT < INIT_DT )  THEN
             --CNT:=1;
             IF INIT_TAG =1  AND INIT_SLNO >1 THEN
                INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
                 SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
                 NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
                 FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
                 COMMIT;
             END IF;         
             INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, 
             NARR, POST_TAG,     PAGENO, SAVE_DT)
               SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO, (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)  AS  TRANS_DT,
               TRANS_ID, PRNCR, PRNDR, 
               BAL, INTR,  PENAL,  OTH_AMT, INSTR_NO1,  INSTR_DT1, BONUS,   NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
              FROM (           
                 SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, BONUS_DR AS INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                 INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                   FROM TABLE(FUNC_GN_PASSBOOK_MDS(ACTNUM))--WHERE  TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END)  
               ) TR ;   
               COMMIT;
               SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
          END IF;
         COMMIT;                                      
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM ,
                SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT
                 AS IDNO,  TRANS_DT,  TRANS_ID, PRNCR,    PRNDR, 
               BAL,  INTR,   PENAL,  OTH_AMT, 
               INSTR_NO1,   INSTR_DT1,  BONUS,  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (
                 SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, BONUS_DR AS INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                 INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR  ,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                   FROM TABLE(FUNC_GN_PASSBOOK_MDS(ACTNUM))--WHERE  TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END) 
                    ) TR    
              ORDER BY TR.TRANS_DT,TR.RWID; 
         COMMIT;
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(         
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE POST_TAG =0 AND  NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =TP.IDNO)),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1)
                   SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
       (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM PSBKALL ORDER BY IDNO,TAG,ORDNO, TRANS_DT ;
          COMMIT;
          MSG:='1 PROCESS COMPLETED'; 
          DELETE FROM TMP_GN_PASSBOOK; 
          COMMIT;     
       END IF;
      RETURN MSG ;    
      END GN_PASSBK_PROCESS;  
  FUNCTION GN_PASSBOOK_TRANS_LIST (ACTNUM VARCHAR2) RETURN TAB_TYPE_PBK_GRD IS
  -- SELECT * FROM TABLE (GN_PASSBOOK_TRANS_LIST('0003725000035_1'));
  GRDLIST TAB_TYPE_PBK_GRD;
   BEGIN
   SELECT TYPE_PBK_GRD( ACT_NUM,SLNO,NEXT_SL_NO,TRANS_DT,PARTICULARS,DEBIT,CREDIT,BALANCE,INSTRUMENT_NO,INST_TYPE,INST_DT,PAGENO,PREV_BAL,TOD_LIMIT,IDNO) BULK COLLECT INTO GRDLIST FROM (
       SELECT ACT_NUM, RWID AS SLNO, NULL AS NEXT_SL_NO, TRANS_DT, INITCAP (NARR) AS PARTICULARS,
         PRNDR AS DEBIT, PRNCR AS CREDIT,  BAL AS BALANCE,      INSTR_NO1 AS INSTRUMENT_NO,
         NULL AS INST_TYPE,    INSTR_DT1 AS INST_DT,  PAGENO,     LAG (BAL) OVER (ORDER BY IDNO) AS PREV_BAL,
         NULL AS TOD_LIMIT, IDNO  FROM GN_PASSBOOK GK
         LEFT JOIN (SELECT   ACTNUM ,MAX(GP.IDNO) AS MXID FROM  GN_PASSBOOK GP WHERE GP.ACT_NUM =ACTNUM  AND GP.POST_TAG =1  ORDER BY IDNO) GS
         ON GS.ACTNUM =GK.ACT_NUM 
         WHERE GK.ACT_NUM = ACTNUM AND GK.IDNO > NVL(GS.MXID,0)-10 ORDER BY IDNO);
    RETURN GRDLIST;     
   END GN_PASSBOOK_TRANS_LIST;      
 END PKG_GN_PBK;
/

CREATE OR REPLACE TYPE  TAB_TYPE_PBK_GRD  AS TABLE OF  TYPE_PBK_GRD ;

-- End Version [Script Version - 0.0.321] [ReleaseVersion - 9.2.2.15]--[09-Apr-2020] -- By Sanju

-- Start Version [Script Version - 0.0.322] [ReleaseVersion - 9.2.2.16]--[14-APR-2020] -- By Nithya

DROP TYPE TAB_TYPE_GROUP_DEPOSIT_INTR;

CREATE OR REPLACE TYPE TYPE_GROUP_DEPOSIT_INTR AS OBJECT
(
    DEPOSIT_NO      VARCHAR2(15),
    CURR_BAL        NUMBER(16,2),
    INTAMOUNT       NUMBER(16,2),
    TRN_DT          DATE
);


CREATE OR REPLACE TYPE TAB_TYPE_GROUP_DEPOSIT_INTR  AS TABLE OF TYPE_GROUP_DEPOSIT_INTR;
/

/* Formatted on 08/04/2020 10:44:27 (QP5 v5.227.12220.39754) */
CREATE OR REPLACE FUNCTION GET_GROUP_DEP_TRANS_DETAILS (
   DEPOSITNO    VARCHAR2,
   INT_RATE     NUMBER,
   CURRDT       DATE,
   MAXTRNDT     DATE)
   RETURN TAB_TYPE_GROUP_DEPOSIT_INTR
IS
   typeinterest   TAB_TYPE_GROUP_DEPOSIT_INTR;
   INTAMT         NUMBER (16, 2);
   MATURITYDT     DATE;
   DEPOSITDT      DATE;
   INTFORPAID     NUMBER (16, 2);
   INTUPTOCURDT   NUMBER (16, 2);
   MAXTRANSDT     DATE;
   MONTHDIFF      NUMBER (2);
   TRN_DT         DATE;
   DEPOSIT_NO     VARCHAR2(15);
   INTAMOUNT      NUMBER (16, 2);
   CURR_BAL       NUMBER (16, 2);
BEGIN
   SELECT DSA.MATURITY_DT, DSA.DEPOSIT_DT
     INTO MATURITYDT, DEPOSITDT
     FROM DEPOSIT_SUB_ACINFO DSA
    WHERE DSA.DEPOSIT_NO = DEPOSITNO;

   SELECT TRUNC (TO_DATE(MAXTRNDT), 'MM')
     INTO MAXTRANSDT
     from dual;

   SELECT ACC_NUM,
          CURR_BAL,
          INTAMOUNT,
          dt
     INTO DEPOSIT_NO,
          CURR_BAL,
          INTAMOUNT,
          TRN_DT
     FROM (  SELECT TRUNC (D.TRN_DT, 'MM') AS dt,
                    SUM (D.AMOUNT) AS DEP_AMOUNT,
                    D.ACC_NUM,
                    gd.DEPOSIT_AMT,
                    (gd.DEPOSIT_AMT - SUM (D.AMOUNT)) AS DIFFERECE,
                    SUM (
                       SUM (D.AMOUNT))
                    OVER (PARTITION BY d.acc_num
                          ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       AS curr_bal,
                      (  SUM (
                            SUM (D.AMOUNT))
                         OVER (PARTITION BY d.acc_num
                               ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       * INT_RATE)
                    / 1200
                       AS intAmount,
                    SUM (
                       gd.DEPOSIT_AMT - SUM (D.AMOUNT))
                    OVER (PARTITION BY d.acc_num
                          ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       AS diff_curr_bal
               FROM DAILY_DEPOSIT_TRANS d,
                    DEPOSIT_sub_ACINFO dsa,
                    DEPOSIT_ACINFO da,
                    GROUP_DEPOSIT gd
              WHERE     D.ACC_NUM = DEPOSITNO || '_1'
                    AND DSA.DEPOSIT_NO || '_1' = D.ACC_NUM
                    AND DSA.DEPOSIT_NO = DA.DEPOSIT_NO
                    AND DA.GROUP_NO = GD.GROUP_NO
                    AND DA.BRANCH_ID = GD.BRANCH_ID
           GROUP BY TRUNC (D.TRN_DT, 'MM'), D.ACC_NUM, gd.DEPOSIT_AMT
           ORDER BY dt) WHERE dt = MAXTRANSDT;

   SELECT TYPE_GROUP_DEPOSIT_INTR (DEPOSIT_NO,
                                   CURR_BAL,
                                   INTAMOUNT,
                                   TRN_DT)
     BULK COLLECT INTO typeinterest
     FROM DUAL;

   RETURN typeinterest;
END;


CREATE OR REPLACE FUNCTION get_group_deposit_int (DEPOSITNO    VARCHAR2,
                                                  INT_RATE     NUMBER,
                                                  CURRDT       DATE)
   RETURN NUMBER
IS
   INTAMT         NUMBER (16, 2);
   MATURITYDT     DATE;
   DEPOSITDT      DATE;
   INTFORPAID     NUMBER (16, 2);
   INTUPTOCURDT   NUMBER (16, 2);
   MAXTRANSDT     DATE;
   MONTHDIFF      NUMBER (4);
   MAXINTAMOUNT   NUMBER (16, 2);
   NOOFDAYS       NUMBER(10);
 BEGIN
   SELECT DSA.MATURITY_DT, DSA.DEPOSIT_DT
     INTO MATURITYDT, DEPOSITDT
     FROM DEPOSIT_SUB_ACINFO DSA
    WHERE DSA.DEPOSIT_NO = DEPOSITNO;

   SELECT MAX (DT.TRN_DT)
     INTO MAXTRANSDT
     FROM DAILY_DEPOSIT_TRANS DT
    WHERE DT.ACC_NUM = DEPOSITNO || '_1';

   SELECT ROUND (SUM (intAmount))
     INTO INTFORPAID
     FROM (  SELECT TRUNC (D.TRN_DT, 'MM') AS dt,
                    SUM (D.AMOUNT) AS DEP_AMOUNT,
                    D.ACC_NUM,
                    gd.DEPOSIT_AMT,
                    (gd.DEPOSIT_AMT - SUM (D.AMOUNT)) AS DIFFERECE,
                    SUM (
                       SUM (D.AMOUNT))
                    OVER (PARTITION BY d.acc_num
                          ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       AS curr_bal,
                      (  SUM (
                            SUM (D.AMOUNT))
                         OVER (PARTITION BY d.acc_num
                               ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       * 7.0)
                    / 1200
                       AS intAmount,
                    SUM (
                       gd.DEPOSIT_AMT - SUM (D.AMOUNT))
                    OVER (PARTITION BY d.acc_num
                          ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       AS diff_curr_bal
               FROM DAILY_DEPOSIT_TRANS d,
                    DEPOSIT_sub_ACINFO dsa,
                    DEPOSIT_ACINFO da,
                    GROUP_DEPOSIT gd
              WHERE     D.ACC_NUM = DEPOSITNO || '_1'
                    AND DSA.DEPOSIT_NO || '_1' = D.ACC_NUM
                    AND DSA.DEPOSIT_NO = DA.DEPOSIT_NO
                    AND DA.GROUP_NO = GD.GROUP_NO
                    AND DA.BRANCH_ID = GD.BRANCH_ID
           GROUP BY TRUNC (D.TRN_DT, 'MM'), D.ACC_NUM, gd.DEPOSIT_AMT
           ORDER BY dt); 
        SELECT floor(MONTHS_BETWEEN(CURRDT, MAXTRANSDT)) INTO MONTHDIFF FROM DUAL;
        SELECT INTAMOUNT INTO  MAXINTAMOUNT from table(GET_GROUP_DEP_TRANS_DETAILS(DEPOSITNO,INT_RATE,CURRDT,MAXTRANSDT));
        INTUPTOCURDT := NVL(MAXINTAMOUNT,0) * MONTHDIFF;
    
     INTAMT := NVL(INTFORPAID,0) + NVL(INTUPTOCURDT,0);
     --INTAMT := INTFORPAID + INTUPTOCURDT;
     INTAMT := ROUND(INTAMT);
   RETURN INTAMT;
END;

ALTER TABLE MDS_SCHEME_DETAILS ADD SCHEME_GRACE_PERIOD NUMBER(3) DEFAULT 0;

ALTER TABLE SERVICE_TAX_SETTINGS ADD CESS_ROUNDOFF VARCHAR2(20);

-- End Version [Script Version - 0.0.322] [ReleaseVersion - 9.2.2.16]--[14-APR-2020] -- By Nithya

-- Start Version [Script Version - 0.0.323] [ReleaseVersion - 9.2.2.16]--[27-JUL-2020] -- By Sanju
   
CREATE TABLE PARAM_SETTINGS
(
  PARAM_ID     INTEGER                          NOT NULL,
  EXCTYPE      INTEGER,
  PROD_ID      VARCHAR2(5 BYTE),
  BRANCH_ID    VARCHAR2(5 BYTE),
  PARAM_DESC   VARCHAR2(75 BYTE)                NOT NULL,
  PARAM_VALUE  VARCHAR2(75 BYTE)                NOT NULL,
  SAVE_DATE    DATE                             DEFAULT SYSDATE,
  SAVE_USER    VARCHAR2(75 BYTE),
  PAR_DET      VARCHAR2(75 BYTE)
);


CREATE INDEX INDXPARAM_SETTINGS_001 ON PARAM_SETTINGS(PARAM_ID, EXCTYPE, PROD_ID);  

CREATE INDEX INDXPARAM_SETTINGS_002 ON PARAM_SETTINGS(PARAM_DESC, PAR_DET);   

ALTER TABLE PARAM_SETTINGS ADD PAR_DET VARCHAR2(75);

--PAGE NUMBER SETTINGS

INSERT INTO PARAM_SETTINGS
   (PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,     PARAM_VALUE, SAVE_DATE, SAVE_USER,PAR_DET)
SELECT 11, NULL, NULL, NULL, 'PASSBOOK_OA', '39',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL UNION ALL
SELECT 12, NULL, NULL, NULL, 'PASSBOOK_TD', '39',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL UNION ALL
SELECT 13, NULL, NULL, NULL, 'PASSBOOK_AD', '39',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL UNION ALL
SELECT 14, NULL, NULL, NULL, 'PASSBOOK_TL', '39',  '31MAR2019' , 'admin','RECORDS_PER_PAGE' FROM DUAL;

COMMIT;


---PRINT  START DATE SETTINGS

INSERT INTO PARAM_SETTINGS
   (PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,     PARAM_VALUE, SAVE_DATE, SAVE_USER,PAR_DET)
SELECT 21, NULL, NULL, NULL, 'PASSBOOK_OA', '01APR2020',  '31MAR2020' , 'admin','PRINT_START_DT' FROM DUAL UNION ALL
SELECT 22, NULL, NULL, NULL, 'PASSBOOK_TD', '01APR2020',  '31MAR2020' , 'admin','PRINT_START_DT' FROM DUAL UNION ALL
SELECT 23, NULL, NULL, NULL, 'PASSBOOK_AD', '01APR2020',  '31MAR2020' , 'admin','PRINT_START_DT' FROM DUAL UNION ALL
SELECT 24, NULL, NULL, NULL, 'PASSBOOK_TL', '01APR2020',  '31MAR2020' , 'admin','PRINT_START_DT' FROM DUAL;

COMMIT;

---PRINT LINE SKIPPING SETTINGS

INSERT INTO PARAM_SETTINGS
   (PARAM_ID, EXCTYPE, PROD_ID, BRANCH_ID, PARAM_DESC,     PARAM_VALUE, SAVE_DATE, SAVE_USER,PAR_DET)
SELECT 31, NULL, NULL, NULL, 'PASSBOOK_OA', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL UNION ALL
SELECT 34, NULL, NULL, NULL, 'PASSBOOK_TD', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL UNION ALL
SELECT 36, NULL, NULL, NULL, 'PASSBOOK_AD', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL UNION ALL
SELECT 39, NULL, NULL, NULL, 'PASSBOOK_TL', '18,2',  '31MAR2019' , 'admin','PRINT_CNTR_LINE_SKIP' FROM DUAL;

COMMIT;



  
DROP TABLE GN_PASSBOOK;

CREATE TABLE GN_PASSBOOK (
    ACT_NUM       VARCHAR2(15),
    IDNO          INT ,
    TRANS_DT      DATE, 
    TRANS_ID      VARCHAR2(75),
    PRNCR         NUMBER(19,2),
    PRNDR         NUMBER(19,2),
    BAL           NUMBER(19,2), 
    INTR          NUMBER(19,2),
    PENAL         NUMBER(19,2),
    OTH_AMT       NUMBER(19,2),
    INSTR_NO1     VARCHAR2(25),
    INSTR_DT1     DATE,
    BONUS         NUMBER(19,2),
    NARR          VARCHAR2 (250) NULL ,
    POST_TAG      INT   DEFAULT (0),
    PAGENO        INT,
    SAVE_DT       DATE,
    RWID          VARCHAR2(75)
) ;

DROP   TABLE TMP_GN_PASSBOOK;

TRUNCATE TABLE TMP_GN_PASSBOOK;

 CREATE  GLOBAL TEMPORARY TABLE TMP_GN_PASSBOOK (
    ACT_NUM       VARCHAR2(15),
    IDNO          INT ,
    TRANS_DT      DATE, 
    TRANS_ID      VARCHAR2(75),
    PRNCR         NUMBER(19,2),
    PRNDR         NUMBER(19,2),
    BAL           NUMBER(19,2), 
    INTR          NUMBER(19,2),
    PENAL         NUMBER(19,2),
    OTH_AMT       NUMBER(19,2),
    INSTR_NO1     VARCHAR2(25),
    INSTR_DT1     DATE,
    BONUS         NUMBER(19,2),
    NARR          VARCHAR2 (250) NULL ,
    POST_TAG      INT   DEFAULT (0),
    PAGENO        INT,
    SAVE_DT       DATE,
    RWID          VARCHAR2(75)
     ) ON COMMIT PRESERVE ROWS; 

 DELETE FROM LOOKUP_MASTER WHERE  LOOKUP_ID = 'GNPASSBOOK.MODULE';
 
 commit;
 
 SELECT *   FROM LOOKUP_MASTER LM WHERE LM.LOOKUP_ID ='GNPASSBOOK.MODULE'
 
INSERT INTO LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,     AUTHORIZED)
   SELECT LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,     AUTHORIZED FROM 
  (SELECT 'GNPASSBOOK.MODULE' AS LOOKUP_ID , 'OA' AS LOOKUP_REF_ID, 'Operative' AS LOOKUP_DESC, 'CREATED' AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL UNION ALL
   SELECT 'GNPASSBOOK.MODULE'  AS LOOKUP_ID , 'TD' AS LOOKUP_REF_ID, 'TERM DEPOSIT' AS LOOKUP_DESC, 'CREATED' AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL UNION ALL
   SELECT 'GNPASSBOOK.MODULE'  AS LOOKUP_ID, 'AD' AS LOOKUP_REF_ID, 'OVERDRAFT' AS LOOKUP_DESC, 'CREATED'  AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL UNION ALL
   SELECT 'GNPASSBOOK.MODULE'  AS LOOKUP_ID, 'TL' AS LOOKUP_REF_ID, 'TERM LOANS' AS LOOKUP_DESC, 'CREATED' AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL  UNION ALL
   SELECT 'GNPASSBOOK.MODULE' AS LOOKUP_ID, 'M' AS LOOKUP_REF_ID, 'MDS' AS LOOKUP_DESC, 'CREATED'  AS STATUS, NULL AS EDITABLE, 'Y' AS AUTHORIZED FROM DUAL)LK
   WHERE LOOKUP_REF_ID NOT IN(SELECT LOOKUP_REF_ID FROM LOOKUP_MASTER LM WHERE LM.LOOKUP_ID ='GNPASSBOOK.MODULE');

COMMIT;
 
 CREATE OR REPLACE VIEW GN_PASS_BK_AC AS 
  SELECT OP.PROD_ID,PROD_DESC,'OA' AS PROD_TYPE, PARAM_VALUE AS LINES_PER_PAGE,'GN_OA_PASSBK' AS RPTNAME FROM OP_AC_PRODUCT OP,
   PARAM_SETTINGS WHERE PARAM_DESC ='PASSBOOK_OA' AND  PAR_DET = 'RECORDS_PER_PAGE' AND  STATUS NOT IN('DELETED')AND AUTHORIZED_STATUS ='AUTHORIZED'
  UNION ALL
  SELECT DP.PROD_ID,PROD_DESC,'TD' AS PROD_TYPE, PARAM_VALUE AS LINES_PER_PAGE,'GN_TD_PASSBK' AS RPTNAME FROM DEPOSITS_PRODUCT DP ,
  PARAM_SETTINGS WHERE PARAM_DESC ='PASSBOOK_TD'  AND  PAR_DET = 'RECORDS_PER_PAGE' AND  STATUS NOT IN('DELETED')AND AUTHORIZE_STATUS ='AUTHORIZED'
  AND BEHAVES_LIKE ='RECURRING' 
  UNION ALL  
  SELECT LP.PROD_ID,PROD_DESC, 'AD'  AS PROD_TYPE,  PARAM_VALUE AS LINES_PER_PAGE,
  'GN_OD_PASSBK' AS RPTNAME FROM LOANS_PRODUCT LP
  ,PARAM_SETTINGS WHERE BEHAVES_LIKE ='OD' AND  PARAM_DESC =  'PASSBOOK_AD'   AND  PAR_DET = 'RECORDS_PER_PAGE'
  AND  LP.STATUS NOT IN('DELETED')AND LP.AUTHORIZE_STATUS ='AUTHORIZED'
  UNION ALL  
  SELECT LP.PROD_ID,PROD_DESC, 'TL'   AS PROD_TYPE,  PARAM_VALUE AS LINES_PER_PAGE,
  'GN_OD_PASSBK' AS RPTNAME FROM LOANS_PRODUCT LP
  ,PARAM_SETTINGS WHERE BEHAVES_LIKE !='OD' AND PARAM_DESC =   'PASSBOOK_TL'   AND  PAR_DET = 'RECORDS_PER_PAGE' 
  AND  LP.STATUS NOT IN('DELETED')AND LP.AUTHORIZE_STATUS ='AUTHORIZED' 
  UNION ALL 
    SELECT MD.SCHEME_NAME AS PROD_ID,MD.SCHEME_DESC AS  PROD_DESC,'MDS' AS PROD_TYPE, PARAM_VALUE AS LINES_PER_PAGE,
  'GN_MDS_PASSBK' AS RPTNAME FROM MDS_SCHEME_DETAILS MD ,PARAM_SETTINGS WHERE PARAM_DESC =  'PASSBOOK_MDS'   AND  PAR_DET = 'RECORDS_PER_PAGE'
     AND  MD.STATUS NOT IN('DELETED')AND MD.AUTHORIZEd_STATUS ='AUTHORIZED';

DROP TYPE  TAB_TYPE_PBK_GRD;

CREATE OR REPLACE TYPE TYPE_PBK_GRD  AS OBJECT
(
  ACT_NUM                 VARCHAR2(15),
  SLNO                    VARCHAR2(5),
  NEXT_SL_NO              VARCHAR2(5),
  TRANS_DT                DATE,
  PARTICULARS                 VARCHAR2(500),
  DEBIT                     NUMBER(19,2),
  CREDIT                    NUMBER(19,2),
  BALANCE                       NUMBER(19,2),
  INSTRUMENT_NO             VARCHAR2(15),
  INST_TYPE                 VARCHAR2(15),
  INST_DT                   VARCHAR2(15),
  PAGENO                    VARCHAR2(5),
  PREV_BAL                  NUMBER(19,2),
  TOD_LIMIT                 NUMBER(19,2),
  IDNO                      VARCHAR2(5)
);

/

CREATE OR REPLACE TYPE  TAB_TYPE_PBK_GRD  AS TABLE OF  TYPE_PBK_GRD ;

/

drop TYPE  TAB_TYPE_NAM_ADDRESS;

CREATE OR REPLACE TYPE TYPE_NAM_ADDRESS  AS OBJECT
(
  PROD_TYPE               VARCHAR2(5),
  MODULE_DESC             VARCHAR2(75),  
  PROD_ID                 VARCHAR2(5),
  PROD_DESC               VARCHAR2(75),
  ACT_NUM                 VARCHAR2(15),
  CUSTOMER_NAME           VARCHAR2(150),
  MINOR                   VARCHAR2(5),
  ACT_STATUS_ID           VARCHAR2(15),
  ADDRESS                 VARCHAR2(500)
);



 CREATE OR REPLACE TYPE  TAB_TYPE_NAM_ADDRESS  AS TABLE OF TYPE_NAM_ADDRESS ;

/
CREATE OR REPLACE PACKAGE  PKG_GN_PBK
AS
/*

DROP TYPE  TAB_TYPE_NAM_ADDRESS ;

CREATE OR REPLACE TYPE TYPE_NAM_ADDRESS  AS OBJECT
(
  PROD_TYPE               VARCHAR2(5),
  MODULE_DESC             VARCHAR2(75),  
  PROD_ID                 VARCHAR2(5),
  PROD_DESC               VARCHAR2(75),
  ACT_NUM                 VARCHAR2(15),
  CUSTOMER_NAME           VARCHAR2(150),
  MINOR                   VARCHAR2(5),
  ACT_STATUS_ID           VARCHAR2(15),
  ADDRESS                 VARCHAR2(500)
);

/
CREATE OR REPLACE TYPE  TAB_TYPE_NAM_ADDRESS  AS TABLE OF TYPE_NAM_ADDRESS ;

/

DROP TYPE  TAB_TYPE_PBK_GRD ;

CREATE OR REPLACE TYPE TYPE_PBK_GRD  AS OBJECT
(
  ACT_NUM                 VARCHAR2(15),
  SLNO                    VARCHAR2(5),
  NEXT_SL_NO              VARCHAR2(5),
  TRANS_DT                DATE,
  PARTICULARS                 VARCHAR2(500),
  DEBIT                     NUMBER(19,2),
  CREDIT                    NUMBER(19,2),
  BALANCE                       NUMBER(19,2),
  INSTRUMENT_NO             VARCHAR2(15),
  INST_TYPE                 VARCHAR2(15),
  INST_DT                   VARCHAR2(15),
  PAGENO                    VARCHAR2(5),
  PREV_BAL                  NUMBER(19,2),
  TOD_LIMIT                 NUMBER(19,2),
  IDNO                      VARCHAR2(5)
);

/
CREATE OR REPLACE TYPE  TAB_TYPE_PBK_GRD  AS TABLE OF  TYPE_PBK_GRD ;

DROP TYPE  TAB_TYPE_GN_PASSBOOK_MDS ;

/
CREATE OR REPLACE TYPE  TYPE_GN_PASSBOOK_MDS AS OBJECT
(
   ACT_NUM VARCHAR2 (15),
   TRANS_DT DATE,
   TRANS_ID VARCHAR2 (20),
   PRNCR NUMBER (12,2),
   PRNDR NUMBER (12,2),
   BALANCE NUMBER (12,2),
   INTR NUMBER (12, 2),
   PENAL NUMBER (19, 2),
   OTH_AMT NUMBER (19, 2),
   INSTR_NO1 VARCHAR2(50),
   INSTR_DT1 DATE,
   BONUS_CR NUMBER (12, 2),
   BONUS_DR NUMBER (12, 2),
   DUEDATE DATE,
   NARR VARCHAR2 (500),
   INSTNO VARCHAR2(20),
   COMMISSION_PAID NUMBER(12,2)
    );

/

CREATE OR REPLACE TYPE  TAB_TYPE_GN_PASSBOOK_MDS  AS TABLE OF TYPE_GN_PASSBOOK_MDS;

/



*/
 FUNCTION GN_PB_PRN_INTDT (MODULE_TYPE VARCHAR2,ACTNUM VARCHAR2) RETURN DATE;
 FUNCTION GN_PB_NAM_ADD (ACTNUM VARCHAR2) RETURN TAB_TYPE_NAM_ADDRESS;  ---FOR NAME AND ADDRESS
 FUNCTION GN_PASSBK_PROCESS (MODULE_TYPE VARCHAR2, ACTNUM VARCHAR2, INITDT DATE,INITSLNO INT,INIT_TAG INT) RETURN VARCHAR2; --- PASSBOOK PROCESS
 FUNCTION GN_PASSBOOK_TRANS_LIST (ACTNUM VARCHAR2) RETURN TAB_TYPE_PBK_GRD; -- FOR LISTING IN GRID 
 FUNCTION FUNC_GN_PASSBOOK_MDS (CHITNO VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS;
 FUNCTION FUNC_GN_PASSBOOK_RECURRING (ACTNUMBER VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS;
 FUNCTION FUNC_GN_PASSBOOK_AD (ACTNUMBER VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS;
 FUNCTION FUNC_GN_PASSBOOK_TL (ACTNUMBER VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS;
END PKG_GN_PBK;
/




CREATE OR REPLACE PACKAGE BODY PKG_GN_PBK AS 
 FUNCTION GN_PB_PRN_INTDT(MODULE_TYPE VARCHAR2,ACTNUM VARCHAR2) RETURN DATE IS
 DT DATE;
 BEGIN
  SELECT MAX(MXDT) INTO DT FROM(
  SELECT  CAST(PARAM_VALUE AS DATE) AS MXDT FROM PARAM_SETTINGS WHERE PAR_DET ='PRINT_START_DT' AND PARAM_DESC ='PASSBOOK_'||MODULE_TYPE
  UNION ALL
  SELECT MAX(TRANS_DT) AS MXDT FROM  GN_PASSBOOK  WHERE POST_TAG =1 AND TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) WHERE MXDT IS NOT NULL; 
  RETURN DT;
  END GN_PB_PRN_INTDT;
FUNCTION GN_PB_NAM_ADD (ACTNUM VARCHAR2) RETURN TAB_TYPE_NAM_ADDRESS IS 
  -- SELECT * FROM TABLE (PKG_GN_PBK.GN_PB_NAM_ADD('0001104004020'));
 NM_ADD TAB_TYPE_NAM_ADDRESS;
   BEGIN
     SELECT  TYPE_NAM_ADDRESS(PROD_TYPE,MODULE_DESC, PROD_ID,PROD_DESC,ACT_NUM,CUSTOMER_NAME,MINOR,ACT_STATUS_ID,ADDRESS) BULK COLLECT INTO  NM_ADD FROM(
     SELECT 'OA' AS  PROD_TYPE,LOOKUP_DESC AS MODULE_DESC ,AM.PROD_ID,OP.PROD_DESC AS PROD_DESC , AM.ACT_NUM AS ACT_NUM,DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME, MINOR, ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM ACT_MASTER AM, CUSTOMER C, CUST_ADDR CA ,LOOKUP_MASTER LM,OP_AC_PRODUCT OP     
     WHERE OP.PROD_ID = AM.PROD_ID AND  CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   AM.CUST_ID = C.CUST_ID      
     AND AM.ACT_NUM = ACTNUM  AND LM.LOOKUP_ID ='GNPASSBOOK.MODULE'  AND LM.LOOKUP_REF_ID ='OA' 
     UNION ALL
     SELECT 'TD' AS  PROD_TYPE,LOOKUP_DESC AS MODULE_DESC,AM.PROD_ID,OP.PROD_DESC AS PROD_DESC, AM.DEPOSIT_NO AS ACT_NUM,DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, DEPOSIT_STATUS AS ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM DEPOSIT_ACINFO AM, CUSTOMER C, CUST_ADDR CA ,LOOKUP_MASTER LM ,DEPOSITS_PRODUCT OP    
     WHERE OP.PROD_ID = AM.PROD_ID AND CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   AM.CUST_ID = C.CUST_ID      
     AND AM.DEPOSIT_NO = ACTNUM AND LM.LOOKUP_ID ='GNPASSBOOK.MODULE'  AND LM.LOOKUP_REF_ID ='TD'
     UNION ALL
     SELECT 'TL' AS  PROD_TYPE,LOOKUP_DESC AS MODULE_DESC,AM.PROD_ID,OP.PROD_DESC AS PROD_DESC,AM.ACCT_NUM AS ACT_NUM, DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, AM.ACCT_STATUS AS ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM LOANS_FACILITY_DETAILS AM,LOANS_PRODUCT LP,LOANS_BORROWER LB, CUSTOMER C, CUST_ADDR CA ,LOOKUP_MASTER LM ,LOANS_PRODUCT OP    
     WHERE OP.PROD_ID = AM.PROD_ID AND LP.BEHAVES_LIKE NOT IN('OD') AND  LP.PROD_ID =  AM.PROD_ID AND  AM.BORROW_NO =LB.BORROW_NO AND  CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   LB.CUST_ID = C.CUST_ID      
     AND AM.ACCT_NUM = ACTNUM  AND LM.LOOKUP_ID ='GNPASSBOOK.MODULE'  AND LM.LOOKUP_REF_ID ='TL'
     UNION ALL
     SELECT 'AD' AS  PROD_TYPE,LOOKUP_DESC AS MODULE_DESC,AM.PROD_ID,OP.PROD_DESC AS PROD_DESC,AM.ACCT_NUM AS ACT_NUM, DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, AM.ACCT_STATUS AS ACT_STATUS_ID, STREET || ', ' || AREA || ', ' || CITY AS ADDRESS       
     FROM LOANS_FACILITY_DETAILS AM,LOANS_PRODUCT LP,LOANS_BORROWER LB, CUSTOMER C, CUST_ADDR CA ,LOOKUP_MASTER LM ,LOANS_PRODUCT OP         
     WHERE OP.PROD_ID = AM.PROD_ID AND LP.BEHAVES_LIKE  IN('OD') AND  LP.PROD_ID =  AM.PROD_ID AND  AM.BORROW_NO =LB.BORROW_NO AND  CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   LB.CUST_ID = C.CUST_ID      
     AND AM.ACCT_NUM = ACTNUM  AND LM.LOOKUP_ID ='GNPASSBOOK.MODULE'  AND LM.LOOKUP_REF_ID ='AD'    
     UNION ALL
     SELECT 'MDS' AS  PROD_TYPE,LOOKUP_DESC AS MODULE_DESC,AM.SCHEME_NAME AS PROD_ID,OP.SCHEME_DESC AS PROD_DESC,AM.CHITTAL_NO||'_'||AM.SUB_NO AS ACT_NUM, DECODE (C.CUST_TYPE, 'INDIVIDUAL', C.FNAME||' '|| C.MNAME||' '|| C.LNAME,         C.COMP_NAME) 
     CUSTOMER_NAME,NULL AS  MINOR, AM.STATUS AS ACT_STATUS_ID, CA.STREET || ', ' || CA.AREA || ', ' || CA.CITY AS ADDRESS       
     FROM MDS_APPLICATION AM,  CUSTOMER C, CUST_ADDR CA ,LOOKUP_MASTER LM  ,MDS_SCHEME_DETAILS OP       
     WHERE OP.SCHEME_NAME = AM.SCHEME_NAME AND   CA.CUST_ID = C.CUST_ID   AND CA.ADDR_TYPE = C.COMM_ADDR_TYPE AND   AM.CUST_ID = C.CUST_ID      
     AND AM.CHITTAL_NO  = ACTNUM   AND LM.LOOKUP_ID ='GNPASSBOOK.MODULE'  AND LM.LOOKUP_REF_ID ='MDS'        );   
     RETURN NM_ADD;    
  END  GN_PB_NAM_ADD;
FUNCTION FUNC_GN_PASSBOOK_MDS (CHITNO VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS  IS   
      PBK_MDS TAB_TYPE_GN_PASSBOOK_MDS ;
/*
SELECT * FROM TABLE(FUNC_GN_PASSBOOK_MDS('0001405000007'));
*/    
    BEGIN  
        WITH MST
             AS (SELECT MSD.SCHEME_NAME,MSD.SCHEME_DESC,MSD.SCHEME_START_DT,MSD.SCHEME_END_DT,
                        MA.CHITTAL_NO||'_'||MA.SUB_NO AS CHITTAL_NO ,MSD.NO_OF_DIVISIONS,MSD.NO_OF_MEMBER_PER_DIVISION,
                        MSD.INSTALLMENT_AMOUNT FROM MDS_SCHEME_DETAILS MSD
                        JOIN MDS_APPLICATION MA ON MA.SCHEME_NAME = MSD.SCHEME_NAME
                  WHERE MA.CHITTAL_NO||'_'||MA.SUB_NO = CHITNO||'_'||MA.SUB_NO),
             PRIZED_MONEY_DET
             AS (SELECT MPD.SCHEME_NAME,MPD.DRAW_AUCTION_DATE,MPD.NEXT_INSTALLMENT_DATE AS DUEDATE,
                        MPD.INSTALLMENT_NO,MPD.CHITTAL_NO,MPD.NEXT_BONUS_AMOUNT AS BONUS_AMT,
                        M.INSTALLMENT_AMOUNT - MPD.NEXT_BONUS_AMOUNT AS SUBSCRIPTION_AMT,
                        TO_CHAR (MPD.NEXT_INSTALLMENT_DATE, 'DD') AS DUE_DAY,
                        INITCAP (TO_CHAR (MPD.NEXT_INSTALLMENT_DATE, 'MM')) AS DUE_MONTH,
                        TO_CHAR (MPD.NEXT_INSTALLMENT_DATE, 'YYYY') AS DUE_YR
                   FROM MDS_PRIZED_MONEY_DETAILS MPD 
                        JOIN MST M ON M.SCHEME_NAME = MPD.SCHEME_NAME AND MPD.AUTHORIZED_STATUS = 'AUTHORIZED' AND MPD.STATUS NOT IN ('DELETED')),
             MDS_TRANS
             AS (SELECT DENSE_RANK () OVER (ORDER BY MTD.TRANS_DT, MTD.NET_TRANS_ID)  AS START_SLNO,
                        CASE WHEN MTD.NO_OF_INST > 1  THEN
                          TO_CHAR (TO_NUMBER ((  DENSE_RANK () OVER ( ORDER BY MTD.TRANS_DT, MTD.NET_TRANS_ID)+ MTD.NO_OF_INST))- 1)
                        ELSE
                          TO_CHAR (DENSE_RANK () OVER (ORDER BY MTD.TRANS_DT, MTD.NET_TRANS_ID))
                        END  AS END_SLNO,MTD.SCHEME_NAME,MTD.CHITTAL_NO||'_'||MTD.SUB_NO AS CHITTAL_NO,MTD.NO_OF_INST,
                        MTD.TRANS_DT,MTD.NET_TRANS_ID,(MTD.INST_AMT * NO_OF_INST) - MTD.BONUS_AMT AS SUBSCRIPTION_AMT,
                        MTD.BONUS_AMT,MTD.PENAL_AMT
                   FROM MDS_TRANS_DETAILS MTD
                   JOIN MST M ON M.CHITTAL_NO = MTD.CHITTAL_NO||'_'||MTD.SUB_NO)
         SELECT     TYPE_GN_PASSBOOK_MDS (ACT_NUM,TRANS_DT,TRANS_ID,PRNCR,PRNDR,BALANCE,INTR, PENAL,OTH_AMT,INSTR_NO1,INSTR_DT1,
                                         BONUS_CR,BONUS_DR ,DUEDATE,NARR, INSTNO,COMMISSION_PAID )  BULK COLLECT INTO  PBK_MDS FROM (SELECT 
         CHITTAL_NO AS ACT_NUM,TRANS_DT,NET_TRANS_ID AS TRANS_ID, PRNCR,  PRNDR,  BALANCE,  0 as INTR,  penal_amt AS PENAL,
         0 as oth_amt,    null as instr_no1,   null as instr_dt1,  BONUS_CR,  BONUS_DR,   duedate,  narration as narr, INSTNO,COMMISSION AS COMMISSION_PAID 
         FROM            
        (SELECT CHITTAL_NO ,INSTNO,DUEDATE,TRANS_DT,NET_TRANS_ID,0 AS PRNDR,SUBSCRIPTION_AMT AS PRNCR,0 AS BONUS_DR,
        BONUS_AMT AS BONUS_CR,0 AS COMMISSION, PENAL_AMT AS PENAL_AMT,
        SUM (NVL (SUBSCRIPTION_AMT, 0) + NVL (BONUS_AMT, 0))  OVER (ORDER BY TRANS_DT, NET_TRANS_ID) AS BALANCE,NARRATION ||' [Inst No  '||INSTNO||']' as NARRATION 
          FROM (SELECT M.CHITTAL_NO,  CASE WHEN TO_NUMBER (END_SLNO) = TO_NUMBER (START_SLNO)  THEN
                             TO_CHAR (TO_NUMBER (START_SLNO))
                        ELSE
                              TO_CHAR (TO_NUMBER (START_SLNO)) || ' To ' || TO_CHAR (TO_NUMBER (END_SLNO))
                        END  AS INSTNO,
                        CASE WHEN T.NO_OF_INST > 1 THEN
                             (SELECT P.DUEDATE FROM PRIZED_MONEY_DET P WHERE TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.END_SLNO))
                        ELSE
                             P.DUEDATE
                        END AS DUEDATE, T.TRANS_DT,T.SUBSCRIPTION_AMT,T.BONUS_AMT,T.PENAL_AMT,T.NET_TRANS_ID,
                        CASE WHEN T.NO_OF_INST > 1 THEN 
                            (SELECT  trim(DUE_MONTH)||'/'||trim(DUE_YR) FROM PRIZED_MONEY_DET P WHERE TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.START_SLNO))||' To '||
                            (SELECT  trim(DUE_MONTH)||'/'||trim(DUE_YR) FROM PRIZED_MONEY_DET P WHERE TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.end_slno)) 
                        ELSE 
                            trim(DUE_MONTH)||'/'||trim(DUE_YR)
                        END AS NARRATION
                  FROM MST M
                  LEFT JOIN MDS_TRANS T ON M.CHITTAL_NO = T.CHITTAL_NO
                  LEFT JOIN PRIZED_MONEY_DET P ON P.SCHEME_NAME = M.SCHEME_NAME AND TO_NUMBER (P.INSTALLMENT_NO) = TO_NUMBER (T.END_SLNO))
        UNION ALL
        SELECT MST.CHITTAL_NO, TO_CHAR (PRIZED_INST_NO) AS PAID_INSTLNO,NULL AS INST_DUE_DT,STATUS_DT AS PAID_DT,NVL(MPD.CASH_ID,TRANS_ID) AS NET_TRANS_ID,  NVL (PRIZED_AMOUNT, 0)  AS PRNDR,0 AS PRNCR,
               BONUS_AMOUNT AS BONUS_DR, 0 AS  BONUS_CR,NVL (COMMISION_AMOUNT, 0) AS COMMISSION ,0 AS PENAL,
               NULL AS BALANCE,'Prized Inst No '|| TO_CHAR (PRIZED_INST_NO) as NARRATION
          FROM MDS_MONEY_PAYMENT_DETAILS MPD
          JOIN MST ON MST.CHITTAL_NO = MPD.CHITTAL_NO||'_'||MPD.SUB_NO  AND MPD.STATUS NOT IN ('DELETED') AND MPD.AUTHORIZED_STATUS = 'AUTHORIZED'));
     RETURN PBK_MDS;
   END   FUNC_GN_PASSBOOK_MDS;
FUNCTION FUNC_GN_PASSBOOK_RECURRING (ACTNUMBER VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS  IS   
      PBK_RD TAB_TYPE_GN_PASSBOOK_MDS ;
/*
 SELECT * FROM TABLE(FUNC_GN_PASSBOOK_RECURRING('0003204001722'));
*/    
BEGIN      
        WITH MSTR AS 
            (
            SELECT DA.DEPOSIT_NO,DP.ACCT_HEAD,DPA.INT_PAY AS  INT_DEBIT,DPA.DELAYED_ACHD,DSA.DEPOSIT_DT,DSA.MATURITY_DT,
               DSA.DEPOSIT_AMT,DSA.DEPOSIT_PERIOD_MM,DSA.RATE_OF_INT,DA.DEPOSIT_NO||'_1' AS LINK_ID
            FROM DEPOSIT_ACINFO DA
               JOIN DEPOSIT_SUB_ACINFO DSA ON DSA.DEPOSIT_NO = DA.DEPOSIT_NO
               JOIN DEPOSITS_PRODUCT DP ON DP.PROD_ID = DA.PROD_ID
               JOIN CUSTOMER C ON C.CUST_ID = DA.CUST_ID
               JOIN DEPOSITS_PROD_ACHD DPA ON DPA.PROD_ID = DP.PROD_ID
            WHERE DP.BEHAVES_LIKE = 'RECURRING' AND DSA.DEPOSIT_NO = ACTNUMBER AND 
            DSA.AUTHORIZE_STATUS = 'AUTHORIZED' AND DA.AUTHORIZE_STATUS = 'AUTHORIZED'
            ),
        PRINC_TRNS AS
            ( SELECT A.* FROM 
                (SELECT MSTR.DEPOSIT_NO,CT.TRANS_DT,CT.TRANS_ID,DECODE(CT.TRANS_TYPE,'CREDIT',CT.AMOUNT,0) AS CRPRINC,
                       DECODE(CT.TRANS_TYPE,'DEBIT',CT.AMOUNT,0) AS DRPRINC,0 AS INTEREST,0 AS PENAL
                  FROM MSTR
                       JOIN CASH_TRANS CT ON CT.AC_HD_ID = MSTR.ACCT_HEAD AND CT.ACT_NUM = MSTR.LINK_ID
                 WHERE  CT.AUTHORIZE_STATUS = 'AUTHORIZED' AND CT.STATUS NOT IN ('DELETED')
                UNION ALL
                SELECT MSTR.DEPOSIT_NO,CT.TRANS_DT,CT.BATCH_ID,DECODE(CT.TRANS_TYPE,'CREDIT',CT.AMOUNT,0) AS CRPRINC,
                       DECODE(CT.TRANS_TYPE,'DEBIT',CT.AMOUNT,0) AS DRPRINC,0 AS INTEREST,0 AS PENAL
                  FROM MSTR
                       JOIN TRANSFER_TRANS CT
                          ON CT.AC_HD_ID = MSTR.ACCT_HEAD AND CT.ACT_NUM = MSTR.LINK_ID
                 WHERE CT.AUTHORIZE_STATUS = 'AUTHORIZED' AND CT.STATUS NOT IN ('DELETED')
                 ) A
             LEFT JOIN
                 ( 
                  SELECT S.TRANS_DT,S.BATCH_ID,S.ACT_NUM FROM TRANSFER_TRANS S 
                    JOIN(
                   SELECT * FROM TRANSFER_TRANS T 
                            JOIN MSTR M ON M.INT_DEBIT = T.AC_HD_ID 
                   WHERE T.TRANS_TYPE = 'DEBIT' AND T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS NOT IN ('DELETED')
                   )L ON L.TRANS_DT=S.TRANS_DT AND L.BATCH_ID = S.BATCH_ID
                    WHERE S.TRANS_TYPE = 'CREDIT'  AND  S.AUTHORIZE_STATUS = 'AUTHORIZED' AND S.STATUS NOT IN ('DELETED')
                 ) F ON F.TRANS_DT = A.TRANS_DT AND F.BATCH_ID = A.TRANS_ID AND A.DEPOSIT_NO||'_1' =F.ACT_NUM
                 WHERE F.ACT_NUM IS NULL
             ),
        INTR_TRNS AS
         (SELECT REPLACE(S.ACT_NUM,'_1',NULL) AS DEPOSIT_NO, S.TRANS_DT,S.BATCH_ID,0 AS CRPRINC, 0 AS DRPRINC,
          S.AMOUNT AS INTEREST,0 AS PENAL FROM TRANSFER_TRANS S
            JOIN(
               SELECT * FROM TRANSFER_TRANS T 
                        JOIN MSTR M ON M.INT_DEBIT = T.AC_HD_ID
               WHERE T.TRANS_TYPE = 'DEBIT' AND T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS NOT IN ('DELETED')
           )L ON L.TRANS_DT=S.TRANS_DT AND L.BATCH_ID = S.BATCH_ID 
            WHERE  S.TRANS_TYPE = 'CREDIT' AND S.AUTHORIZE_STATUS = 'AUTHORIZED' AND S.STATUS NOT IN ('DELETED')
           UNION ALL
           SELECT MSTR.DEPOSIT_NO,CT.TRANS_DT,CT.TRANS_ID,0 AS CRPRINC, 0 AS DRPRINC,
           CT.AMOUNT AS INTEREST,0 AS PENAL FROM CASH_TRANS CT 
           JOIN MSTR ON MSTR.INT_DEBIT = CT.AC_HD_ID  AND  MSTR.LINK_ID = CT.LINK_BATCH_ID
           WHERE CT.AUTHORIZE_STATUS = 'AUTHORIZED' AND CT.STATUS NOT IN ('DELETED')  
          ),
        PENAL_TRANS AS
         (
            SELECT MSTR.DEPOSIT_NO,CT.TRANS_DT,CT.TRANS_ID,0 AS CRPRINC, 0 AS DRPRINC,
                   0 AS INTEREST,  CT.AMOUNT AS PENAL 
            FROM CASH_TRANS CT
            JOIN MSTR ON MSTR.LINK_ID = CT.LINK_BATCH_ID AND MSTR.DELAYED_ACHD = CT.AC_HD_ID
            WHERE CT.AUTHORIZE_STATUS = 'AUTHORIZED'
            AND CT.STATUS NOT IN ('DELETED') AND CT.TRANS_TYPE= 'CREDIT'
            UNION ALL
            SELECT MSTR.DEPOSIT_NO,CT.TRANS_DT,CT.BATCH_ID,0 AS CRPRINC,0 AS DRPRINC,
                   0 AS INTEREST,CT.AMOUNT AS PENAL  
            FROM TRANSFER_TRANS CT
            JOIN MSTR ON MSTR.LINK_ID = CT.LINK_BATCH_ID AND MSTR.DELAYED_ACHD = CT.AC_HD_ID
            WHERE CT.AUTHORIZE_STATUS = 'AUTHORIZED'
            AND CT.STATUS NOT IN ('DELETED') AND CT.TRANS_TYPE= 'CREDIT'
         )
         SELECT  TYPE_GN_PASSBOOK_MDS(ACT_NUM,TRANS_DT,TRANS_ID,PRNCR,PRNDR,BALANCE,INTR,PENAL,
         OTH_AMT,INSTR_NO1,INSTR_DT1,BONUS_CR,BONUS_DR,DUEDATE,NARR,INSTNO,COMMISSION_PAID)  BULK COLLECT INTO  PBK_RD 
         FROM (SELECT DEPOSIT_NO AS ACT_NUM ,TRANS_DT ,TRANS_ID,CRPRINC AS PRNCR ,
                 DRPRINC AS PRNDR,BALANCE,INTEREST AS INTR ,PENAL,0 AS OTH_AMT,NULL AS INSTR_NO1,NULL AS INSTR_DT1,0 AS BONUS_CR,
                 0 AS BONUS_DR,NULL AS DUEDATE, 
                 CASE WHEN CRPRINC > 0 THEN
                   CASE WHEN NOOF_INST > 1 THEN
                         'Inst# From ' || START_NO || ' To ' || END_NO
                   ELSE
                         'Inst# ' || INST_NO
                   END
                 ELSE
                   NULL
                 END AS NARR,NULL AS INSTNO,0 AS COMMISSION_PAID
                FROM 
                    (SELECT DEPOSIT_NO, DEPOSIT_AMT,TRANS_DT,TRANS_ID,CRPRINC,DRPRINC,
                            INTEREST,PENAL,BALANCE,NOOF_INST,SUM (NOOF_INST) OVER (ORDER BY TRANS_DT, TRANS_ID) AS INST_NO,
                             CASE WHEN NOOF_INST > 1 THEN
                              SUM (NOOF_INST) OVER (ORDER BY TRANS_DT, TRANS_ID)- ( (NOOF_INST) - 1)
                             ELSE
                              SUM (NOOF_INST) OVER (ORDER BY TRANS_DT, TRANS_ID)
                             END AS START_NO,
                             CASE  WHEN NOOF_INST > 1 THEN
                              SUM (NOOF_INST) OVER (ORDER BY TRANS_DT, TRANS_ID)
                             ELSE
                              SUM (NOOF_INST) OVER (ORDER BY TRANS_DT, TRANS_ID)
                             END AS END_NO
                    FROM 
                        (SELECT DEPOSIT_NO,DEPOSIT_AMT,TRANS_DT,TRANS_ID,CRPRINC,DRPRINC,
                                INTEREST,PENAL,BALANCE,CRPRINC / DEPOSIT_AMT AS NOOF_INST
                        FROM 
                            (SELECT M.DEPOSIT_NO,MSTR.DEPOSIT_AMT,M.TRANS_DT,
                                    M.TRANS_ID,M.CRPRINC,M.DRPRINC,M.INTEREST,M.PENAL,
                                    SUM (CRPRINC - DRPRINC)OVER (PARTITION BY M.DEPOSIT_NO ORDER BY M.DEPOSIT_NO, M.TRANS_DT, M.TRANS_ID) AS BALANCE
                             FROM MSTR
                             LEFT JOIN 
                             (SELECT * FROM PRINC_TRNS
                               UNION ALL
                              SELECT * FROM INTR_TRNS
                               UNION ALL
                              SELECT * FROM PENAL_TRANS) M ON M.DEPOSIT_NO = MSTR.DEPOSIT_NO))))
ORDER BY TRANS_DT, TRANS_ID;
RETURN PBK_RD;
END FUNC_GN_PASSBOOK_RECURRING;
FUNCTION FUNC_GN_PASSBOOK_AD (ACTNUMBER VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS  IS   
      PBK_TL TAB_TYPE_GN_PASSBOOK_MDS ;
/*
 SELECT * FROM TABLE(FUNC_GN_PASSBOOK_AD('0003204001722'));
*/     
BEGIN
SELECT TYPE_GN_PASSBOOK_MDS(ACT_NUM,TRANS_DT,TRANS_ID,PRNCR,PRNDR,BALANCE,INTR,PENAL,
         OTH_AMT,INSTR_NO1,INSTR_DT1,BONUS_CR,BONUS_DR,DUEDATE,NARR,INSTNO,COMMISSION_PAID) BULK COLLECT INTO  PBK_TL 
       FROM (               
SELECT ACT_NUM,TRANS_DT,TRANS_ID,DECODE(TRANS_TYPE,'DEBIT',PRINCIPLE,0) AS PRNDR,DECODE(TRANS_TYPE,'CREDIT',PRINCIPLE,0) AS PRNCR,PRNBAL AS BALANCE,INTEREST AS INTR,PENAL,
0 AS OTH_AMT,NULL AS INSTR_NO1,NULL AS INSTR_DT1,OTHCHG_CR AS BONUS_CR,OTHCH_DR AS BONUS_DR,NULL AS DUEDATE,PARTICULARS AS NARR,NULL AS INSTNO,NULL AS COMMISSION_PAID FROM (               
SELECT ACT_NUM,  TRANS_DT,TRANS_ID,TRANS_TYPE,SUM(PRINCIPLE) AS PRINCIPLE,SUM((DECODE(TRANS_TYPE,'CREDIT',-1,1)* SUM(NVL(PRINCIPLE,0)))) OVER (ORDER BY TRANS_DT,TRANS_ID,TRANS_TYPE DESC ) AS PRNBAL,
       SUM(INTEREST) AS INTEREST ,SUM(PENAL) AS PENAL,SUM(OTHCHG_CR) AS OTHCHG_CR,SUM(OTHCH_DR) AS OTHCH_DR, 
       MIN(PARTICULARS) AS PARTICULARS  FROM ( SELECT LT.ACT_NUM, TRANS_DT,TRANS_ID,TRANS_TYPE,PRINCIPLE, INTEREST,PENAL, NVL(LEGAL_CHARGE,0)  +  NVL( INSURANCE_CHARGE,0)  +
       NVL( MISC_CHARGES,0) +NVL(LT.POSTAGE_CHARGE,0) +NVL(LT.POSTAGE_CHARGE,0) + NVL(LT.ARBITARY_CHARGE,0)  + DECODE(PARTICULARS,'ARC_COST',NVL(LT.EXPENSE,0),0)
       + NVL(LT.ARBITARY_CHARGE,0) + NVL(LT.EXE_DEGREE,0) AS OTHCHG_CR,0 AS OTHCH_DR,
       LT.PARTICULARS  
       FROM ADV_TRANS_DETAILS LT WHERE LT.ACT_NUM =ACTNUMBER 
       AND LT.AUTHORIZE_STATUS = 'AUTHORIZED'
       UNION ALL   
       SELECT A.ACT_NUM, CHARGE_DATE AS TRANS_DT,TO_CHAR(A.CHARGE_NO) AS TRANS_ID,'DEBIT' AS TRANS_TYPE,NULL AS PRINCIPLE, NULL AS INTEREST,NULL AS PENAL,
       0  AS OTHCHG_CR, A.AMOUNT AS OTHCH_DR,NULL AS PARTICULARS 
       FROM LOANS_ACCT_CHARGE_DETAILS A 
       WHERE A.ACT_NUM = ACTNUMBER AND A.AUTHORIZE_STATUS = 'AUTHORIZED' AND A.STATUS NOT IN ('DELETED')
       UNION ALL
       SELECT  AL.LINK_BATCH_ID, TRANS_DT, TRANS_ID,TRANS_TYPE,NULL AS PRINCIPLE, NULL AS INTEREST,NULL AS PENAL,
       CASE WHEN RC.CHARGE_DESC='Risk Fund' AND AL.TRANS_TYPE='CREDIT' THEN  AL.AMOUNT ELSE 0 END   AS OTHCHG_CR,
       CASE WHEN RC.CHARGE_DESC='Risk Fund' AND AL.TRANS_TYPE='DEBIT' THEN  AL.AMOUNT ELSE 0 END AS OTHCH_DR,  PARTICULARS 
       FROM ALL_TRANS AL JOIN RPT_CHARGE_RISKFUND RC ON AL.AC_HD_ID = RC.ACC_HEAD
       AND AL.LINK_BATCH_ID = ACTNUMBER
       AND AL.AUTHORIZE_STATUS = 'AUTHORIZED' AND AL.STATUS NOT IN ('DELETED')
       ) TR
       GROUP BY ACT_NUM,TRANS_DT,TRANS_ID,TRANS_TYPE) ORDER BY TRANS_DT,TRANS_ID,TRANS_TYPE DESC);
RETURN PBK_TL; 
END FUNC_GN_PASSBOOK_AD;
FUNCTION FUNC_GN_PASSBOOK_TL (ACTNUMBER VARCHAR2) RETURN   TAB_TYPE_GN_PASSBOOK_MDS  IS   
      PBK_TL TAB_TYPE_GN_PASSBOOK_MDS ;
/*
 SELECT * FROM TABLE(FUNC_GN_PASSBOOK_TL('0003204001722'));
*/    
BEGIN
SELECT TYPE_GN_PASSBOOK_MDS(ACT_NUM,TRANS_DT,TRANS_ID,PRNCR,PRNDR,BALANCE,INTR,PENAL,
         OTH_AMT,INSTR_NO1,INSTR_DT1,BONUS_CR,BONUS_DR,DUEDATE,NARR,INSTNO,COMMISSION_PAID) BULK COLLECT INTO  PBK_TL 
       FROM (     
SELECT ACT_NUM,TRANS_DT,TRANS_ID,DECODE(TRANS_TYPE,'DEBIT',PRINCIPLE,0) AS  PRNDR,DECODE(TRANS_TYPE,'CREDIT',PRINCIPLE,0) AS PRNCR,PRNBAL AS BALANCE,INTEREST AS INTR,PENAL,
       0 AS OTH_AMT,NULL AS INSTR_NO1,NULL AS INSTR_DT1,OTHCHG_CR AS BONUS_CR,OTHCH_DR AS BONUS_DR,NULL AS DUEDATE,PARTICULARS AS NARR,NULL AS INSTNO,0 AS COMMISSION_PAID FROM (
SELECT ACT_NUM, TRANS_DT,TRANS_ID,TRANS_TYPE,SUM(PRINCIPLE) AS PRINCIPLE,SUM((DECODE(TRANS_TYPE,'CREDIT',-1,1)* SUM(NVL(PRINCIPLE,0)))) OVER (ORDER BY TRANS_DT,TRANS_ID,TRANS_TYPE DESC ) AS PRNBAL,
       SUM(INTEREST) AS INTEREST ,SUM(PENAL) AS PENAL,SUM(OTHCHG_CR) AS OTHCHG_CR,SUM(OTHCH_DR) AS OTHCH_DR, 
       MIN(PARTICULARS) AS PARTICULARS  FROM (SELECT LT.ACT_NUM, TRANS_DT,TRANS_ID,TRANS_TYPE,PRINCIPLE, INTEREST,PENAL, NVL(LEGAL_CHARGE,0)  +  NVL( INSURANCE_CHARGE,0)  +
       NVL( MISC_CHARGES,0) +NVL(LT.POSTAGE_CHARGE,0) +NVL(LT.NOTICE_CHARGES,0) +NVL(LT.POSTAGE_CHARGE,0) + NVL(LT.ARBITARY_CHARGE,0)  + DECODE(PARTICULARS,'ARC_COST',NVL(LT.EXPENSE,0),0)
       + NVL(LT.ARBITARY_CHARGE,0) + NVL(LT.EXE_DEGREE,0) AS OTHCHG_CR,0 AS OTHCH_DR,
       LT.PARTICULARS  
       FROM LOAN_TRANS_DETAILS LT WHERE LT.ACT_NUM =ACTNUMBER
       AND LT.AUTHORIZE_STATUS = 'AUTHORIZED' 
       UNION ALL   
       SELECT A.ACT_NUM, CHARGE_DATE AS TRANS_DT,TO_CHAR(A.CHARGE_NO) AS TRANS_ID,'DEBIT' AS TRANS_TYPE,NULL AS PRINCIPLE, NULL AS INTEREST,NULL AS PENAL,
       0  AS OTHCHG_CR, A.AMOUNT AS OTHCH_DR,NULL AS PARTICULARS 
       FROM LOANS_ACCT_CHARGE_DETAILS A 
       WHERE A.ACT_NUM = ACTNUMBER AND A.AUTHORIZE_STATUS = 'AUTHORIZED'
       UNION ALL
       SELECT AL.LINK_BATCH_ID, TRANS_DT, TRANS_ID,TRANS_TYPE,NULL AS PRINCIPLE, NULL AS INTEREST,NULL AS PENAL,
       CASE WHEN RC.CHARGE_DESC='Risk Fund' AND AL.TRANS_TYPE='CREDIT' THEN  AL.AMOUNT ELSE 0 END   AS OTHCHG_CR,
       CASE WHEN RC.CHARGE_DESC='Risk Fund' AND AL.TRANS_TYPE='DEBIT' THEN  AL.AMOUNT ELSE 0 END AS OTHCH_DR,  PARTICULARS 
       FROM ALL_TRANS AL JOIN RPT_CHARGE_RISKFUND RC ON AL.AC_HD_ID = RC.ACC_HEAD
       AND AL.LINK_BATCH_ID = ACTNUMBER
       AND AL.AUTHORIZE_STATUS = 'AUTHORIZED' AND AL.STATUS NOT IN ('DELETED')
       ) TR
       GROUP BY ACT_NUM,TRANS_DT,TRANS_ID,TRANS_TYPE) ORDER BY TRANS_DT,TRANS_ID,TRANS_TYPE DESC);
RETURN PBK_TL; 
END FUNC_GN_PASSBOOK_TL;
FUNCTION GN_PASSBK_PROCESS (MODULE_TYPE VARCHAR2, ACTNUM VARCHAR2, INITDT DATE,INITSLNO INT,INIT_TAG INT) RETURN VARCHAR2 IS
  PRAGMA AUTONOMOUS_TRANSACTION;
    -- LAST PRINT LINE ONWARDS
    -- SELECT PKG_GN_PBK.GN_PASSBK_PROCESS ('OA','0001104004020',null,null,0) FROM DUAL;
    -- INITIALISE
    --   SELECT PKG_GN_PBK.GN_PASSBK_PROCESS ('OA','0001104004020','01APR2018',5,1) FROM DUAL;
     REC_PER_PAGE INT; 
     PRINT_STRT_DT DATE;
     ACT_OPN_DT DATE;
     TMP_OB NUMBER(19,2);
     CNT INT:=0;
     PRV_PRINT_CNT INT;
     MST_CLR_BALANCE NUMBER(19,2);
     PSBK_CLR_BALANCE NUMBER(19,2);
     MSG VARCHAR2(75);
     SKIPLNE INT;
     SKIPCNT  INT;
     INIT_DT DATE;
     INIT_SLNO INT;
    BEGIN   
         COMMIT;
         DELETE TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM;
         COMMIT;
         IF INIT_TAG =1 THEN 
          DELETE FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM;
          COMMIT;
     --    ELSE  -- UNCOMMENT AFTER ENABLING PRINT ON  REPRINT BUTTON 
     --     DELETE FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM AND POST_TAG =0;
          COMMIT;  
         END IF;  
         IF INITSLNO IS NULL THEN
              INIT_SLNO:=1;
         ELSE 
              INIT_SLNO:=INITSLNO;     
         END IF;
         SELECT COUNT(*) INTO PRV_PRINT_CNT FROM GN_PASSBOOK WHERE ACT_NUM = ACTNUM ;  ---AND POST_TAG =1;
--OPERATIVE         
       IF MODULE_TYPE ='OA' THEN
             IF INITDT IS NULL THEN
              SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_START_DT';
             ELSE 
              INIT_DT:= INITDT;
             END IF;
         SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
         SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM ACT_MASTER AM WHERE AM.ACT_NUM = ACTNUM;
         SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_OA'  AND    PAR_DET ='RECORDS_PER_PAGE';
         SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_OA'  AND  PAR_DET ='PRINT_START_DT';   
          IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
               SELECT MIN(TRANS_DT) INTO PRINT_STRT_DT FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
          END IF;  
         IF INIT_TAG =1  THEN  -- REPRINT OR INITIALISE
            PRINT_STRT_DT :=INIT_DT;
          IF  INIT_SLNO >1 THEN --BLANK LINES
            INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
             SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
             NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
             FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
             COMMIT;
           END IF;  
         END IF;                  
          --OPENING       
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
          SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO, PRINT_STRT_DT  AS  TRANS_DT,'Opening' AS TRANS_ID,NULL AS PRNCR,NULL AS PRNDR, 
          SUM(AMOUNT) AS BAL,NULL AS INTR, NULL AS PENAL, NULL AS OTH_AMT, NULL AS INSTR_NO1, NULL AS INSTR_DT1,NULL AS BONUS, 'Opening' AS NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
          FROM ( SELECT TRANS_DT,'' AS BATCH_ID,TRANS_ID,TRANS_TYPE,(DECODE(TRANS_TYPE,'DEBIT',-1,1)* AMOUNT) AS AMOUNT,C.ROWID AS RWID  FROM CASH_TRANS C ,OP_AC_PRODUCT P  WHERE C.AC_HD_ID = P.AC_HD_ID  AND 
           SUBSTR(C.ACT_NUM,5,3) = P.PROD_ID AND  C.TRANS_DT < PRINT_STRT_DT     AND 
           C.ACT_NUM =ACTNUM AND C.AUTHORIZE_STATUS ='AUTHORIZED' AND C.STATUS NOT IN('DELETED') 
          UNION ALL 
           SELECT TRANS_DT,BATCH_ID,TRANS_ID,TRANS_TYPE,(DECODE(TRANS_TYPE,'DEBIT',-1,1)* AMOUNT) AS AMOUNT,T.ROWID AS RWID  FROM TRANSFER_TRANS T ,OP_AC_PRODUCT P  WHERE T.AC_HD_ID =  P.AC_HD_ID   AND 
           SUBSTR(T.ACT_NUM,5,3) = P.PROD_ID AND T.TRANS_DT < PRINT_STRT_DT  AND 
           T.ACT_NUM =ACTNUM AND T.AUTHORIZE_STATUS ='AUTHORIZED' AND T.STATUS NOT IN('DELETED') ) TR ;   
           COMMIT;
           SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM;               
         COMMIT; 
          ---TRANSACTIONS                                     
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM , SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID)+CNT
                 AS IDNO,  TRANS_DT,  TRANS_ID,DECODE(TRANS_TYPE,'CREDIT',AMOUNT,0) AS PRNCR,DECODE(TRANS_TYPE,'DEBIT',AMOUNT,0) AS   PRNDR, 
             SUM((DECODE(TR.TRANS_TYPE,'DEBIT',-1,1)* AMOUNT)) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID)+NVL(TMP_OB,0) AS BAL,NULL AS INTR, NULL AS PENAL, NULL AS OTH_AMT, 
             INSTRUMENT_NO1 AS INSTR_NO1, INST_DT AS INSTR_DT1,NULL AS BONUS,PARTICULARS AS  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.RWID,TR.TRANS_TYPE DESC)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (
           SELECT TRANS_DT, TRANS_ID,TRANS_TYPE,AMOUNT,C.INSTRUMENT_NO1,C.INST_DT,C.PARTICULARS,C.STATUS_DT,C.ROWID AS RWID  FROM CASH_TRANS C ,OP_AC_PRODUCT P  WHERE C.AC_HD_ID = P.AC_HD_ID  AND 
            SUBSTR(C.ACT_NUM,5,3) = P.PROD_ID AND  C.TRANS_DT >= PRINT_STRT_DT AND 
            C.ACT_NUM =ACTNUM AND C.AUTHORIZE_STATUS ='AUTHORIZED' AND C.STATUS NOT IN('DELETED') 
          UNION ALL 
            SELECT TRANS_DT,BATCH_ID||'_'||TRANS_ID AS TRANS_ID,TRANS_TYPE,AMOUNT,T.INSTRUMENT_NO1,T.INST_DT,T.PARTICULARS,T.STATUS_DT,T.ROWID AS RWID  FROM TRANSFER_TRANS T ,OP_AC_PRODUCT P  WHERE T.AC_HD_ID =  P.AC_HD_ID   AND 
            SUBSTR(T.ACT_NUM,5,3) = P.PROD_ID AND  t.TRANS_DT >=  PRINT_STRT_DT AND 
            T.ACT_NUM =ACTNUM AND T.AUTHORIZE_STATUS ='AUTHORIZED' AND T.STATUS NOT IN('DELETED')   ) TR    
              ORDER BY TR.TRANS_DT,TR.STATUS_DT,TR.TRANS_TYPE ,TR.RWID; 
         COMMIT;
        --NEW ENTRY INSERTION
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG, PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(         
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG, PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE ACT_NUM =ACTNUM  ),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1),
              PBK AS( SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
               (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM 
               PSBKALL ORDER BY IDNO,TAG,ORDNO, TRANS_DT)
               SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                     PAGENO, SAVE_DT, RWID FROM PBK PK WHERE  NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =PK.IDNO) ;
          COMMIT;
           DELETE FROM TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM ; 
          COMMIT;
          SELECT BAL INTO PSBK_CLR_BALANCE FROM GN_PASSBOOK GP WHERE TRANS_DT IS NOT NULL AND  ACT_NUM =ACTNUM AND IDNO =(SELECT MAX(IDNO) FROM  GN_PASSBOOK   WHERE TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) ;  
              IF MST_CLR_BALANCE = PSBK_CLR_BALANCE THEN
               MSG:='1 PROCESS COMPLETED';    
              ELSE
               --DELETE FROM GN_PASSBOOK GP WHERE POST_TAG =0 AND ACT_NUM =ACTNUM;
               COMMIT; 
               MSG:='0 BALANCE AMOUNT MISMATCH '|| CAST(MST_CLR_BALANCE AS VARCHAR2)   || ', ' || CAST(PSBK_CLR_BALANCE AS VARCHAR2 )  || ' = ' ||  CAST((MST_CLR_BALANCE - PSBK_CLR_BALANCE)  AS VARCHAR2 )  ;
              END IF;
---MDS              
       ELSIF MODULE_TYPE ='MDS' THEN
             IF INITDT IS NULL THEN
              SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND  PAR_DET ='PRINT_START_DT';
             ELSE 
              INIT_DT:= INITDT;
             END IF;
           SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
           --SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM MDS_ AM WHERE AM.ACT_NUM = ACTNUM;
           SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND    PAR_DET ='RECORDS_PER_PAGE';
           SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_MDS'  AND  PAR_DET ='PRINT_START_DT';
           IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
               SELECT MIN(TRANS_DT) INTO PRINT_STRT_DT FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
           END IF;  
           IF INIT_TAG =1  THEN  -- REPRINT OR INITIALISE
            PRINT_STRT_DT :=INIT_DT;
              IF  INIT_SLNO >1 THEN --BLANK LINES
                INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
                 SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
                 NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
                 FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
                 COMMIT;
              END IF;     
           END IF;                  
                --OPENING    
                 INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, 
                 NARR, POST_TAG,     PAGENO, SAVE_DT)
                   SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO, PRINT_STRT_DT  AS  TRANS_DT,
                   TRANS_ID, PRNCR, PRNDR, 
                   BAL, INTR,  PENAL,  OTH_AMT, INSTR_NO1,  INSTR_DT1, BONUS,   NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
                  FROM (           
                     SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, BONUS_DR AS INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                     INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                       FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_MDS(ACTNUM))WHERE  TRANS_DT <PRINT_STRT_DT  
                   ) TR ;   
                   COMMIT;
                   SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
         -- TRANSACTIONS                                
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM ,  SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT  AS IDNO,  TRANS_DT,  TRANS_ID, PRNCR,    PRNDR, 
               BAL,  INTR,   PENAL,  OTH_AMT,  INSTR_NO1,   INSTR_DT1,  BONUS,  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, BONUS_DR AS INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                 INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR  ,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                   FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_MDS(ACTNUM)) WHERE  TRANS_DT >= PRINT_STRT_DT  ) TR    
              ORDER BY TR.TRANS_DT,TR.RWID; 
         COMMIT;
        --NEW ENTRY INSERTION         
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(         
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE POST_TAG =0  ),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1),
              PBK AS (SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
       (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM
        PSBKALL ORDER BY IDNO,TAG,ORDNO, TRANS_DT )  
         SELECT  ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                     PAGENO,SAVE_DT, RWID FROM PBK PK WHERE NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =PK.IDNO) ;
          COMMIT;
          MSG:='1 PROCESS COMPLETED'; 
          DELETE FROM TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM ;  
          COMMIT;
--RD          
       ELSIF MODULE_TYPE ='TD' THEN
       IF INITDT IS NULL THEN
              SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_TD'  AND  PAR_DET ='PRINT_START_DT';
             ELSE 
              INIT_DT:= INITDT;
             END IF;
         SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_TD'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
         --SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM MDS_ AM WHERE AM.ACT_NUM = ACTNUM;
         SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_TD'  AND    PAR_DET ='RECORDS_PER_PAGE';
         SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_TD'  AND  PAR_DET ='PRINT_START_DT';   
           IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
               SELECT MIN(TRANS_DT) INTO PRINT_STRT_DT FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
           END IF;  
           IF INIT_TAG =1  THEN  -- REPRINT OR INITIALISE
            PRINT_STRT_DT :=INIT_DT;
              IF  INIT_SLNO >1 THEN --BLANK LINES
                INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
                 SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
                 NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
                 FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
                 COMMIT;
              END IF;     
           END IF;  
         --opening
                 INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, 
                 NARR, POST_TAG,     PAGENO, SAVE_DT)
                   SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO,PRINT_STRT_DT  AS  TRANS_DT,
                   TRANS_ID, PRNCR, PRNDR, 
                   BAL, INTR,  PENAL,  OTH_AMT, INSTR_NO1,  INSTR_DT1, BONUS,   NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
                  FROM (           
                     SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, BONUS_DR AS INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                     INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                       FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_RECURRING(ACTNUM)) WHERE  TRANS_DT < PRINT_STRT_DT  
                   ) TR ;   
                   COMMIT;
                   SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
         COMMIT;                                      
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM ,
                SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT
                 AS IDNO,  TRANS_DT,  TRANS_ID, PRNCR,    PRNDR, 
               BAL,  INTR,   PENAL,  OTH_AMT, 
               INSTR_NO1,   INSTR_DT1,  BONUS,  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (
                 SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, BONUS_DR AS INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                 INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR  ,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                   FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_RECURRING(ACTNUM))--WHERE  TRANS_DT < (CASE WHEN INIT_TAG =0 THEN PRINT_STRT_DT ELSE INIT_DT END) 
                    ) TR    
              ORDER BY TR.TRANS_DT,TR.RWID; 
         COMMIT;
         --NEW ENTRY INSERTION
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(         
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE POST_TAG =0  ),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1),
             PBK AS(SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
                   (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM PSBKALL
                 ORDER BY IDNO,TAG,ORDNO, TRANS_DT) 
                SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                    PAGENO, SAVE_DT, RWID FROM PBK  PK WHERE NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =PK.IDNO);
          COMMIT;
          DELETE FROM TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM ;  
          COMMIT;
          SELECT BAL INTO PSBK_CLR_BALANCE FROM GN_PASSBOOK GP WHERE TRANS_DT IS NOT NULL AND  ACT_NUM =ACTNUM AND IDNO =(SELECT MAX(IDNO) FROM  GN_PASSBOOK   WHERE TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) ;  
              IF MST_CLR_BALANCE = PSBK_CLR_BALANCE THEN
               MSG:='1 PROCESS COMPLETED';    
              ELSE
               --DELETE FROM GN_PASSBOOK GP WHERE POST_TAG =0 AND ACT_NUM =ACTNUM;
               COMMIT; 
               MSG:='0 BALANCE AMOUNT MISMATCH '|| CAST(MST_CLR_BALANCE AS VARCHAR2)   || ', ' || CAST(PSBK_CLR_BALANCE AS VARCHAR2 )  || ' = ' ||  CAST((MST_CLR_BALANCE - PSBK_CLR_BALANCE)  AS VARCHAR2 )  ;
              END IF;          
--TERM LOAN          
       ELSIF MODULE_TYPE ='TL' THEN
          IF INITDT IS NULL THEN
              SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_TL'  AND  PAR_DET ='PRINT_START_DT';
             ELSE 
              INIT_DT:= INITDT;
             END IF;
         SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_TL'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
         --SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM MDS_ AM WHERE AM.ACT_NUM = ACTNUM;
         SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_TL'  AND    PAR_DET ='RECORDS_PER_PAGE';
         SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_TL'  AND  PAR_DET ='PRINT_START_DT';   
           IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
               SELECT MIN(TRANS_DT) INTO PRINT_STRT_DT FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
           END IF;  
           IF INIT_TAG =1  THEN  -- REPRINT OR INITIALISE
            PRINT_STRT_DT :=INIT_DT;
              IF  INIT_SLNO >1 THEN --BLANK LINES
                    INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
                     SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
                     NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
                     FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
                 COMMIT;
              END IF;     
           END IF;           
        --OPENING        
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, 
         NARR, POST_TAG,     PAGENO, SAVE_DT)
           SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO, PRINT_STRT_DT AS  TRANS_DT,
           TRANS_ID, PRNCR, PRNDR, 
           BAL, INTR,  PENAL,  OTH_AMT, INSTR_NO1,  INSTR_DT1, BONUS,   NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
          FROM (           
             SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
             INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
               FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_TL(ACTNUM)) WHERE  TRANS_DT < PRINT_STRT_DT     ) TR ;   
           COMMIT;
           SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
         --TRANSACTION  
          INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM ,   SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT
                 AS IDNO,  TRANS_DT,  TRANS_ID, PRNCR,    PRNDR, 
               BAL,  INTR,   PENAL,  OTH_AMT, 
               INSTR_NO1,   INSTR_DT1,  BONUS,  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (
                 SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                 INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR  ,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                   FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_TL(ACTNUM))WHERE  TRANS_DT >=PRINT_STRT_DT  ) TR    ORDER BY TR.TRANS_DT,TR.RWID; 
         COMMIT;
         --NEW ENTRY INSERTION
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(         
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE POST_TAG =0    ),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1),
                PBK AS  (SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
       (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM
        PSBKALL ORDER BY IDNO,TAG,ORDNO, TRANS_DT) 
        SELECT  ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                    PAGENO, SAVE_DT, RWID FROM PBK PK WHERE NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =PK.IDNO)  ;
          COMMIT;
          DELETE FROM TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM ; 
          COMMIT;
          SELECT BAL INTO PSBK_CLR_BALANCE FROM GN_PASSBOOK GP WHERE TRANS_DT IS NOT NULL AND  ACT_NUM =ACTNUM AND IDNO =(SELECT MAX(IDNO) FROM  GN_PASSBOOK   WHERE TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) ;  
              IF MST_CLR_BALANCE = PSBK_CLR_BALANCE THEN
               MSG:='1 PROCESS COMPLETED';    
              ELSE
               --DELETE FROM GN_PASSBOOK GP WHERE POST_TAG =0 AND ACT_NUM =ACTNUM;
               COMMIT; 
               MSG:='0 BALANCE AMOUNT MISMATCH '|| CAST(MST_CLR_BALANCE AS VARCHAR2)   || ', ' || CAST(PSBK_CLR_BALANCE AS VARCHAR2 )  || ' = ' ||  CAST((MST_CLR_BALANCE - PSBK_CLR_BALANCE)  AS VARCHAR2 )  ;
              END IF;          
--ADVANCES          
       ELSIF MODULE_TYPE ='AD' THEN
       IF INITDT IS NULL THEN
              SELECT CAST(PARAM_VALUE AS DATE) INTO INIT_DT FROM PARAM_SETTINGS  WHERE  PARAM_DESC ='PASSBOOK_AD'  AND  PAR_DET ='PRINT_START_DT';
             ELSE 
              INIT_DT:= INITDT;
             END IF;
         SELECT  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 1),  REGEXP_SUBSTR(PARAM_VALUE, '[^,]+', 1, 2)  INTO SKIPLNE,   SKIPCNT  FROM PARAM_SETTINGS 
           WHERE  PARAM_DESC ='PASSBOOK_AD'  AND  PAR_DET ='PRINT_CNTR_LINE_SKIP';
         --SELECT AM.CREATE_DT,AM.CLEAR_BALANCE INTO  ACT_OPN_DT,MST_CLR_BALANCE FROM MDS_ AM WHERE AM.ACT_NUM = ACTNUM;
         SELECT PARAM_VALUE INTO REC_PER_PAGE  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_AD'  AND    PAR_DET ='RECORDS_PER_PAGE';
         SELECT CAST(PARAM_VALUE AS DATE) INTO PRINT_STRT_DT  FROM PARAM_SETTINGS WHERE  PARAM_DESC ='PASSBOOK_AD'  AND  PAR_DET ='PRINT_START_DT';  
           IF PRV_PRINT_CNT >0 AND INIT_TAG =0 THEN -- PREVIOUSLY PRINTED 
               SELECT MIN(TRANS_DT) INTO PRINT_STRT_DT FROM  GN_PASSBOOK WHERE  ACT_NUM = ACTNUM;
           END IF;  
           IF INIT_TAG =1  THEN  -- REPRINT OR INITIALISE
            PRINT_STRT_DT :=INIT_DT;
              IF  INIT_SLNO >1 THEN --BLANK LINES
                INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT)
                 SELECT ACTNUM AS ACT_NUM, LEVEL AS IDNO,NULL AS TRANS_DT, NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR, NULL AS BAL, NULL AS INTR, NULL AS PENAL, 
                 NULL AS OTH_AMT,NULL AS INSTR_NO1,NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, 1  AS PAGENO,SYSDATE AS SAVE_DT
                 FROM DUAL CONNECT BY LEVEL <= INIT_SLNO-1;
                 COMMIT;
              END IF;     
           END IF;           
        --OPENING          
         INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT,INSTR_NO1, INSTR_DT1, BONUS, 
         NARR, POST_TAG,     PAGENO, SAVE_DT)
           SELECT ACTNUM ,DECODE(INIT_TAG,1,INIT_SLNO,1) AS IDNO,PRINT_STRT_DT  AS  TRANS_DT,
           TRANS_ID, PRNCR, PRNDR, 
           BAL, INTR,  PENAL,  OTH_AMT, INSTR_NO1,  INSTR_DT1, BONUS,   NARR, 0 AS POST_TAG, 1 PAGENO,SYSDATE AS SAVE_DT 
          FROM (  SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL,  INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
             INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
               FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_AD(ACTNUM)) WHERE  TRANS_DT < PRINT_STRT_DT  ) TR ;   
           COMMIT;
           SELECT  BAL,IDNO INTO TMP_OB,CNT FROM  TMP_GN_PASSBOOK WHERE TRANS_DT IS NOT NULL AND ACT_NUM  = ACTNUM; 
        --TRANSACTION
           INSERT INTO TMP_GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)         
          SELECT ACTNUM ,
                SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT
                 AS IDNO,  TRANS_DT,  TRANS_ID, PRNCR,    PRNDR, 
               BAL,  INTR,   PENAL,  OTH_AMT, 
               INSTR_NO1,   INSTR_DT1,  BONUS,  NARR, 0 AS POST_TAG,CEIL ( (SUM(1) OVER (ORDER BY TR.TRANS_DT,TR.RWID)+CNT)/REC_PER_PAGE) AS  PAGENO,SYSDATE AS SAVE_DT,RWID
            FROM (
                 SELECT  TRANS_DT,'' AS BATCH_ID,TRANS_ID,PRNCR,PRNDR,BALANCE AS BAL, INTR, PENAL, COMMISSION_PAID AS OTH_AMT,
                 INSTNO AS INSTR_NO1,DUEDATE AS  INSTR_DT1,BONUS_CR AS BONUS,NARR  ,SUM(1) OVER (ORDER BY TRANS_DT,TRANS_ID ) AS RWID
                   FROM TABLE(PKG_GN_PBK.FUNC_GN_PASSBOOK_AD(ACTNUM)) WHERE  TRANS_DT >=PRINT_STRT_DT
                    ) TR    
              ORDER BY TR.TRANS_DT,TR.RWID; 
         COMMIT;
      --NEW ENTRY INSERTION
          INSERT INTO GN_PASSBOOK (ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID)
          WITH TMPPS AS(       
                        SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,     PAGENO, SAVE_DT,RWID 
                         FROM   TMP_GN_PASSBOOK TP WHERE ACT_NUM = ACTNUM ),
               SKPLN AS( SELECT ACTNUM AS ACT_NUM, A.IDNO  AS IDNO,LVCNT FROM 
                          (SELECT   ( ( SKIPLNE-(REC_PER_PAGE+1)) +( LEVEL * (REC_PER_PAGE))) - ((LEVEL-1) * SKIPCNT)  AS IDNO FROM DUAL CONNECT BY LEVEL <100  ) A,
                          (SELECT LEVEL-1 AS LVCNT FROM DUAL CONNECT BY LEVEL<= SKIPCNT  ) B 
                        ),
               PSBKALL AS  (SELECT 0 AS TAG,0 AS ORDNO,ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,PAGENO, SAVE_DT,RWID FROM TMPPS UNION ALL
                        SELECT 1 AS TAG,LVCNT AS ORDNO,A.ACT_NUM, A.IDNO, NULL AS TRANS_DT,NULL AS  TRANS_ID,NULL AS  PRNCR,NULL AS PRNDR,NULL AS BAL,NULL AS INTR,NULL AS PENAL,NULL AS  OTH_AMT,NULL AS  INSTR_NO1,
                        NULL AS  INSTR_DT1,NULL AS  BONUS,NULL AS  NARR,0 AS POST_TAG, NULL AS  PAGENO,SYSDATE AS  SAVE_DT,NULL AS RWID FROM TMPPS A   JOIN
                        SKPLN B ON A.ACT_NUM =B.ACT_NUM AND  A.IDNO = B.IDNO WHERE   SKIPCNT>=1),
                 PBK AS ( SELECT ACT_NUM,SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) AS IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                   CEIL ( (SUM(1) OVER (ORDER BY IDNO,TAG,ORDNO, TRANS_DT) )/REC_PER_PAGE) AS PAGENO, SAVE_DT,
                     ((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT))  )  -
                     (((CEIL (NVL(((SUM(1) OVER (  order by IDNO,TAG,ORDNO, TRANS_DT ))  ),0)/REC_PER_PAGE))-1)*REC_PER_PAGE) AS RWID FROM PSBKALL 
                    ORDER BY IDNO,TAG,ORDNO, TRANS_DT)
                SELECT ACT_NUM, IDNO, TRANS_DT, TRANS_ID, PRNCR,PRNDR, BAL, INTR, PENAL, OTH_AMT, INSTR_NO1, INSTR_DT1, BONUS, NARR, POST_TAG,
                     PAGENO, SAVE_DT,
                      RWID FROM PBK PK WHERE  NOT EXISTS(SELECT * FROM GN_PASSBOOK GP WHERE ACT_NUM =ACTNUM  AND GP.IDNO =PK.IDNO) ;
          COMMIT; 
           DELETE FROM TMP_GN_PASSBOOK WHERE ACT_NUM = ACTNUM ;  
          COMMIT; 
          SELECT BAL INTO PSBK_CLR_BALANCE FROM GN_PASSBOOK GP WHERE TRANS_DT IS NOT NULL AND  ACT_NUM =ACTNUM AND IDNO =(SELECT MAX(IDNO) FROM  GN_PASSBOOK   WHERE TRANS_DT IS NOT NULL AND ACT_NUM =ACTNUM) ;  
              IF MST_CLR_BALANCE = PSBK_CLR_BALANCE THEN
               MSG:='1 PROCESS COMPLETED';    
              ELSE
               --DELETE FROM GN_PASSBOOK GP WHERE POST_TAG =0 AND ACT_NUM =ACTNUM;
               COMMIT; 
               MSG:='0 BALANCE AMOUNT MISMATCH '|| CAST(MST_CLR_BALANCE AS VARCHAR2)   || ', ' || CAST(PSBK_CLR_BALANCE AS VARCHAR2 )  || ' = ' ||  CAST((MST_CLR_BALANCE - PSBK_CLR_BALANCE)  AS VARCHAR2 )  ;
              END IF;          
       END IF;
      RETURN MSG ;    
    END GN_PASSBK_PROCESS;   
  FUNCTION GN_PASSBOOK_TRANS_LIST (ACTNUM VARCHAR2) RETURN TAB_TYPE_PBK_GRD IS
  -- SELECT * FROM TABLE (GN_PASSBOOK_TRANS_LIST('0003725000035_1'));
  GRDLIST TAB_TYPE_PBK_GRD;
   BEGIN
   SELECT TYPE_PBK_GRD( ACT_NUM,SLNO,NEXT_SL_NO,TRANS_DT,PARTICULARS,DEBIT,CREDIT,BALANCE,INSTRUMENT_NO,INST_TYPE,INST_DT,PAGENO,PREV_BAL,TOD_LIMIT,IDNO) BULK COLLECT INTO GRDLIST FROM (
       SELECT ACT_NUM, RWID AS SLNO, NULL AS NEXT_SL_NO, TRANS_DT, INITCAP (NARR) AS PARTICULARS,
         PRNDR AS DEBIT, PRNCR AS CREDIT,  BAL AS BALANCE,      INSTR_NO1 AS INSTRUMENT_NO,
         NULL AS INST_TYPE,    INSTR_DT1 AS INST_DT,  PAGENO,     LAG (BAL) OVER (ORDER BY IDNO) AS PREV_BAL,
         NULL AS TOD_LIMIT, IDNO  FROM GN_PASSBOOK GK
         LEFT JOIN (SELECT   ACTNUM ,MAX(GP.IDNO) AS MXID FROM  GN_PASSBOOK GP WHERE GP.ACT_NUM =ACTNUM  AND GP.POST_TAG =1  ORDER BY IDNO) GS
         ON GS.ACTNUM =GK.ACT_NUM 
         WHERE GK.ACT_NUM = ACTNUM AND GK.IDNO > NVL(GS.MXID,0)-10 ORDER BY IDNO);
    RETURN GRDLIST;     
   END GN_PASSBOOK_TRANS_LIST;      
 END PKG_GN_PBK;
/

-- End Version [Script Version - 0.0.323] [ReleaseVersion - 9.2.2.16]--[27-JUL-2020] -- By Sanju

-- Start Version [Script Version - 0.0.324] [ReleaseVersion - 9.2.2.16]--[29-JUL-2020] -- By Nithya K

ALTER TABLE MDS_PRODUCT_GENERAL_DETAILS ADD BANK_ADV_Y_N VARCHAR2(1) DEFAULT 'N';

ALTER TABLE MDS_TRANS_DETAILS ADD BANK_ADV_AMTCR NUMBER (19,2);

ALTER TABLE MDS_TRANS_DETAILS ADD FORFEITED_AMT NUMBER (19,2);

ALTER TABLE MDS_RECEIPT_ENTRY ADD FORFEITED_TRANS_ID VARCHAR2(15);

ALTER TABLE MDS_RECEIPT_ENTRY ADD FORFEITED_AMT NUMBER (19,2);

ALTER TABLE MDS_RECEIPT_ENTRY ADD BANK_ADV_AMTCR NUMBER (19,2);

-- End Version [Script Version - 0.0.324] [ReleaseVersion - 9.2.2.16]--[29-JUL-2020] -- By Nithya K


-- Start Version [Script Version - 0.0.325] [ReleaseVersion - 9.2.2.16]--[04-SEP-2020] -- By Nithya K
-- Deleted the script committed by Sanju - and added the script that required - Given by Gibi Sir
CREATE OR REPLACE PROCEDURE RDACHD_UPDATE (ACHDID VARCHAR,INCACHD VARCHAR,EXPACHD VARCHAR) AS
BEGIN
 MERGE INTO RESERVE_DEPRECIATION_ACHD RDAH USING (SELECT AH.AC_HD_ID FROM AC_HD AH WHERE AH.AC_HD_ID= ACHDID)
 H ON (
        RDAH.AC_HD_ID = ACHDID
        ) WHEN MATCHED THEN
  UPDATE SET  RDAH.INC_AC_HD=INCACHD, RDAH.EXP_AC_HD=EXPACHD
        WHEN NOT MATCHED THEN

        INSERT (AC_HD_ID, INC_AC_HD, EXP_AC_HD)
        VALUES (ACHDID, INCACHD, EXPACHD);
COMMIT;
END RDACHD_UPDATE;

CREATE OR REPLACE function GETACHD_DESC(ACHD VARCHAR2) RETURN VARCHAR2 IS
    ACHD_NAME VARCHAR2(128);
BEGIN
    SELECT  AC_HD_DESC INTO ACHD_NAME FROM AC_HD WHERE AC_HD_ID=ACHD;
    RETURN ACHD_NAME;
    EXCEPTION WHEN OTHERS THEN RETURN NULL;
END;

DELETE FROM LOOKUP_MASTER WHERE LOOKUP_ID ='INDEND_STOCK_TYPE'
COMMIT;

Insert into LOOKUP_MASTER   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,    AUTHORIZED)
 Values
   ('INDEND_STOCK_TYPE', 'DAMAGE', 'DAMAGE', 'CREATED', NULL,    'Y');
Insert into LOOKUP_MASTER   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,    AUTHORIZED)
 Values
   ('INDEND_STOCK_TYPE', 'DEFICIT', 'DEFICIT', 'CREATED', NULL,    'Y');
Insert into LOOKUP_MASTER   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,    AUTHORIZED)
 Values
   ('INDEND_STOCK_TYPE', 'CLOSING', 'CLOSING', 'CREATED', NULL,   'Y');
COMMIT;

DELETE FROM LOOKUP_MASTER WHERE LOOKUP_ID ='INDEND_CLOSE_TYPE'
COMMIT;
Insert into LOOKUP_MASTER   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,    AUTHORIZED)
 Values
   ('INDEND_CLOSE_TYPE', 'DEPRECIATION', 'DEPRECIATION', 'CREATED', NULL,    'Y');
Insert into LOOKUP_MASTER   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,    AUTHORIZED)
 Values
   ('INDEND_CLOSE_TYPE', 'RESERVE', 'RESERVE', 'CREATED', NULL,    'Y');
COMMIT;
 
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,     AUTHORIZED)
 Values
   ('INDEND_CLOSE_TYPE', 'EXPENSEOBJECTED', 'EXPENSEOBJECTED', 'CREATED', NULL,     'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE,     AUTHORIZED)
 Values
   ('INDEND_CLOSE_TYPE', 'INCOMEOBJECTED', 'INCOMEOBJECTED', 'CREATED', NULL,     'Y');
COMMIT;


DELETE FROM ID_GENERATION WHERE ID_KEY ='RESERVE_DEP_ID'
COMMIT;

Insert into ID_GENERATION    (ID_KEY, CURR_VALUE, PREFIX, LAST_UPDATED, ID_LENGTH,    BRANCH_CODE)
 Values
   ('RESERVE_DEP_ID', 0, 'RD', TO_DATE('06/18/2004 17:42:56', 'MM/DD/YYYY HH24:MI:SS'), 10,    '0001');
COMMIT;

CREATE OR REPLACE FUNCTION RESERVE_PREV_CLOSING_AMT(ACHDID VARCHAR,CLOSEDT DATE, BRANCHCODE VARCHAR) RETURN NUMBER IS
 PREV_CLOSEAMT NUMBER (16, 2);
  LASTTEAREND_DT DATE;
BEGIN
    SELECT ADD_MONTHS(CLOSEDT, -12) INTO LASTTEAREND_DT FROM DUAL;
    
    SELECT NVL(AMOUNT,0) INTO PREV_CLOSEAMT FROM RESERVE_DEPRECIATION WHERE RES_OR_DEPR='R' AND FIN_DT=LASTTEAREND_DT AND AC_HD_ID=ACHDID AND BRANCH_CODE=BRANCHCODE;
   
   RETURN PREV_CLOSEAMT;
 END;
/

CREATE OR REPLACE FUNCTION CALC_INDEND_CLOSING_AMT(DEPOID VARCHAR,CLOSEDT DATE, BRANCHCODE VARCHAR, STOCKTYPE VARCHAR) RETURN NUMBER IS
 CLOSEAMT NUMBER (16, 2);
 LASTYEARCLOSEAMT NUMBER (16, 2);
 INDEND_PURCHASE_AMT NUMBER (16, 2);
 SALE_PURCHASE_RETUTN1 NUMBER (16, 2);
 SALE_PURCHASE_RETUTN2 NUMBER (16, 2);
 LASTTEAREND_DT DATE;
BEGIN
    SELECT ADD_MONTHS(CLOSEDT, -12) INTO LASTTEAREND_DT FROM DUAL;
     
    SELECT NVL(CLOSING_AMT,0) INTO LASTYEARCLOSEAMT FROM INDEND_CLOSE_STOCK CS WHERE CLOSING_DT=LASTTEAREND_DT AND STOCK_TYPE=STOCKTYPE
    AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;
    
    SELECT SUM(NVL(AMOUNT,0)) INTO INDEND_PURCHASE_AMT  FROM INDEND_REGISTER WHERE STATUS!='DELETED' AND AUTHORIZE_STATUS='AUTHORIZED'
    AND TRANS_TYPE IN('Purchase','Sales Return') AND TRAN_DATE BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND DEPID=DEPOID AND BRANCH_CODE=BRANCHCODE;
    
    SELECT SUM(NVL(TT.AMOUNT,0)) INTO SALE_PURCHASE_RETUTN1 FROM ALL_TRANS TT WHERE TT.STATUS!='DELETED' 
    AND TT.AUTHORIZE_STATUS='AUTHORIZED' AND AC_HD_ID IN((SELECT DISTINCT PUR_RET_AC_HD_ID FROM DEPO_MASTER WHERE DEPOID=DEPOID)) 
    AND TRANS_DT BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND TT.BRANCH_ID=BRANCHCODE; 
    
    SELECT SUM(NVL(TT.AMOUNT,0)) INTO SALE_PURCHASE_RETUTN2 FROM ALL_TRANS TT WHERE TT.STATUS!='DELETED' 
    AND TT.AUTHORIZE_STATUS='AUTHORIZED' AND AC_HD_ID IN((SELECT DISTINCT SALES_AC_HD_ID FROM DEPO_MASTER WHERE DEPOID=DEPOID)) 
    AND TRANS_DT BETWEEN LASTTEAREND_DT+1 AND CLOSEDT AND TT.BRANCH_ID=BRANCHCODE;

    CLOSEAMT:=NVL(LASTYEARCLOSEAMT,0)+NVL(INDEND_PURCHASE_AMT,0)-NVL(SALE_PURCHASE_RETUTN1,0)-NVL(SALE_PURCHASE_RETUTN2,0);
    IF(CLOSEAMT<=0) THEN 
        CLOSEAMT:=0;
    END IF;
    
   RETURN CLOSEAMT;
 END;
/ 

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR20160', '20159', 'Balancesheet Closing', 'APP01', 'DONE', 
    '14', NULL, 3, 'CREATED', NULL, 
    NULL, NULL);
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR20161', '20159', 'Audit Closing', 'APP01', 'DONE', 
    '14', NULL, 3, 'CREATED', NULL, 
    NULL, NULL);
COMMIT;

CREATE TABLE FIN_AUDIT_CLOSE
(
  MJR_TYPE     VARCHAR2(25 BYTE)                NOT NULL,
  MJR_HD       VARCHAR2(15 BYTE)                NOT NULL,
  SUB_HD       VARCHAR2(15 BYTE)                NOT NULL,
  MJR_DESC     VARCHAR2(150 BYTE)               NOT NULL,
  AC_DESC      VARCHAR2(150 BYTE)               NOT NULL,
  DT           DATE                             NOT NULL,
  BRANCH_CODE  VARCHAR2(8 BYTE)                 NOT NULL,
  AC_HD_ID     VARCHAR2(16 BYTE)                NOT NULL,
  CLOSE_BAL    NUMBER(16,2)                     NOT NULL,
  MJR_ORDER    INTEGER,
  ACHD_ORDER   INTEGER,
  CLSTYPE      INTEGER,
  USER_ID      VARCHAR2(25 BYTE),
  SAVE_DT      DATE
)

-- End Version [Script Version - 0.0.325] [ReleaseVersion - 9.2.2.16]--[29-JUL-2020] -- By Nithya K


-- Start Version [Script Version - 0.0.326] [ReleaseVersion - 9.2.2.16]--[29-JUL-2020] -- By Nithya K
CREATE OR REPLACE FUNCTION GET_EMI_UNIFORM_PRINCIPLE_DUE(ACTNUM VARCHAR2,CURDT DATE) RETURN NUMBER IS
PRINCIPALAMT NUMBER(16,2);
PAIDPRINCIPAL NUMBER(16,2);
PRINCIPALDUE NUMBER(16,2);
BEGIN
SELECT nvl(SUM (nvl(LI.PRINCIPAL_AMT,0)),0) INTO PRINCIPALAMT
  FROM LOANS_INSTALLMENT LI
 WHERE     LI.INSTALLMENT_DT <= CURDT
       AND LI.ACCT_NUM = ACTNUM
       AND LI.STATUS != 'DELETED';
SELECT nvl(SUM (NVL (PRINCIPLE, 0)),0) INTO PAIDPRINCIPAL       
  FROM LOAN_TRANS_DETAILS lt
 WHERE lt.ACT_NUM = ACTNUM AND (lt.TRN_CODE = 'C*' OR lt.TRN_CODE = 'OLG')
 and lt.trans_dt <= CURDT;
 PRINCIPALDUE := PRINCIPALAMT - PAIDPRINCIPAL;
 RETURN PRINCIPALDUE; 
END;
/

CREATE OR REPLACE FUNCTION GET_SPECIAL_RD_INTEREST(ACTNUM VARCHAR,ASONDATE DATE)
RETURN NUMBER IS
    DEPOSITDT  DATE;
    INSTALLMENT_AMOUNT NUMBER(16,2) := 0;
    TOTAL_INT_DRAWN NUMBER(16,2) := 0;
    ROI NUMBER(16,2) := 0;
    SUB_NO VARCHAR2(2);
    DUE_DATE DATE;
    BALANCE NUMBER(16,2) := 0;
    NO_OF_INST_PAID NUMBER(16,2) := 0;
    NO_OF_INST_PAID_COMPOUND INTEGER;
    LAST_PAID_DATE DATE;
    CALC_DATE DATE;
    INTEREST NUMBER(16,2) := 0;
    CLS_DATE DATE;
    LASTCALCDT DATE;
BEGIN
    SELECT S.DEPOSIT_DT,S.DEPOSIT_SUB_NO,S.MATURITY_DT,S.DEPOSIT_AMT,NVL(S.RATE_OF_INT,0),S.CLOSE_DT,S.TOTAL_INT_DRAWN,S.TOTAL_BALANCE
    INTO DEPOSITDT,SUB_NO,DUE_DATE,INSTALLMENT_AMOUNT,ROI,CLS_DATE,TOTAL_INT_DRAWN,BALANCE
    FROM DEPOSIT_SUB_ACINFO S
    WHERE S.DEPOSIT_NO = ACTNUM;
    
select MAX(DI.APPL_DT) INTO LASTCALCDT from deposit_interest di 
where DI.ACT_NUM = ACTNUM||'_1'
and DI.PAID_INT = 'CREDIT';
    
    IF LASTCALCDT <= DUE_DATE THEN
    IF ASONDATE > DUE_DATE THEN
        CALC_DATE := DUE_DATE;
    ELSE
        CALC_DATE := ASONDATE;
    END IF;    
    IF CLS_DATE <= ASONDATE THEN
        RETURN INTEREST;
    END IF;
    IF ROI = 0 THEN
        RETURN INTEREST;
    END IF;    
    IF BALANCE <= 0 THEN
        RETURN INTEREST;
    END IF;
    SELECT MAX(DR.TRANS_DT) INTO LAST_PAID_DATE
    FROM DEPOSIT_RECURRING DR
    WHERE DR.DEPOSIT_NO_SUB = ACTNUM || '_' || SUB_NO AND
         (DR.TRANS_DT IS NOT NULL AND DR.TRANS_DT <= ASONDATE);         
    NO_OF_INST_PAID := BALANCE/INSTALLMENT_AMOUNT;
    NO_OF_INST_PAID_COMPOUND := FLOOR(NO_OF_INST_PAID/3);
    IF NO_OF_INST_PAID < 3 THEN
        INTEREST := (BALANCE * (CALC_DATE-LAST_PAID_DATE) * ROI)/36500;
        RETURN INTEREST;
    END IF;
    IF NO_OF_INST_PAID >= 3 THEN
        INTEREST := (ROUND((INSTALLMENT_AMOUNT * (POWER((1+(ROI/400)),NO_OF_INST_PAID_COMPOUND) - 1)) / 
                           (1- POWER((1+(ROI/400)),(-1/3))))) - BALANCE;                    
    END IF;
    INTEREST := INTEREST - TOTAL_INT_DRAWN;
    END IF;
    IF ((ASONDATE-DUE_DATE) > 0) THEN
        IF LASTCALCDT IS NULL THEN
        INTEREST := INTEREST + ((BALANCE *  (ASONDATE-DUE_DATE) * ROI)/36500);
        ELSE
        INTEREST := INTEREST + ((BALANCE *  (ASONDATE-LASTCALCDT) * ROI)/36500);
        END IF;
    END IF;    
    IF INTEREST < 0 THEN
        INTEREST := 0;
    END IF;
    INTEREST := ROUND(INTEREST);
    RETURN INTEREST;
--    DBMS_OUTPUT.PUT_LINE(TO_CHAR(BALANCE));
--    DBMS_OUTPUT.PUT_LINE(TO_CHAR(NO_OF_INST_PAID));
--    DBMS_OUTPUT.PUT_LINE('NO_OF_INST_PAID_COMPOUND '|| TO_CHAR(NO_OF_INST_PAID_COMPOUND));
--    DBMS_OUTPUT.PUT_LINE('LAST_PAID_DATE ' ||TO_CHAR(LAST_PAID_DATE));
--    DBMS_OUTPUT.PUT_LINE(TO_CHAR(INTEREST));
END;
/

ALTER TABLE DEPOSIT_MULTI_CLOSING_TEMP ADD TDS_AMOUNT NUMBER(16,2);

CREATE TABLE SHARE_ACCT_CONVERSION_DETAILS
(
  SHARE_ACCT_NO               VARCHAR2(16 BYTE),
  CUST_ID                     VARCHAR2(16 BYTE),
  RESOLUTION_NO               VARCHAR2(32 BYTE),
  PROPERTY_DETAILS            VARCHAR2(256 BYTE),
  RELATIVE_MEMBERS            VARCHAR2(256 BYTE),
  CONNECTED_GROUP             VARCHAR2(256 BYTE),
  DIRECTOR_RELATIVE           VARCHAR2(256 BYTE),
  ID_ISSUE_DT                 DATE,
  NOT_ELIGIBLE_LOAN           CHAR(1 BYTE),
  NOT_ELIGIBLE_DT             DATE,
  APPL_FEE                    NUMBER(16,2),
  MEM_FEE                     NUMBER(16,2),
  SHARE_FEE                   NUMBER(16,2),
  SHARE_AMOUNT                NUMBER(16,2),
  WELFARE_FUND_PAID           VARCHAR2(256 BYTE),
  ACCT_STATUS                 VARCHAR2(16 BYTE),
  STATUS                      VARCHAR2(16 BYTE),
  STATUS_BY                   VARCHAR2(32 BYTE),
  STATUS_DT                   DATE,
  AUTHORIZE                   VARCHAR2(16 BYTE),
  AUTHORIZE_BY                VARCHAR2(32 BYTE),
  AUTHORIZE_DT                DATE,
  CREATED_DT                  DATE,
  CREATED_BY                  VARCHAR2(32 BYTE),
  CONSTITUTION                VARCHAR2(32 BYTE),
  COMM_ADDR_TYPE              VARCHAR2(32 BYTE),
  SHARE_TYPE                  VARCHAR2(32 BYTE),
  REMARKS                     VARCHAR2(512 BYTE),
  DIVIDEND_CREDIT_AC          VARCHAR2(16 BYTE),
  DIVIDEND_CREDIT_PRODUCT     VARCHAR2(32 BYTE),
  BRANCH_CODE                 VARCHAR2(16 BYTE),
  OUTSTANDING_AMOUNT          NUMBER(16,2),
  AVILABLE_NO_SHARES          NUMBER(16),
  DIVIDEND_AMOUNT             NUMBER(16,2),
  UPTO_DIVIDEND_APPLDT        DATE,
  UPTO_DIVIDEND_PAID_DATE     DATE,
  DIVIDEND_PAY_MODE           VARCHAR2(16 BYTE),
  DIVIDEND_CREDIT_PRODUCT_ID  VARCHAR2(16 BYTE),
  OPENING_BALANCE             NUMBER(16,2)      DEFAULT 0,
  OPENING_DATE                DATE,
  OPENING_NO_OF_SHARES        INTEGER           DEFAULT 0,
  ID_CARD_NO                  VARCHAR2(32 BYTE),
  SHARE_APPL_NO               VARCHAR2(16 BYTE),
  IMBP                        NUMBER(16,2),
  EMP_REFNO_OLD               VARCHAR2(32 BYTE),
  EMP_REFNO_NEW               VARCHAR2(32 BYTE),
  DRF_APPLICABLE              VARCHAR2(1 BYTE),
  DRF_STATUS                  VARCHAR2(16 BYTE),
  DRF_PRODUCT                 VARCHAR2(16 BYTE),
  DRF_INT_CALCUPTO            DATE,
  DUPLICATE_ID                VARCHAR2(1 BYTE),
  ID_RESOLUTION_NO            VARCHAR2(32 BYTE),
  IDCARD_ISSUE_DT             DATE,
  RESOLUTION_DT               DATE,
  INITIATED_BRANCH            VARCHAR2(16 BYTE),
  CLOSE_DT                    DATE,
  OB                          VARCHAR2(16 BYTE),
  CONVERSION_DT               DATE
)

CREATE OR REPLACE FUNCTION get_share_pattern_prefix(SHARECLASS VARCHAR2) RETURN VARCHAR IS
PREFIX VARCHAR2(4);
BEGIN
SELECT SH.NUM_PATTERN_PREFIX INTO PREFIX FROM SHARE_CONF_DETAILS SH WHERE SH.SHARE_TYPE = SHARECLASS;
 RETURN PREFIX; 
END;
/

CREATE TABLE AGENT_COMMISSION_CALC_SLAB
(
  PROD_ID           VARCHAR2(28 BYTE),
  FROM_AMT          NUMBER,
  TO_AMT            NUMBER,
  COMM_PERCENTAGE        NUMBER,
  CREATED_BY        VARCHAR2(50 BYTE),
  CREATED_DT        DATE,
  STATUS            VARCHAR2(10 BYTE),
  STATUS_BY         VARCHAR2(50 BYTE),
  STATUS_DT         DATE,
  AUTHORIZE_STATUS  VARCHAR2(10 BYTE),
  AUTHORIZE_BY      VARCHAR2(50 BYTE),
  AUTHORIZE_DT      DATE
)

ALTER TABLE DEPOSITS_PROD_SCHEME ADD AGENT_COMM_SLAB_REQUIRED VARCHAR2(1) DEFAULT 'N'; 
    
ALTER TABLE DEPOSITS_PROD_SCHEME ADD AGENT_COMM_CALC_METHOD VARCHAR2(16) ;

ALTER TABLE OP_AC_PRODUCT ADD AGENT_COMM_SLAB_REQUIRED VARCHAR2(1) DEFAULT 'N'; 
    
ALTER TABLE OP_AC_PRODUCT ADD AGENT_COMM_CALC_METHOD VARCHAR2(16) ;

ALTER TABLE SUSPENSE_PRODUCT ADD AGENT_COMM_SLAB_REQUIRED VARCHAR2(1) DEFAULT 'N'; 
    
ALTER TABLE SUSPENSE_PRODUCT ADD AGENT_COMM_CALC_METHOD VARCHAR2(16) ;

CREATE OR REPLACE FUNCTION GET_AGENT_COLLECTION_AMOUNT (PRODID     VARCHAR2,
                                                        AGENTID    VARCHAR2,
                                                        CURRDT     DATE)
   RETURN NUMBER
IS
   COLLECTIONAMOUNT   NUMBER (16, 2);
BEGIN
     SELECT SUM (D.AMOUNT)
       INTO COLLECTIONAMOUNT
       FROM DAILY_DEPOSIT_TRANS D,
            AGENTMASTDET AG,
            ALL_PRODUCTS AP,
            AGENT_COLLECTION_PROD AC,
            AGENT_PROD_MAPPING AM
      WHERE     (D.ACC_NUM = AG.ACT_NUM || '_1' OR D.ACC_NUM = AG.ACT_NUM)
            AND AM.COMM_BASED_LOAN = 0
            AND AG.AGENT_ID = D.AGENT_NO
            AND AC.AGENT_ID = AG.AGENT_ID
            AND AP.PROD_ID = AG.PROD_ID
            AND AC.PROD_ID = AP.PROD_ID
            AND AP.PROD_ID = AG.PROD_ID
            AND AC.AGENT_ID = AG.AGENT_ID
            AND AM.PROD_ID = AG.PROD_ID
            AND AG.PROD_ID = PRODID
            AND D.AGENT_NO = AGENTID
            AND D.AUTHORIZE_STATUS = 'AUTHORIZED'
            AND D.TRN_DT BETWEEN AC.LAST_COL_DT AND CURRDT
   GROUP BY D.AGENT_NO,
            AG.PROD_ID,
            AP.PROD_DESC,
            AC.LAST_COL_DT,
            AM.COMM_PER_BANK,
            AM.COMM_PER_AC_HOLDR;
   RETURN COLLECTIONAMOUNT;
END;
/

CREATE OR REPLACE FUNCTION PKD.GET_AGENT_COMM_SLAB_REQUIRED(PRODID VARCHAR) RETURN VARCHAR IS

    SLABREQUIRED VARCHAR2(10);
    PROD_TYPE VARCHAR(10);

BEGIN
 
  SELECT AP.PROD_TYPE INTO PROD_TYPE FROM ALL_PRODUCTS AP WHERE AP.PROD_ID = PRODID;

    IF PROD_TYPE='OA' THEN

        SELECT DP.AGENT_COMM_SLAB_REQUIRED INTO SLABREQUIRED FROM OP_AC_PRODUCT DP WHERE DP.PROD_ID = PRODID;

    ELSIF PROD_TYPE='SA' THEN

        SELECT DP.AGENT_COMM_SLAB_REQUIRED INTO SLABREQUIRED FROM SUSPENSE_PRODUCT DP WHERE DP.PROD_ID = PRODID;

    ELSIF PROD_TYPE='TD' THEN

        SELECT DP.AGENT_COMM_SLAB_REQUIRED INTO SLABREQUIRED FROM DEPOSITS_PROD_SCHEME DP WHERE DP.PROD_ID = PRODID;

    END IF;

RETURN SLABREQUIRED;

END;
/

CREATE OR REPLACE FUNCTION GET_AGENT_COMM_CALC_METHOD(PRODID VARCHAR) RETURN VARCHAR IS

    CALCMETHOD VARCHAR2(10);
    PROD_TYPE VARCHAR(10);

BEGIN
 
  SELECT AP.PROD_TYPE INTO PROD_TYPE FROM ALL_PRODUCTS AP WHERE AP.PROD_ID = PRODID;

    IF PROD_TYPE='OA' THEN

        SELECT OP.AGENT_COMM_CALC_METHOD INTO CALCMETHOD FROM OP_AC_PRODUCT OP WHERE OP.PROD_ID = PRODID;

    ELSIF PROD_TYPE='SA' THEN

        SELECT SP.AGENT_COMM_CALC_METHOD INTO CALCMETHOD FROM SUSPENSE_PRODUCT SP WHERE SP.PROD_ID = PRODID;

    ELSIF PROD_TYPE='TD' THEN

        SELECT DP.AGENT_COMM_CALC_METHOD INTO CALCMETHOD FROM DEPOSITS_PROD_SCHEME DP WHERE DP.PROD_ID = PRODID;

    END IF;

RETURN CALCMETHOD;

END;
/

CREATE OR REPLACE FUNCTION GET_AGENT_COMMISSION_SLAB (PRODID        VARCHAR2,
                                                      SLABAMOUNT    NUMBER)
   RETURN NUMBER
IS
   PERCENTAGE   NUMBER (16, 2);
BEGIN
   SELECT ACS.COMM_PERCENTAGE INTO PERCENTAGE
     FROM AGENT_COMMISSION_CALC_SLAB ACS  WHERE SLABAMOUNT BETWEEN ACS.FROM_AMT AND ACS.TO_AMT AND ACS.PROD_ID = PRODID AND ACS.STATUS != 'DELETED';
 RETURN PERCENTAGE;
END;
/

CREATE OR REPLACE FUNCTION GET_AGENT_COMMISSION_AMOUNT (PRODID     VARCHAR2,
                                                        AGENTID    VARCHAR2,
                                                        DT     DATE)
   RETURN NUMBER
IS
   COMMISSIONAMOUNT   NUMBER (16, 2);
   SLABREQUIRED VARCHAR2(1);
   CALCMETHOD VARCHAR2(30);
BEGIN
       SELECT GET_AGENT_COMM_CALC_METHOD(PRODID) INTO CALCMETHOD FROM DUAL;
       IF CALCMETHOD = 'DAY_WISE' THEN
          select sum(COMMISSIONAMOUNT) INTO COMMISSIONAMOUNT  from (SELECT ROUND((SUM (D.AMOUNT) * GET_AGENT_COMMISSION_SLAB(PRODID,SUM (D.AMOUNT)) / 100),0) AS COMMISSIONAMOUNT
         FROM DAILY_DEPOSIT_TRANS D,
         AGENTMASTDET AG,
         ALL_PRODUCTS AP,
         AGENT_COLLECTION_PROD AC,
         AGENT_PROD_MAPPING AM,
         AGENT_COMMISSION_CALC_SLAB acs
         WHERE (D.ACC_NUM = AG.ACT_NUM ||'_1' OR D.ACC_NUM = AG.ACT_NUM) AND  AM.COMM_BASED_LOAN=0
         AND AG.AGENT_ID = D.AGENT_NO
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.PROD_ID = AP.PROD_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AM.PROD_ID = AG.PROD_ID
         and ACS.PROD_ID = ag.prod_id
         AND Acs.PROD_ID = PRODID
         AND D.AGENT_NO = AGENTID
         AND D.TRN_DT BETWEEN AC.LAST_COL_DT AND DT
         AND D.AUTHORIZE_STATUS = 'AUTHORIZED'
         --AND GET_AGENT_COLLECTION_AMOUNT(PRODID,AGENTID,DT) BETWEEN ACS.FROM_AMT and ACS.TO_AMT 
         GROUP BY D.AGENT_NO, AG.PROD_ID, AP.PROD_DESC, AC.LAST_COL_DT,
         AM.COMM_PER_BANK,AM.COMM_PER_AC_HOLDR,D.TRN_DT);
       ELSE
         SELECT ROUND((SUM (D.AMOUNT) * GET_AGENT_COMMISSION_SLAB(PRODID,SUM (D.AMOUNT)) / 100),0) INTO COMMISSIONAMOUNT
         FROM DAILY_DEPOSIT_TRANS D,
         AGENTMASTDET AG,
         ALL_PRODUCTS AP,
         AGENT_COLLECTION_PROD AC,
         AGENT_PROD_MAPPING AM,
         AGENT_COMMISSION_CALC_SLAB acs
         WHERE (D.ACC_NUM = AG.ACT_NUM ||'_1' OR D.ACC_NUM = AG.ACT_NUM) AND  AM.COMM_BASED_LOAN=0
         AND AG.AGENT_ID = D.AGENT_NO
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.PROD_ID = AP.PROD_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AM.PROD_ID = AG.PROD_ID
         and ACS.PROD_ID = ag.prod_id
         AND Acs.PROD_ID = PRODID
         AND D.AGENT_NO = AGENTID
         AND D.TRN_DT BETWEEN AC.LAST_COL_DT AND DT
         AND D.AUTHORIZE_STATUS = 'AUTHORIZED'
         --AND GET_AGENT_COLLECTION_AMOUNT(PRODID,AGENTID,DT) BETWEEN ACS.FROM_AMT and ACS.TO_AMT 
         GROUP BY D.AGENT_NO, AG.PROD_ID, AP.PROD_DESC, AC.LAST_COL_DT,
         AM.COMM_PER_BANK,AM.COMM_PER_AC_HOLDR;
       END IF;      
   RETURN COMMISSIONAMOUNT;
END;
/

DROP TYPE TAB_TYPE_AGENT_COMMISSION;

CREATE OR REPLACE TYPE TYPE_AGENT_COMMISSION AS OBJECT
(
   AGENTID VARCHAR2 (15),
   PROD_ID VARCHAR2 (15),
   COLLECTION_AMOUNT NUMBER (16, 2),
   COMMISSION NUMBER (16, 2),
   VAT NUMBER (16, 2)
);

CREATE OR REPLACE TYPE TAB_TYPE_AGENT_COMMISSION  AS TABLE OF TYPE_AGENT_COMMISSION;
/

CREATE OR REPLACE FUNCTION GET_AGENT_COMMISSION_DETAILS (AGENTID    VARCHAR2,
                                                         PRODID     VARCHAR2,
                                                         DT         DATE,
                                                         VATRATE NUMBER)
   RETURN TAB_TYPE_AGENT_COMMISSION
IS
   typeCommission      TAB_TYPE_AGENT_COMMISSION;
   INTAMT              NUMBER (16, 2);
   MATURITYDT          DATE;
   DEPOSITDT           DATE;
   INTFORPAID          NUMBER (16, 2);
   COLLECTION_AMOUNT   NUMBER (16, 2);
   LAST_COL_DT          DATE;
   MONTHDIFF           NUMBER (2);
   TRN_DT              DATE;
   SLABREQUIRED        VARCHAR2 (15);
   PROD_ID VARCHAR2(10);
   VAT                 NUMBER (16, 2);
   COMMISSION           NUMBER (16, 2);
   PROD_DESC VARCHAR2(60);
BEGIN
   SELECT GET_AGENT_COMM_SLAB_REQUIRED(PRODID) INTO SLABREQUIRED FROM DUAL;
   IF SLABREQUIRED = 'N'
   THEN
         SELECT AP.PROD_DESC, AG.PROD_ID, AC.LAST_COL_DT,
         SUM (D.AMOUNT),
         ROUND((SUM (D.AMOUNT) * (NVL(AM.COMM_PER_BANK,0)+NVL(AM.COMM_PER_AC_HOLDR,0)) / 100),0),
          (SUM (D.AMOUNT) * (NVL(AM.COMM_PER_BANK,0)+NVL(AM.COMM_PER_AC_HOLDR,0) / 100) * VATRATE  / 100)
          INTO PROD_DESC,PROD_ID,LAST_COL_DT,COLLECTION_AMOUNT,COMMISSION,VAT
         FROM DAILY_DEPOSIT_TRANS D,
         AGENTMASTDET AG,
         ALL_PRODUCTS AP,
         AGENT_COLLECTION_PROD AC,
         AGENT_PROD_MAPPING AM
         WHERE (D.ACC_NUM = AG.ACT_NUM ||'_1' OR D.ACC_NUM = AG.ACT_NUM) AND  AM.COMM_BASED_LOAN=0
         AND AG.AGENT_ID = D.AGENT_NO
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.PROD_ID = AP.PROD_ID
         AND AP.PROD_ID = AG.PROD_ID
         AND AC.AGENT_ID = AG.AGENT_ID
         AND AM.PROD_ID = AG.PROD_ID
         AND AG.PROD_ID = PRODID
         AND D.AGENT_NO = AGENTID
         AND D.TRN_DT BETWEEN AC.LAST_COL_DT AND DT
         AND D.AUTHORIZE_STATUS = 'AUTHORIZED'
         GROUP BY D.AGENT_NO, AG.PROD_ID, AP.PROD_DESC, AC.LAST_COL_DT,
         AM.COMM_PER_BANK,AM.COMM_PER_AC_HOLDR;
   ELSE        
     SELECT GET_AGENT_COLLECTION_AMOUNT(PRODID,AGENTID,DT) INTO COLLECTION_AMOUNT FROM DUAL;
     SELECT GET_AGENT_COMMISSION_AMOUNT(PRODID,AGENTID,DT) INTO COMMISSION FROM DUAL;
     VAT := round(COMMISSION * (VATRATE/100));
   END IF;

   SELECT TYPE_AGENT_COMMISSION (AGENTID,
                                   PRODID,
                                   COLLECTION_AMOUNT,
                                   COMMISSION,
                                   VAT)
     BULK COLLECT INTO typeCommission
     FROM DUAL;

   RETURN typeCommission;
END;
/


CREATE OR REPLACE FUNCTION CHECK_MDS_AUTH_PENDING (CHITALNO    VARCHAR,
                                                   SCHEME      VARCHAR)
   RETURN NUMBER
IS
   ACT_COUNT   NUMBER (16, 2) := 0;
BEGIN
     SELECT COUNT (*)
       INTO ACT_COUNT
       FROM MDS_RECEIPT_ENTRY
      WHERE     STATUS != 'DELETED'
            AND AUTHORIZE_STATUS IS NULL
            AND SCHEME_NAME = SCHEME
            AND CHITTAL_NO = CHITALNO
   ORDER BY CHITTAL_NO;
   RETURN ACT_COUNT;
END;
/

DROP TYPE TAB_TYPE_GROUP_DEPOSIT_INTR;

CREATE OR REPLACE TYPE TYPE_GROUP_DEPOSIT_INTR AS OBJECT
(
    DEPOSIT_NO      VARCHAR2(15),
    DEP_AMOUNT      NUMBER(16,2),
    CURR_BAL        NUMBER(16,2),
    INTAMOUNT       NUMBER(16,2),
    TRN_DT          DATE
);


CREATE OR REPLACE TYPE TAB_TYPE_GROUP_DEPOSIT_INTR  AS TABLE OF TYPE_GROUP_DEPOSIT_INTR;


CREATE OR REPLACE FUNCTION GET_GROUP_DEP_TRANS_DETAILS (
   DEPOSITNO    VARCHAR2,
   INT_RATE     NUMBER
   )
   RETURN TAB_TYPE_GROUP_DEPOSIT_INTR
IS
   typeinterest   TAB_TYPE_GROUP_DEPOSIT_INTR;
   INTAMT         NUMBER (20, 5);
   MATURITYDT     DATE;
   DEPOSITDT      DATE;
   INTFORPAID     NUMBER (16, 2);
   INTUPTOCURDT   NUMBER (16, 2);
   MAXTRANSDT     DATE;
   MONTHDIFF      NUMBER (2);
   TRN_DT         DATE;
   DEPOSIT_NO     VARCHAR2(15);
   INTAMOUNT      NUMBER (16, 2);
   CURR_BAL       NUMBER (16, 2);
BEGIN  
     SELECT TYPE_GROUP_DEPOSIT_INTR (ACC_NUM,DEP_AMOUNT,
                                   CURR_BAL,
                                   INTAMOUNT,
                                   dt)
     BULK COLLECT INTO typeinterest from(
     SELECT ACC_NUM,DEP_AMOUNT,
          CURR_BAL,
          INTAMOUNT,
          dt
     FROM (  SELECT TRUNC (D.TRN_DT, 'MM') AS dt,
                    SUM (D.AMOUNT) AS DEP_AMOUNT,
                    D.ACC_NUM AS ACC_NUM ,
                    gd.DEPOSIT_AMT,
                    (gd.DEPOSIT_AMT - SUM (D.AMOUNT)) AS DIFFERECE,
                    SUM (
                       SUM (D.AMOUNT))
                    OVER (PARTITION BY d.acc_num
                          ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       AS curr_bal,
                      (  SUM (
                            SUM (D.AMOUNT))
                         OVER (PARTITION BY d.acc_num
                               ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       * INT_RATE)
                    / 1200
                       AS intAmount,
                    SUM (
                       gd.DEPOSIT_AMT - SUM (D.AMOUNT))
                    OVER (PARTITION BY d.acc_num
                          ORDER BY TRUNC (D.TRN_DT, 'MM'))
                       AS diff_curr_bal
               FROM DAILY_DEPOSIT_TRANS d,
                    DEPOSIT_sub_ACINFO dsa,
                    DEPOSIT_ACINFO da,
                    GROUP_DEPOSIT gd
              WHERE     D.ACC_NUM = DEPOSITNO || '_1'
                    AND DSA.DEPOSIT_NO || '_1' = D.ACC_NUM
                    AND DSA.DEPOSIT_NO = DA.DEPOSIT_NO
                    AND DA.GROUP_NO = GD.GROUP_NO
                    AND DA.BRANCH_ID = GD.BRANCH_ID
           GROUP BY TRUNC (D.TRN_DT, 'MM'), D.ACC_NUM, gd.DEPOSIT_AMT
           ORDER BY dt) );
   RETURN typeinterest;
END;
/


CREATE OR REPLACE FUNCTION get_group_deposit_int (DEPOSITNO    VARCHAR2,
                                                  INT_RATE     NUMBER,
                                                  CURRDT       DATE)
   RETURN NUMBER
IS
   INTAMT           NUMBER (16, 2);
   MATURITYDT       DATE;
   DEPOSITDT        DATE;
   INTFORPAID       NUMBER (16, 2);
   INTUPTOCURDT     NUMBER (16, 2);
   MAXTRANSDT       DATE;
   MONTHDIFF        NUMBER (4);
   MAXINTAMOUNT     NUMBER (16, 2);
   NOOFDAYS         NUMBER (10);
   START_DT         DATE;
   END_DT           DATE;
   TOTALINTAMOUNT   NUMBER (16, 2);
   INTAMOUNT        NUMBER (16, 2);   
BEGIN
   SELECT DSA.MATURITY_DT, DSA.DEPOSIT_DT
     INTO MATURITYDT, DEPOSITDT
     FROM DEPOSIT_SUB_ACINFO DSA
    WHERE DSA.DEPOSIT_NO = DEPOSITNO;
   SELECT MAX (DT.TRN_DT)
     INTO MAXTRANSDT
     FROM DAILY_DEPOSIT_TRANS DT
    WHERE DT.ACC_NUM = DEPOSITNO || '_1';
   SELECT MIN (TRN_DT),MAX (TRN_DT) INTO START_DT,END_DT
     FROM TABLE (GET_GROUP_DEP_TRANS_DETAILS9 (DEPOSITNO, INT_RATE));
   TOTALINTAMOUNT := 0.0;   
   WHILE (START_DT <= END_DT)
   LOOP
     BEGIN      
      SELECT INTAMOUNT
        INTO INTAMOUNT
        FROM TABLE (GET_GROUP_DEP_TRANS_DETAILS9 (DEPOSITNO,INT_RATE))
       WHERE TRN_DT = START_DT;
       TOTALINTAMOUNT := TOTALINTAMOUNT + INTAMOUNT;        
      EXCEPTION WHEN OTHERS THEN     
      TOTALINTAMOUNT := TOTALINTAMOUNT + INTAMOUNT;  
      END;
      SELECT ADD_MONTHS (START_DT, 1) INTO START_DT FROM DUAL;
   END LOOP;
   SELECT FLOOR (MONTHS_BETWEEN (CURRDT, MAXTRANSDT))
     INTO MONTHDIFF
     FROM DUAL;
   SELECT INTAMOUNT
     INTO MAXINTAMOUNT
     FROM TABLE (GET_GROUP_DEP_TRANS_DETAILS (DEPOSITNO, INT_RATE))
    WHERE TRN_DT = END_DT;   
   INTUPTOCURDT := NVL (MAXINTAMOUNT, 0) * MONTHDIFF;
   INTAMT := NVL (TOTALINTAMOUNT, 0) + NVL (INTUPTOCURDT, 0);
   INTAMT := ROUND (INTAMT);  
   RETURN INTAMT;
END;
/

SET DEFINE OFF;
Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE, DESCRIPTION)
 Values
   ('GST_ROUNDOFF', 'NORMAL', 'Rounding off to 50 paise');
Insert into CBMS_PARAMETERS
   (CBMS_KEY, CBMS_VALUE, DESCRIPTION)
 Values
   ('CESS_ROUNDOFF', 'NORMAL', 'Rounding off to 50 paise');
COMMIT;


-- End Version [Script Version - 0.0.326] [ReleaseVersion - 9.2.2.16]--[29-JUL-2020] -- By Nithya K

-- Start Version [Script Version - 0.0.327] [ReleaseVersion - 9.2.2.16]--[15-OCT-2020] -- By Nithya K

SET DEFINE OFF;
Insert into SCREEN_MASTER
   (SCREEN_ID, MENU_ID, SCREEN_NAME, APP_ID, WF_STATUS, 
    MODULE_ID, SCREEN_CLASS, SL_NO, STATUS, SCREEN_TYPE, 
    RECORD_KEY_COL, SCREEN_DESC)
 Values
   ('SCR12325', '12324', 'Share Conversion', 'APP01', 'DONE', 
    '15', 'Share Conversion', 8, 'CREATED', 'REPORT', 
    NULL, 'Share Conversion');
COMMIT;

ALTER TABLE MDS_BANK_ADVANCE ADD GDS_NO VARCHAR2(30);

-- End Version [Script Version - 0.0.327] [ReleaseVersion - 9.2.2.16]--[15-OCT-2020] -- By Nithya K

-- Start Version [Script Version - 0.0.328] [ReleaseVersion - 9.2.2.16]--[03-Dec-2020] -- By Nithya K

ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD WITNESS1_CUST_ID VARCHAR2(20);

ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD WITNESS2_CUST_ID VARCHAR2(20);

ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD WITNESS1_CHITTAL VARCHAR2(20);

ALTER TABLE MDS_PRIZED_MONEY_DETAILS ADD WITNESS2_CHITTAL VARCHAR2(20);

ALTER TABLE LOANS_FACILITY_DETAILS ADD RECOMMANDED_BY2 VARCHAR2(50);

ALTER TABLE CUSTOMER ADD PROOF_PHOTO_FILE BLOB;

SET DEFINE OFF;
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('BANK_AMT_TRANS_CATEGORY', 'SUBAMT_TO_SUBAMT', 'Sub Amt to Sub Amt', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('BANK_AMT_TRANS_CATEGORY', 'FULLAMT_TO_FULLAMT', 'Full Amt to Full Amt', 'CREATED', 'Y', 
    'Y');
Insert into LOOKUP_MASTER
   (LOOKUP_ID, LOOKUP_REF_ID, LOOKUP_DESC, STATUS, EDITABLE, 
    AUTHORIZED)
 Values
   ('BANK_AMT_TRANS_CATEGORY', 'FULLAMT_TO_SUBAMT', 'Full Amt to Sub Amt', 'CREATED', 'Y', 
    'Y');
COMMIT;
  
  
ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD BANK_MDS_TRNF_CAT_THALAYAL VARCHAR2(50 BYTE) DEFAULT ('FULLAMT_TO_FULLAMT');
  
ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD BANK_MDS_TRNF_CAT_MUNNAL VARCHAR2(50 BYTE) DEFAULT ('FULLAMT_TO_FULLAMT');

-- End Version [Script Version - 0.0.328] [ReleaseVersion - 9.2.2.16]--[03-Dec-2020] -- By Nithya K

-- Start Version [Script Version - 0.0.329] [ReleaseVersion - 9.2.2.17]--[24-Dec-2020] -- By Nithya K

CREATE OR REPLACE FUNCTION GET_DEP_NOMINEE (ACTNUM VARCHAR2) RETURN VARCHAR2 IS
CURSOR C1 is select D.NOMINEE_NAME from DEPOSIT_NOMINEE_DETAIL D WHERE D.DEPOSIT_NO=ACTNUM AND D.STATUS != 'DELETED' and D.NOMINEE_CURRENT_STATUS = 'EXISTING';
NOMINEE VARCHAR2(300):=' ';
BEGIN
FOR I IN C1 LOOP
NOMINEE :=NOMINEE || '  ' || I.NOMINEE_NAME ;
END LOOP; 
RETURN NOMINEE;
END;
/


ALTER TABLE MDS_SCHEME_DETAILS  ADD DISCOUNT_FIRST_INSTALLMENT VARCHAR2(1) DEFAULT 'N';

ALTER TABLE MDS_SCHEME_DETAILS ADD FIRST_DISCOUNT_AMT NUMBER(16,2) DEFAULT 0;


CREATE OR REPLACE FUNCTION GET_AUCTION_ENTRY_CNT (SCHEMENAME VARCHAR2,DIVISIONNO VARCHAR2) RETURN NUMBER IS
INST_CNT NUMBER(4);
PREDEFINED VARCHAR2(1);
BEGIN
SELECT MSD.PREDEFINITION_INSTALLMENT INTO PREDEFINED  FROM MDS_SCHEME_DETAILS MSD WHERE MSD.SCHEME_NAME = SCHEMENAME;
IF PREDEFINED = 'Y' THEN
   INST_CNT := 1;
ELSE
   SELECT COUNT (*) INTO INST_CNT
        FROM (SELECT MP.INSTALLMENT_NO
        FROM mds_prized_money_details mp,
        mds_product_general_details mpd,
        mds_scheme_details ms
        WHERE mpd.prod_id = ms.prod_id
        AND ms.scheme_name = mp.scheme_name
        AND mp.scheme_name = SCHEMENAME
        AND mpd.advance_collection = 'Y'
        and MP.DIVISION_NO = DIVISIONNO
        group by MP.INSTALLMENT_NO
        );
END IF;
RETURN INST_CNT;
END;
/

CREATE OR REPLACE FORCE VIEW ALL_TRANSACTIONS_VIEW
(
   TRANS_ID,
   BATCH_ID,
   AC_HD_ID,
   ACT_NUM,
   AMOUNT,
   TRANS_DT,
   TRANS_TYPE,
   INST_TYPE,
   INST_DT,
   PARTICULARS,
   STATUS,
   INSTRUMENT_NO1,
   INSTRUMENT_NO2,
   PROD_ID,
   PROD_TYPE,
   AUTHORIZE_STATUS,
   AUTHORIZE_BY,
   STATUS_BY,
   STATUS_DT,
   TRANS_MODE,
   BRANCH_ID,
   INITIATED_BRANCH,
   AUTHORIZE_STATUS_2,
   SINGLE_TRANS_ID,
   LINK_BATCH_ID,
   TRANS_MOD_TYPE,
   NARRATION,
   INTERBRANCH_FLAG,
   GL_TRANS_ACT_NUM
)
AS
   SELECT trans_id,
          batch_id,
          ac_hd_id,
          NVL (act_num, link_batch_id),
          amount,
          trans_dt,
          trans_type,
          inst_type,
          inst_dt,
          particulars,
          status,
          instrument_no1,
          instrument_no2,
          prod_id,
          prod_type,
          authorize_status,
          authorize_by,
          status_by,
          status_dt,
          trans_mode,
          branch_id,
          initiated_branch,
          authorize_status_2,
          single_trans_id,
          link_batch_id,
          trans_mod_type,
          narration,
          INTERBRANCH_FLAG,
          GL_TRANS_ACT_NUM
     FROM (SELECT trans_id,
                  batch_id,
                  ac_hd_id,
                  act_num,
                  amount,
                  trans_dt,
                  trans_type,
                  inst_type,
                  inst_dt,
                  particulars,
                  status,
                  instrument_no1,
                  instrument_no2,
                  prod_id,
                  prod_type,
                  authorize_status,
                  authorize_by,
                  status_by,
                  status_dt,
                  trans_mode,
                  branch_id,
                  initiated_branch,
                  authorize_status_2,
                  single_trans_id,
                  link_batch_id,
                  trans_mod_type,
                  narration,
                  INTERBRANCH_FLAG,
                  GL_TRANS_ACT_NUM
             FROM all_trans
           /* Script added for updating dayend balance of Daily Deposit accounts */
           UNION ALL
           SELECT TO_CHAR (trans_id),
                  batch_id,
                  (SELECT acct_head
                     FROM deposits_product
                    WHERE prod_id = SUBSTR (acc_num, 5, 3))
                     AS ac_hd_id,
                  acc_num AS act_num,
                  amount,
                  trn_dt AS trans_dt,
                  trans_type,
                  '' AS inst_type,
                  NULL AS inst_dt,
                  particulars,
                  status,
                  '' AS instrument_no1,
                  '' AS instrument_no2,
                  SUBSTR (acc_num, 5, 3) AS prod_id,
                  prod_type,
                  authorize_status,
                  authorize_by,
                  '' AS status_by,
                  trn_dt AS status_dt,
                  trans_mode,
                  SUBSTR (acc_num, 1, 4) AS branch_id,
                  initiated_branch,
                  '' AS authorize_status_2,
                  '' AS single_trans_id,
                  '' AS link_batch_id,
                  '' AS trans_mod_type,
                  '' AS narration,
                  'N' AS INTERBRANCH_FLAG,
                  '' AS GL_TRANS_ACT_NUM
             FROM daily_deposit_trans
           ORDER BY status_dt);

-- End Version [Script Version - 0.0.329] [ReleaseVersion - 9.2.2.17]--[24-Dec-2020] -- By Nithya K

-- Start Version [Script Version - 0.0.329] [ReleaseVersion - 9.2.2.17]--[18-Jan-2021] -- By Nithya K

CREATE OR REPLACE FUNCTION GET_CUSTOMER_ADDRESS (ACCTNO VARCHAR2)
   RETURN VARCHAR2
IS
   PRODTYPE       VARCHAR2 (10);
   COMMADDRTYPE   VARCHAR2 (30);
   ADDR           VARCHAR2 (300);
BEGIN
   SELECT AC.PROD_TYPE
     INTO PRODTYPE
     FROM ALL_CUSTOMER_ACCOUNTS ac
    WHERE AC.ACT_NUM = SUBSTR(ACCTNO,0,13);

   IF PRODTYPE = 'OA'
   THEN
      SELECT ACT.COMM_ADDR_TYPE
        INTO COMMADDRTYPE
        FROM act_master act
       WHERE ACT.ACT_NUM = ACCTNO;
   ELSIF PRODTYPE = 'TD'
   THEN
      SELECT DA.ADDR_TYPE
        INTO COMMADDRTYPE
        FROM DEPOSIT_ACINFO da
       WHERE DA.DEPOSIT_NO = SUBSTR(ACCTNO,0,13);
   ELSE
      SELECT CU.COMM_ADDR_TYPE
        INTO COMMADDRTYPE
        FROM CUSTOMER CU
       WHERE CU.CUST_ID = (SELECT DISTINCT CUST_ID
                             FROM ALL_CUSTOMER
                            WHERE ACT_NUM = ACCTNO);
   END IF;

   IF COMMADDRTYPE IS NULL
   THEN
      COMMADDRTYPE := 'HOME';
   END IF;

   SELECT DISTINCT STREET
     INTO ADDR
     FROM CUST_ADDR CA, CUSTOMER CU
    WHERE     CA.CUST_ID = CA.CUST_ID
          AND CA.ADDR_TYPE = COMMADDRTYPE
          AND CA.CUST_ID = (SELECT DISTINCT CUST_ID
                              FROM ALL_CUSTOMER
                             WHERE ACT_NUM = ACCTNO);

   RETURN ADDR;
END;
/

-- End Version [Script Version - 0.0.329] [ReleaseVersion - 9.2.2.17]--[18-Jan-2021] -- By Nithya K


-- Start Version [Script Version - 0.0.329] [ReleaseVersion - 9.2.2.17]--[17-Feb-2021] -- By Nithya K

ALTER TABLE OP_AC_SPCLITEM_PARAM ADD IMPS_TXN_LIMIT NUMBER(16,2) default 0.0;

ALTER TABLE ACT_MASTER ADD IS_PRIMARY_ACT VARCHAR2(1) DEFAULT 'N';

-- End Version [Script Version - 0.0.329] [ReleaseVersion - 9.2.2.17]--[17-Feb-2021] -- By Nithya K


ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD SPECIAL_INTEREST VARCHAR(1) DEFAULT 'N';
 
ALTER TABLE MDS_PRODUCT_OTHER_DETAILS ADD SPECIAL_INT_DUE_PERIOD_MONTH NUMERIC(2) default 0;