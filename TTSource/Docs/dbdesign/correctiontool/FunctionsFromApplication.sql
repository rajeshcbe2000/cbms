
-- Added by nithya on 19-06-2024 -- Version 1.0 - Correction Tool - Start

CREATE OR REPLACE FUNCTION get_active_account(act_no character varying, prod_type character varying)
 RETURNS numeric
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
ACT_COUNT numeric(16,2) := 0;
begin
	--select * from  GET_ACTIVE_ACCOUNT('0001114014873','TD')
  IF PROD_TYPE='AB' THEN
        SELECT COUNT(*) INTO ACT_COUNT FROM OTHER_BANKS_ACT_MASTER
        WHERE ACT_MASTER_ID=ACT_NO AND ACT_STATUS='NEW'
        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZED_STATUS='AUTHORIZED';
    ELSIF PROD_TYPE='AD' OR PROD_TYPE='TL' THEN
        SELECT COUNT(*) INTO ACT_COUNT FROM LOANS_FACILITY_DETAILS
        WHERE ACCT_NUM=ACT_NO AND ACCT_STATUS='NEW'
        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZE_STATUS_1='AUTHORIZED';
    ELSIF PROD_TYPE='INV' THEN
        SELECT COUNT(*) INTO ACT_COUNT
        FROM INVESTMENT_DEPOSIT INVDEP
        JOIN INVESTMENT_MASTER INVMAS ON (INVDEP.INVESTMENT_ID = INVMAS.INVESTMENT_ID)
        WHERE INVDEP.INVESTMENT_ID=ACT_NO AND INVDEP.ACCT_STATUS='NEW'
        AND INVDEP.STATUS IN ('CREATED','MODIFIED') AND INVDEP.AUTHORIZED_STATUS='AUTHORIZED'
        AND INVMAS.STATUS IN ('CREATED','MODIFIED') AND INVMAS.AUTHORIZED_STATUS='AUTHORIZED';
    ELSIF PROD_TYPE='OA' THEN
        SELECT COUNT(*) INTO ACT_COUNT FROM ACT_MASTER
        WHERE ACT_NUM=ACT_NO AND ACT_STATUS_ID='NEW'
        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZATION_STATUS='AUTHORIZED';
    ELSIF PROD_TYPE='SA' THEN
        SELECT COUNT(*) INTO ACT_COUNT FROM SUSPENSE_ACCOUNT_MASTER
        WHERE SUSPENSE_ACCT_NUM=ACT_NO
        AND STATUS IN ('CREATED','MODIFIED') AND AUTHORIZE_STATUS='AUTHORIZED';
    ELSIF PROD_TYPE='TD' THEN
        SELECT COUNT(*) INTO ACT_COUNT
        FROM DEPOSIT_SUB_ACINFO DSA
        JOIN DEPOSIT_ACINFO DA ON (DSA.DEPOSIT_NO=DA.DEPOSIT_NO)
        WHERE (DSA.DEPOSIT_NO=ACT_NO OR DSA.DEPOSIT_NO||'_1'=ACT_NO)
        AND DSA.ACCT_STATUS='NEW' AND DA.DEPOSIT_STATUS='NEW'
        AND DSA.STATUS IN ('CREATED','MODIFIED','LIEN') AND DSA.AUTHORIZE_STATUS='AUTHORIZED'
        AND DA.STATUS IN ('CREATED','MODIFIED') AND DA.AUTHORIZE_STATUS='AUTHORIZED';
     ELSIF PROD_TYPE='GL' THEN
          ACT_COUNT := 1;
    END IF;  
RETURN ACT_COUNT;
END;
$function$
;

------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION func_act_trans_negative_bal(actnumber character varying, frdate date, transamt numeric)
 RETURNS SETOF type_trans_bal
 LANGUAGE plpgsql
AS $function$
declare
ACTDET TYPE_TRANS_BAL;
begin
/*  
CREATE  TYPE TYPE_TRANS_BAL as
(
    ACT_NUM VARCHAR(15),
    TRANS_DT DATE,
    TRAMT numeric(16,2),
    BALANCE numeric(16,2)
)
*/
--select * from FUNC_ACT_TRANS_NEGATIVE_BAL('0001110010046','01-apr-2024',-250000)
for ACTDET in 
With Mstr as 
(
select am.act_num,OAP.AC_HD_ID, TRANSAMT as TRAMT ,DE.CURR_APPL_DT AS CUR_DT,TO_DATE(FRDATE) AS FDATE  from act_master am
join op_ac_product oap on oap.prod_id = am.prod_id
JOIN DAY_END DE ON DE.BRANCH_CODE = AM.BRANCH_CODE  
where am.act_num = ACTNUMBER
UNION ALL
select am.SUSPENSE_ACCT_NUM,OAP.AC_HD_ID, TRANSAMT as TRAMT ,DE.CURR_APPL_DT AS CUR_DT,TO_DATE(FRDATE) AS FDATE  from SUSPENSE_ACCOUNT_MASTER am
join SUSPENSE_PRODUCT oap on oap.prod_id = am.SUSPENSE_PROD_ID
JOIN DAY_END DE ON DE.BRANCH_CODE = AM.BRANCH_CODE  
where am.SUSPENSE_ACCT_NUM = ACTNUMBER
), OPBAL AS 
(
SELECT ACT_NUM,OPDATE,SUM(OPENING) AS OPENING_BAL,0 AS TRANS_BAL,TRAMT FROM (
select T.ACT_NUM,TO_DATE(FDATE) AS OPDATE,  SUM(CASE WHEN T.TRANS_DT < MSTR.FDATE THEN CASE WHEN T.TRANS_TYPE = 'CREDIT' THEN 1 ELSE -1 END * T.AMOUNT  END) AS OPENING,MSTR.TRAMT   from transfer_trans t
join mstr on mstr.act_num = t.act_num and mstr.ac_hd_id = t.ac_hd_id 
where T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS NOT IN ('DELETED')
AND T.TRANS_DT <= MSTR.CUR_DT
GROUP BY T.ACT_NUM,FDATE,MSTR.TRAMT  
UNION ALL
select T.ACT_NUM, TO_DATE(FDATE) AS OPDATE,SUM(CASE WHEN T.TRANS_DT < MSTR.FDATE THEN CASE WHEN T.TRANS_TYPE = 'CREDIT' THEN 1 ELSE -1 END * T.AMOUNT  END) AS OPENING,MSTR.TRAMT   from cASH_trans t
join mstr on mstr.act_num = t.act_num and mstr.ac_hd_id = t.ac_hd_id 
where T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS NOT IN ('DELETED')
AND T.TRANS_DT <= MSTR.CUR_DT
GROUP BY T.ACT_NUM,FDATE,MSTR.TRAMT
) A GROUP BY ACT_NUM,OPDATE,TRAMT
),TRANS_BAL AS
(
SELECT ACT_NUM,TRANS_DT, 0 AS OPENING_BAL,SUM(TRANS_BAL) AS TRANS_BAL,TRAMT FROM (
select T.ACT_NUM, TRANS_DT ,SUM(CASE WHEN T.TRANS_TYPE = 'CREDIT' THEN 1 ELSE -1 END * T.AMOUNT) AS TRANS_BAL ,mstr.TRAMT from Cash_trans t
join mstr on mstr.act_num = t.act_num and mstr.ac_hd_id = t.ac_hd_id 
where T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS NOT IN ('DELETED')
AND T.TRANS_DT BETWEEN MSTR.FDATE AND  MSTR.CUR_DT
GROUP BY T.ACT_NUM,TRANS_DT,mstr.TRAMT  
UNION ALL
select T.ACT_NUM, TRANS_DT ,SUM(CASE WHEN T.TRANS_TYPE = 'CREDIT' THEN 1 ELSE -1 END * T.AMOUNT) AS TRANS_BAL  ,mstr.TRAMT from transfer_trans t
join mstr on mstr.act_num = t.act_num and mstr.ac_hd_id = t.ac_hd_id 
where T.AUTHORIZE_STATUS = 'AUTHORIZED' AND T.STATUS NOT IN ('DELETED')
AND T.TRANS_DT BETWEEN MSTR.FDATE AND  MSTR.CUR_DT
GROUP BY T.ACT_NUM,TRANS_DT ,mstr.TRAMT 
)A GROUP BY ACT_NUM,TRANS_DT,TRAMT
)
SELECT ACT_NUM,TRANS_DT,TRAMT,BALANCE FROM (
SELECT ACT_NUM,TRANS_DT,MIN(TRANS_DT)OVER(ORDER BY TRANS_DT) AS MINTRDT, TRAMT,PRG_BALANCE AS BALANCE FROM (
SELECT ACT_NUM,TRANS_DT ,OPENING_BAL,TRANS_BAL,TRAMT,SUM(OPENING_BAL+TRANS_BAL+TRAMT)OVER (ORDER BY TRANS_DT) AS PRG_BALANCE  FROM (
SELECT ACT_NUM,TRANS_DT,SUM(OPENING_BAL) AS OPENING_BAL,SUM(TRANS_BAL) AS TRANS_BAL,TRAMT FROM (
SELECT ACT_NUM,OPDATE AS TRANS_DT,OPENING_BAL,TRANS_BAL,TRAMT FROM OPBAL
UNION ALL
SELECT ACT_NUM,TRANS_DT,OPENING_BAL,TRANS_BAL ,0 AS TRAMT FROM TRANS_BAL
) A GROUP BY ACT_NUM,TRANS_DT,TRAMT)B
) C  WHERE PRG_BALANCE <0
) A WHERE A.MINTRDT = TRANS_DT
  LOOP
 RETURN NEXT actdet;
END LOOP;
END;
$function$
;


--------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION get_transfer_batch_cnt(batchid character varying, transdt date, branchcode character varying)
 RETURNS numeric
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
CNT numeric(2) := 0;
begin
select count(*) INTO CNT
        from transfer_trans where trans_dt = TRANSDT
        and initiated_branch = BRANCHCODE
        and batch_id = BATCHID
        AND PROD_TYPE IN ('GL','SA','OA','AB')
        AND TRANS_MOD_TYPE IN ('GL','SA','OA','AB')
        and AUTHORIZE_STATUS = 'AUTHORIZED'  ;
RETURN CNT;
END;
$function$
;

---------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION get_ab_transfer_batch_cnt(batchid character varying, transdt date, branchcode character varying)
 RETURNS numeric
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
CNT numeric(2) := 0;
begin
select count(*) INTO CNT
        from transfer_trans where trans_dt = TRANSDT
        and initiated_branch = BRANCHCODE
        and batch_id = BATCHID
        AND PROD_TYPE IN ('GL','AB')
        AND TRANS_MOD_TYPE IN ('GL','AB')
        and AUTHORIZE_STATUS = 'AUTHORIZED'  ;
RETURN CNT;
END;
$function$
;

--------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION get_account_opendt(prodtype character varying, actno character varying)
 RETURNS date
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
DECLARE
OPENDT DATE;
begin
IF PRODTYPE = 'OA'THEN
  SELECT CREATE_DT INTO OPENDT FROM ACT_MASTER WHERE ACT_NUM = ACTNO;
ELSIF PRODTYPE = 'SA'THEN
  SELECT SUSPENSE_OPEN__DATE INTO OPENDT FROM SUSPENSE_ACCOUNT_MASTER WHERE SUSPENSE_ACCT_NUM = ACTNO;
ELSIF PRODTYPE = 'AB'THEN
  SELECT ACT_OPEN_DT INTO OPENDT FROM OTHER_BANKS_ACT_MASTER WHERE ACT_MASTER_ID = ACTNO;
END IF;  
RETURN OPENDT;
END;
$function$
;

-- Added by nithya on 19-06-2024 -- Version 1.0 - Correction Tool - End